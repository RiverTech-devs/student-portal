<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#0f172a">
  <meta name="description" content="JCalculator - Math Teacher Edition">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="JCalculator">
  <title>JCalculator</title>
  
  <link rel="manifest" href="data:application/json,%7B%22name%22%3A%22JCalculator%22%2C%22short_name%22%3A%22JCalc%22%2C%22start_url%22%3A%22.%22%2C%22display%22%3A%22standalone%22%2C%22background_color%22%3A%22%230f172a%22%2C%22theme_color%22%3A%22%230f172a%22%7D">
  
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 8px;
      color: #fff;
    }
    .calculator {
      width: 100%;
      max-width: 700px;
      background: #1e293b;
      border-radius: 12px;
      box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
      border: 1px solid #334155;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      max-height: 98vh;
    }
    .titlebar {
      background: #334155;
      padding: 10px 16px;
      display: flex;
      align-items: center;
      gap: 8px;
      border-bottom: 1px solid #475569;
    }
    .dots { display: flex; gap: 6px; }
    .dot { width: 12px; height: 12px; border-radius: 50%; }
    .dot.red { background: #ef4444; }
    .dot.yellow { background: #eab308; }
    .dot.green { background: #22c55e; }
    .title { color: #94a3b8; font-size: 13px; margin-left: 8px; }
    .ans-display { color: #22c55e; font-size: 12px; margin-left: auto; }
    .output {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      background: #0f172a;
      min-height: 200px;
    }
    .line { white-space: pre-wrap; word-break: break-word; margin-bottom: 8px; line-height: 1.4; font-size: 14px; }
    .line.user { color: #22d3ee; }
    .line.system { color: #64748b; }
    .line.result { color: #4ade80; padding-left: 8px; border-left: 2px solid #22c55e; }
    .line.error { color: #f87171; padding-left: 8px; border-left: 2px solid #ef4444; }
    .line.help { color: #cbd5e1; padding-left: 8px; border-left: 2px solid #475569; }
    .input-area { border-top: 1px solid #334155; background: #1e293b; padding: 12px 16px; }
    .input-row { display: flex; align-items: center; gap: 8px; }
    .prompt { color: #22c55e; font-size: 16px; }
    #input {
      flex: 1;
      background: transparent;
      border: none;
      outline: none;
      color: #fff;
      font-family: inherit;
      font-size: 16px;
    }
    #input::placeholder { color: #475569; }
    .quick-links {
      display: flex;
      gap: 12px;
      padding: 8px 16px;
      background: #334155;
      border-top: 1px solid #475569;
      overflow-x: auto;
    }
    .quick-links span { color: #64748b; font-size: 12px; cursor: pointer; white-space: nowrap; }
    .quick-links span:hover { color: #22d3ee; }
    .quick-links span.clear:hover { color: #f87171; }
    .install-banner { display: none; background: linear-gradient(90deg, #0891b2, #6366f1); padding: 10px 16px; align-items: center; justify-content: space-between; }
    .install-banner.show { display: flex; }
    .install-btn { background: #fff; color: #0f172a; border: none; padding: 6px 16px; border-radius: 6px; font-weight: 600; cursor: pointer; }
    .dismiss-btn { background: transparent; color: #fff; border: none; font-size: 18px; cursor: pointer; }
    @media (max-width: 500px) {
      .calculator { border-radius: 0; max-height: 100vh; }
      body { padding: 0; }
      .line { font-size: 13px; }
      .title { display: none; }
    }
  </style>
</head>
<body>
  <div class="calculator">
    <div class="install-banner" id="installBanner">
      <span>üì± Install as app!</span>
      <button class="install-btn" id="installBtn">Install</button>
      <button class="dismiss-btn" id="dismissBtn">√ó</button>
    </div>
    <div class="titlebar">
      <div class="dots">
        <div class="dot red"></div>
        <div class="dot yellow"></div>
        <div class="dot green"></div>
      </div>
      <span class="title">JCalculator - Math Teacher Edition</span>
      <span class="ans-display" id="ansDisplay">ans = 0</span>
    </div>
    <div class="output" id="output"></div>
    <div class="input-area">
      <div class="input-row">
        <span class="prompt">‚ùØ</span>
        <input type="text" id="input" placeholder="Type a command..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
      </div>
    </div>
    <div class="quick-links">
      <span onclick="setInput('help')">help</span>
      <span onclick="setInput('formulas')">formulas</span>
      <span onclick="setInput('math')">math</span>
      <span onclick="setInput('algebra')">algebra</span>
      <span onclick="setInput('geometry')">geometry</span>
      <span onclick="setInput('caesar')">caesar</span>
      <span onclick="setInput('morse')">morse</span>
      <span onclick="setInput('random')">random</span>
      <span class="clear" onclick="clearOutput()">clear</span>
    </div>
  </div>

<script>
// ===== PWA INSTALL =====
let deferredPrompt;
window.addEventListener('beforeinstallprompt', e => {
  e.preventDefault();
  deferredPrompt = e;
  document.getElementById('installBanner').classList.add('show');
});
document.getElementById('installBtn')?.addEventListener('click', async () => {
  if (deferredPrompt) {
    deferredPrompt.prompt();
    await deferredPrompt.userChoice;
    deferredPrompt = null;
    document.getElementById('installBanner').classList.remove('show');
  }
});
document.getElementById('dismissBtn')?.addEventListener('click', () => {
  document.getElementById('installBanner').classList.remove('show');
});

// ===== HELP SYSTEM =====
const helpCategories = {
  math: { name: 'Math', desc: 'Basic and advanced math', commands: [
    '‚îÄ‚îÄ BASIC ARITHMETIC ‚îÄ‚îÄ',
    '2 + 2, 5 * 4, 20 / 4   ‚Üí  Basic ops',
    '5 ^ 3 or pow(5,3)      ‚Üí  Exponents',
    'sqrt(16), cbrt(27)     ‚Üí  Roots',
    '5!                     ‚Üí  Factorial',
    '',
    '‚îÄ‚îÄ SMART INPUT ‚îÄ‚îÄ',
    'five plus three        ‚Üí  8',
    'what is 5 + 3?         ‚Üí  8',
    'twenty-three times 2   ‚Üí  46',
    'half of 50             ‚Üí  25',
    '5 squared              ‚Üí  25',
    'square root of 16      ‚Üí  4',
    '2(3+4)                 ‚Üí  14 (implicit √ó)',
    '5 + 3 apples           ‚Üí  8 (ignores units)',
    '',
    '‚îÄ‚îÄ FUNCTIONS ‚îÄ‚îÄ',
    'abs(-5), floor, ceil, round',
    'min(3,5), max(3,5), log(100), ln(e)',
    'pi, e, ans (previous answer)'
  ]},
  trig: { name: 'Trigonometry', desc: 'Trig functions & angles', commands: [
    'sin(45 deg)            ‚Üí  Sine with degrees',
    'cos(60 deg)            ‚Üí  Cosine with degrees',
    'tan(45 deg)            ‚Üí  Tangent with degrees',
    'sin(pi/4)              ‚Üí  Trig with radians',
    'csc(x), sec(x), cot(x) ‚Üí  Reciprocal trig',
    '45 deg to rad          ‚Üí  Degrees to radians',
    '1.57 rad to deg        ‚Üí  Radians to degrees',
    'unit circle 30         ‚Üí  sin/cos/tan at angle'
  ]},
  algebra: { name: 'Algebra', desc: 'Equations & formulas', commands: [
    'solve 2x + 5 = 15      ‚Üí  Linear equation',
    'solve -3x + 10 = 1     ‚Üí  Negative coefficient',
    'quadratic 1, 5, 6      ‚Üí  ax¬≤ + bx + c = 0',
    'quadratic 1, -4, 4     ‚Üí  Perfect square',
    'quadratic 1, 0, 1      ‚Üí  Complex roots',
    'discriminant 1, 5, 6   ‚Üí  b¬≤ - 4ac',
    'vertex 2, -8, 6        ‚Üí  Parabola vertex'
  ]},
  geometry: { name: 'Geometry', desc: 'Shapes & coordinate geometry', commands: [
    'area circle r=5        ‚Üí  œÄr¬≤',
    'area triangle b=10,h=5 ‚Üí  ¬Ωbh',
    'area rectangle l=4,w=6 ‚Üí  length √ó width',
    'volume sphere r=3      ‚Üí  ‚Å¥‚ÅÑ‚ÇÉœÄr¬≥',
    'volume cylinder r=2,h=5‚Üí  œÄr¬≤h',
    'volume cube s=4        ‚Üí  s¬≥',
    'volume box l=2,w=3,h=4 ‚Üí  lwh',
    'pythagorean a=3, b=4   ‚Üí  Find c',
    'pythagorean a=3, c=5   ‚Üí  Find b',
    'distance (1,2) to (4,6)‚Üí  Distance formula',
    'midpoint (1,2) and (5,8)‚Üí Midpoint',
    'slope (1,2) to (4,8)   ‚Üí  Rise over run'
  ]},
  stats: { name: 'Statistics', desc: 'Data analysis', commands: [
    'stats 1,2,3,4,5        ‚Üí  Full analysis',
    'mean of 10, 20, 30     ‚Üí  Average',
    'median of 1,2,3,4,5    ‚Üí  Middle value',
    'mode of 1,2,2,3,3,3    ‚Üí  Most frequent',
    'range of 1,5,10        ‚Üí  Max - min'
  ]},
  numbers: { name: 'Number Theory', desc: 'Factors, primes, divisibility', commands: [
    'factors of 120         ‚Üí  All factors',
    'primes up to 100       ‚Üí  List primes',
    'is 17 prime            ‚Üí  Primality check',
    'is 100 prime           ‚Üí  Not prime',
    'gcf of 48 and 18       ‚Üí  Greatest common factor',
    'gcd of 48 and 18       ‚Üí  (same as gcf)',
    'lcm of 12 and 8        ‚Üí  Least common multiple',
    '10 choose 3            ‚Üí  Combinations (nCr)',
    '10 permute 3           ‚Üí  Permutations (nPr)'
  ]},
  percent: { name: 'Percentages', desc: 'Percent calculations', commands: [
    'what is 15% of 200     ‚Üí  Find amount',
    '30 is what % of 200    ‚Üí  Find percentage',
    'percent change 80 to 100‚Üí % increase/decrease',
    '80 + 15%               ‚Üí  Add percentage',
    '100 - 20%              ‚Üí  Subtract (discount)'
  ]},
  fractions: { name: 'Fractions', desc: 'Fraction operations', commands: [
    '0.75 as fraction       ‚Üí  Decimal to fraction',
    '0.333 as fraction      ‚Üí  Converts to 1/3',
    'simplify 3/4 + 1/2     ‚Üí  Evaluate & simplify'
  ]},
  convert: { name: 'Conversions', desc: 'Units, temperature, bases', commands: [
    '‚îÄ‚îÄ NUMBER BASES ‚îÄ‚îÄ',
    '42 to binary           ‚Üí  Decimal to binary',
    '42 to hex              ‚Üí  Decimal to hex',
    '42 to octal            ‚Üí  Decimal to octal',
    '‚îÄ‚îÄ TEMPERATURE ‚îÄ‚îÄ',
    '100 fahrenheit to celsius',
    '0 celsius to fahrenheit',
    '‚îÄ‚îÄ LENGTH ‚îÄ‚îÄ',
    '5 miles to km',
    '10 feet to meters',
    '‚îÄ‚îÄ WEIGHT ‚îÄ‚îÄ',
    '10 kg to pounds',
    '16 oz to grams'
  ]},
  binary: { name: 'Binary Converter', desc: 'Text ‚Üî Binary conversion', commands: [
    '‚îÄ‚îÄ TEXT TO BINARY ‚îÄ‚îÄ',
    'binary: hello          ‚Üí  ASCII mode (standard)',
    'binary alpha: hello    ‚Üí  Alphabetic (a=0, b=1)',
    '‚îÄ‚îÄ BINARY TO TEXT ‚îÄ‚îÄ',
    'binary decode: 01001000 01101001',
    'binary decode alpha: 00000000 00000001',
    '‚îÄ‚îÄ REFERENCE ‚îÄ‚îÄ',
    'binary chart           ‚Üí  ASCII reference table',
    '‚îÄ‚îÄ NOTES ‚îÄ‚îÄ',
    'ASCII: A=65 (01000001), a=97 (01100001)',
    'Alpha: a=0, b=1, c=2... (for teaching)'
  ]},
  caesar: { name: 'Caesar Cipher', desc: 'Shift cipher encoding', commands: [
    '‚îÄ‚îÄ LETTERS MODE ‚îÄ‚îÄ',
    'caesar encode 3: hello ‚Üí  Shift letters by 3',
    'caesar decode 3: khoor ‚Üí  Reverse shift',
    'caesar encode 13: hi   ‚Üí  ROT13',
    '‚îÄ‚îÄ NUMBERS MODE ‚îÄ‚îÄ',
    'caesar numbers: hello  ‚Üí  A=0, B=1, C=2...',
    'caesar numbers 3: hello‚Üí  With shift applied',
    'caesar decode numbers: 7 4 11 11 14',
    '‚îÄ‚îÄ REFERENCE ‚îÄ‚îÄ',
    'caesar chart           ‚Üí  Letter/number table',
    '‚îÄ‚îÄ NOTES ‚îÄ‚îÄ',
    'Letters shift mod 26, digits shift mod 10',
    'Numbers mode: space=/, digit 5=d5'
  ]},
  morse: { name: 'Morse Code', desc: 'Dots and dashes', commands: [
    '‚îÄ‚îÄ ENCODE ‚îÄ‚îÄ',
    'morse encode: hello    ‚Üí  Text to morse',
    'morse encode: SOS      ‚Üí  ... --- ...',
    'morse: hello world     ‚Üí  Auto-encodes text',
    '‚îÄ‚îÄ DECODE ‚îÄ‚îÄ',
    'morse decode: .... .   ‚Üí  Morse to text',
    'morse: .... . .-.. .-..‚Üí  Auto-detects morse',
    '‚îÄ‚îÄ REFERENCE ‚îÄ‚îÄ',
    'morse chart            ‚Üí  Full alphabet',
    '‚îÄ‚îÄ NOTES ‚îÄ‚îÄ',
    'Letters separated by spaces',
    'Words separated by /'
  ]},
  strings: { name: 'String Tools', desc: 'Count words, letters, patterns', commands: [
    '‚îÄ‚îÄ COUNT WORDS ‚îÄ‚îÄ',
    'words: hello world           ‚Üí  2',
    'count words: the quick fox   ‚Üí  3',
    '',
    '‚îÄ‚îÄ COUNT LETTERS ‚îÄ‚îÄ',
    'letters: hello               ‚Üí  5 (a-z only)',
    'letters: Hello World 123     ‚Üí  10 (no spaces/digits)',
    '',
    '‚îÄ‚îÄ STRING LENGTH ‚îÄ‚îÄ',
    'length: hello world          ‚Üí  11 (all chars)',
    'len: test                    ‚Üí  4',
    '',
    '‚îÄ‚îÄ COUNT PATTERN ‚îÄ‚îÄ',
    'count "the" in: the cat the  ‚Üí  2',
    'count "a" in: banana         ‚Üí  3',
    '',
    '‚îÄ‚îÄ FULL ANALYSIS ‚îÄ‚îÄ',
    'analyze: Hello World 123',
    '  ‚Üí words, letters, digits, spaces, etc.'
  ]},
  dice: { name: 'Dice Roller', desc: 'Roll dice for probability', commands: [
    '‚îÄ‚îÄ ROLL DICE ‚îÄ‚îÄ',
    'roll d6                ‚Üí  Roll one 6-sided die',
    'roll 2d6               ‚Üí  Roll two 6-sided dice',
    'roll 3d8               ‚Üí  Roll three 8-sided dice',
    'roll d20               ‚Üí  Roll a 20-sided die',
    'roll 4d6+5             ‚Üí  Roll and add modifier',
    'roll 2d10-3            ‚Üí  Roll with negative mod',
    '',
    '‚îÄ‚îÄ DICE STATISTICS ‚îÄ‚îÄ',
    'dice stats 2d6         ‚Üí  Probability breakdown',
    'stats 3d6              ‚Üí  Shows min/max/avg',
    'dice stats 1d20        ‚Üí  Distribution chart',
    '',
    '‚îÄ‚îÄ EXAMPLES ‚îÄ‚îÄ',
    'roll d6      ‚Üí  üé≤ 4',
    'roll 2d6     ‚Üí  üé≤ 3 + 5 = 8',
    'roll 3d6+2   ‚Üí  üé≤ 2 + 4 + 6 + 2 = 14',
    '',
    '‚îÄ‚îÄ COMMON DICE ‚îÄ‚îÄ',
    'd4, d6, d8, d10, d12, d20, d100'
  ]},
  roman: { name: 'Roman Numerals', desc: 'Convert to/from Roman numerals', commands: [
    '‚îÄ‚îÄ TO ROMAN ‚îÄ‚îÄ',
    '42 to roman            ‚Üí  XLII',
    'roman 1999             ‚Üí  MCMXCIX',
    '2024 to roman          ‚Üí  MMXXIV',
    '',
    '‚îÄ‚îÄ FROM ROMAN ‚îÄ‚îÄ',
    'roman XIV              ‚Üí  14',
    'roman MCMLXXX          ‚Üí  1980',
    'roman to number XLII   ‚Üí  42',
    '',
    '‚îÄ‚îÄ LIMITS ‚îÄ‚îÄ',
    'Works for 1 to 3999'
  ]},
  dates: { name: 'Date Calculator', desc: 'Days between dates', commands: [
    '‚îÄ‚îÄ INCLUSIVE (from...to) ‚îÄ‚îÄ',
    'days from jan 1 to dec 31     ‚Üí  365',
    'days from today to dec 25',
    '  Counts both start & end date',
    '',
    '‚îÄ‚îÄ GAP (between...and) ‚îÄ‚îÄ',
    'days between jan 1 and dec 31 ‚Üí  364',
    'days between today and jan 1',
    '  Days in the gap only',
    '',
    '‚îÄ‚îÄ DATE FORMATS ‚îÄ‚îÄ',
    'jan 15, january 15',
    '1/15, 1/15/2024',
    'today',
    '',
    '‚îÄ‚îÄ EXAMPLES ‚îÄ‚îÄ',
    'days from jan 1 to jan 3  ‚Üí  3 (1,2,3)',
    'days between jan 1 and jan 3 ‚Üí 2 (gap)'
  ]},
  time: { name: 'Time Tools', desc: 'Time conversions & calculations', commands: [
    '‚îÄ‚îÄ TIME UNTIL ‚îÄ‚îÄ',
    'time until 5pm             ‚Üí  Xh Xm',
    'time until 3:30am',
    'how long until 17:00',
    '',
    '‚îÄ‚îÄ TIME DIFFERENCE ‚îÄ‚îÄ',
    'time from 9am to 5pm       ‚Üí  8h 0m',
    'time from 11:30 to 14:45   ‚Üí  3h 15m',
    '',
    '‚îÄ‚îÄ MILITARY / 24-HOUR ‚îÄ‚îÄ',
    '5pm to military            ‚Üí  17:00',
    '3:30am to military         ‚Üí  03:30',
    '17:00 to standard          ‚Üí  5:00 PM',
    '09:45 to standard          ‚Üí  9:45 AM',
    '',
    '‚îÄ‚îÄ CURRENT TIME ‚îÄ‚îÄ',
    'now                        ‚Üí  Shows current time'
  ]},
  physics: { name: 'Physics', desc: 'Physics formulas & calculations', commands: [
    '‚îÄ‚îÄ MOTION ‚îÄ‚îÄ',
    'velocity d=100 t=10        ‚Üí  10 m/s',
    'acceleration v=20 t=5      ‚Üí  4 m/s¬≤',
    'distance v=10 t=5          ‚Üí  50 m',
    '',
    '‚îÄ‚îÄ FORCES & ENERGY ‚îÄ‚îÄ',
    'force m=10 a=9.8           ‚Üí  98 N',
    'momentum m=10 v=5          ‚Üí  50 kg¬∑m/s',
    'KE m=10 v=5                ‚Üí  125 J',
    'PE m=10 h=5                ‚Üí  490.5 J',
    'work f=100 d=5             ‚Üí  500 J',
    '',
    '‚îÄ‚îÄ FREE FALL ‚îÄ‚îÄ',
    'fall t=3                   ‚Üí  d=44.1m, v=29.4m/s',
    'fall h=20                  ‚Üí  t=2.02s, v=19.8m/s',
    '',
    '‚îÄ‚îÄ ELECTRICAL ‚îÄ‚îÄ',
    'ohms v=12 i=3              ‚Üí  R=4 Œ©',
    'ohms v=12 r=4              ‚Üí  I=3 A',
    'ohms i=3 r=4               ‚Üí  V=12 V',
    'watts v=120 i=2            ‚Üí  240 W',
    'watts p=100 v=20           ‚Üí  I=5 A',
    '',
    '‚îÄ‚îÄ WAVES ‚îÄ‚îÄ',
    'wavelength f=500 v=343     ‚Üí  0.686 m',
    'frequency v=343 w=0.5      ‚Üí  686 Hz'
  ]},
  chemistry: { name: 'Chemistry', desc: 'Chemistry formulas & calculations', commands: [
    '‚îÄ‚îÄ ELEMENT LOOKUP ‚îÄ‚îÄ',
    'element Fe                 ‚Üí  Info on Iron',
    'element Oxygen             ‚Üí  Info by name',
    'element 79                 ‚Üí  Info by atomic #',
    '',
    '‚îÄ‚îÄ ELEMENT LISTS ‚îÄ‚îÄ',
    'elements all               ‚Üí  All by category',
    'elements noble gas         ‚Üí  Noble gases',
    'elements halogen           ‚Üí  Halogens',
    'elements alkali            ‚Üí  Alkali metals',
    'elements transition        ‚Üí  Transition metals',
    'elements lanthanide        ‚Üí  Lanthanides',
    'elements actinide          ‚Üí  Actinides',
    '',
    '‚îÄ‚îÄ BALANCE EQUATIONS ‚îÄ‚îÄ',
    'balance H2 + O2 = H2O',
    'balance Fe + O2 = Fe2O3',
    '',
    '‚îÄ‚îÄ MOLAR MASS ‚îÄ‚îÄ',
    'mass of H2O               ‚Üí  18.015 g/mol',
    'mass of NaCl              ‚Üí  58.44 g/mol',
    'formula H2SO4             ‚Üí  Full breakdown',
    '',
    '‚îÄ‚îÄ pH & SOLUTIONS ‚îÄ‚îÄ',
    'pH 0.001                   ‚Üí  pH=3',
    'molarity mol=0.5 L=2       ‚Üí  0.25 M',
    'dilute M1=2 V1=50 M2=0.5   ‚Üí  V2=200 mL',
    '',
    '‚îÄ‚îÄ GAS & DENSITY ‚îÄ‚îÄ',
    'gas P=1 V=22.4 T=273       ‚Üí  n‚âà1 mol',
    'density m=100 v=50         ‚Üí  2 g/mL'
  ]},
  formulas: { name: 'Custom Formulas', desc: 'Save & reuse your own formulas', commands: [
    '‚îÄ‚îÄ SAVE A FORMULA ‚îÄ‚îÄ',
    'save NAME = FORMULA',
    '',
    'Examples:',
    '  save tri = 0.5 * b * h',
    '  save hyp = sqrt(a^2 + b^2)',
    '  save circle = pi * r^2',
    '  save interest = P * r * t',
    '  save fToC = (f - 32) * 5/9',
    '',
    '‚îÄ‚îÄ USE A FORMULA ‚îÄ‚îÄ',
    'NAME where var1=value, var2=value',
    'NAME var1=value var2=value',
    '',
    'Examples:',
    '  tri where b=10, h=5     ‚Üí  25',
    '  hyp a=3, b=4            ‚Üí  5',
    '  circle r=7              ‚Üí  153.94',
    '  fToC f=98.6             ‚Üí  37',
    '',
    '‚îÄ‚îÄ MANAGE FORMULAS ‚îÄ‚îÄ',
    'formulas           List all saved',
    'saved              List all saved',
    'delete NAME        Remove a formula',
    'clear formulas     Remove ALL formulas',
    '',
    '‚îÄ‚îÄ HOW IT WORKS ‚îÄ‚îÄ',
    '‚Ä¢ Formulas save to your browser',
    '‚Ä¢ They persist after closing',
    '‚Ä¢ Use variables like a, b, x, r, etc',
    '‚Ä¢ Use any math: + - * / ^ sqrt sin',
    '‚Ä¢ Use pi, e, and ans in formulas',
    '',
    '‚îÄ‚îÄ NESTED FORMULAS ‚îÄ‚îÄ',
    '‚Ä¢ Use one formula inside another!',
    '  save circle = pi * r^2',
    '  save cylinder = circle * h',
    '  cylinder r=5, h=10  ‚Üí  785.4'
  ]},
  random: { name: 'Random & Practice', desc: 'Generators for teaching', commands: [
    '‚îÄ‚îÄ BASIC PRACTICE ‚îÄ‚îÄ',
    'practice addition      ‚Üí  + problems',
    'practice subtraction   ‚Üí  - problems',
    'practice multiplication‚Üí  √ó problems',
    'practice division      ‚Üí  √∑ problems',
    'practice mixed         ‚Üí  Random basic op',
    '',
    '‚îÄ‚îÄ ADVANCED PRACTICE ‚îÄ‚îÄ',
    'practice algebra       ‚Üí  Solve for x',
    'practice multistep     ‚Üí  Two operations',
    'practice pemdas        ‚Üí  Order of operations',
    'practice fractions     ‚Üí  Fraction problems',
    'practice percent       ‚Üí  Percentage problems',
    'practice exponents     ‚Üí  Powers & roots',
    'practice word          ‚Üí  Word/story problems',
    '',
    '‚îÄ‚îÄ RANDOM NUMBERS ‚îÄ‚îÄ',
    'random 1 to 100        ‚Üí  Single random',
    'random 5 numbers 1 to 50‚Üí Multiple randoms',
    'pick from a, b, c, d   ‚Üí  Random choice',
    '',
    '‚îÄ‚îÄ TIMES TABLES ‚îÄ‚îÄ',
    'times table 7          ‚Üí  7√ó1 through 7√ó12'
  ]}
};

function renderHelp(cat = null) {
  if (!cat) {
    let t = '‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n';
    t += '‚ïë          JCALCULATOR HELP MENU           ‚ïë\n';
    t += '‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n';
    t += '‚ïë  Type a category name for details:       ‚ïë\n';
    t += '‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n';
    Object.entries(helpCategories).forEach(([k, v]) => {
      t += `‚ïë  ${k.padEnd(12)} ‚îÇ ${v.desc.padEnd(24)} ‚ïë\n`;
    });
    t += '‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n';
    t += '‚ïë  üí° TIP: Save your own formulas!         ‚ïë\n';
    t += '‚ïë     save myformula = a * b + c           ‚ïë\n';
    t += '‚ïë     myformula a=2, b=3, c=4  ‚Üí  10       ‚ïë\n';
    t += '‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù';
    return t;
  }
  const c = helpCategories[cat];
  if (!c) return `Unknown: "${cat}". Type "help" for list.`;
  let t = `‚îå‚îÄ‚îÄ‚îÄ ${c.name.toUpperCase()} ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n`;
  t += `‚îÇ ${c.desc.padEnd(42)} ‚îÇ\n`;
  t += '‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n';
  c.commands.forEach(cmd => {
    if (cmd.startsWith('‚îÄ‚îÄ')) {
      t += `‚îÇ ${cmd.padEnd(42)} ‚îÇ\n`;
    } else {
      t += `‚îÇ  ${cmd.padEnd(41)} ‚îÇ\n`;
    }
  });
  t += '‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n';
  t += '‚îÇ  ‚Üê Type "help" to go back                  ‚îÇ\n';
  t += '‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò';
  return t;
}

// ===== WEIRD INPUT NORMALIZER =====
function normalizeWeirdInput(input) {
  let s = input.toLowerCase().trim();
  
  // Word numbers mapping
  const wordNums = {
    'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5,
    'six': 6, 'seven': 7, 'eight': 8, 'nine': 9, 'ten': 10,
    'eleven': 11, 'twelve': 12, 'thirteen': 13, 'fourteen': 14, 'fifteen': 15,
    'sixteen': 16, 'seventeen': 17, 'eighteen': 18, 'nineteen': 19, 'twenty': 20,
    'thirty': 30, 'forty': 40, 'fifty': 50, 'sixty': 60, 'seventy': 70,
    'eighty': 80, 'ninety': 90, 'hundred': 100, 'thousand': 1000,
    'dozen': 12, 'couple': 2, 'few': 3, 'several': 5, 'score': 20
  };
  
  // Strip question words and junk at start
  s = s.replace(/^(what is|what's|whats|calculate|compute|solve|find|tell me|give me|how much is|how many is|evaluate)\s*/i, '');
  
  // Strip trailing junk
  s = s.replace(/[\s]*[=?]+[\s]*$/g, '');
  
  // Strip unit words (but keep the numbers)
  s = s.replace(/\b(apples?|oranges?|bananas?|items?|things?|dollars?|cents?|pounds?|miles?|feet|foot|inches?|inch|meters?|seconds?|minutes?|hours?|days?|people|students?|cookies?|candies?|candy|toys?|books?|pencils?|pens?|total|each|left|remaining|kids?|children|cars?|cats?|dogs?|birds?|balls?|boxes?|pieces?|slices?|parts?)\b/gi, '');
  
  // "a" or "an" at word boundary = 1 (before certain words)
  s = s.replace(/\b(a|an)\s+(?=half|third|quarter|dozen|hundred|thousand|couple|few|score)/gi, '1 ');
  
  // Handle "half a dozen", "half of X"
  s = s.replace(/\bhalf\s+(a\s+)?dozen\b/gi, '6');
  s = s.replace(/\bhalf\s+(of\s+)?(\d+)/gi, '($2/2)');
  s = s.replace(/\bhalf\b/gi, '0.5');
  
  // Handle "quarter of X", "third of X"
  s = s.replace(/\b(a\s+)?quarter\s+(of\s+)?(\d+)/gi, '($3/4)');
  s = s.replace(/\b(a\s+)?third\s+(of\s+)?(\d+)/gi, '($3/3)');
  
  // Handle "double", "twice", "triple" - before OR after number
  s = s.replace(/\bdouble\s+(\d+)/gi, '(2*$1)');
  s = s.replace(/\btwice\s+(\d+)/gi, '(2*$1)');
  s = s.replace(/\btriple\s+(\d+)/gi, '(3*$1)');
  s = s.replace(/(\d+)\s+doubled\b/gi, '(2*$1)');
  s = s.replace(/(\d+)\s+tripled\b/gi, '(3*$1)');
  
  // Handle "X squared", "X cubed"
  s = s.replace(/(\d+)\s+squared\b/gi, '($1^2)');
  s = s.replace(/(\d+)\s+cubed\b/gi, '($1^3)');
  s = s.replace(/\bsquare\s+(of\s+)?(\d+)/gi, '($2^2)');
  s = s.replace(/\bcube\s+(of\s+)?(\d+)/gi, '($2^3)');
  
  // Handle "square root of X", "cube root of X"
  s = s.replace(/\bsquare\s*root\s*(of\s+)?(\d+)/gi, 'sqrt($2)');
  s = s.replace(/\bcube\s*root\s*(of\s+)?(\d+)/gi, 'cbrt($2)');
  s = s.replace(/\bsqrt\s+of\s+(\d+)/gi, 'sqrt($1)');
  
  // Handle "the sum of X and Y", "the product of X and Y"
  s = s.replace(/\b(the\s+)?sum\s+of\s+(\d+)\s+and\s+(\d+)/gi, '($2+$3)');
  s = s.replace(/\b(the\s+)?product\s+of\s+(\d+)\s+and\s+(\d+)/gi, '($2*$3)');
  s = s.replace(/\b(the\s+)?difference\s+(of|between)\s+(\d+)\s+and\s+(\d+)/gi, '($3-$4)');
  s = s.replace(/\b(the\s+)?quotient\s+of\s+(\d+)\s+and\s+(\d+)/gi, '($2/$3)');
  
  // Word operators to symbols
  s = s.replace(/\bplus\b/gi, '+');
  s = s.replace(/\badd\b/gi, '+');
  s = s.replace(/\bminus\b/gi, '-');
  s = s.replace(/\bsubtract\b/gi, '-');
  s = s.replace(/\btimes\b/gi, '*');
  s = s.replace(/\bmultiplied\s+by\b/gi, '*');
  s = s.replace(/\bdivided\s+by\b/gi, '/');
  s = s.replace(/\bover\b/gi, '/');
  s = s.replace(/\bto\s+the\s+power\s+(of\s+)?/gi, '^');
  s = s.replace(/\braised\s+to\s+(the\s+)?/gi, '^');
  s = s.replace(/\bmod(ulo)?\b/gi, '%');
  
  // Replace word numbers with digits (handle compound like "twenty-three", "twenty three")
  // First handle "X hundred Y" patterns like "five hundred twenty three"
  s = s.replace(/\b(one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty)\s+hundred\s+(and\s+)?(.*?)(?=\s*[\+\-\*\/\^]|$)/gi, (m, h, and, rest) => {
    const hVal = wordNums[h.toLowerCase()] || 0;
    // Process rest recursively later, for now just mark
    return `${hVal * 100}+${rest || '0'}`;
  });
  
  s = s.replace(/\b(one|two|three|four|five|six|seven|eight|nine|ten)\s+thousand\b/gi, (m, t) => {
    return (wordNums[t.toLowerCase()] * 1000).toString();
  });

  // Handle tens-ones compounds like "twenty-three", "twenty three"
  s = s.replace(/\b(twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety)[\s-]*(one|two|three|four|five|six|seven|eight|nine)\b/gi, (m, tens, ones) => {
    return (wordNums[tens.toLowerCase()] + wordNums[ones.toLowerCase()]).toString();
  });
  
  // Then handle single word numbers (but not hundred/thousand as standalone)
  const singleWordNums = {...wordNums};
  delete singleWordNums.hundred;
  delete singleWordNums.thousand;
  for (const [word, num] of Object.entries(singleWordNums)) {
    const regex = new RegExp(`\\b${word}\\b`, 'gi');
    s = s.replace(regex, num.toString());
  }
  
  // Clean up any "X+0" from hundred handling
  s = s.replace(/\+0\b/g, '');
  
  // Implicit multiplication: 2(3), (2)(3), 5pi, )2
  s = s.replace(/(\d)\s*\(/g, '$1*(');       // 2( ‚Üí 2*(
  s = s.replace(/\)\s*\(/g, ')*(');           // )( ‚Üí )*(
  s = s.replace(/\)\s*(\d)/g, ')*$1');        // )2 ‚Üí )*2
  s = s.replace(/(\d)\s*(pi|e)\b/gi, '$1*$2'); // 5pi ‚Üí 5*pi
  s = s.replace(/\)\s*(pi|e)\b/gi, ')*$1');   // )pi ‚Üí )*pi
  
  // Clean up multiple spaces
  s = s.replace(/\s+/g, ' ').trim();
  
  return s;
}

// ===== MATH PARSER =====
function evaluate(expr) {
  const tokens = tokenize(expr);
  if (!tokens.length) throw new Error('Empty');
  return parseExpr(tokens, {pos: 0});
}

function tokenize(expr) {
  const tokens = [];
  let i = 0;
  expr = expr.replace(/\s+/g, '');
  while (i < expr.length) {
    const c = expr[i];
    if (/[0-9.]/.test(c) || (c === '-' && (!tokens.length || ['(','+','-','*','/','^',',','%'].includes(tokens[tokens.length-1])))) {
      let num = '';
      if (c === '-') { num = '-'; i++; }
      while (i < expr.length && /[0-9.]/.test(expr[i])) { num += expr[i]; i++; }
      tokens.push(parseFloat(num));
    } else if (/[a-zA-Z]/.test(c)) {
      let fn = '';
      while (i < expr.length && /[a-zA-Z0-9]/.test(expr[i])) { fn += expr[i].toLowerCase(); i++; }
      if (fn === 'pi') tokens.push(Math.PI);
      else if (fn === 'e' && (i >= expr.length || !/[a-zA-Z]/.test(expr[i]))) tokens.push(Math.E);
      else tokens.push(fn);
    } else if ('+-*/^(),!%'.includes(c)) { tokens.push(c); i++; }
    else i++;
  }
  return tokens;
}

function parseExpr(t, s) {
  let left = parseTerm(t, s);
  while (s.pos < t.length && (t[s.pos] === '+' || t[s.pos] === '-')) {
    const op = t[s.pos++];
    left = op === '+' ? left + parseTerm(t, s) : left - parseTerm(t, s);
  }
  return left;
}

function parseTerm(t, s) {
  let left = parsePow(t, s);
  while (s.pos < t.length && (t[s.pos] === '*' || t[s.pos] === '/' || t[s.pos] === '%')) {
    const op = t[s.pos++];
    const right = parsePow(t, s);
    if (op === '/' && right === 0) throw new Error('Division by zero');
    left = op === '*' ? left * right : op === '/' ? left / right : left % right;
  }
  return left;
}

function parsePow(t, s) {
  let base = parseUnary(t, s);
  if (s.pos < t.length && t[s.pos] === '^') { s.pos++; base = Math.pow(base, parsePow(t, s)); }
  return base;
}

function parseUnary(t, s) {
  let r = parseFactor(t, s);
  while (s.pos < t.length && t[s.pos] === '!') { s.pos++; r = factorial(r); }
  return r;
}

function parseFactor(t, s) {
  const tok = t[s.pos];
  if (typeof tok === 'number') { s.pos++; return tok; }
  if (tok === '(') {
    s.pos++;
    const r = parseExpr(t, s);
    if (t[s.pos] === ')') s.pos++;
    return r;
  }
  if (typeof tok === 'string') {
    s.pos++;
    if (t[s.pos] === '(') {
      s.pos++;
      const args = [];
      while (t[s.pos] !== ')' && s.pos < t.length) {
        args.push(parseExpr(t, s));
        if (t[s.pos] === ',') s.pos++;
      }
      s.pos++;
      const fns = {
        sin: a => Math.sin(a), cos: a => Math.cos(a), tan: a => Math.tan(a),
        asin: a => Math.asin(a), acos: a => Math.acos(a), atan: a => Math.atan(a),
        csc: a => 1/Math.sin(a), sec: a => 1/Math.cos(a), cot: a => 1/Math.tan(a),
        log: (a,b) => b ? Math.log(a)/Math.log(b) : Math.log10(a),
        ln: a => Math.log(a), sqrt: a => Math.sqrt(a), cbrt: a => Math.cbrt(a),
        abs: a => Math.abs(a), floor: a => Math.floor(a), ceil: a => Math.ceil(a),
        round: a => Math.round(a), pow: (a,b) => Math.pow(a,b),
        min: (...a) => Math.min(...a), max: (...a) => Math.max(...a),
        ncr: (n,r) => comb(n,r), npr: (n,r) => perm(n,r)
      };
      if (fns[tok]) return fns[tok](...args);
      throw new Error(`Unknown: ${tok}`);
    }
  }
  throw new Error('Unexpected token');
}

// ===== UTILITIES =====
function factorial(n) {
  if (n < 0 || !Number.isInteger(n)) throw new Error('Factorial needs non-negative integer');
  let r = 1; for (let i = 2; i <= n; i++) r *= i; return r;
}
function comb(n, r) { return factorial(n) / (factorial(r) * factorial(n - r)); }
function perm(n, r) { return factorial(n) / factorial(n - r); }
function gcd(a, b) { return b ? gcd(b, a % b) : Math.abs(a); }

function getFactors(n) {
  const f = []; n = Math.abs(n);
  for (let i = 1; i <= Math.sqrt(n); i++) if (n % i === 0) { f.push(i); if (i !== n/i) f.push(n/i); }
  return f.sort((a,b) => a-b);
}

function getPrimes(n) {
  if (n < 2) return [];
  const s = new Array(n+1).fill(true); s[0] = s[1] = false;
  for (let i = 2; i*i <= n; i++) if (s[i]) for (let j = i*i; j <= n; j += i) s[j] = false;
  return s.map((p,i) => p ? i : null).filter(Boolean);
}

function isPrime(n) {
  if (n < 2) return false; if (n === 2) return true; if (n % 2 === 0) return false;
  for (let i = 3; i <= Math.sqrt(n); i += 2) if (n % i === 0) return false;
  return true;
}

function stats(nums) {
  const sorted = [...nums].sort((a,b) => a-b);
  const n = sorted.length, sum = nums.reduce((a,b) => a+b, 0);
  const mean = sum / n;
  const median = n % 2 ? sorted[Math.floor(n/2)] : (sorted[n/2-1] + sorted[n/2]) / 2;
  const counts = {}; nums.forEach(x => counts[x] = (counts[x]||0) + 1);
  const maxC = Math.max(...Object.values(counts));
  const modes = Object.entries(counts).filter(([,c]) => c === maxC).map(([v]) => +v);
  const variance = nums.reduce((s,x) => s + Math.pow(x - mean, 2), 0) / n;
  return { mean, median, modes, range: sorted[n-1] - sorted[0], stdDev: Math.sqrt(variance), min: sorted[0], max: sorted[n-1], sum, count: n };
}

function toFrac(d) {
  if (Number.isInteger(d)) return `${d}`;
  const sign = d < 0 ? -1 : 1; d = Math.abs(d);
  let best = {n: 0, d: 1, err: d};
  for (let den = 1; den <= 10000; den++) {
    const num = Math.round(d * den);
    const err = Math.abs(num/den - d);
    if (err < best.err) { best = {n: num, d: den, err}; if (err < 1e-10) break; }
  }
  const g = gcd(best.n, best.d);
  return `${sign * best.n / g}/${best.d / g}`;
}

// ===== CAESAR CIPHER =====
function caesar(text, shift, decrypt = false) {
  if (decrypt) shift = -shift;
  return text.split('').map(c => {
    if (/[a-zA-Z]/.test(c)) {
      const base = c >= 'A' && c <= 'Z' ? 65 : 97;
      const norm = ((shift % 26) + 26) % 26;
      return String.fromCharCode(((c.charCodeAt(0) - base + norm) % 26) + base);
    }
    if (/[0-9]/.test(c)) {
      const norm = ((shift % 10) + 10) % 10;
      return ((parseInt(c) + norm) % 10).toString();
    }
    return c;
  }).join('');
}

function caesarToNums(text, shift = 0) {
  const r = [];
  for (const c of text) {
    if (/[a-zA-Z]/.test(c)) {
      const pos = c.toUpperCase().charCodeAt(0) - 65;
      r.push(((pos + shift) % 26 + 26) % 26);
    } else if (c === ' ') r.push('/');
    else if (/[0-9]/.test(c)) r.push('d' + ((parseInt(c) + ((shift % 10) + 10) % 10) % 10));
    else r.push(c);
  }
  return r.join(' ');
}

function numsToLetters(text, shift = 0) {
  const tokens = text.trim().split(/\s+/);
  let r = '';
  for (const t of tokens) {
    if (t === '/') r += ' ';
    else if (t.startsWith('d') && t.length > 1) {
      const d = parseInt(t.substring(1));
      if (!isNaN(d)) r += ((d - ((shift % 10) + 10) % 10) % 10 + 10) % 10;
      else r += t;
    } else if (!isNaN(parseInt(t))) {
      const pos = ((parseInt(t) - shift) % 26 + 26) % 26;
      r += String.fromCharCode(65 + pos);
    } else r += t;
  }
  return r;
}

function getCaesarChart() {
  let c = 'Caesar Cipher Reference:\n';
  c += '‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n';
  c += '‚îÇ LETTERS MODE: Shifts A-Z (mod 26)      ‚îÇ\n';
  c += '‚îÇ               Also shifts 0-9 (mod 10) ‚îÇ\n';
  c += '‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n';
  c += '‚îÇ NUMBERS MODE (A=0, B=1, C=2...):       ‚îÇ\n';
  c += '‚îÇ A=0  B=1  C=2  D=3  E=4  F=5  G=6      ‚îÇ\n';
  c += '‚îÇ H=7  I=8  J=9  K=10 L=11 M=12 N=13     ‚îÇ\n';
  c += '‚îÇ O=14 P=15 Q=16 R=17 S=18 T=19 U=20     ‚îÇ\n';
  c += '‚îÇ V=21 W=22 X=23 Y=24 Z=25               ‚îÇ\n';
  c += '‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n';
  c += '‚îÇ Space = /     Digits = d0, d1, d2...   ‚îÇ\n';
  c += '‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò';
  return c;
}

// ===== MORSE CODE =====
const MORSE = {
  'A':'.-','B':'-...','C':'-.-.','D':'-..','E':'.','F':'..-.','G':'--.','H':'....',
  'I':'..','J':'.---','K':'-.-','L':'.-..','M':'--','N':'-.','O':'---','P':'.--.',
  'Q':'--.-','R':'.-.','S':'...','T':'-','U':'..-','V':'...-','W':'.--','X':'-..-',
  'Y':'-.--','Z':'--..','0':'-----','1':'.----','2':'..---','3':'...--','4':'....-',
  '5':'.....','6':'-....','7':'--...','8':'---..','9':'----.', ' ':'/'
};
const MORSE_REV = Object.fromEntries(Object.entries(MORSE).map(([k,v]) => [v,k]));

function toMorse(text) {
  return text.toUpperCase().split('').map(c => MORSE[c] || '').filter(Boolean).join(' ');
}
function fromMorse(morse) {
  return morse.trim().split(' ').map(c => c === '/' ? ' ' : MORSE_REV[c] || '?').join('').replace(/\s+/g, ' ');
}
function getMorseChart() {
  let c = 'Morse Code Reference:\n';
  c += '‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n';
  c += '‚îÇ A .-    H ....  O ---   V ...-  2 ..--- ‚îÇ\n';
  c += '‚îÇ B -...  I ..    P .--.  W .--   3 ...-- ‚îÇ\n';
  c += '‚îÇ C -.-.  J .---  Q --.-  X -..-  4 ....- ‚îÇ\n';
  c += '‚îÇ D -..   K -.-   R .-.   Y -.--  5 ..... ‚îÇ\n';
  c += '‚îÇ E .     L .-..  S ...   Z --..  6 -.... ‚îÇ\n';
  c += '‚îÇ F ..-.  M --    T -     0 -----  7 --... ‚îÇ\n';
  c += '‚îÇ G --.   N -.    U ..-   1 .----  8 ---.. ‚îÇ\n';
  c += '‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n';
  c += '‚îÇ Space between words: /                 ‚îÇ\n';
  c += '‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò';
  return c;
}

// ===== BINARY CONVERTER =====
function textToBin(text, mode = 'ascii') {
  if (mode === 'alpha') {
    const letters = text.toLowerCase().replace(/[^a-z]/g, '');
    if (!letters) return null;
    return letters.split('').map(c => (c.charCodeAt(0) - 97).toString(2).padStart(8, '0')).join(' ');
  }
  return text.split('').map(c => c.charCodeAt(0).toString(2).padStart(8, '0')).join(' ');
}

function binToText(bin, mode = 'ascii') {
  const clean = bin.replace(/\s+/g, '');
  if (!/^[01]+$/.test(clean)) return { err: 'Invalid binary' };
  if (clean.length % 8 !== 0) return { err: 'Must be groups of 8 bits' };
  const bytes = clean.match(/.{8}/g);
  if (mode === 'alpha') {
    return { text: bytes.map(b => { const v = parseInt(b, 2); return v >= 0 && v <= 25 ? String.fromCharCode(97 + v) : '?'; }).join('') };
  }
  return { text: bytes.map(b => String.fromCharCode(parseInt(b, 2))).join('') };
}

function getBinaryChart() {
  let c = 'Binary Reference (ASCII):\n';
  c += '‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n';
  c += '‚îÇ UPPERCASE: A=01000001, B=01000010...    ‚îÇ\n';
  c += '‚îÇ LOWERCASE: a=01100001, b=01100010...    ‚îÇ\n';
  c += '‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n';
  c += '‚îÇ ALPHABETIC MODE: a=00000000, b=00000001 ‚îÇ\n';
  c += '‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò';
  return c;
}

// ===== CONVERSIONS =====
const UNITS = {
  length: { m:1, km:1000, cm:0.01, mm:0.001, mi:1609.344, ft:0.3048, in:0.0254, mile:1609.344, miles:1609.344, feet:0.3048 },
  weight: { kg:1, g:0.001, lb:0.453592, oz:0.0283495, pound:0.453592, pounds:0.453592 },
  volume: { l:1, ml:0.001, gal:3.78541, gallon:3.78541 }
};
function convertTemp(v, from, to) {
  let c = from === 'c' ? v : from === 'f' ? (v-32)*5/9 : v - 273.15;
  return to === 'c' ? c : to === 'f' ? c*9/5+32 : c + 273.15;
}

// ===== MAIN PROCESSOR =====

function process(input) {
  const orig = input;
  const s = input.toLowerCase().trim();
  const ans = lastAnswer;

  // Help
  if (s === 'help' || s === '?') return { type: 'help', result: renderHelp() };
  
  // Direct category match
  if (helpCategories[s]) return { type: 'help', result: renderHelp(s) };
  
  // ===== STRING TOOLS =====
  // Count words
  if (s.match(/^(count\s+)?words\s*[:\s]\s*(.+)$/i)) {
    const text = s.match(/^(?:count\s+)?words\s*[:\s]\s*(.+)$/i)[1];
    const words = text.trim().split(/\s+/).filter(w => w.length > 0);
    return { type: 'result', result: `Words: ${words.length}\n"${text}"`, newAnswer: words.length };
  }
  
  // Count letters (no spaces)
  if (s.match(/^(count\s+)?letters\s*[:\s]\s*(.+)$/i)) {
    const text = s.match(/^(?:count\s+)?letters\s*[:\s]\s*(.+)$/i)[1];
    const letters = text.replace(/[^a-zA-Z]/g, '').length;
    return { type: 'result', result: `Letters: ${letters}\n"${text}"`, newAnswer: letters };
  }
  
  // Length
  if (s.match(/^(len|length)\s*[:\s]\s*(.+)$/i)) {
    const text = s.match(/^(?:len|length)\s*[:\s]\s*(.+)$/i)[1];
    return { type: 'result', result: `Length: ${text.length}`, newAnswer: text.length };
  }
  
  // Count pattern in string
  if (s.match(/^count\s+["'](.+?)["']\s+in\s*[:\s]\s*(.+)$/i)) {
    const m = s.match(/^count\s+["'](.+?)["']\s+in\s*[:\s]\s*(.+)$/i);
    const pattern = m[1];
    const text = m[2];
    const regex = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
    const matches = text.match(regex) || [];
    return { type: 'result', result: `"${pattern}" appears ${matches.length} time${matches.length !== 1 ? 's' : ''}\n"${text}"`, newAnswer: matches.length };
  }
  
  // Analyze string
  if (s.match(/^analyze\s*[:\s]\s*(.+)$/i)) {
    const text = s.match(/^analyze\s*[:\s]\s*(.+)$/i)[1];
    const letters = (text.match(/[a-zA-Z]/g) || []).length;
    const digits = (text.match(/[0-9]/g) || []).length;
    const spaces = (text.match(/\s/g) || []).length;
    const upper = (text.match(/[A-Z]/g) || []).length;
    const lower = (text.match(/[a-z]/g) || []).length;
    const special = text.length - letters - digits - spaces;
    const words = text.trim().split(/\s+/).filter(w => w.length > 0).length;
    
    let result = `String Analysis: "${text}"\n`;
    result += '‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n';
    result += `‚îÇ Total length:    ${text.length.toString().padStart(8)} ‚îÇ\n`;
    result += `‚îÇ Words:           ${words.toString().padStart(8)} ‚îÇ\n`;
    result += `‚îÇ Letters:         ${letters.toString().padStart(8)} ‚îÇ\n`;
    result += `‚îÇ   Uppercase:     ${upper.toString().padStart(8)} ‚îÇ\n`;
    result += `‚îÇ   Lowercase:     ${lower.toString().padStart(8)} ‚îÇ\n`;
    result += `‚îÇ Digits:          ${digits.toString().padStart(8)} ‚îÇ\n`;
    result += `‚îÇ Spaces:          ${spaces.toString().padStart(8)} ‚îÇ\n`;
    result += `‚îÇ Special chars:   ${special.toString().padStart(8)} ‚îÇ\n`;
    result += '‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò';
    return { type: 'help', result: result };
  }

  // ===== DICE ROLLER =====
  if (s.match(/^roll\s+(\d*)d(\d+)([+-]\d+)?$/i)) {
    const m = s.match(/^roll\s+(\d*)d(\d+)([+-]\d+)?$/i);
    const count = parseInt(m[1]) || 1;
    const sides = parseInt(m[2]);
    const modifier = parseInt(m[3]) || 0;
    
    if (count > 100) return { type: 'error', result: 'Max 100 dice at a time!' };
    if (sides < 2) return { type: 'error', result: 'Dice must have at least 2 sides!' };
    if (sides > 1000) return { type: 'error', result: 'Max 1000 sides!' };
    
    const rolls = [];
    for (let i = 0; i < count; i++) {
      rolls.push(Math.floor(Math.random() * sides) + 1);
    }
    const sum = rolls.reduce((a, b) => a + b, 0);
    const total = sum + modifier;
    
    let result = `üé≤ ${count}d${sides}`;
    if (modifier !== 0) result += (modifier > 0 ? '+' : '') + modifier;
    result += '\n';
    
    if (count === 1) {
      result += `Rolled: ${rolls[0]}`;
      if (modifier !== 0) result += ` ${modifier > 0 ? '+' : ''}${modifier} = ${total}`;
    } else {
      result += `Rolls: ${rolls.join(' + ')}`;
      if (modifier !== 0) result += ` ${modifier > 0 ? '+' : ''}${modifier}`;
      result += ` = ${total}`;
    }
    
    return { type: 'result', result: result, newAnswer: total };
  }

  // ===== DICE STATISTICS =====
  if (s.match(/^(dice\s+)?stats?\s+(\d*)d(\d+)$/i)) {
    const m = s.match(/^(?:dice\s+)?stats?\s+(\d*)d(\d+)$/i);
    const count = parseInt(m[1]) || 1;
    const sides = parseInt(m[2]);
    
    if (count > 10) return { type: 'error', result: 'Stats limited to 10 dice max (too many combinations)' };
    if (sides > 100) return { type: 'error', result: 'Stats limited to d100 max' };
    if (sides < 2) return { type: 'error', result: 'Dice must have at least 2 sides!' };
    
    const minSum = count;
    const maxSum = count * sides;
    const totalCombos = Math.pow(sides, count);
    const average = count * (sides + 1) / 2;
    
    // Calculate probability distribution using dynamic programming
    // dist[i] = number of ways to get sum i
    let dist = new Array(maxSum + 1).fill(0);
    dist[0] = 1;
    
    for (let die = 0; die < count; die++) {
      const newDist = new Array(maxSum + 1).fill(0);
      for (let sum = 0; sum <= maxSum; sum++) {
        if (dist[sum] > 0) {
          for (let face = 1; face <= sides; face++) {
            newDist[sum + face] += dist[sum];
          }
        }
      }
      dist = newDist;
    }
    
    // Find mode(s) and build distribution
    let maxCount = 0;
    let modes = [];
    for (let i = minSum; i <= maxSum; i++) {
      if (dist[i] > maxCount) {
        maxCount = dist[i];
        modes = [i];
      } else if (dist[i] === maxCount) {
        modes.push(i);
      }
    }
    
    let result = `üé≤ ${count}d${sides} Statistics\n`;
    result += '‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n';
    result += `‚îÇ Minimum:        ${minSum.toString().padStart(8)}        ‚îÇ\n`;
    result += `‚îÇ Maximum:        ${maxSum.toString().padStart(8)}        ‚îÇ\n`;
    result += `‚îÇ Average:        ${average.toFixed(2).padStart(8)}        ‚îÇ\n`;
    result += `‚îÇ Most likely:    ${modes.join(', ').padStart(8)}        ‚îÇ\n`;
    result += `‚îÇ Total combos:   ${totalCombos.toString().padStart(8)}        ‚îÇ\n`;
    result += '‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n';
    result += '‚îÇ Sum    Ways    Probability         ‚îÇ\n';
    result += '‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n';
    
    // Show distribution (limit rows for readability)
    const range = maxSum - minSum + 1;
    const step = range > 20 ? Math.ceil(range / 20) : 1;
    
    for (let i = minSum; i <= maxSum; i += step) {
      const ways = dist[i];
      const prob = (ways / totalCombos * 100).toFixed(2);
      const bar = '‚ñà'.repeat(Math.round(ways / maxCount * 10));
      result += `‚îÇ ${i.toString().padStart(4)}  ${ways.toString().padStart(6)}   ${prob.padStart(6)}%  ${bar.padEnd(10)} ‚îÇ\n`;
    }
    
    result += '‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò';
    
    return { type: 'help', result: result };
  }

  // ===== ROMAN NUMERALS =====
  // Number to Roman
  if (s.match(/^(\d+)\s*to\s*roman$/i) || s.match(/^roman\s+(\d+)$/i)) {
    const m = s.match(/(\d+)/);
    const num = parseInt(m[1]);
    
    if (num < 1 || num > 3999) {
      return { type: 'error', result: 'Roman numerals work for 1-3999' };
    }
    
    const romanNumerals = [
      ['M', 1000], ['CM', 900], ['D', 500], ['CD', 400],
      ['C', 100], ['XC', 90], ['L', 50], ['XL', 40],
      ['X', 10], ['IX', 9], ['V', 5], ['IV', 4], ['I', 1]
    ];
    
    let result = '';
    let remaining = num;
    for (const [numeral, value] of romanNumerals) {
      while (remaining >= value) {
        result += numeral;
        remaining -= value;
      }
    }
    
    return { type: 'result', result: `${num} = ${result}` };
  }
  
  // Roman to Number
  if (s.match(/^roman\s+([IVXLCDM]+)$/i) || s.match(/^roman\s+to\s+number\s+([IVXLCDM]+)$/i) || s.match(/^([IVXLCDM]+)\s+to\s+(number|decimal|arabic)$/i)) {
    const m = s.match(/([IVXLCDM]+)/i);
    const roman = m[1].toUpperCase();
    
    const values = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000 };
    let result = 0;
    
    for (let i = 0; i < roman.length; i++) {
      const current = values[roman[i]];
      const next = values[roman[i + 1]] || 0;
      if (current < next) {
        result -= current;
      } else {
        result += current;
      }
    }
    
    return { type: 'result', result: `${roman} = ${result}`, newAnswer: result };
  }

  // ===== DAYS BETWEEN DATES =====
  if (s.match(/days\s+(from|between)\s+(.+?)\s+(to|and)\s+(.+)/i)) {
    const m = s.match(/days\s+(from|between)\s+(.+?)\s+(to|and)\s+(.+)/i);
    const mode = m[1].toLowerCase(); // "from" or "between"
    let date1Str = m[2].trim();
    let date2Str = m[4].trim();
    
    const parseDate = (str) => {
      const today = new Date();
      const currentYear = today.getFullYear();
      
      // Handle "today"
      if (str.toLowerCase() === 'today') {
        return today;
      }
      
      // Month names
      const months = {
        jan: 0, january: 0, feb: 1, february: 1, mar: 2, march: 2,
        apr: 3, april: 3, may: 4, jun: 5, june: 5,
        jul: 6, july: 6, aug: 7, august: 7, sep: 8, september: 8,
        oct: 9, october: 9, nov: 10, november: 10, dec: 11, december: 11
      };
      
      // Try "jan 15" or "jan 15 2024" or "january 15"
      let match = str.match(/^([a-z]+)\s+(\d{1,2})(?:\s+(\d{4}))?$/i);
      if (match) {
        const month = months[match[1].toLowerCase()];
        if (month !== undefined) {
          const day = parseInt(match[2]);
          const year = match[3] ? parseInt(match[3]) : currentYear;
          return new Date(year, month, day);
        }
      }
      
      // Try "1/15" or "1/15/2024"
      match = str.match(/^(\d{1,2})\/(\d{1,2})(?:\/(\d{4}))?$/);
      if (match) {
        const month = parseInt(match[1]) - 1;
        const day = parseInt(match[2]);
        const year = match[3] ? parseInt(match[3]) : currentYear;
        return new Date(year, month, day);
      }
      
      // Try standard date parse
      const parsed = new Date(str);
      if (!isNaN(parsed)) return parsed;
      
      return null;
    };
    
    const date1 = parseDate(date1Str);
    const date2 = parseDate(date2Str);
    
    if (!date1 || !date2) {
      return { type: 'error', result: 'Could not parse date. Try: jan 15, 1/15/2024, or today' };
    }
    
    const diffTime = Math.abs(date2 - date1);
    const gapDays = Math.round(diffTime / (1000 * 60 * 60 * 24));
    
    // "from X to Y" = inclusive, "between X and Y" = gap
    const isInclusive = mode === 'from';
    const diffDays = isInclusive ? gapDays + 1 : gapDays;
    
    const formatDate = (d) => d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
    
    return { 
      type: 'result', 
      result: `üìÖ ${formatDate(date1)} ‚Üí ${formatDate(date2)}\n${diffDays} day${diffDays !== 1 ? 's' : ''} (${isInclusive ? 'inclusive' : 'gap'})`,
      newAnswer: diffDays 
    };
  }

  // ===== TIME TOOLS =====
  // Helper to parse time strings
  const parseTime = (str) => {
    str = str.trim().toLowerCase();
    
    // Handle "now"
    if (str === 'now') {
      const now = new Date();
      return { hours: now.getHours(), minutes: now.getMinutes() };
    }
    
    // 12-hour format: 5pm, 5:30pm, 5:30 pm, 5 pm
    let match = str.match(/^(\d{1,2})(?::(\d{2}))?\s*(am|pm)$/i);
    if (match) {
      let hours = parseInt(match[1]);
      const minutes = parseInt(match[2]) || 0;
      const period = match[3].toLowerCase();
      
      if (hours === 12) hours = 0;
      if (period === 'pm') hours += 12;
      
      return { hours, minutes };
    }
    
    // 24-hour format: 17:00, 09:30, 9:30
    match = str.match(/^(\d{1,2}):(\d{2})$/);
    if (match) {
      return { hours: parseInt(match[1]), minutes: parseInt(match[2]) };
    }
    
    // Just hour: 5, 17
    match = str.match(/^(\d{1,2})$/);
    if (match) {
      return { hours: parseInt(match[1]), minutes: 0 };
    }
    
    return null;
  };
  
  // Format minutes to "Xh Ym"
  const formatDuration = (totalMinutes) => {
    const hours = Math.floor(Math.abs(totalMinutes) / 60);
    const minutes = Math.abs(totalMinutes) % 60;
    if (hours === 0) return `${minutes}m`;
    if (minutes === 0) return `${hours}h`;
    return `${hours}h ${minutes}m`;
  };

  // Current time
  if (s === 'now' || s === 'current time' || s === 'what time' || s === 'what time is it') {
    const now = new Date();
    const standard = now.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
    const military = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
    return { type: 'result', result: `üïê ${standard}\n   ${military} (24-hr)` };
  }

  // Time until X
  if (s.match(/^(time\s+until|how\s+long\s+until|until)\s+(.+)$/i)) {
    const m = s.match(/^(?:time\s+until|how\s+long\s+until|until)\s+(.+)$/i);
    const targetTime = parseTime(m[1]);
    
    if (!targetTime) {
      return { type: 'error', result: 'Could not parse time. Try: 5pm, 5:30pm, 17:00' };
    }
    
    const now = new Date();
    const target = new Date();
    target.setHours(targetTime.hours, targetTime.minutes, 0, 0);
    
    // If target is in the past, assume tomorrow
    if (target <= now) {
      target.setDate(target.getDate() + 1);
    }
    
    const diffMs = target - now;
    const diffMins = Math.round(diffMs / 60000);
    
    const formatTarget = target.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
    const tomorrow = target.getDate() !== now.getDate() ? ' (tomorrow)' : '';
    
    return { 
      type: 'result', 
      result: `üïê Time until ${formatTarget}${tomorrow}\n${formatDuration(diffMins)}`,
      newAnswer: diffMins
    };
  }

  // Time from X to Y
  if (s.match(/^time\s+from\s+(.+?)\s+to\s+(.+)$/i)) {
    const m = s.match(/^time\s+from\s+(.+?)\s+to\s+(.+)$/i);
    const time1 = parseTime(m[1]);
    const time2 = parseTime(m[2]);
    
    if (!time1 || !time2) {
      return { type: 'error', result: 'Could not parse time. Try: 9am, 5:30pm, 17:00' };
    }
    
    let mins1 = time1.hours * 60 + time1.minutes;
    let mins2 = time2.hours * 60 + time2.minutes;
    
    // If end is before start, assume it crosses midnight
    if (mins2 < mins1) mins2 += 24 * 60;
    
    const diffMins = mins2 - mins1;
    
    const format12 = (t) => {
      let h = t.hours % 12 || 12;
      let m = t.minutes.toString().padStart(2, '0');
      let p = t.hours < 12 ? 'AM' : 'PM';
      return `${h}:${m} ${p}`;
    };
    
    return { 
      type: 'result', 
      result: `üïê ${format12(time1)} ‚Üí ${format12(time2)}\n${formatDuration(diffMins)}`,
      newAnswer: diffMins
    };
  }

  // To military/24-hour
  if (s.match(/^(\d{1,2}(?::\d{2})?\s*(?:am|pm))\s+to\s+(military|24.?h(?:ou)?r?)$/i)) {
    const m = s.match(/^(.+?)\s+to\s+(?:military|24.?h(?:ou)?r?)$/i);
    const time = parseTime(m[1]);
    
    if (!time) {
      return { type: 'error', result: 'Could not parse time. Try: 5pm, 5:30pm' };
    }
    
    const military = `${time.hours.toString().padStart(2, '0')}:${time.minutes.toString().padStart(2, '0')}`;
    const original = m[1].trim().toUpperCase();
    
    return { type: 'result', result: `üïê ${original} = ${military}` };
  }

  // To standard/12-hour
  if (s.match(/^(\d{1,2}:\d{2})\s+to\s+(standard|12.?h(?:ou)?r?)$/i)) {
    const m = s.match(/^(\d{1,2}:\d{2})\s+to\s+(?:standard|12.?h(?:ou)?r?)$/i);
    const time = parseTime(m[1]);
    
    if (!time) {
      return { type: 'error', result: 'Could not parse time. Try: 17:00, 09:30' };
    }
    
    let h = time.hours % 12 || 12;
    let mins = time.minutes.toString().padStart(2, '0');
    let period = time.hours < 12 ? 'AM' : 'PM';
    const standard = `${h}:${mins} ${period}`;
    
    return { type: 'result', result: `üïê ${m[1]} = ${standard}` };
  }

  // ===== CUSTOM FORMULAS =====
  // List formulas
  if (s === 'formulas' || s === 'saved' || s === 'my formulas' || s === 'list formulas') {
    return { type: 'help', result: listFormulas() };
  }

  // ===== PHYSICS =====
  // Velocity: v = d / t
  if (s.match(/^velocity\s+/i)) {
    const vars = {}; (s.match(/([a-z])=(-?[\d.]+)/gi) || []).forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    if (vars.d !== undefined && vars.t !== undefined) {
      const v = vars.d / vars.t;
      return { type: 'result', result: `Velocity = distance / time\nv = ${vars.d} / ${vars.t} = ${v.toFixed(4)} m/s`, newAnswer: v };
    }
    return { type: 'error', result: 'Need d= and t= (e.g., velocity d=100 t=10)' };
  }

  // Acceleration: a = v / t (or Œîv / t)
  if (s.match(/^acceleration\s+/i)) {
    const vars = {}; (s.match(/([a-z])=(-?[\d.]+)/gi) || []).forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    if (vars.v !== undefined && vars.t !== undefined) {
      const a = vars.v / vars.t;
      return { type: 'result', result: `Acceleration = velocity / time\na = ${vars.v} / ${vars.t} = ${a.toFixed(4)} m/s¬≤`, newAnswer: a };
    }
    return { type: 'error', result: 'Need v= and t= (e.g., acceleration v=20 t=5)' };
  }

  // Distance: d = v * t
  if (s.match(/^distance\s+v=/i)) {
    const vars = {}; (s.match(/([a-z])=(-?[\d.]+)/gi) || []).forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    if (vars.v !== undefined && vars.t !== undefined) {
      const d = vars.v * vars.t;
      return { type: 'result', result: `Distance = velocity √ó time\nd = ${vars.v} √ó ${vars.t} = ${d.toFixed(4)} m`, newAnswer: d };
    }
    return { type: 'error', result: 'Need v= and t= (e.g., distance v=10 t=5)' };
  }

  // Force: F = m * a
  if (s.match(/^force\s+/i)) {
    const vars = {}; (s.match(/([a-z])=(-?[\d.]+)/gi) || []).forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    if (vars.m !== undefined && vars.a !== undefined) {
      const f = vars.m * vars.a;
      return { type: 'result', result: `Force = mass √ó acceleration\nF = ${vars.m} √ó ${vars.a} = ${f.toFixed(4)} N`, newAnswer: f };
    }
    return { type: 'error', result: 'Need m= and a= (e.g., force m=10 a=9.8)' };
  }

  // Momentum: p = m * v
  if (s.match(/^momentum\s+/i)) {
    const vars = {}; (s.match(/([a-z])=(-?[\d.]+)/gi) || []).forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    if (vars.m !== undefined && vars.v !== undefined) {
      const p = vars.m * vars.v;
      return { type: 'result', result: `Momentum = mass √ó velocity\np = ${vars.m} √ó ${vars.v} = ${p.toFixed(4)} kg¬∑m/s`, newAnswer: p };
    }
    return { type: 'error', result: 'Need m= and v= (e.g., momentum m=10 v=5)' };
  }

  // Kinetic Energy: KE = 0.5 * m * v^2
  if (s.match(/^ke\s+/i) || s.match(/^kinetic\s+(energy\s+)?/i)) {
    const vars = {}; (s.match(/([a-z])=(-?[\d.]+)/gi) || []).forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    if (vars.m !== undefined && vars.v !== undefined) {
      const ke = 0.5 * vars.m * vars.v * vars.v;
      return { type: 'result', result: `Kinetic Energy = ¬Ωmv¬≤\nKE = 0.5 √ó ${vars.m} √ó ${vars.v}¬≤ = ${ke.toFixed(4)} J`, newAnswer: ke };
    }
    return { type: 'error', result: 'Need m= and v= (e.g., KE m=10 v=5)' };
  }

  // Potential Energy: PE = m * g * h
  if (s.match(/^pe\s+/i) || s.match(/^potential\s+(energy\s+)?/i)) {
    const vars = {}; (s.match(/([a-z])=(-?[\d.]+)/gi) || []).forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    const g = vars.g || 9.81;
    if (vars.m !== undefined && vars.h !== undefined) {
      const pe = vars.m * g * vars.h;
      return { type: 'result', result: `Potential Energy = mgh\nPE = ${vars.m} √ó ${g} √ó ${vars.h} = ${pe.toFixed(4)} J`, newAnswer: pe };
    }
    return { type: 'error', result: 'Need m= and h= (e.g., PE m=10 h=5)' };
  }

  // Work: W = F * d
  if (s.match(/^work\s+/i)) {
    const vars = {}; (s.match(/([a-z])=(-?[\d.]+)/gi) || []).forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    if (vars.f !== undefined && vars.d !== undefined) {
      const w = vars.f * vars.d;
      return { type: 'result', result: `Work = force √ó distance\nW = ${vars.f} √ó ${vars.d} = ${w.toFixed(4)} J`, newAnswer: w };
    }
    return { type: 'error', result: 'Need f= and d= (e.g., work f=100 d=5)' };
  }

  // Free fall
  if (s.match(/^fall\s+/i)) {
    const vars = {}; (s.match(/([a-z])=(-?[\d.]+)/gi) || []).forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    const g = 9.81;
    
    if (vars.t !== undefined) {
      // Given time, find distance and velocity
      const d = 0.5 * g * vars.t * vars.t;
      const v = g * vars.t;
      return { type: 'result', result: `Free Fall (t=${vars.t}s)\nd = ¬Ωgt¬≤ = ${d.toFixed(2)} m\nv = gt = ${v.toFixed(2)} m/s`, newAnswer: d };
    }
    if (vars.h !== undefined) {
      // Given height, find time and final velocity
      const t = Math.sqrt(2 * vars.h / g);
      const v = Math.sqrt(2 * g * vars.h);
      return { type: 'result', result: `Free Fall (h=${vars.h}m)\nt = ‚àö(2h/g) = ${t.toFixed(2)} s\nv = ‚àö(2gh) = ${v.toFixed(2)} m/s`, newAnswer: t };
    }
    return { type: 'error', result: 'Need t= or h= (e.g., fall t=3 or fall h=20)' };
  }

  // Ohm's Law: V = I * R
  if (s.match(/^ohms?\s+/i)) {
    const vars = {}; (s.match(/([a-z])=(-?[\d.]+)/gi) || []).forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    
    if (vars.v !== undefined && vars.i !== undefined) {
      const r = vars.v / vars.i;
      return { type: 'result', result: `Ohm's Law: V = IR\nR = V/I = ${vars.v}/${vars.i} = ${r.toFixed(4)} Œ©`, newAnswer: r };
    }
    if (vars.v !== undefined && vars.r !== undefined) {
      const i = vars.v / vars.r;
      return { type: 'result', result: `Ohm's Law: V = IR\nI = V/R = ${vars.v}/${vars.r} = ${i.toFixed(4)} A`, newAnswer: i };
    }
    if (vars.i !== undefined && vars.r !== undefined) {
      const v = vars.i * vars.r;
      return { type: 'result', result: `Ohm's Law: V = IR\nV = I√óR = ${vars.i}√ó${vars.r} = ${v.toFixed(4)} V`, newAnswer: v };
    }
    return { type: 'error', result: 'Need 2 of: v=, i=, r= (e.g., ohms v=12 r=4)' };
  }

  // Power: P = I * V
  if (s.match(/^watts\s+/i) || s.match(/^power\s+/i)) {
    const vars = {}; (s.match(/([a-z])=(-?[\d.]+)/gi) || []).forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    
    if (vars.v !== undefined && vars.i !== undefined) {
      const p = vars.v * vars.i;
      return { type: 'result', result: `Power: P = IV\nP = ${vars.i} √ó ${vars.v} = ${p.toFixed(4)} W`, newAnswer: p };
    }
    if (vars.p !== undefined && vars.v !== undefined) {
      const i = vars.p / vars.v;
      return { type: 'result', result: `Power: P = IV\nI = P/V = ${vars.p}/${vars.v} = ${i.toFixed(4)} A`, newAnswer: i };
    }
    if (vars.p !== undefined && vars.i !== undefined) {
      const v = vars.p / vars.i;
      return { type: 'result', result: `Power: P = IV\nV = P/I = ${vars.p}/${vars.i} = ${v.toFixed(4)} V`, newAnswer: v };
    }
    return { type: 'error', result: 'Need 2 of: p=, v=, i= (e.g., watts v=120 i=2)' };
  }

  // Wavelength: Œª = v / f
  if (s.match(/^wavelength\s+/i)) {
    const vars = {}; (s.match(/([a-z])=(-?[\d.]+)/gi) || []).forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    if (vars.v !== undefined && vars.f !== undefined) {
      const w = vars.v / vars.f;
      return { type: 'result', result: `Wavelength: Œª = v/f\nŒª = ${vars.v}/${vars.f} = ${w.toFixed(4)} m`, newAnswer: w };
    }
    return { type: 'error', result: 'Need v= and f= (e.g., wavelength f=500 v=343)' };
  }

  // Frequency: f = v / Œª
  if (s.match(/^frequency\s+/i)) {
    const vars = {}; (s.match(/([a-z])=(-?[\d.]+)/gi) || []).forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    if (vars.v !== undefined && vars.w !== undefined) {
      const f = vars.v / vars.w;
      return { type: 'result', result: `Frequency: f = v/Œª\nf = ${vars.v}/${vars.w} = ${f.toFixed(4)} Hz`, newAnswer: f };
    }
    return { type: 'error', result: 'Need v= and w= (e.g., frequency v=343 w=0.5)' };
  }

  // ===== CHEMISTRY =====
  // Complete Periodic Table: symbol -> {name, number, mass, category}
  const ELEMENTS = {
    H:  {n:'Hydrogen',      z:1,   m:1.008,    cat:'Nonmetal'},
    He: {n:'Helium',        z:2,   m:4.003,    cat:'Noble Gas'},
    Li: {n:'Lithium',       z:3,   m:6.941,    cat:'Alkali Metal'},
    Be: {n:'Beryllium',     z:4,   m:9.012,    cat:'Alkaline Earth'},
    B:  {n:'Boron',         z:5,   m:10.81,    cat:'Metalloid'},
    C:  {n:'Carbon',        z:6,   m:12.011,   cat:'Nonmetal'},
    N:  {n:'Nitrogen',      z:7,   m:14.007,   cat:'Nonmetal'},
    O:  {n:'Oxygen',        z:8,   m:15.999,   cat:'Nonmetal'},
    F:  {n:'Fluorine',      z:9,   m:18.998,   cat:'Halogen'},
    Ne: {n:'Neon',          z:10,  m:20.18,    cat:'Noble Gas'},
    Na: {n:'Sodium',        z:11,  m:22.99,    cat:'Alkali Metal'},
    Mg: {n:'Magnesium',     z:12,  m:24.305,   cat:'Alkaline Earth'},
    Al: {n:'Aluminum',      z:13,  m:26.982,   cat:'Post-Transition'},
    Si: {n:'Silicon',       z:14,  m:28.086,   cat:'Metalloid'},
    P:  {n:'Phosphorus',    z:15,  m:30.974,   cat:'Nonmetal'},
    S:  {n:'Sulfur',        z:16,  m:32.065,   cat:'Nonmetal'},
    Cl: {n:'Chlorine',      z:17,  m:35.453,   cat:'Halogen'},
    Ar: {n:'Argon',         z:18,  m:39.948,   cat:'Noble Gas'},
    K:  {n:'Potassium',     z:19,  m:39.098,   cat:'Alkali Metal'},
    Ca: {n:'Calcium',       z:20,  m:40.078,   cat:'Alkaline Earth'},
    Sc: {n:'Scandium',      z:21,  m:44.956,   cat:'Transition Metal'},
    Ti: {n:'Titanium',      z:22,  m:47.867,   cat:'Transition Metal'},
    V:  {n:'Vanadium',      z:23,  m:50.942,   cat:'Transition Metal'},
    Cr: {n:'Chromium',      z:24,  m:51.996,   cat:'Transition Metal'},
    Mn: {n:'Manganese',     z:25,  m:54.938,   cat:'Transition Metal'},
    Fe: {n:'Iron',          z:26,  m:55.845,   cat:'Transition Metal'},
    Co: {n:'Cobalt',        z:27,  m:58.933,   cat:'Transition Metal'},
    Ni: {n:'Nickel',        z:28,  m:58.693,   cat:'Transition Metal'},
    Cu: {n:'Copper',        z:29,  m:63.546,   cat:'Transition Metal'},
    Zn: {n:'Zinc',          z:30,  m:65.38,    cat:'Transition Metal'},
    Ga: {n:'Gallium',       z:31,  m:69.723,   cat:'Post-Transition'},
    Ge: {n:'Germanium',     z:32,  m:72.64,    cat:'Metalloid'},
    As: {n:'Arsenic',       z:33,  m:74.922,   cat:'Metalloid'},
    Se: {n:'Selenium',      z:34,  m:78.96,    cat:'Nonmetal'},
    Br: {n:'Bromine',       z:35,  m:79.904,   cat:'Halogen'},
    Kr: {n:'Krypton',       z:36,  m:83.798,   cat:'Noble Gas'},
    Rb: {n:'Rubidium',      z:37,  m:85.468,   cat:'Alkali Metal'},
    Sr: {n:'Strontium',     z:38,  m:87.62,    cat:'Alkaline Earth'},
    Y:  {n:'Yttrium',       z:39,  m:88.906,   cat:'Transition Metal'},
    Zr: {n:'Zirconium',     z:40,  m:91.224,   cat:'Transition Metal'},
    Nb: {n:'Niobium',       z:41,  m:92.906,   cat:'Transition Metal'},
    Mo: {n:'Molybdenum',    z:42,  m:95.96,    cat:'Transition Metal'},
    Tc: {n:'Technetium',    z:43,  m:98,       cat:'Transition Metal'},
    Ru: {n:'Ruthenium',     z:44,  m:101.07,   cat:'Transition Metal'},
    Rh: {n:'Rhodium',       z:45,  m:102.91,   cat:'Transition Metal'},
    Pd: {n:'Palladium',     z:46,  m:106.42,   cat:'Transition Metal'},
    Ag: {n:'Silver',        z:47,  m:107.87,   cat:'Transition Metal'},
    Cd: {n:'Cadmium',       z:48,  m:112.41,   cat:'Transition Metal'},
    In: {n:'Indium',        z:49,  m:114.82,   cat:'Post-Transition'},
    Sn: {n:'Tin',           z:50,  m:118.71,   cat:'Post-Transition'},
    Sb: {n:'Antimony',      z:51,  m:121.76,   cat:'Metalloid'},
    Te: {n:'Tellurium',     z:52,  m:127.6,    cat:'Metalloid'},
    I:  {n:'Iodine',        z:53,  m:126.9,    cat:'Halogen'},
    Xe: {n:'Xenon',         z:54,  m:131.29,   cat:'Noble Gas'},
    Cs: {n:'Cesium',        z:55,  m:132.91,   cat:'Alkali Metal'},
    Ba: {n:'Barium',        z:56,  m:137.33,   cat:'Alkaline Earth'},
    La: {n:'Lanthanum',     z:57,  m:138.91,   cat:'Lanthanide'},
    Ce: {n:'Cerium',        z:58,  m:140.12,   cat:'Lanthanide'},
    Pr: {n:'Praseodymium',  z:59,  m:140.91,   cat:'Lanthanide'},
    Nd: {n:'Neodymium',     z:60,  m:144.24,   cat:'Lanthanide'},
    Pm: {n:'Promethium',    z:61,  m:145,      cat:'Lanthanide'},
    Sm: {n:'Samarium',      z:62,  m:150.36,   cat:'Lanthanide'},
    Eu: {n:'Europium',      z:63,  m:151.96,   cat:'Lanthanide'},
    Gd: {n:'Gadolinium',    z:64,  m:157.25,   cat:'Lanthanide'},
    Tb: {n:'Terbium',       z:65,  m:158.93,   cat:'Lanthanide'},
    Dy: {n:'Dysprosium',    z:66,  m:162.5,    cat:'Lanthanide'},
    Ho: {n:'Holmium',       z:67,  m:164.93,   cat:'Lanthanide'},
    Er: {n:'Erbium',        z:68,  m:167.26,   cat:'Lanthanide'},
    Tm: {n:'Thulium',       z:69,  m:168.93,   cat:'Lanthanide'},
    Yb: {n:'Ytterbium',     z:70,  m:173.05,   cat:'Lanthanide'},
    Lu: {n:'Lutetium',      z:71,  m:174.97,   cat:'Lanthanide'},
    Hf: {n:'Hafnium',       z:72,  m:178.49,   cat:'Transition Metal'},
    Ta: {n:'Tantalum',      z:73,  m:180.95,   cat:'Transition Metal'},
    W:  {n:'Tungsten',      z:74,  m:183.84,   cat:'Transition Metal'},
    Re: {n:'Rhenium',       z:75,  m:186.21,   cat:'Transition Metal'},
    Os: {n:'Osmium',        z:76,  m:190.23,   cat:'Transition Metal'},
    Ir: {n:'Iridium',       z:77,  m:192.22,   cat:'Transition Metal'},
    Pt: {n:'Platinum',      z:78,  m:195.08,   cat:'Transition Metal'},
    Au: {n:'Gold',          z:79,  m:196.97,   cat:'Transition Metal'},
    Hg: {n:'Mercury',       z:80,  m:200.59,   cat:'Transition Metal'},
    Tl: {n:'Thallium',      z:81,  m:204.38,   cat:'Post-Transition'},
    Pb: {n:'Lead',          z:82,  m:207.2,    cat:'Post-Transition'},
    Bi: {n:'Bismuth',       z:83,  m:208.98,   cat:'Post-Transition'},
    Po: {n:'Polonium',      z:84,  m:209,      cat:'Metalloid'},
    At: {n:'Astatine',      z:85,  m:210,      cat:'Halogen'},
    Rn: {n:'Radon',         z:86,  m:222,      cat:'Noble Gas'},
    Fr: {n:'Francium',      z:87,  m:223,      cat:'Alkali Metal'},
    Ra: {n:'Radium',        z:88,  m:226,      cat:'Alkaline Earth'},
    Ac: {n:'Actinium',      z:89,  m:227,      cat:'Actinide'},
    Th: {n:'Thorium',       z:90,  m:232.04,   cat:'Actinide'},
    Pa: {n:'Protactinium',  z:91,  m:231.04,   cat:'Actinide'},
    U:  {n:'Uranium',       z:92,  m:238.03,   cat:'Actinide'},
    Np: {n:'Neptunium',     z:93,  m:237,      cat:'Actinide'},
    Pu: {n:'Plutonium',     z:94,  m:244,      cat:'Actinide'},
    Am: {n:'Americium',     z:95,  m:243,      cat:'Actinide'},
    Cm: {n:'Curium',        z:96,  m:247,      cat:'Actinide'},
    Bk: {n:'Berkelium',     z:97,  m:247,      cat:'Actinide'},
    Cf: {n:'Californium',   z:98,  m:251,      cat:'Actinide'},
    Es: {n:'Einsteinium',   z:99,  m:252,      cat:'Actinide'},
    Fm: {n:'Fermium',       z:100, m:257,      cat:'Actinide'},
    Md: {n:'Mendelevium',   z:101, m:258,      cat:'Actinide'},
    No: {n:'Nobelium',      z:102, m:259,      cat:'Actinide'},
    Lr: {n:'Lawrencium',    z:103, m:262,      cat:'Actinide'},
    Rf: {n:'Rutherfordium', z:104, m:267,      cat:'Transition Metal'},
    Db: {n:'Dubnium',       z:105, m:270,      cat:'Transition Metal'},
    Sg: {n:'Seaborgium',    z:106, m:271,      cat:'Transition Metal'},
    Bh: {n:'Bohrium',       z:107, m:270,      cat:'Transition Metal'},
    Hs: {n:'Hassium',       z:108, m:277,      cat:'Transition Metal'},
    Mt: {n:'Meitnerium',    z:109, m:276,      cat:'Unknown'},
    Ds: {n:'Darmstadtium',  z:110, m:281,      cat:'Unknown'},
    Rg: {n:'Roentgenium',   z:111, m:282,      cat:'Unknown'},
    Cn: {n:'Copernicium',   z:112, m:285,      cat:'Transition Metal'},
    Nh: {n:'Nihonium',      z:113, m:286,      cat:'Unknown'},
    Fl: {n:'Flerovium',     z:114, m:289,      cat:'Post-Transition'},
    Mc: {n:'Moscovium',     z:115, m:290,      cat:'Unknown'},
    Lv: {n:'Livermorium',   z:116, m:293,      cat:'Unknown'},
    Ts: {n:'Tennessine',    z:117, m:294,      cat:'Halogen'},
    Og: {n:'Oganesson',     z:118, m:294,      cat:'Noble Gas'}
  };

  // Get element by symbol or name
  const getElement = (query) => {
    const q = query.trim();
    // Try symbol first (case-sensitive match)
    const symbol = Object.keys(ELEMENTS).find(s => s.toLowerCase() === q.toLowerCase());
    if (symbol) return { symbol, ...ELEMENTS[symbol] };
    // Try name
    const byName = Object.entries(ELEMENTS).find(([s, e]) => e.n.toLowerCase() === q.toLowerCase());
    if (byName) return { symbol: byName[0], ...byName[1] };
    // Try atomic number
    const num = parseInt(q);
    if (!isNaN(num)) {
      const byNum = Object.entries(ELEMENTS).find(([s, e]) => e.z === num);
      if (byNum) return { symbol: byNum[0], ...byNum[1] };
    }
    return null;
  };

  // Element info: element Fe, element iron, element 26
  if (s.match(/^(element|atom|el)\s+(.+)$/i)) {
    const query = s.match(/^(?:element|atom|el)\s+(.+)$/i)[1];
    const el = getElement(query);
    
    if (!el) {
      return { type: 'error', result: `Element not found: ${query}\nTry: element Fe, element Iron, element 26` };
    }
    
    let result = `‚öõÔ∏è ${el.n} (${el.symbol})\n`;
    result += '‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n';
    result += `‚îÇ Atomic Number:    ${el.z.toString().padStart(10)} ‚îÇ\n`;
    result += `‚îÇ Atomic Mass:      ${el.m.toFixed(3).padStart(10)} ‚îÇ\n`;
    result += `‚îÇ Category:     ${el.cat.padStart(14)} ‚îÇ\n`;
    result += '‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò';
    
    return { type: 'help', result: result };
  }

  // List elements by category
  if (s.match(/^elements?\s+(all|list)$/i)) {
    const categories = {};
    Object.entries(ELEMENTS).forEach(([sym, el]) => {
      if (!categories[el.cat]) categories[el.cat] = [];
      categories[el.cat].push(sym);
    });
    
    let result = '‚öõÔ∏è All Elements by Category\n';
    result += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
    Object.entries(categories).sort((a,b) => a[0].localeCompare(b[0])).forEach(([cat, syms]) => {
      result += `\n${cat} (${syms.length}):\n`;
      result += syms.join(', ') + '\n';
    });
    
    return { type: 'help', result: result };
  }

  // List by specific category
  if (s.match(/^elements?\s+(.+)$/i)) {
    const catQuery = s.match(/^elements?\s+(.+)$/i)[1].toLowerCase();
    
    // Map common terms to category names
    const catMap = {
      'noble': 'Noble Gas', 'noble gas': 'Noble Gas', 'noble gases': 'Noble Gas',
      'halogen': 'Halogen', 'halogens': 'Halogen',
      'alkali': 'Alkali Metal', 'alkali metal': 'Alkali Metal', 'alkali metals': 'Alkali Metal',
      'alkaline': 'Alkaline Earth', 'alkaline earth': 'Alkaline Earth',
      'transition': 'Transition Metal', 'transition metal': 'Transition Metal', 'transition metals': 'Transition Metal',
      'lanthanide': 'Lanthanide', 'lanthanides': 'Lanthanide', 'rare earth': 'Lanthanide',
      'actinide': 'Actinide', 'actinides': 'Actinide',
      'metalloid': 'Metalloid', 'metalloids': 'Metalloid', 'semimetal': 'Metalloid',
      'nonmetal': 'Nonmetal', 'nonmetals': 'Nonmetal', 'non-metal': 'Nonmetal',
      'post-transition': 'Post-Transition', 'post transition': 'Post-Transition'
    };
    
    const category = catMap[catQuery] || Object.values(ELEMENTS).find(e => e.cat.toLowerCase() === catQuery)?.cat;
    
    if (!category) {
      return { type: 'error', result: `Unknown category: ${catQuery}\n\nCategories: Noble Gas, Halogen, Alkali Metal,\nAlkaline Earth, Transition Metal, Lanthanide,\nActinide, Metalloid, Nonmetal, Post-Transition` };
    }
    
    const elements = Object.entries(ELEMENTS)
      .filter(([s, e]) => e.cat === category)
      .sort((a, b) => a[1].z - b[1].z);
    
    let result = `‚öõÔ∏è ${category}s (${elements.length} elements)\n`;
    result += '‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n';
    result += '‚îÇ  #   ‚îÇ Name           ‚îÇ  Mass  ‚îÇ\n';
    result += '‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n';
    
    elements.forEach(([sym, el]) => {
      result += `‚îÇ ${el.z.toString().padStart(3)}  ‚îÇ ${(el.n + ' (' + sym + ')').padEnd(14)} ‚îÇ ${el.m.toFixed(2).padStart(6)} ‚îÇ\n`;
    });
    
    result += '‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò';
    
    return { type: 'help', result: result };
  }

  // Parse chemical formula into element counts: H2O -> {H: 2, O: 1}
  const parseFormula = (formula) => {
    const elements = {};
    // Match element + optional number, handling parentheses
    let f = formula.replace(/\s/g, '');
    
    // Simple parser (doesn't handle nested parentheses)
    const regex = /([A-Z][a-z]?)(\d*)/g;
    let match;
    while ((match = regex.exec(f)) !== null) {
      const el = match[1];
      const count = parseInt(match[2]) || 1;
      elements[el] = (elements[el] || 0) + count;
    }
    return elements;
  };

  // Calculate molar mass from formula
  const calcMolarMass = (formula) => {
    const elements = parseFormula(formula);
    let mass = 0;
    for (const [el, count] of Object.entries(elements)) {
      if (!ELEMENTS[el]) return null;
      mass += ELEMENTS[el].m * count;
    }
    return mass;
  };

  // Balance chemical equation
  if (s.match(/^balance\s+(.+)/i)) {
    const eq = s.match(/^balance\s+(.+)/i)[1];
    const sides = eq.split(/\s*[=‚Üí]\s*/);
    
    if (sides.length !== 2) {
      return { type: 'error', result: 'Use format: balance H2 + O2 = H2O' };
    }
    
    const reactants = sides[0].split(/\s*\+\s*/).map(s => s.trim());
    const products = sides[1].split(/\s*\+\s*/).map(s => s.trim());
    const allCompounds = [...reactants, ...products];
    
    // Get all unique elements
    const allElements = new Set();
    allCompounds.forEach(c => {
      Object.keys(parseFormula(c)).forEach(e => allElements.add(e));
    });
    const elements = [...allElements];
    
    // Try brute force for small coefficients (1-10)
    const maxCoef = 10;
    const numCompounds = allCompounds.length;
    
    const tryCoefficients = (coeffs) => {
      const totals = {};
      elements.forEach(e => totals[e] = { left: 0, right: 0 });
      
      // Sum left side
      for (let i = 0; i < reactants.length; i++) {
        const parsed = parseFormula(reactants[i]);
        for (const [el, count] of Object.entries(parsed)) {
          totals[el].left += count * coeffs[i];
        }
      }
      
      // Sum right side
      for (let i = 0; i < products.length; i++) {
        const parsed = parseFormula(products[i]);
        for (const [el, count] of Object.entries(parsed)) {
          totals[el].right += count * coeffs[reactants.length + i];
        }
      }
      
      // Check if balanced
      return elements.every(e => totals[e].left === totals[e].right);
    };
    
    // Generate all coefficient combinations
    const findBalance = (depth, coeffs) => {
      if (depth === numCompounds) {
        if (coeffs.some(c => c > 0) && tryCoefficients(coeffs)) {
          return [...coeffs];
        }
        return null;
      }
      
      for (let c = 1; c <= maxCoef; c++) {
        coeffs[depth] = c;
        const result = findBalance(depth + 1, coeffs);
        if (result) return result;
      }
      return null;
    };
    
    const solution = findBalance(0, new Array(numCompounds).fill(0));
    
    if (!solution) {
      return { type: 'error', result: 'Could not balance equation (try simpler formulas)' };
    }
    
    // Simplify coefficients by GCD
    const gcdAll = solution.reduce((a, b) => gcd(a, b));
    const simplified = solution.map(c => c / gcdAll);
    
    // Format output
    const formatSide = (compounds, coeffs, startIdx) => {
      return compounds.map((c, i) => {
        const coef = coeffs[startIdx + i];
        return coef === 1 ? c : `${coef}${c}`;
      }).join(' + ');
    };
    
    const leftSide = formatSide(reactants, simplified, 0);
    const rightSide = formatSide(products, simplified, reactants.length);
    
    return { type: 'result', result: `‚öóÔ∏è Balanced Equation:\n${leftSide} ‚Üí ${rightSide}` };
  }

  // Molar mass of compound
  if (s.match(/^mass\s+of\s+([A-Za-z0-9]+)$/i) || s.match(/^molar\s+mass\s+of\s+([A-Za-z0-9]+)$/i)) {
    const formula = s.match(/of\s+([A-Za-z0-9]+)$/i)[1];
    const mass = calcMolarMass(formula);
    
    if (mass === null) {
      return { type: 'error', result: `Unknown element in formula: ${formula}` };
    }
    
    const elements = parseFormula(formula);
    let breakdown = Object.entries(elements)
      .map(([el, count]) => `${el}: ${count} √ó ${ELEMENTS[el].m} = ${(count * ELEMENTS[el].m).toFixed(3)}`)
      .join('\n');
    
    return { type: 'result', result: `‚öóÔ∏è Molar Mass of ${formula}\n${breakdown}\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nTotal: ${mass.toFixed(3)} g/mol`, newAnswer: mass };
  }

  // Formula breakdown
  if (s.match(/^formula\s+([A-Za-z0-9]+)$/i)) {
    const formula = s.match(/^formula\s+([A-Za-z0-9]+)$/i)[1];
    const elements = parseFormula(formula);
    const mass = calcMolarMass(formula);
    
    if (mass === null) {
      return { type: 'error', result: `Unknown element in formula: ${formula}` };
    }
    
    let result = `‚öóÔ∏è ${formula} Breakdown\n`;
    result += '‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n';
    
    for (const [el, count] of Object.entries(elements)) {
      const elMass = ELEMENTS[el].m * count;
      const percent = (elMass / mass * 100).toFixed(1);
      result += `‚îÇ ${el.padEnd(3)} √ó ${count.toString().padStart(2)} = ${elMass.toFixed(2).padStart(7)} g  ${percent.padStart(5)}% ‚îÇ\n`;
    }
    
    result += '‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n';
    result += `‚îÇ Molar Mass: ${mass.toFixed(3).padStart(10)} g/mol ‚îÇ\n`;
    result += '‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò';
    
    return { type: 'help', result: result };
  }

  // pH from concentration
  if (s.match(/^ph\s+[\d.e-]+$/i)) {
    const conc = parseFloat(s.match(/[\d.e-]+/i)[0]);
    if (conc <= 0) return { type: 'error', result: 'Concentration must be positive' };
    const ph = -Math.log10(conc);
    return { type: 'result', result: `[H‚Å∫] = ${conc} M\npH = -log‚ÇÅ‚ÇÄ(${conc}) = ${ph.toFixed(4)}`, newAnswer: ph };
  }

  // pOH to pH
  if (s.match(/^poh\s+[\d.]+$/i)) {
    const poh = parseFloat(s.match(/[\d.]+/)[0]);
    const ph = 14 - poh;
    return { type: 'result', result: `pOH = ${poh}\npH = 14 - pOH = ${ph.toFixed(4)}`, newAnswer: ph };
  }

  // H+ from pH
  if (s.match(/^h\+?\s*from\s*ph\s+[\d.]+$/i)) {
    const ph = parseFloat(s.match(/[\d.]+/)[0]);
    const h = Math.pow(10, -ph);
    return { type: 'result', result: `pH = ${ph}\n[H‚Å∫] = 10^(-${ph}) = ${h.toExponential(4)} M`, newAnswer: h };
  }

  // Molarity: M = mol / L
  if (s.match(/^molarity\s+/i)) {
    const vars = {}; (s.match(/([a-z]+)=(-?[\d.]+)/gi) || []).forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    if (vars.mol !== undefined && vars.l !== undefined) {
      const M = vars.mol / vars.l;
      return { type: 'result', result: `Molarity = moles / liters\nM = ${vars.mol} / ${vars.l} = ${M.toFixed(4)} M`, newAnswer: M };
    }
    return { type: 'error', result: 'Need mol= and L= (e.g., molarity mol=0.5 L=2)' };
  }

  // Moles from molarity
  if (s.match(/^moles\s+m=/i)) {
    const vars = {}; (s.match(/([a-z]+)=(-?[\d.]+)/gi) || []).forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    if (vars.m !== undefined && vars.l !== undefined) {
      const mol = vars.m * vars.l;
      return { type: 'result', result: `Moles = Molarity √ó Liters\nmol = ${vars.m} √ó ${vars.l} = ${mol.toFixed(4)} mol`, newAnswer: mol };
    }
    return { type: 'error', result: 'Need M= and L= (e.g., moles M=0.5 L=2)' };
  }

  // Dilution: M1V1 = M2V2
  if (s.match(/^dilute\s+/i)) {
    const vars = {}; 
    const matches = s.match(/([a-z]\d)=(-?[\d.]+)/gi) || [];
    matches.forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    
    if (vars.m1 !== undefined && vars.v1 !== undefined && vars.m2 !== undefined) {
      const v2 = (vars.m1 * vars.v1) / vars.m2;
      return { type: 'result', result: `Dilution: M‚ÇÅV‚ÇÅ = M‚ÇÇV‚ÇÇ\nV‚ÇÇ = (${vars.m1} √ó ${vars.v1}) / ${vars.m2} = ${v2.toFixed(4)} mL`, newAnswer: v2 };
    }
    if (vars.m1 !== undefined && vars.v1 !== undefined && vars.v2 !== undefined) {
      const m2 = (vars.m1 * vars.v1) / vars.v2;
      return { type: 'result', result: `Dilution: M‚ÇÅV‚ÇÅ = M‚ÇÇV‚ÇÇ\nM‚ÇÇ = (${vars.m1} √ó ${vars.v1}) / ${vars.v2} = ${m2.toFixed(4)} M`, newAnswer: m2 };
    }
    return { type: 'error', result: 'Need M1=, V1=, and M2= or V2= (e.g., dilute M1=2 V1=50 M2=0.5)' };
  }

  // Density: d = m / v
  if (s.match(/^density\s+/i)) {
    const vars = {}; (s.match(/([a-z])=(-?[\d.]+)/gi) || []).forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    if (vars.m !== undefined && vars.v !== undefined) {
      const d = vars.m / vars.v;
      return { type: 'result', result: `Density = mass / volume\nd = ${vars.m} / ${vars.v} = ${d.toFixed(4)} g/mL`, newAnswer: d };
    }
    return { type: 'error', result: 'Need m= and v= (e.g., density m=100 v=50)' };
  }

  // Mass from density
  if (s.match(/^mass\s+d=/i)) {
    const vars = {}; (s.match(/([a-z])=(-?[\d.]+)/gi) || []).forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    if (vars.d !== undefined && vars.v !== undefined) {
      const m = vars.d * vars.v;
      return { type: 'result', result: `Mass = density √ó volume\nm = ${vars.d} √ó ${vars.v} = ${m.toFixed(4)} g`, newAnswer: m };
    }
    return { type: 'error', result: 'Need d= and v= (e.g., mass d=2.5 v=40)' };
  }

  // Molar mass
  if (s.match(/^molar\s*mass\s+/i)) {
    const vars = {}; (s.match(/([a-z]+)=(-?[\d.]+)/gi) || []).forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    if (vars.g !== undefined && vars.mol !== undefined) {
      const mm = vars.g / vars.mol;
      return { type: 'result', result: `Molar Mass = grams / moles\nMM = ${vars.g} / ${vars.mol} = ${mm.toFixed(4)} g/mol`, newAnswer: mm };
    }
    return { type: 'error', result: 'Need g= and mol= (e.g., molar mass g=25 mol=0.5)' };
  }

  // Ideal Gas Law: PV = nRT
  if (s.match(/^gas\s+/i)) {
    const vars = {}; (s.match(/([a-z])=(-?[\d.]+)/gi) || []).forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    const R = 0.0821; // L¬∑atm/(mol¬∑K)
    
    // Count how many we have
    const have = ['p', 'v', 'n', 't'].filter(x => vars[x] !== undefined);
    
    if (have.length === 3) {
      if (vars.n === undefined) {
        const n = (vars.p * vars.v) / (R * vars.t);
        return { type: 'result', result: `Ideal Gas: PV = nRT\nn = PV/RT = (${vars.p}√ó${vars.v})/(${R}√ó${vars.t})\nn = ${n.toFixed(4)} mol`, newAnswer: n };
      }
      if (vars.v === undefined) {
        const v = (vars.n * R * vars.t) / vars.p;
        return { type: 'result', result: `Ideal Gas: PV = nRT\nV = nRT/P = (${vars.n}√ó${R}√ó${vars.t})/${vars.p}\nV = ${v.toFixed(4)} L`, newAnswer: v };
      }
      if (vars.p === undefined) {
        const p = (vars.n * R * vars.t) / vars.v;
        return { type: 'result', result: `Ideal Gas: PV = nRT\nP = nRT/V = (${vars.n}√ó${R}√ó${vars.t})/${vars.v}\nP = ${p.toFixed(4)} atm`, newAnswer: p };
      }
      if (vars.t === undefined) {
        const t = (vars.p * vars.v) / (vars.n * R);
        return { type: 'result', result: `Ideal Gas: PV = nRT\nT = PV/nR = (${vars.p}√ó${vars.v})/(${vars.n}√ó${R})\nT = ${t.toFixed(4)} K`, newAnswer: t };
      }
    }
    return { type: 'error', result: 'Need 3 of: P=, V=, n=, T= (e.g., gas P=1 V=22.4 T=273)' };
  }
  
  // Save formula: save NAME = FORMULA
  const saveMatch = input.match(/^save\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*(.+)$/i);
  if (saveMatch) {
    const name = saveMatch[1];
    const formula = saveMatch[2].trim();
    saveFormula(name, formula);
    return { type: 'result', result: `‚úì Saved "${name}"\n  Formula: ${formula}\n\n  Use: ${name} where x=1, y=2` };
  }
  
  // Delete formula
  const delMatch = input.match(/^delete\s+([a-zA-Z_][a-zA-Z0-9_]*)$/i);
  if (delMatch) {
    const name = delMatch[1].toLowerCase();
    if (customFormulas[name]) {
      deleteFormula(name);
      return { type: 'result', result: `‚úì Deleted "${name}"` };
    }
    return { type: 'error', result: `Formula "${name}" not found.` };
  }
  
  // Clear all formulas
  if (s === 'clear formulas' || s === 'delete all formulas') {
    const count = Object.keys(customFormulas).length;
    customFormulas = {};
    localStorage.setItem('jcalc_formulas', '{}');
    return { type: 'result', result: `‚úì Cleared ${count} formula(s).` };
  }
  
  // Use formula: NAME where x=1, y=2  OR  NAME x=1, y=2
  const useMatch = input.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\s+(?:where\s+)?(.+)$/i);
  if (useMatch) {
    const name = useMatch[1].toLowerCase();
    const varsStr = useMatch[2];
    
    if (customFormulas[name]) {
      let formula = customFormulas[name].formula;
      
      // Parse variables: x=5, y=10 or x=5 y=10
      const varMatches = varsStr.match(/([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*(-?[\d.]+)/g) || [];
      const vars = {};
      varMatches.forEach(v => {
        const [varName, varVal] = v.split('=').map(s => s.trim());
        vars[varName.toLowerCase()] = parseFloat(varVal);
      });
      
      // Substitute variables into formula
      Object.entries(vars).forEach(([k, v]) => {
        formula = formula.replace(new RegExp(`\\b${k}\\b`, 'gi'), `(${v})`);
      });
      
      // NESTED FORMULAS: Replace any other formula names with their formulas
      // Keep doing this until no more substitutions are made (handles deep nesting)
      let maxDepth = 10; // Prevent infinite loops
      let changed = true;
      while (changed && maxDepth > 0) {
        changed = false;
        Object.entries(customFormulas).forEach(([fname, fdata]) => {
          if (fname !== name) { // Don't self-reference
            const regex = new RegExp(`\\b${fname}\\b`, 'gi');
            if (regex.test(formula)) {
              formula = formula.replace(regex, `(${fdata.formula})`);
              changed = true;
            }
          }
        });
        maxDepth--;
      }
      
      // Substitute variables again (in case nested formulas used same var names)
      Object.entries(vars).forEach(([k, v]) => {
        formula = formula.replace(new RegExp(`\\b${k}\\b`, 'gi'), `(${v})`);
      });
      
      // Replace ans
      formula = formula.replace(/\bans\b/gi, `(${ans})`);
      
      try {
        const result = evaluate(formula);
        const varList = Object.entries(vars).map(([k,v]) => `${k}=${v}`).join(', ');
        const originalFormula = customFormulas[name].formula;
        let output = `${customFormulas[name].name}(${varList})\n= ${originalFormula}`;
        // If formula was expanded (nested formulas), show the expansion
        if (formula !== originalFormula.replace(/\bans\b/gi, `(${ans})`)) {
          // Clean up the expanded formula for display (remove extra parens if simple)
          let expanded = formula;
          Object.entries(vars).forEach(([k, v]) => {
            expanded = expanded.replace(new RegExp(`\\(${v}\\)`, 'g'), v.toString());
          });
          output += `\n= ${expanded}`;
        }
        output += `\n= ${result}`;
        return { type: 'result', result: output, newAnswer: result };
      } catch(e) {
        return { type: 'error', result: `Error evaluating: ${formula}\n${e.message}` };
      }
    }
  }
  
  // Aliases and partial matches
  const aliases = {
    'cipher': 'caesar',
    'ciphers': 'caesar',
    'encode': 'caesar',
    'decode': 'caesar',
    'code': 'morse',
    'codes': 'morse',
    'bin': 'binary',
    'hex': 'convert',
    'temp': 'convert',
    'temperature': 'convert',
    'units': 'convert',
    'trig': 'trig',
    'trigonometry': 'trig',
    'alg': 'algebra',
    'geo': 'geometry',
    'geom': 'geometry',
    'stat': 'stats',
    'statistics': 'stats',
    'num': 'numbers',
    'number': 'numbers',
    'prime': 'numbers',
    'primes': 'numbers',
    'factor': 'numbers',
    'factors': 'numbers',
    'pct': 'percent',
    'percentage': 'percent',
    'percentages': 'percent',
    'frac': 'fractions',
    'fraction': 'fractions',
    'rand': 'random',
    'rng': 'random',
    'times': 'random',
    'times table': 'random',
    'formula': 'formulas',
    'custom': 'formulas',
    'my': 'formulas',
    'string': 'strings',
    'str': 'strings',
    'text': 'strings',
    'roll': 'dice',
    'die': 'dice',
    'd20': 'dice',
    'd6': 'dice',
    'roman': 'roman',
    'numeral': 'roman',
    'numerals': 'roman',
    'date': 'dates',
    'days': 'dates',
    'calendar': 'dates',
    'clock': 'time',
    'military': 'time',
    '24hr': 'time',
    'phys': 'physics',
    'chem': 'chemistry',
    'element': 'chemistry',
    'elements': 'chemistry',
    'periodic': 'chemistry',
    'periodic table': 'chemistry'
  };
  if (aliases[s]) return { type: 'help', result: renderHelp(aliases[s]) };

  // Caesar
  if (s.match(/caesar\s*chart/i)) return { type: 'help', result: getCaesarChart() };
  
  if (s.match(/caesar\s*(encode\s*)?numbers?\s*(\d+)?\s*[:\s]\s*(.+)/i)) {
    const m = s.match(/caesar\s*(?:encode\s*)?numbers?\s*(\d+)?\s*[:\s]\s*(.+)/i);
    const shift = parseInt(m[1]) || 0;
    const text = m[2];
    return { type: 'result', result: `Text: ${text}\nShift: ${shift}\nNumbers: ${caesarToNums(text, shift)}` };
  }
  
  if (s.match(/caesar\s*decode\s*numbers?\s*(\d+)?\s*[:\s]\s*(.+)/i)) {
    const m = s.match(/caesar\s*decode\s*numbers?\s*(\d+)?\s*[:\s]\s*(.+)/i);
    const shift = parseInt(m[1]) || 0;
    const nums = m[2];
    return { type: 'result', result: `Numbers: ${nums}\nShift: ${shift}\nText: ${numsToLetters(nums, shift)}` };
  }
  
  const caesarM = s.match(/caesar\s*(encode|decode)?\s*(\d+)\s*[:\s]\s*(.+)/i);
  if (caesarM) {
    const decode = caesarM[1]?.match(/decode/i);
    const shift = parseInt(caesarM[2]) || 0;
    const text = caesarM[3];
    const result = caesar(text, shift, !!decode);
    return { type: 'result', result: `${decode ? 'Decoded' : 'Encoded'} (shift ${shift}):\n${text} ‚Üí ${result}` };
  }

  // Morse
  if (s.match(/morse\s*chart/i)) return { type: 'help', result: getMorseChart() };
  if (s.match(/morse\s*(encode)?\s*[:\s]\s*([a-zA-Z0-9\s]+)/i) && !/^[\.\-\s\/]+$/.test(s.split(':')[1]?.trim())) {
    const text = s.match(/morse\s*(?:encode)?\s*[:\s]\s*(.+)/i)[1];
    return { type: 'result', result: `Text: ${text}\nMorse: ${toMorse(text)}` };
  }
  if (s.match(/morse\s*(decode)?\s*[:\s]\s*([\.\-\s\/]+)/i)) {
    const morse = s.match(/morse\s*(?:decode)?\s*[:\s]\s*(.+)/i)[1];
    return { type: 'result', result: `Morse: ${morse}\nText: ${fromMorse(morse)}` };
  }

  // Binary
  if (s.match(/binary\s*chart/i)) return { type: 'help', result: getBinaryChart() };
  if (s.match(/binary\s*alpha\s*chart/i)) return { type: 'help', result: 'Alphabetic: a=00000000, b=00000001, c=00000010...' };
  
  if (s.match(/binary\s*alpha\s*[:\s]\s*(.+)/i)) {
    const text = s.match(/binary\s*alpha\s*[:\s]\s*(.+)/i)[1];
    const bin = textToBin(text, 'alpha');
    if (!bin) return { type: 'error', result: 'Alphabetic mode only supports letters' };
    return { type: 'result', result: `Text: ${text}\nMode: Alphabetic (a=0)\nBinary: ${bin}` };
  }
  
  if (s.match(/binary\s*decode\s*alpha\s*[:\s]\s*([01\s]+)/i)) {
    const bin = s.match(/binary\s*decode\s*alpha\s*[:\s]\s*([01\s]+)/i)[1];
    const r = binToText(bin, 'alpha');
    if (r.err) return { type: 'error', result: r.err };
    return { type: 'result', result: `Binary: ${bin}\nText: ${r.text}` };
  }
  
  if (s.match(/binary\s*decode\s*[:\s]\s*([01\s]+)/i)) {
    const bin = s.match(/binary\s*decode\s*[:\s]\s*([01\s]+)/i)[1];
    const r = binToText(bin);
    if (r.err) return { type: 'error', result: r.err };
    return { type: 'result', result: `Binary: ${bin}\nText: ${r.text}` };
  }
  
  if (s.match(/binary\s*[:\s]\s*([a-zA-Z].+)/i)) {
    const text = s.match(/binary\s*[:\s]\s*(.+)/i)[1];
    return { type: 'result', result: `Text: ${text}\nBinary: ${textToBin(text)}` };
  }
  
  if (s.match(/(\d+)\s*to\s*binary/i)) {
    const n = parseInt(s.match(/(\d+)/)[1]);
    return { type: 'result', result: `${n} = 0b${(n >>> 0).toString(2)}` };
  }
  if (s.match(/to\s*hex/)) {
    const n = parseInt(s.match(/(\d+)/)?.[1]);
    if (!isNaN(n)) return { type: 'result', result: `${n} = 0x${(n >>> 0).toString(16).toUpperCase()}` };
  }

  // Temperature
  const tempM = s.match(/(-?[\d.]+)\s*(celsius|fahrenheit|kelvin|[cfk])\s*to\s*(celsius|fahrenheit|kelvin|[cfk])/i);
  if (tempM) {
    const v = parseFloat(tempM[1]), from = tempM[2][0].toLowerCase(), to = tempM[3][0].toLowerCase();
    const r = convertTemp(v, from, to);
    const names = {c:'¬∞C', f:'¬∞F', k:'K'};
    return { type: 'result', result: `${v}${names[from]} = ${r.toFixed(2)}${names[to]}`, newAnswer: r };
  }

  // Unit conversion
  const unitM = s.match(/(-?[\d.]+)\s*(\w+)\s*to\s*(\w+)/i);
  if (unitM) {
    const v = parseFloat(unitM[1]), from = unitM[2].toLowerCase(), to = unitM[3].toLowerCase();
    for (const cat of Object.values(UNITS)) {
      if (cat[from] && cat[to]) {
        const r = v * cat[from] / cat[to];
        return { type: 'result', result: `${v} ${from} = ${r.toFixed(4)} ${to}`, newAnswer: r };
      }
    }
  }

  // Trig with degrees
  const trigD = s.match(/(sin|cos|tan|csc|sec|cot)\s*\(?\s*(-?\d+\.?\d*)\s*deg/i);
  if (trigD) {
    const fn = trigD[1].toLowerCase(), deg = parseFloat(trigD[2]);
    const rad = deg * Math.PI / 180;
    const fns = { sin: Math.sin, cos: Math.cos, tan: Math.tan, csc: x=>1/Math.sin(x), sec: x=>1/Math.cos(x), cot: x=>1/Math.tan(x) };
    const r = fns[fn](rad);
    return { type: 'result', result: `${fn}(${deg}¬∞) = ${r.toFixed(6)}`, newAnswer: r };
  }
  
  // Degree to radian
  if (s.match(/(-?\d+\.?\d*)\s*deg(rees?)?\s*to\s*rad/i)) {
    const deg = parseFloat(s.match(/(-?\d+\.?\d*)/)[1]);
    const rad = deg * Math.PI / 180;
    return { type: 'result', result: `${deg}¬∞ = ${rad.toFixed(6)} rad`, newAnswer: rad };
  }
  
  // Radian to degree
  if (s.match(/(-?\d+\.?\d*)\s*rad(ians?)?\s*to\s*deg/i)) {
    const rad = parseFloat(s.match(/(-?\d+\.?\d*)/)[1]);
    const deg = rad * 180 / Math.PI;
    return { type: 'result', result: `${rad} rad = ${deg.toFixed(4)}¬∞`, newAnswer: deg };
  }
  
  if (s.match(/unit\s*circle\s*(\d+)/i)) {
    const deg = parseInt(s.match(/(\d+)/)[1]);
    const rad = deg * Math.PI / 180;
    return { type: 'result', result: `Unit Circle at ${deg}¬∞:\nsin = ${Math.sin(rad).toFixed(4)}\ncos = ${Math.cos(rad).toFixed(4)}\ntan = ${Math.tan(rad).toFixed(4)}` };
  }

  // Algebra
  if (s.match(/solve\s+(-?\d*\.?\d*)?\s*x\s*([+-]\s*\d+\.?\d*)?\s*=\s*(-?\d+\.?\d*)/i)) {
    const m = s.match(/solve\s+(-?\d*\.?\d*)?\s*x\s*([+-]\s*\d+\.?\d*)?\s*=\s*(-?\d+\.?\d*)/i);
    let coef = m[1] ? parseFloat(m[1]) : 1; if (m[1] === '-') coef = -1;
    const con = m[2] ? parseFloat(m[2].replace(/\s/g,'')) : 0;
    const x = (parseFloat(m[3]) - con) / coef;
    return { type: 'result', result: `x = ${x}`, newAnswer: x };
  }

  if (s.match(/quadratic\s+(-?\d+\.?\d*)\s*[,\s]\s*(-?\d+\.?\d*)\s*[,\s]\s*(-?\d+\.?\d*)/i)) {
    const m = s.match(/(-?\d+\.?\d*)\s*[,\s]\s*(-?\d+\.?\d*)\s*[,\s]\s*(-?\d+\.?\d*)/);
    const a = parseFloat(m[1]), b = parseFloat(m[2]), c = parseFloat(m[3]);
    const d = b*b - 4*a*c;
    let r = `${a}x¬≤ + ${b}x + ${c} = 0\nDiscriminant = ${d}\n`;
    if (d < 0) r += `Complex roots`;
    else if (d === 0) r += `x = ${-b/(2*a)}`;
    else r += `x‚ÇÅ = ${((-b + Math.sqrt(d))/(2*a)).toFixed(4)}\nx‚ÇÇ = ${((-b - Math.sqrt(d))/(2*a)).toFixed(4)}`;
    return { type: 'result', result: r };
  }

  // Geometry
  if (s.match(/area\s+(circle|triangle|rectangle)\s+/i)) {
    const shape = s.match(/(circle|triangle|rectangle)/i)[1].toLowerCase();
    const vars = {}; (s.match(/([a-z])=(-?[\d.]+)/gi) || []).forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    let r;
    if (shape === 'circle') r = Math.PI * vars.r * vars.r;
    else if (shape === 'triangle') r = 0.5 * vars.b * vars.h;
    else r = vars.l * vars.w;
    return { type: 'result', result: `Area of ${shape} = ${r.toFixed(4)}`, newAnswer: r };
  }

  if (s.match(/volume\s+(sphere|cylinder|cube|box)/i)) {
    const shape = s.match(/(sphere|cylinder|cube|box)/i)[1].toLowerCase();
    const vars = {}; (s.match(/([a-z])=(-?[\d.]+)/gi) || []).forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    let r;
    if (shape === 'sphere') r = (4/3) * Math.PI * Math.pow(vars.r, 3);
    else if (shape === 'cylinder') r = Math.PI * vars.r * vars.r * vars.h;
    else if (shape === 'cube') r = Math.pow(vars.s || vars.a, 3);
    else r = vars.l * vars.w * vars.h;
    return { type: 'result', result: `Volume of ${shape} = ${r.toFixed(4)}`, newAnswer: r };
  }

  if (s.match(/pythagorean/i)) {
    const vars = {}; (s.match(/([a-z])=(-?[\d.]+)/gi) || []).forEach(m => { const [k,v] = m.split('='); vars[k.toLowerCase()] = parseFloat(v); });
    let r;
    if (vars.a && vars.b) r = Math.sqrt(vars.a*vars.a + vars.b*vars.b);
    else if (vars.a && vars.c) r = Math.sqrt(vars.c*vars.c - vars.a*vars.a);
    else if (vars.b && vars.c) r = Math.sqrt(vars.c*vars.c - vars.b*vars.b);
    return { type: 'result', result: `= ${r.toFixed(4)}`, newAnswer: r };
  }

  if (s.match(/distance\s*\(?(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\)?\s*(to|and)\s*\(?(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)/i)) {
    const m = s.match(/(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\)?\s*(?:to|and)\s*\(?(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)/i);
    const d = Math.sqrt(Math.pow(parseFloat(m[3])-parseFloat(m[1]), 2) + Math.pow(parseFloat(m[4])-parseFloat(m[2]), 2));
    return { type: 'result', result: `Distance = ${d.toFixed(4)}`, newAnswer: d };
  }

  if (s.match(/midpoint\s*\(?(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\)?\s*(and|to)\s*\(?(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)/i)) {
    const m = s.match(/(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\)?\s*(?:and|to)\s*\(?(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)/i);
    return { type: 'result', result: `Midpoint = (${(parseFloat(m[1])+parseFloat(m[3]))/2}, ${(parseFloat(m[2])+parseFloat(m[4]))/2})` };
  }

  if (s.match(/slope\s*\(?(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\)?\s*(to|and)\s*\(?(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)/i)) {
    const m = s.match(/(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\)?\s*(?:to|and)\s*\(?(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)/i);
    const slope = (parseFloat(m[4]) - parseFloat(m[2])) / (parseFloat(m[3]) - parseFloat(m[1]));
    return { type: 'result', result: `Slope = ${slope}`, newAnswer: slope };
  }

  // Percentages
  if (s.match(/([\d.]+)\s*%?\s*of\s*([\d.]+)/i)) {
    const m = s.match(/([\d.]+)\s*%?\s*of\s*([\d.]+)/i);
    const r = parseFloat(m[1]) / 100 * parseFloat(m[2]);
    return { type: 'result', result: `${m[1]}% of ${m[2]} = ${r}`, newAnswer: r };
  }

  if (s.match(/([\d.]+)\s*is\s*what\s*percent\s*of\s*([\d.]+)/i)) {
    const m = s.match(/([\d.]+)\s*is\s*what\s*percent\s*of\s*([\d.]+)/i);
    const p = parseFloat(m[1]) / parseFloat(m[2]) * 100;
    return { type: 'result', result: `= ${p.toFixed(2)}%`, newAnswer: p };
  }

  if (s.match(/percent\s*change.*?(-?[\d.]+)\s*to\s*(-?[\d.]+)/i)) {
    const m = s.match(/(-?[\d.]+)\s*to\s*(-?[\d.]+)/i);
    const from = parseFloat(m[1]), to = parseFloat(m[2]);
    const change = ((to - from) / Math.abs(from)) * 100;
    const dir = change >= 0 ? 'increase' : 'decrease';
    return { type: 'result', result: `${Math.abs(change).toFixed(2)}% ${dir}`, newAnswer: change };
  }

  if (s.match(/(-?[\d.]+)\s*\+\s*(\d+\.?\d*)\s*%/i)) {
    const m = s.match(/(-?[\d.]+)\s*\+\s*(\d+\.?\d*)\s*%/i);
    const base = parseFloat(m[1]), pct = parseFloat(m[2]);
    const r = base * (1 + pct/100);
    return { type: 'result', result: `${base} + ${pct}% = ${r.toFixed(2)}`, newAnswer: r };
  }

  if (s.match(/(-?[\d.]+)\s*-\s*(\d+\.?\d*)\s*%/i)) {
    const m = s.match(/(-?[\d.]+)\s*-\s*(\d+\.?\d*)\s*%/i);
    const base = parseFloat(m[1]), pct = parseFloat(m[2]);
    const r = base * (1 - pct/100);
    return { type: 'result', result: `${base} - ${pct}% = ${r.toFixed(2)}`, newAnswer: r };
  }

  // Stats
  if (s.match(/^stats/i)) {
    const nums = s.match(/-?[\d.]+/g)?.map(Number);
    if (nums?.length) {
      const st = stats(nums);
      return { type: 'result', result: `Stats:\nMean: ${st.mean.toFixed(4)}\nMedian: ${st.median}\nMode: ${st.modes.join(',')}\nRange: ${st.range}\nStd Dev: ${st.stdDev.toFixed(4)}` };
    }
  }

  if (s.match(/^mean/i)) {
    const nums = s.match(/-?[\d.]+/g)?.map(Number);
    if (nums) { const m = nums.reduce((a,b)=>a+b,0)/nums.length; return { type: 'result', result: `Mean = ${m.toFixed(4)}`, newAnswer: m }; }
  }

  if (s.match(/^median/i)) {
    const nums = s.match(/-?[\d.]+/g)?.map(Number).sort((a,b)=>a-b);
    if (nums) { 
      const mid = Math.floor(nums.length / 2);
      const m = nums.length % 2 ? nums[mid] : (nums[mid-1] + nums[mid]) / 2;
      return { type: 'result', result: `Median = ${m}`, newAnswer: m }; 
    }
  }

  if (s.match(/^mode/i)) {
    const nums = s.match(/-?[\d.]+/g)?.map(Number);
    if (nums) { 
      const counts = {}; 
      nums.forEach(x => counts[x] = (counts[x]||0) + 1);
      const maxC = Math.max(...Object.values(counts));
      const modes = Object.entries(counts).filter(([,c]) => c === maxC).map(([v]) => +v);
      return { type: 'result', result: `Mode = ${modes.join(', ')}` }; 
    }
  }

  if (s.match(/^range/i)) {
    const nums = s.match(/-?[\d.]+/g)?.map(Number);
    if (nums) { 
      const r = Math.max(...nums) - Math.min(...nums);
      return { type: 'result', result: `Range = ${r}`, newAnswer: r }; 
    }
  }

  // Numbers
  if (s.match(/factors\s*(of)?\s*(\d+)/i)) {
    const n = parseInt(s.match(/(\d+)/)[1]);
    return { type: 'result', result: `Factors of ${n}: ${getFactors(n).join(', ')}` };
  }

  if (s.match(/primes?\s*(up\s*to|below)\s*(\d+)/i)) {
    const n = parseInt(s.match(/(\d+)/)[1]);
    const p = getPrimes(n);
    return { type: 'result', result: `Primes to ${n}: ${p.slice(0,20).join(', ')}${p.length > 20 ? '...' : ''}` };
  }

  if (s.match(/is\s*(\d+)\s*prime/i)) {
    const n = parseInt(s.match(/(\d+)/)[1]);
    return { type: 'result', result: isPrime(n) ? `‚úì ${n} is prime` : `‚úó ${n} is not prime` };
  }

  if (s.match(/gcd|gcf/i)) {
    const nums = s.match(/\d+/g)?.map(Number);
    if (nums?.length >= 2) { const r = nums.reduce((a,b) => gcd(a,b)); return { type: 'result', result: `GCF/GCD = ${r}`, newAnswer: r }; }
  }

  if (s.match(/lcm/i)) {
    const nums = s.match(/\d+/g)?.map(Number);
    if (nums?.length >= 2) { const r = nums.reduce((a,b) => (a*b)/gcd(a,b)); return { type: 'result', result: `LCM = ${r}`, newAnswer: r }; }
  }

  // Fractions
  if (s.match(/as\s*fraction/i)) {
    const n = parseFloat(s.match(/-?[\d.]+/)?.[0]);
    if (!isNaN(n)) return { type: 'result', result: `${n} = ${toFrac(n)}` };
  }

  // Practice problem generators
  if (s === 'practice' || s === 'practice problems' || s === 'problems') {
    return { type: 'help', result: renderHelp('random') };
  }

  if (s.match(/^practice\s+(addition|add|\+)$/i)) {
    const a = Math.floor(Math.random() * 50) + 1;
    const b = Math.floor(Math.random() * 50) + 1;
    const answer = a + b;
    return { type: 'result', result: `üìù Practice Addition:\n\n   ${a} + ${b} = ?\n\n(Answer: ${answer})`, newAnswer: answer };
  }

  if (s.match(/^practice\s+(subtraction|subtract|-)$/i)) {
    let a = Math.floor(Math.random() * 50) + 10;
    let b = Math.floor(Math.random() * a); // Ensure positive result
    const answer = a - b;
    return { type: 'result', result: `üìù Practice Subtraction:\n\n   ${a} - ${b} = ?\n\n(Answer: ${answer})`, newAnswer: answer };
  }

  if (s.match(/^practice\s+(multiplication|multiply|times|√ó|\*)$/i)) {
    const a = Math.floor(Math.random() * 12) + 1;
    const b = Math.floor(Math.random() * 12) + 1;
    const answer = a * b;
    return { type: 'result', result: `üìù Practice Multiplication:\n\n   ${a} √ó ${b} = ?\n\n(Answer: ${answer})`, newAnswer: answer };
  }

  if (s.match(/^practice\s+(division|divide|√∑|\/)$/i)) {
    const b = Math.floor(Math.random() * 11) + 2; // Divisor 2-12
    const answer = Math.floor(Math.random() * 12) + 1; // Answer 1-12
    const a = b * answer; // Ensure clean division
    return { type: 'result', result: `üìù Practice Division:\n\n   ${a} √∑ ${b} = ?\n\n(Answer: ${answer})`, newAnswer: answer };
  }

  // Multi-step: two operations
  if (s.match(/^practice\s+(multi-?step|two-?step|2-?step)$/i)) {
    const templates = [
      () => {
        const a = Math.floor(Math.random() * 10) + 2;
        const b = Math.floor(Math.random() * 10) + 1;
        const c = Math.floor(Math.random() * 20) + 1;
        const answer = a * b + c;
        return { q: `${a} √ó ${b} + ${c}`, a: answer };
      },
      () => {
        const a = Math.floor(Math.random() * 10) + 2;
        const b = Math.floor(Math.random() * 10) + 1;
        const c = Math.floor(Math.random() * (a*b - 1)) + 1;
        const answer = a * b - c;
        return { q: `${a} √ó ${b} - ${c}`, a: answer };
      },
      () => {
        const b = Math.floor(Math.random() * 8) + 2;
        const div = Math.floor(Math.random() * 10) + 1;
        const a = b * div;
        const c = Math.floor(Math.random() * 15) + 1;
        const answer = a / b + c;
        return { q: `${a} √∑ ${b} + ${c}`, a: answer };
      },
      () => {
        const a = Math.floor(Math.random() * 20) + 10;
        const b = Math.floor(Math.random() * 10) + 1;
        const c = Math.floor(Math.random() * 5) + 2;
        const answer = (a + b) * c;
        return { q: `(${a} + ${b}) √ó ${c}`, a: answer };
      },
      () => {
        const a = Math.floor(Math.random() * 30) + 15;
        const b = Math.floor(Math.random() * 10) + 1;
        const c = Math.floor(Math.random() * 5) + 2;
        const answer = (a - b) / c;
        const adjusted_a = b + answer * c; // ensure clean division
        return { q: `(${adjusted_a} - ${b}) √∑ ${c}`, a: answer };
      }
    ];
    const prob = templates[Math.floor(Math.random() * templates.length)]();
    return { type: 'result', result: `üìù Multi-Step Problem:\n\n   ${prob.q} = ?\n\n(Answer: ${prob.a})`, newAnswer: prob.a };
  }

  // Algebra: solve for x (linear)
  if (s.match(/^practice\s+(algebra|linear|solve)$/i)) {
    const templates = [
      () => {
        // x + b = c
        const x = Math.floor(Math.random() * 20) + 1;
        const b = Math.floor(Math.random() * 15) + 1;
        const c = x + b;
        return { q: `x + ${b} = ${c}`, a: x, hint: `x = ${c} - ${b}` };
      },
      () => {
        // x - b = c
        const x = Math.floor(Math.random() * 20) + 5;
        const b = Math.floor(Math.random() * (x - 1)) + 1;
        const c = x - b;
        return { q: `x - ${b} = ${c}`, a: x, hint: `x = ${c} + ${b}` };
      },
      () => {
        // ax = b
        const a = Math.floor(Math.random() * 9) + 2;
        const x = Math.floor(Math.random() * 12) + 1;
        const b = a * x;
        return { q: `${a}x = ${b}`, a: x, hint: `x = ${b} √∑ ${a}` };
      },
      () => {
        // x/a = b
        const a = Math.floor(Math.random() * 8) + 2;
        const b = Math.floor(Math.random() * 10) + 1;
        const x = a * b;
        return { q: `x √∑ ${a} = ${b}`, a: x, hint: `x = ${b} √ó ${a}` };
      },
      () => {
        // ax + b = c
        const a = Math.floor(Math.random() * 5) + 2;
        const x = Math.floor(Math.random() * 10) + 1;
        const b = Math.floor(Math.random() * 10) + 1;
        const c = a * x + b;
        return { q: `${a}x + ${b} = ${c}`, a: x, hint: `${a}x = ${c - b}, x = ${c - b} √∑ ${a}` };
      },
      () => {
        // ax - b = c
        const a = Math.floor(Math.random() * 5) + 2;
        const x = Math.floor(Math.random() * 10) + 2;
        const b = Math.floor(Math.random() * 10) + 1;
        const c = a * x - b;
        return { q: `${a}x - ${b} = ${c}`, a: x, hint: `${a}x = ${c + b}, x = ${c + b} √∑ ${a}` };
      }
    ];
    const prob = templates[Math.floor(Math.random() * templates.length)]();
    return { type: 'result', result: `üìù Solve for x:\n\n   ${prob.q}\n\n(Answer: x = ${prob.a})`, newAnswer: prob.a };
  }

  // Order of operations (PEMDAS)
  if (s.match(/^practice\s+(pemdas|order|order of operations)$/i)) {
    const templates = [
      () => {
        const a = Math.floor(Math.random() * 8) + 2;
        const b = Math.floor(Math.random() * 5) + 1;
        const c = Math.floor(Math.random() * 6) + 2;
        const d = Math.floor(Math.random() * 10) + 1;
        const answer = a + b * c - d;
        return { q: `${a} + ${b} √ó ${c} - ${d}`, a: answer };
      },
      () => {
        const a = Math.floor(Math.random() * 5) + 1;
        const b = Math.floor(Math.random() * 4) + 2;
        const c = Math.floor(Math.random() * 6) + 1;
        const d = Math.floor(Math.random() * 3) + 2;
        const answer = a * b + c * d;
        return { q: `${a} √ó ${b} + ${c} √ó ${d}`, a: answer };
      },
      () => {
        const a = Math.floor(Math.random() * 10) + 5;
        const b = Math.floor(Math.random() * 5) + 1;
        const c = Math.floor(Math.random() * 4) + 2;
        const answer = (a - b) * c;
        return { q: `(${a} - ${b}) √ó ${c}`, a: answer };
      },
      () => {
        const a = Math.floor(Math.random() * 4) + 2;
        const b = Math.floor(Math.random() * 3) + 1;
        const c = Math.floor(Math.random() * 5) + 1;
        const answer = a * a + b * c;
        return { q: `${a}¬≤ + ${b} √ó ${c}`, a: answer };
      }
    ];
    const prob = templates[Math.floor(Math.random() * templates.length)]();
    return { type: 'result', result: `üìù Order of Operations:\n\n   ${prob.q} = ?\n\n(Answer: ${prob.a})`, newAnswer: prob.a };
  }

  // Fractions
  if (s.match(/^practice\s+(fractions?|frac)$/i)) {
    const templates = [
      () => {
        // a/b + c/b (same denominator)
        const b = Math.floor(Math.random() * 8) + 2;
        const a = Math.floor(Math.random() * (b - 1)) + 1;
        const c = Math.floor(Math.random() * (b - 1)) + 1;
        const num = a + c;
        const g = gcd(num, b);
        return { q: `${a}/${b} + ${c}/${b}`, a: num >= b ? `${Math.floor(num/b)} ${(num%b)/g}/${b/g}` : `${num/g}/${b/g}` };
      },
      () => {
        // a/b √ó c/d
        const a = Math.floor(Math.random() * 5) + 1;
        const b = Math.floor(Math.random() * 6) + 2;
        const c = Math.floor(Math.random() * 5) + 1;
        const d = Math.floor(Math.random() * 6) + 2;
        const num = a * c;
        const den = b * d;
        const g = gcd(num, den);
        return { q: `${a}/${b} √ó ${c}/${d}`, a: `${num/g}/${den/g}` };
      },
      () => {
        // Simplify
        const g = Math.floor(Math.random() * 5) + 2;
        const a = Math.floor(Math.random() * 6) + 1;
        const b = Math.floor(Math.random() * 6) + 2;
        if (a >= b) return { q: `Simplify: ${(a+1)*g}/${b*g}`, a: `${a+1}/${b}` };
        return { q: `Simplify: ${a*g}/${b*g}`, a: `${a}/${b}` };
      }
    ];
    const prob = templates[Math.floor(Math.random() * templates.length)]();
    return { type: 'result', result: `üìù Fractions:\n\n   ${prob.q} = ?\n\n(Answer: ${prob.a})` };
  }

  // Percentages
  if (s.match(/^practice\s+(percent(age)?s?|%)$/i)) {
    const templates = [
      () => {
        // What is X% of Y?
        const pct = [10, 20, 25, 50, 75, 15, 30][Math.floor(Math.random() * 7)];
        const num = Math.floor(Math.random() * 20) * 10 + 20; // 20, 30, ... 200
        const answer = num * pct / 100;
        return { q: `What is ${pct}% of ${num}?`, a: answer };
      },
      () => {
        // X is what percent of Y?
        const pct = [10, 20, 25, 50, 75, 40][Math.floor(Math.random() * 6)];
        const y = Math.floor(Math.random() * 15) * 10 + 50;
        const x = y * pct / 100;
        return { q: `${x} is what % of ${y}?`, a: `${pct}%` };
      },
      () => {
        // Percent increase/decrease
        const old = Math.floor(Math.random() * 50) * 2 + 20;
        const pct = [10, 20, 25, 50][Math.floor(Math.random() * 4)];
        const increase = Math.random() > 0.5;
        const newVal = increase ? old * (1 + pct/100) : old * (1 - pct/100);
        return { 
          q: `${old} ${increase ? 'increased' : 'decreased'} by ${pct}% = ?`, 
          a: newVal 
        };
      }
    ];
    const prob = templates[Math.floor(Math.random() * templates.length)]();
    return { type: 'result', result: `üìù Percentages:\n\n   ${prob.q}\n\n(Answer: ${prob.a})`, newAnswer: typeof prob.a === 'number' ? prob.a : undefined };
  }

  // Exponents
  if (s.match(/^practice\s+(exponents?|powers?)$/i)) {
    const templates = [
      () => {
        const base = Math.floor(Math.random() * 9) + 2;
        const exp = Math.floor(Math.random() * 3) + 2;
        return { q: `${base}^${exp} = ?`, a: Math.pow(base, exp) };
      },
      () => {
        const base = Math.floor(Math.random() * 5) + 2;
        return { q: `${base}^2 + ${base}^2 = ?`, a: 2 * base * base };
      },
      () => {
        const base = Math.floor(Math.random() * 4) + 2;
        const a = Math.floor(Math.random() * 3) + 1;
        const b = Math.floor(Math.random() * 3) + 1;
        return { q: `${base}^${a} √ó ${base}^${b} = ${base}^?`, a: a + b };
      },
      () => {
        const n = Math.floor(Math.random() * 6) + 2;
        return { q: `‚àö${n*n} = ?`, a: n };
      }
    ];
    const prob = templates[Math.floor(Math.random() * templates.length)]();
    return { type: 'result', result: `üìù Exponents:\n\n   ${prob.q}\n\n(Answer: ${prob.a})`, newAnswer: prob.a };
  }

  // Word problems
  if (s.match(/^practice\s+(word|story)(\s+problems?)?$/i)) {
    const templates = [
      () => {
        const name = ['Sam', 'Alex', 'Jordan', 'Taylor', 'Morgan'][Math.floor(Math.random() * 5)];
        const item = ['apples', 'books', 'stickers', 'marbles', 'cookies'][Math.floor(Math.random() * 5)];
        const a = Math.floor(Math.random() * 15) + 5;
        const b = Math.floor(Math.random() * 10) + 3;
        return { q: `${name} has ${a} ${item}. They get ${b} more.\nHow many ${item} does ${name} have now?`, a: a + b };
      },
      () => {
        const name = ['Sam', 'Alex', 'Jordan', 'Taylor', 'Morgan'][Math.floor(Math.random() * 5)];
        const item = ['dollars', 'points', 'candies', 'cards', 'coins'][Math.floor(Math.random() * 5)];
        const a = Math.floor(Math.random() * 30) + 20;
        const b = Math.floor(Math.random() * 15) + 5;
        return { q: `${name} has ${a} ${item}. They spend ${b}.\nHow many ${item} are left?`, a: a - b };
      },
      () => {
        const packs = Math.floor(Math.random() * 6) + 3;
        const perPack = Math.floor(Math.random() * 8) + 4;
        const item = ['pencils', 'cards', 'stickers', 'erasers'][Math.floor(Math.random() * 4)];
        return { q: `There are ${packs} packs of ${item}.\nEach pack has ${perPack} ${item}.\nHow many ${item} in total?`, a: packs * perPack };
      },
      () => {
        const total = Math.floor(Math.random() * 8 + 3) * 6;
        const groups = [2, 3, 4, 6][Math.floor(Math.random() * 4)];
        const item = ['students', 'cookies', 'toys', 'books'][Math.floor(Math.random() * 4)];
        return { q: `${total} ${item} are divided equally into ${groups} groups.\nHow many in each group?`, a: total / groups };
      },
      () => {
        const rate = Math.floor(Math.random() * 5) + 3;
        const hours = Math.floor(Math.random() * 4) + 2;
        return { q: `A car travels ${rate * 10} miles per hour.\nHow far does it go in ${hours} hours?`, a: rate * 10 * hours };
      }
    ];
    const prob = templates[Math.floor(Math.random() * templates.length)]();
    return { type: 'result', result: `üìù Word Problem:\n\n${prob.q}\n\n(Answer: ${prob.a})`, newAnswer: prob.a };
  }

  if (s.match(/^practice\s+(mixed|random|all)$/i)) {
    const ops = ['+', '-', '√ó', '√∑'];
    const op = ops[Math.floor(Math.random() * 4)];
    let a, b, answer, question;
    
    if (op === '+') {
      a = Math.floor(Math.random() * 50) + 1;
      b = Math.floor(Math.random() * 50) + 1;
      answer = a + b;
      question = `${a} + ${b}`;
    } else if (op === '-') {
      a = Math.floor(Math.random() * 50) + 10;
      b = Math.floor(Math.random() * a);
      answer = a - b;
      question = `${a} - ${b}`;
    } else if (op === '√ó') {
      a = Math.floor(Math.random() * 12) + 1;
      b = Math.floor(Math.random() * 12) + 1;
      answer = a * b;
      question = `${a} √ó ${b}`;
    } else {
      b = Math.floor(Math.random() * 11) + 2;
      answer = Math.floor(Math.random() * 12) + 1;
      a = b * answer;
      question = `${a} √∑ ${b}`;
    }
    
    return { type: 'result', result: `üìù Practice Problem:\n\n   ${question} = ?\n\n(Answer: ${answer})`, newAnswer: answer };
  }

  // Random
  if (s.match(/random\s+(\d+)\s*to\s*(\d+)/i)) {
    const m = s.match(/(\d+)\s*to\s*(\d+)/i);
    const r = Math.floor(Math.random() * (parseInt(m[2]) - parseInt(m[1]) + 1)) + parseInt(m[1]);
    return { type: 'result', result: `Random: ${r}`, newAnswer: r };
  }

  if (s.match(/random\s+(\d+)\s+numbers?\s+(\d+)\s*to\s*(\d+)/i)) {
    const m = s.match(/(\d+)\s+numbers?\s+(\d+)\s*to\s*(\d+)/i);
    const nums = Array(Math.min(parseInt(m[1]), 20)).fill().map(() => 
      Math.floor(Math.random() * (parseInt(m[3]) - parseInt(m[2]) + 1)) + parseInt(m[2])
    );
    return { type: 'result', result: `Random: ${nums.join(', ')}` };
  }

  if (s.match(/pick\s+from\s+(.+)/i)) {
    const items = s.match(/pick\s+from\s+(.+)/i)[1].split(/[,\s]+/).filter(Boolean);
    return { type: 'result', result: `üé≤ ${items[Math.floor(Math.random() * items.length)]}` };
  }

  if (s.match(/times\s*table\s+(\d+)/i)) {
    const n = parseInt(s.match(/(\d+)/)[1]);
    let t = `${n} Times Table:\n`;
    for (let i = 1; i <= 12; i++) t += `${n} √ó ${i} = ${n*i}\n`;
    return { type: 'result', result: t };
  }

  // Combinations
  if (s.match(/(\d+)\s*choose\s*(\d+)/i)) {
    const m = s.match(/(\d+)\s*choose\s*(\d+)/i);
    const r = comb(parseInt(m[1]), parseInt(m[2]));
    return { type: 'result', result: `C(${m[1]},${m[2]}) = ${r}`, newAnswer: r };
  }

  // Permutations
  if (s.match(/(\d+)\s*permute\s*(\d+)/i)) {
    const m = s.match(/(\d+)\s*permute\s*(\d+)/i);
    const r = perm(parseInt(m[1]), parseInt(m[2]));
    return { type: 'result', result: `P(${m[1]},${m[2]}) = ${r}`, newAnswer: r };
  }

  // Direct math (with weird input normalization)
  const normalized = normalizeWeirdInput(orig);
  const expr = normalized.replace(/\bans\b/gi, String(ans)).trim();
  if (expr) {
    try {
      const r = evaluate(expr);
      const fmt = Number.isFinite(r) ? (Number.isInteger(r) ? r.toString() : r.toPrecision(10).replace(/\.?0+$/,'')) : r;
      // Show what we interpreted if it changed significantly
      const showInterp = normalized.toLowerCase() !== orig.toLowerCase() && !/^[\d\s\+\-\*\/\^\(\)\.]+$/.test(orig);
      return { type: 'result', result: showInterp ? `"${orig}" ‚Üí ${normalized}\n= ${fmt}` : `= ${fmt}`, newAnswer: r };
    } catch(e) {
      return { type: 'error', result: `Unknown: "${input}"\nType "help" for commands.` };
    }
  }

  return { type: 'error', result: 'Type "help" for commands.' };
}

// ===== CUSTOM FORMULAS (localStorage) =====
let customFormulas = JSON.parse(localStorage.getItem('jcalc_formulas') || '{}');

function saveFormula(name, formula) {
  customFormulas[name.toLowerCase()] = { name: name, formula: formula, created: new Date().toISOString() };
  localStorage.setItem('jcalc_formulas', JSON.stringify(customFormulas));
}

function deleteFormula(name) {
  delete customFormulas[name.toLowerCase()];
  localStorage.setItem('jcalc_formulas', JSON.stringify(customFormulas));
}

function listFormulas() {
  const keys = Object.keys(customFormulas);
  if (keys.length === 0) {
    let t = 'No saved formulas yet.\n\n';
    t += '‚îå‚îÄ‚îÄ‚îÄ HOW TO SAVE A FORMULA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n';
    t += '‚îÇ                                             ‚îÇ\n';
    t += '‚îÇ  save NAME = FORMULA                        ‚îÇ\n';
    t += '‚îÇ                                             ‚îÇ\n';
    t += '‚îÇ  Examples:                                  ‚îÇ\n';
    t += '‚îÇ    save tri = 0.5 * b * h                   ‚îÇ\n';
    t += '‚îÇ    save hyp = sqrt(a^2 + b^2)               ‚îÇ\n';
    t += '‚îÇ    save circle = pi * r^2                   ‚îÇ\n';
    t += '‚îÇ                                             ‚îÇ\n';
    t += '‚îÇ  Then use it:                               ‚îÇ\n';
    t += '‚îÇ    tri where b=10, h=5                      ‚îÇ\n';
    t += '‚îÇ    hyp a=3, b=4                             ‚îÇ\n';
    t += '‚îÇ                                             ‚îÇ\n';
    t += '‚îÇ  You can even NEST formulas:                ‚îÇ\n';
    t += '‚îÇ    save cylinder = circle * h               ‚îÇ\n';
    t += '‚îÇ    cylinder r=5, h=10  ‚Üí  uses circle!      ‚îÇ\n';
    t += '‚îÇ                                             ‚îÇ\n';
    t += '‚îÇ  Formulas are saved in your browser!        ‚îÇ\n';
    t += '‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò';
    return t;
  }
  
  let t = `Your Saved Formulas (${keys.length}):\n`;
  t += '‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n';
  keys.forEach(k => {
    const f = customFormulas[k];
    const name = f.name.length > 12 ? f.name.substring(0, 9) + '...' : f.name;
    const formula = f.formula.length > 26 ? f.formula.substring(0, 23) + '...' : f.formula;
    t += `‚îÇ  ${name.padEnd(12)} = ${formula.padEnd(26)} ‚îÇ\n`;
  });
  t += '‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n';
  t += '‚îÇ  Usage: NAME where x=1, y=2              ‚îÇ\n';
  t += '‚îÇ  Delete: delete NAME                      ‚îÇ\n';
  t += '‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò';
  return t;
}

// ===== UI =====
const output = document.getElementById('output');
const input = document.getElementById('input');
const ansDisplay = document.getElementById('ansDisplay');
const cmdHistory = [];
let histIdx = -1;
let lastAnswer = 0;

function addLine(text, type) {
  const line = document.createElement('div');
  line.className = `line ${type}`;
  line.textContent = text;
  output.appendChild(line);
  output.scrollTop = output.scrollHeight;
}

function setInput(t) { input.value = t; input.focus(); }
function clearOutput() { output.innerHTML = ''; addLine('Cleared. Your saved formulas are preserved.', 'system'); }

function handleSubmit() {
  const val = input.value.trim();
  if (!val) return;
  cmdHistory.push(val);
  histIdx = -1;
  addLine(`> ${val}`, 'user');
  const r = process(val);
  if (r.newAnswer !== undefined) {
    lastAnswer = r.newAnswer;
    ansDisplay.textContent = `ans = ${typeof lastAnswer === 'number' ? (Number.isInteger(lastAnswer) ? lastAnswer : lastAnswer.toFixed(4)) : lastAnswer}`;
  }
  addLine(r.result, r.type === 'error' ? 'error' : r.type === 'help' ? 'help' : 'result');
  input.value = '';
}

input.addEventListener('keydown', e => {
  if (e.key === 'Enter') { e.preventDefault(); handleSubmit(); }
  else if (e.key === 'ArrowUp') {
    e.preventDefault();
    if (cmdHistory.length) { histIdx = Math.min(histIdx + 1, cmdHistory.length - 1); input.value = cmdHistory[cmdHistory.length - 1 - histIdx] || ''; }
  }
  else if (e.key === 'ArrowDown') {
    e.preventDefault();
    if (histIdx > 0) { histIdx--; input.value = cmdHistory[cmdHistory.length - 1 - histIdx] || ''; }
    else { histIdx = -1; input.value = ''; }
  }
});

// Welcome message
const formulaCount = Object.keys(customFormulas).length;
let welcomeMsg = '‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n';
welcomeMsg += '‚ïë      JCALCULATOR v2.0 - Math Teacher     ‚ïë\n';
welcomeMsg += '‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n';
welcomeMsg += '‚ïë  "help"     ‚Üí See all commands           ‚ïë\n';
welcomeMsg += '‚ïë  "formulas" ‚Üí Save your own formulas     ‚ïë\n';
if (formulaCount > 0) {
  welcomeMsg += `‚ïë  ‚úì ${formulaCount} saved formula${formulaCount > 1 ? 's' : ''} loaded from storage   ‚ïë\n`;
}
welcomeMsg += '‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù';
addLine(welcomeMsg, 'system');
input.focus();
</script>
</body>
</html>
