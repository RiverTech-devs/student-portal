<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ExamFlow | Testing Platform</title>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Fraunces:wght@600;700&display=swap" rel="stylesheet">
    <!-- Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        :root {
            --bg-primary: #0f0f12;
            --bg-secondary: #1a1a21;
            --bg-tertiary: #24242e;
            --bg-card: #1e1e27;
            --accent-primary: #6366f1;
            --accent-secondary: #818cf8;
            --accent-success: #10b981;
            --accent-warning: #f59e0b;
            --accent-danger: #ef4444;
            --text-primary: #f4f4f5;
            --text-secondary: #a1a1aa;
            --text-muted: #71717a;
            --border-color: rgba(255,255,255,0.08);
            --shadow-glow: 0 0 60px rgba(99, 102, 241, 0.15);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
        }

        body {
            font-family: 'DM Sans', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
        }

        .bg-grid {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-image: linear-gradient(rgba(99, 102, 241, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(99, 102, 241, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none; z-index: 0;
        }

        .bg-gradient {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle at 30% 30%, rgba(99, 102, 241, 0.08) 0%, transparent 50%),
                radial-gradient(circle at 70% 70%, rgba(129, 140, 248, 0.05) 0%, transparent 50%);
            pointer-events: none; z-index: 0;
        }

        .header {
            position: fixed; top: 0; left: 0; right: 0; height: 72px;
            background: rgba(15, 15, 18, 0.8); backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border-color);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 32px; z-index: 100;
        }

        .logo {
            font-family: 'Fraunces', serif; font-size: 24px; font-weight: 700;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
        }

        .user-info { display: flex; align-items: center; gap: 12px; }

        .avatar {
            width: 40px; height: 40px; border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            font-weight: 600; font-size: 14px;
        }
        .avatar.teacher { background: linear-gradient(135deg, #6366f1, #8b5cf6); }
        .avatar.student { background: linear-gradient(135deg, #10b981, #34d399); }

        .user-name { font-weight: 500; font-size: 14px; }
        .user-role { font-size: 12px; color: var(--text-muted); }


        .main-content {
            padding-top: 32px; padding-left: 32px; padding-right: 32px; padding-bottom: 48px;
            max-width: 1400px; margin: 0 auto; position: relative; z-index: 1;
            height: calc(100vh - 72px); overflow-y: auto; overflow-x: hidden;
            margin-top: 72px;
        }

        .dashboard-header { margin-bottom: 32px; }
        .dashboard-title { font-family: 'Fraunces', serif; font-size: 32px; font-weight: 700; margin-bottom: 8px; }
        .dashboard-subtitle { color: var(--text-secondary); font-size: 15px; }

        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 32px; }

        .stat-card {
            background: var(--bg-card); border: 1px solid var(--border-color);
            border-radius: 16px; padding: 24px; position: relative; overflow: hidden;
        }
        .stat-card::before {
            content: ''; position: absolute; top: 0; left: 0; right: 0; height: 3px;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            opacity: 0; transition: opacity 0.3s ease;
        }
        .stat-card:hover::before { opacity: 1; }
        .stat-label { font-size: 13px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; }
        .stat-value { font-size: 28px; font-weight: 700; }

        .actions-bar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; flex-wrap: wrap; gap: 16px; }
        .section-title { font-size: 18px; font-weight: 600; }

        .btn {
            padding: 12px 24px; border: none; border-radius: 10px; font-family: inherit;
            font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.3s ease;
            display: inline-flex; align-items: center; gap: 8px;
        }
        .btn-primary { background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary)); color: white; box-shadow: 0 4px 16px rgba(99, 102, 241, 0.3); }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 8px 24px rgba(99, 102, 241, 0.4); }
        .btn-secondary { background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); }
        .btn-secondary:hover { background: var(--bg-card); border-color: var(--accent-primary); }
        .btn-danger { background: rgba(239, 68, 68, 0.1); color: var(--accent-danger); border: 1px solid rgba(239, 68, 68, 0.2); }
        .btn-danger:hover { background: rgba(239, 68, 68, 0.2); }
        .btn-success { background: linear-gradient(135deg, var(--accent-success), #34d399); color: white; }
        .btn-warning { background: rgba(245, 158, 11, 0.1); color: var(--accent-warning); border: 1px solid rgba(245, 158, 11, 0.2); }
        .btn-info { background: rgba(59, 130, 246, 0.1); color: #3b82f6; border: 1px solid rgba(59, 130, 246, 0.2); }
        .btn-info:hover { background: rgba(59, 130, 246, 0.2); }
        .btn-sm { padding: 8px 16px; font-size: 13px; }

        .tests-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(340px, 1fr)); gap: 20px; }

        .test-card {
            background: var(--bg-card); border: 1px solid var(--border-color);
            border-radius: 16px; padding: 24px; transition: all 0.3s ease;
            position: relative; overflow: hidden;
        }
        .test-card:hover { border-color: rgba(99, 102, 241, 0.3); box-shadow: var(--shadow-glow); transform: translateY(-4px); }
        .test-card-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 16px; }
        .test-title { font-size: 18px; font-weight: 600; margin-bottom: 4px; }
        .test-subject { font-size: 13px; color: var(--accent-secondary); }

        .test-status { padding: 6px 12px; border-radius: 20px; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
        .status-draft { background: rgba(161, 161, 170, 0.1); color: var(--text-secondary); }
        .status-active { background: rgba(16, 185, 129, 0.1); color: var(--accent-success); }
        .status-pending { background: rgba(245, 158, 11, 0.1); color: var(--accent-warning); }
        .status-completed { background: rgba(99, 102, 241, 0.1); color: var(--accent-primary); }
        .status-graded { background: rgba(16, 185, 129, 0.1); color: var(--accent-success); }

        .test-meta { display: flex; gap: 20px; margin-bottom: 20px; color: var(--text-muted); font-size: 13px; flex-wrap: wrap; }
        .test-meta span { display: flex; align-items: center; gap: 6px; }
        .test-actions { display: flex; gap: 8px; flex-wrap: wrap; }

        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(8px);
            display: none; align-items: center; justify-content: center;
            z-index: 200; padding: 20px;
        }
        .modal-overlay.active { display: flex; }

        .modal {
            background: var(--bg-secondary); border: 1px solid var(--border-color);
            border-radius: 20px; width: 100%; max-width: 800px; max-height: 90vh;
            overflow-y: auto; animation: modalSlide 0.3s ease;
        }
        .modal.wide { max-width: 1000px; }

        @keyframes modalSlide { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        .modal-header {
            padding: 24px 28px; border-bottom: 1px solid var(--border-color);
            display: flex; justify-content: space-between; align-items: center;
        }
        .modal-title { font-size: 20px; font-weight: 600; }

        .modal-close {
            width: 36px; height: 36px; border: none; background: var(--bg-tertiary);
            border-radius: 10px; color: var(--text-secondary); cursor: pointer;
            font-size: 20px; transition: all 0.2s ease;
        }
        .modal-close:hover { background: var(--accent-danger); color: white; }

        .modal-body { padding: 28px; }
        .modal-footer { padding: 20px 28px; border-top: 1px solid var(--border-color); display: flex; justify-content: flex-end; gap: 12px; }

        .form-group { margin-bottom: 20px; }
        .form-label { display: block; font-size: 13px; font-weight: 500; color: var(--text-secondary); margin-bottom: 8px; }

        .form-input, .form-select, .form-textarea {
            width: 100%; padding: 14px 16px; background: var(--bg-tertiary);
            border: 1px solid var(--border-color); border-radius: 10px;
            color: var(--text-primary); font-family: inherit; font-size: 14px;
            transition: all 0.2s ease;
        }
        .form-input:focus, .form-select:focus, .form-textarea:focus { outline: none; border-color: var(--accent-primary); box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1); }
        .form-textarea { min-height: 100px; resize: vertical; }
        .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }

        .checkbox-group { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
        .checkbox-item {
            display: flex; align-items: center; gap: 8px; padding: 10px 14px;
            background: var(--bg-tertiary); border: 1px solid var(--border-color);
            border-radius: 8px; cursor: pointer; transition: all 0.2s ease; font-size: 13px;
        }
        .checkbox-item:hover { border-color: var(--accent-primary); }
        .checkbox-item.checked { background: rgba(99, 102, 241, 0.1); border-color: var(--accent-primary); }
        .checkbox-item input { display: none; }

        .question-item {
            background: var(--bg-tertiary); border: 1px solid var(--border-color);
            border-radius: 12px; padding: 20px; margin-bottom: 16px; position: relative;
        }
        .question-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
        .question-number { font-size: 12px; font-weight: 600; color: var(--accent-primary); text-transform: uppercase; letter-spacing: 0.5px; }
        .question-type-badge { padding: 4px 10px; background: var(--bg-card); border-radius: 6px; font-size: 11px; color: var(--text-muted); }

        .option-item {
            display: flex; align-items: center; gap: 12px; padding: 12px;
            background: var(--bg-card); border-radius: 8px; margin-bottom: 8px;
            cursor: pointer; transition: all 0.2s ease; border: 2px solid transparent;
        }
        .option-item:hover { background: rgba(99, 102, 241, 0.05); }
        .option-item.selected { border-color: var(--accent-primary); background: rgba(99, 102, 241, 0.1); }
        .option-item.correct { border-color: var(--accent-success); background: rgba(16, 185, 129, 0.1); }
        .option-item.incorrect { border-color: var(--accent-danger); background: rgba(239, 68, 68, 0.1); }

        .option-marker {
            width: 28px; height: 28px; border-radius: 8px; background: var(--bg-tertiary);
            display: flex; align-items: center; justify-content: center;
            font-size: 13px; font-weight: 600; color: var(--text-secondary); flex-shrink: 0;
        }
        .option-item.selected .option-marker { background: var(--accent-primary); color: white; }
        .option-text { flex: 1; font-size: 14px; }

        .test-view { max-width: 800px; margin: 0 auto; }
        .test-view-header { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 16px; padding: 24px; margin-bottom: 24px; }
        .test-view-title { font-family: 'Fraunces', serif; font-size: 24px; margin-bottom: 8px; }
        .test-view-info { display: flex; gap: 24px; color: var(--text-secondary); font-size: 14px; flex-wrap: wrap; }

        .progress-bar { height: 6px; background: var(--bg-tertiary); border-radius: 3px; margin-top: 20px; overflow: hidden; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary)); border-radius: 3px; transition: width 0.3s ease; }

        .question-card { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 16px; padding: 28px; margin-bottom: 20px; }
        .question-text { font-size: 16px; line-height: 1.6; margin-bottom: 20px; }

        .write-in-input {
            width: 100%; padding: 16px; background: var(--bg-tertiary);
            border: 1px solid var(--border-color); border-radius: 10px;
            color: var(--text-primary); font-family: inherit; font-size: 14px;
            min-height: 120px; resize: vertical;
        }
        .write-in-input:focus { outline: none; border-color: var(--accent-primary); }

        .test-navigation { display: flex; justify-content: space-between; gap: 16px; margin-top: 24px; }

        .results-summary {
            background: var(--bg-card); border: 1px solid var(--border-color);
            border-radius: 16px; padding: 32px; text-align: center; margin-bottom: 24px;
        }

        .score-circle {
            width: 140px; height: 140px; border-radius: 50%;
            background: conic-gradient(var(--accent-primary) var(--score-percent), var(--bg-tertiary) 0);
            display: flex; align-items: center; justify-content: center;
            margin: 0 auto 20px; position: relative;
        }
        .score-inner {
            width: 110px; height: 110px; border-radius: 50%; background: var(--bg-card);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .score-value { font-size: 32px; font-weight: 700; }
        .score-label { font-size: 12px; color: var(--text-muted); }

        .submissions-table { width: 100%; border-collapse: collapse; }
        .submissions-table th, .submissions-table td {
            padding: 14px 16px; text-align: left; border-bottom: 1px solid var(--border-color);
        }
        .submissions-table th { font-size: 12px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600; }
        .submissions-table tr:hover td { background: rgba(99, 102, 241, 0.03); }

        .grade-input {
            width: 60px; padding: 8px; background: var(--bg-tertiary);
            border: 1px solid var(--border-color); border-radius: 6px;
            color: var(--text-primary); font-family: inherit; font-size: 14px; text-align: center;
        }
        .grade-input:focus { outline: none; border-color: var(--accent-primary); }

        .feedback-input {
            width: 100%; padding: 10px; background: var(--bg-tertiary);
            border: 1px solid var(--border-color); border-radius: 8px;
            color: var(--text-primary); font-family: inherit; font-size: 13px;
            margin-top: 8px; resize: vertical; min-height: 60px;
        }

        .toast {
            position: fixed; bottom: 24px; right: 24px; padding: 16px 24px;
            background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 12px;
            display: flex; align-items: center; gap: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            transform: translateY(100px); opacity: 0; transition: all 0.3s ease; z-index: 300;
        }
        .toast.show { transform: translateY(0); opacity: 1; }
        .toast.success { border-color: var(--accent-success); }
        .toast-icon { font-size: 20px; }

        .tab-container { display: flex; gap: 4px; margin-bottom: 24px; background: var(--bg-tertiary); border-radius: 12px; padding: 4px; }
        .tab-btn {
            flex: 1; padding: 12px 20px; border: none; background: transparent;
            color: var(--text-secondary); font-family: inherit; font-size: 14px;
            font-weight: 500; border-radius: 8px; cursor: pointer; transition: all 0.2s ease;
        }
        .tab-btn.active { background: var(--accent-primary); color: white; }
        .tab-btn:hover:not(.active) { color: var(--text-primary); }

        .empty-state { text-align: center; padding: 60px 20px; color: var(--text-muted); }
        .empty-icon { font-size: 48px; margin-bottom: 16px; opacity: 0.5; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .fade-in { animation: fadeIn 0.4s ease forwards; }
        .delay-1 { animation-delay: 0.1s; opacity: 0; }
        .delay-2 { animation-delay: 0.2s; opacity: 0; }
        .delay-3 { animation-delay: 0.3s; opacity: 0; }

        @media (max-width: 768px) {
            .header { padding: 0 16px; }
            .main-content { padding-left: 16px; padding-right: 16px; }
            .form-row { grid-template-columns: 1fr; }
            .tests-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="bg-grid"></div>
    <div class="bg-gradient"></div>

    <header class="header">
        <div class="logo">Testing Center</div>
        <div class="user-info">
            <div class="avatar teacher" id="userAvatar">--</div>
            <div>
                <div class="user-name" id="userName">Loading...</div>
                <div class="user-role" id="userRole">--</div>
            </div>
        </div>
    </header>

    <main class="main-content">
        <!-- Teacher Dashboard -->
        <div id="teacherDashboard">
            <div class="dashboard-header fade-in">
                <h1 class="dashboard-title">Teacher Dashboard</h1>
                <p class="dashboard-subtitle">Manage your tests, track student progress, and grade submissions</p>
            </div>

            <div class="stats-grid">
                <div class="stat-card fade-in delay-1">
                    <div class="stat-label">Total Tests</div>
                    <div class="stat-value" id="totalTests">3</div>
                </div>
                <div class="stat-card fade-in delay-2">
                    <div class="stat-label">Active Tests</div>
                    <div class="stat-value" id="activeTests">2</div>
                </div>
                <div class="stat-card fade-in delay-2">
                    <div class="stat-label">Pending Reviews</div>
                    <div class="stat-value" id="pendingReviews">2</div>
                </div>
                <div class="stat-card fade-in delay-3">
                    <div class="stat-label">Total Students</div>
                    <div class="stat-value" id="totalStudents">12</div>
                </div>
            </div>

            <div class="actions-bar fade-in delay-3">
                <h2 class="section-title">Your Tests</h2>
                <button class="btn btn-primary" onclick="openCreateModal()">
                    <span>+</span> Create New Test
                </button>
            </div>

            <div class="tests-grid" id="teacherTestsGrid"></div>
        </div>

        <!-- Student Dashboard -->
        <div id="studentDashboard" style="display: none;">
            <div class="dashboard-header fade-in">
                <h1 class="dashboard-title">My Tests</h1>
                <p class="dashboard-subtitle">View and complete your assigned tests</p>
            </div>

            <div class="stats-grid">
                <div class="stat-card fade-in delay-1">
                    <div class="stat-label">Pending Tests</div>
                    <div class="stat-value" id="pendingTests">2</div>
                </div>
                <div class="stat-card fade-in delay-2">
                    <div class="stat-label">Completed</div>
                    <div class="stat-value" id="completedTests">1</div>
                </div>
                <div class="stat-card fade-in delay-2">
                    <div class="stat-label">Average Score</div>
                    <div class="stat-value" id="avgScore">--</div>
                </div>
            </div>

            <div class="actions-bar fade-in delay-3">
                <h2 class="section-title">Available Tests</h2>
            </div>

            <div class="tests-grid" id="studentTestsGrid"></div>
        </div>

        <!-- Test Taking View -->
        <div id="testTakingView" style="display: none;">
            <div class="test-view">
                <div class="test-view-header">
                    <h1 class="test-view-title" id="takingTestTitle">Test Title</h1>
                    <div class="test-view-info">
                        <span id="takingTestSubject">Subject</span>
                        <span id="questionProgress">Question 1 of 5</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 20%"></div>
                    </div>
                </div>
                <div id="questionsContainer"></div>
                <div class="test-navigation">
                    <button class="btn btn-secondary" id="prevBtn" onclick="previousQuestion()">← Previous</button>
                    <button class="btn btn-primary" id="nextBtn" onclick="nextQuestion()">Next →</button>
                    <button class="btn btn-success" id="submitBtn" onclick="submitTest()" style="display: none;">Submit Test</button>
                </div>
            </div>
        </div>

        <!-- Results View -->
        <div id="resultsView" style="display: none;">
            <div class="test-view">
                <div class="results-summary">
                    <div class="score-circle" style="--score-percent: 80%">
                        <div class="score-inner">
                            <div class="score-value" id="finalScore">80%</div>
                            <div class="score-label">Your Score</div>
                        </div>
                    </div>
                    <h2 style="margin-bottom: 8px;">Test Completed!</h2>
                    <p style="color: var(--text-secondary);" id="resultsSubtitle">You answered 4 out of 5 questions correctly</p>
                </div>
                <div id="resultsDetails"></div>
                <div style="text-align: center; margin-top: 24px;">
                    <button class="btn btn-primary" onclick="backToDashboard()">Back to Dashboard</button>
                </div>
            </div>
        </div>
    </main>

    <!-- Create/Edit Test Modal -->
    <div class="modal-overlay" id="testModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title" id="modalTitle">Create New Test</h2>
                <button class="modal-close" onclick="closeModal('testModal')">×</button>
            </div>
            <div class="modal-body">
                <form id="testForm">
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">Test Title</label>
                            <input type="text" class="form-input" id="testTitle" placeholder="Enter test title" required>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Subject</label>
                            <input type="text" class="form-input" id="testSubject" placeholder="e.g., Mathematics">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">Time Limit (minutes)</label>
                            <input type="number" class="form-input" id="testTime" placeholder="30" min="1">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Status</label>
                            <select class="form-select" id="testStatus">
                                <option value="draft">Draft</option>
                                <option value="active">Active</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Description</label>
                        <textarea class="form-textarea" id="testDescription" placeholder="Enter test description..."></textarea>
                    </div>

                    <div class="actions-bar" style="margin-top: 24px;">
                        <h3 class="section-title">Questions</h3>
                        <button type="button" class="btn btn-secondary btn-sm" onclick="addQuestion()">+ Add Question</button>
                    </div>
                    <div id="questionsBuilder"></div>
                </form>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('testModal')">Cancel</button>
                <button class="btn btn-primary" onclick="saveTest()">Save Test</button>
            </div>
        </div>
    </div>

    <!-- Assign Test Modal -->
    <div class="modal-overlay" id="assignModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">Assign Test</h2>
                <button class="modal-close" onclick="closeModal('assignModal')">×</button>
            </div>
            <div class="modal-body">
                <h3 id="assignTestTitle" style="margin-bottom: 20px; color: var(--accent-secondary);"></h3>

                <div class="form-group">
                    <label class="form-label">Select Classes <span style="color: var(--accent-danger);">*</span></label>
                    <p style="font-size: 12px; color: var(--text-muted); margin-bottom: 10px;">Select one or more classes to assign this test to</p>
                    <div class="checkbox-group" id="classCheckboxes"></div>
                </div>

                <div class="form-group">
                    <label class="form-label">Due Date (Optional)</label>
                    <input type="datetime-local" id="assignDueDate" class="form-input">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('assignModal')">Cancel</button>
                <button class="btn btn-primary" id="assignSaveBtn" onclick="saveAssignments()">Save & Issue</button>
            </div>
        </div>
    </div>

    <!-- View Submissions Modal -->
    <div class="modal-overlay" id="submissionsModal">
        <div class="modal wide">
            <div class="modal-header">
                <h2 class="modal-title">Student Submissions</h2>
                <button class="modal-close" onclick="closeModal('submissionsModal')">×</button>
            </div>
            <div class="modal-body">
                <h3 id="submissionsTestTitle" style="margin-bottom: 10px; color: var(--accent-secondary);"></h3>
                <div id="submissionsClassSelector" style="margin-bottom: 20px;"></div>
                <div id="submissionsList"></div>
            </div>
        </div>
    </div>

    <!-- Analytics Modal -->
    <div class="modal-overlay" id="analyticsModal">
        <div class="modal wide">
            <div class="modal-header">
                <h2 class="modal-title">Test Analytics</h2>
                <button class="modal-close" onclick="closeModal('analyticsModal')">×</button>
            </div>
            <div class="modal-body">
                <h3 id="analyticsTestTitle" style="margin-bottom: 10px; color: var(--accent-secondary);"></h3>
                <div id="analyticsClassSelector" style="margin-bottom: 20px;"></div>
                <div id="analyticsContent"></div>
            </div>
        </div>
    </div>

    <!-- Grade Submission Modal -->
    <div class="modal-overlay" id="gradeModal">
        <div class="modal wide">
            <div class="modal-header">
                <h2 class="modal-title">Grade Submission</h2>
                <button class="modal-close" onclick="closeModal('gradeModal')">×</button>
            </div>
            <div class="modal-body" id="gradeModalBody"></div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('gradeModal')">Cancel</button>
                <button class="btn btn-success" onclick="saveGrades()">Save Grades</button>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast">
        <span class="toast-icon">✓</span>
        <span class="toast-message" id="toastMessage">Success!</span>
    </div>

    <script>
        // ==================== SUPABASE CONFIG ====================
        // These match the shared config used by the portal
        const SUPABASE_URL = 'https://joxvhzxkrcigknsdrusr.supabase.co';
        const SUPABASE_ANON_KEY = 'sb_publishable_xgvdFBaHCJKl9p-Lu61aZw_3oLkeTtc';

        let supabaseClient = null;
        let authReady = false;
        let isEmbedded = window.parent !== window; // Check if running in iframe

        // ==================== DATA STORES ====================
        let currentRole = 'teacher';
        let editingTestId = null;
        let currentTestId = null;
        let currentQuestionIndex = 0;
        let studentAnswers = {};
        let assigningTestId = null;
        let gradingSubmissionKey = null;

        // Current user info (populated from auth)
        let currentUser = {
            id: null,
            userType: null,
            firstName: '',
            lastName: '',
            email: ''
        };

        // Data loaded from Supabase (or portal)
        let classesDatabase = [];
        let studentsDatabase = [];
        let currentStudentId = null;
        let testsDatabase = [];
        let submissionsDatabase = {};

        // ==================== AUTH & INITIALIZATION ====================

        // Listen for auth from parent portal
        window.addEventListener('message', async (event) => {
            if (!event.data || !event.data.type) return;

            switch (event.data.type) {
                case 'TESTING_CENTER_AUTH':
                    await handleAuthReceived(event.data.payload);
                    break;
                case 'TESTING_CENTER_CLASSES_DATA':
                    handleClassesData(event.data.payload);
                    break;
                case 'TESTING_CENTER_STUDENTS_DATA':
                    handleStudentsData(event.data.payload);
                    break;
            }
        });

        async function handleAuthReceived(payload) {
            const { userId, userType, accessToken, refreshToken, firstName, lastName, email } = payload;

            console.log('Testing Center: Auth received for', userType, firstName, lastName);

            // Store user info
            currentUser = {
                id: userId,
                userType: userType,
                firstName: firstName || '',
                lastName: lastName || '',
                email: email || ''
            };

            // Initialize Supabase with provided token
            try {
                supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
                    auth: {
                        autoRefreshToken: false,
                        persistSession: false
                    }
                });

                // Set session manually
                if (accessToken && refreshToken) {
                    await supabaseClient.auth.setSession({
                        access_token: accessToken,
                        refresh_token: refreshToken
                    });
                }

                authReady = true;

                // Notify portal that auth is ready
                window.parent.postMessage({ type: 'TESTING_CENTER_AUTH_READY', payload: { success: true } }, '*');

                // Initialize the app
                await initializeApp();
            } catch (error) {
                console.error('Failed to initialize Supabase:', error);
                window.parent.postMessage({
                    type: 'TESTING_CENTER_ERROR',
                    payload: { error: 'Failed to initialize authentication' }
                }, '*');
            }
        }

        function handleClassesData(payload) {
            classesDatabase = payload.classes || [];
            console.log('Testing Center: Received classes data', classesDatabase.length, 'classes');

            // Extract all unique students from classes into studentsDatabase
            const studentMap = new Map();
            classesDatabase.forEach(classObj => {
                if (classObj.students && Array.isArray(classObj.students)) {
                    classObj.students.forEach(student => {
                        if (student && student.id && !studentMap.has(student.id)) {
                            studentMap.set(student.id, student);
                        }
                    });
                }
            });
            studentsDatabase = Array.from(studentMap.values());
            console.log('Testing Center: Extracted', studentsDatabase.length, 'unique students from classes');

            // If assign modal is open, refresh it
            if (assigningTestId) {
                populateAssignModal();
            }
        }

        function handleStudentsData(payload) {
            const { classId, students } = payload;
            console.log('Testing Center: Received students for class', classId, students.length, 'students');

            // Update students in the class
            const classObj = classesDatabase.find(c => c.id === classId);
            if (classObj) {
                classObj.students = students;
            }

            // Also add to global students database
            students.forEach(s => {
                if (!studentsDatabase.find(existing => existing.id === s.id)) {
                    studentsDatabase.push(s);
                }
            });
        }

        async function initializeApp() {
            // Determine role based on user type
            if (currentUser.userType === 'teacher' || currentUser.userType === 'admin') {
                currentRole = 'teacher';
            } else if (currentUser.userType === 'student') {
                currentRole = 'student';
                currentStudentId = currentUser.id;
            } else {
                // Parent or unknown - show read-only view
                currentRole = 'student';
            }

            // Load data from Supabase
            await loadData();

            // Setup UI
            switchRole(currentRole);
        }

        async function loadData() {
            if (!authReady || !supabaseClient) {
                console.warn('Cannot load data - auth not ready');
                return;
            }

            try {
                // Load tests
                await loadTests();

                // Load submissions
                await loadSubmissions();

                // Request classes from portal (for teachers)
                if (currentRole === 'teacher' && isEmbedded) {
                    window.parent.postMessage({ type: 'TESTING_CENTER_REQUEST_CLASSES' }, '*');
                }
            } catch (error) {
                console.error('Error loading data:', error);
                showToast('Error loading data');
            }
        }

        async function loadTests() {
            try {
                if (currentRole === 'teacher') {
                    // Teachers see their own tests
                    const { data, error } = await supabaseClient
                        .from('tests')
                        .select(`
                            *,
                            test_questions (*)
                        `)
                        .eq('owner_id', currentUser.id)
                        .order('created_at', { ascending: false });

                    if (error) throw error;

                    // Also load test assignments (only active ones)
                    const { data: assignments, error: assignError } = await supabaseClient
                        .from('test_assignments')
                        .select('*')
                        .in('test_id', (data || []).map(t => t.id))
                        .eq('is_active', true);

                    if (assignError) console.warn('Error loading assignments:', assignError);

                    // Format tests for the UI
                    testsDatabase = (data || []).map(t => ({
                        id: t.id,
                        title: t.title,
                        subject: t.subject,
                        description: t.description,
                        timeLimit: t.time_limit_minutes,
                        status: t.status,
                        createdAt: t.created_at,
                        assignedClasses: (assignments || [])
                            .filter(a => a.test_id === t.id && a.class_id)
                            .map(a => a.class_id),
                        assignedStudents: (assignments || [])
                            .filter(a => a.test_id === t.id && a.student_id)
                            .map(a => a.student_id),
                        questions: (t.test_questions || [])
                            .sort((a, b) => a.question_order - b.question_order)
                            .map(q => ({
                                id: q.id,
                                type: q.question_type === 'multiple_choice' ? 'multiple-choice' : 'write-in',
                                text: q.question_text,
                                options: q.options || [],
                                correctAnswer: q.correct_answer_index,
                                maxPoints: q.max_points || 1
                            }))
                    }));
                } else {
                    // Students see assigned tests (only active assignments)
                    const { data, error } = await supabaseClient
                        .from('tests')
                        .select(`
                            *,
                            test_questions (*),
                            test_assignments!inner (*)
                        `)
                        .eq('status', 'active')
                        .eq('test_assignments.is_active', true);

                    if (error) throw error;

                    testsDatabase = (data || []).map(t => ({
                        id: t.id,
                        title: t.title,
                        subject: t.subject,
                        description: t.description,
                        timeLimit: t.time_limit_minutes,
                        status: t.status,
                        createdAt: t.created_at,
                        assignedClasses: (t.test_assignments || [])
                            .filter(a => a.class_id && a.is_active)
                            .map(a => a.class_id),
                        assignedStudents: (t.test_assignments || [])
                            .filter(a => a.student_id && a.is_active)
                            .map(a => a.student_id),
                        questions: (t.test_questions || [])
                            .sort((a, b) => a.question_order - b.question_order)
                            .map(q => ({
                                id: q.id,
                                type: q.question_type === 'multiple_choice' ? 'multiple-choice' : 'write-in',
                                text: q.question_text,
                                options: q.options || [],
                                correctAnswer: q.correct_answer_index,
                                maxPoints: q.max_points || 1
                            }))
                    }));
                }

                console.log('Loaded', testsDatabase.length, 'tests');
            } catch (error) {
                console.error('Error loading tests:', error);
                throw error;
            }
        }

        async function loadSubmissions() {
            try {
                let query = supabaseClient
                    .from('test_submissions')
                    .select(`
                        *,
                        test_question_grades (*)
                    `);

                if (currentRole === 'student') {
                    // Students see only their submissions
                    query = query.eq('student_id', currentUser.id);
                } else {
                    // Teachers see submissions for their tests
                    const testIds = testsDatabase.map(t => t.id);
                    if (testIds.length > 0) {
                        query = query.in('test_id', testIds);
                    } else {
                        submissionsDatabase = {};
                        return;
                    }
                }

                const { data, error } = await query;

                if (error) throw error;

                // Convert to legacy format
                submissionsDatabase = {};
                (data || []).forEach(s => {
                    const key = `${s.test_id}_${s.student_id}`;
                    const gradedAnswers = {};
                    (s.test_question_grades || []).forEach(g => {
                        gradedAnswers[g.question_id] = {
                            score: g.points_earned,
                            maxScore: 10, // Default, should be from question
                            feedback: g.feedback
                        };
                    });

                    submissionsDatabase[key] = {
                        id: s.id,
                        testId: s.test_id,
                        studentId: s.student_id,
                        answers: s.answers || {},
                        autoScore: s.auto_score,
                        finalScore: s.final_score,
                        gradedAnswers: gradedAnswers,
                        submittedAt: s.submitted_at,
                        status: s.status === 'graded' ? 'graded' : 'pending_review',
                        linkedSubmissionId: s.linked_submission_id,
                        testAssignmentId: s.test_assignment_id
                    };
                });

                console.log('Loaded', Object.keys(submissionsDatabase).length, 'submissions');
            } catch (error) {
                console.error('Error loading submissions:', error);
                throw error;
            }
        }

        // ==================== SUPABASE SAVE FUNCTIONS ====================

        async function saveTestToDatabase(testData, hasSubmissions = false, originalQIds = []) {
            if (!supabaseClient || !authReady) {
                console.warn('Cannot save - auth not ready');
                return null;
            }

            const { id, title, subject, description, timeLimit, status, questions } = testData;

            try {
                let testId = id;

                if (id) {
                    // Update existing test
                    const { error: testError } = await supabaseClient
                        .from('tests')
                        .update({
                            title,
                            subject,
                            description,
                            time_limit_minutes: timeLimit,
                            status,
                            updated_at: new Date().toISOString()
                        })
                        .eq('id', id);

                    if (testError) throw testError;

                    if (hasSubmissions) {
                        // Update existing questions in place to preserve IDs
                        for (let idx = 0; idx < questions.length; idx++) {
                            const q = questions[idx];
                            const originalId = q.originalId || originalQIds[idx];

                            if (originalId) {
                                // Update existing question
                                const { error: updateError } = await supabaseClient
                                    .from('test_questions')
                                    .update({
                                        question_order: idx,
                                        question_text: q.text,
                                        options: q.options || null,
                                        correct_answer_index: q.correctAnswer,
                                        max_points: q.maxPoints || 1
                                    })
                                    .eq('id', originalId);

                                if (updateError) throw updateError;
                            } else {
                                // Insert new question (added at end)
                                const { error: insertError } = await supabaseClient
                                    .from('test_questions')
                                    .insert({
                                        test_id: testId,
                                        question_order: idx,
                                        question_type: q.type === 'multiple-choice' ? 'multiple_choice' : 'write_in',
                                        question_text: q.text,
                                        options: q.options || null,
                                        correct_answer_index: q.correctAnswer,
                                        max_points: q.maxPoints || 1
                                    });

                                if (insertError) throw insertError;
                            }
                        }
                    } else {
                        // No submissions - safe to delete and recreate questions
                        await supabaseClient.from('test_questions').delete().eq('test_id', id);

                        if (questions && questions.length > 0) {
                            const questionInserts = questions.map((q, idx) => ({
                                test_id: testId,
                                question_order: idx,
                                question_type: q.type === 'multiple-choice' ? 'multiple_choice' : 'write_in',
                                question_text: q.text,
                                options: q.options || null,
                                correct_answer_index: q.correctAnswer,
                                max_points: q.maxPoints || 1
                            }));

                            const { error: qError } = await supabaseClient
                                .from('test_questions')
                                .insert(questionInserts);

                            if (qError) throw qError;
                        }
                    }
                } else {
                    // Insert new test
                    const { data: test, error: testError } = await supabaseClient
                        .from('tests')
                        .insert({
                            owner_id: currentUser.id,
                            title,
                            subject,
                            description,
                            time_limit_minutes: timeLimit,
                            status
                        })
                        .select()
                        .single();

                    if (testError) throw testError;
                    testId = test.id;

                    // Insert questions for new test
                    if (questions && questions.length > 0) {
                        const questionInserts = questions.map((q, idx) => ({
                            test_id: testId,
                            question_order: idx,
                            question_type: q.type === 'multiple-choice' ? 'multiple_choice' : 'write_in',
                            question_text: q.text,
                            options: q.options || null,
                            correct_answer_index: q.correctAnswer,
                            max_points: q.maxPoints || 1
                        }));

                        const { error: qError } = await supabaseClient
                            .from('test_questions')
                            .insert(questionInserts);

                        if (qError) throw qError;
                    }
                }

                return testId;
            } catch (error) {
                console.error('Error saving test:', error);
                throw error;
            }
        }

        async function deleteTestFromDatabase(testId) {
            if (!supabaseClient || !authReady) return;

            try {
                const { error } = await supabaseClient
                    .from('tests')
                    .delete()
                    .eq('id', testId);

                if (error) throw error;
            } catch (error) {
                console.error('Error deleting test:', error);
                throw error;
            }
        }

        // Check if a test has any submissions
        async function testHasSubmissions(testId) {
            if (!supabaseClient || !authReady) return false;

            try {
                const { count, error } = await supabaseClient
                    .from('test_submissions')
                    .select('id', { count: 'exact', head: true })
                    .eq('test_id', testId);

                if (error) throw error;
                return count > 0;
            } catch (error) {
                console.error('Error checking submissions:', error);
                return false;
            }
        }

        // Track if editing a test with submissions (limits what can be changed)
        let editingTestHasSubmissions = false;
        let originalQuestionIds = []; // Store original question IDs for update

        async function saveAssignmentsToDatabase(testId, classIds, dueDate) {
            if (!supabaseClient || !authReady) return [];

            try {
                const test = testsDatabase.find(t => t.id === testId);
                const maxPoints = test ? test.questions.reduce((sum, q) => sum + (q.maxPoints || 1), 0) : 100;

                // Get existing assignments for this test
                const { data: existingAssignments, error: fetchError } = await supabaseClient
                    .from('test_assignments')
                    .select('id, class_id, linked_assignment_id')
                    .eq('test_id', testId)
                    .eq('is_active', true);

                if (fetchError) throw fetchError;

                const existingClassIds = existingAssignments ? existingAssignments.map(a => a.class_id) : [];

                // Find classes to add (in new list but not existing)
                const classesToAdd = classIds.filter(id => !existingClassIds.includes(id));

                // Find assignments to remove (in existing but not in new list)
                const assignmentsToRemove = existingAssignments ?
                    existingAssignments.filter(a => !classIds.includes(a.class_id)) : [];

                // Deactivate removed assignments (this will trigger cascade to deactivate linked assignments)
                for (const assignment of assignmentsToRemove) {
                    await supabaseClient
                        .from('test_assignments')
                        .update({ is_active: false })
                        .eq('id', assignment.id);
                }

                const newAssignments = [];

                // Create new assignments for added classes
                for (const classId of classesToAdd) {
                    const { data, error } = await supabaseClient
                        .from('test_assignments')
                        .insert({
                            test_id: testId,
                            class_id: classId,
                            student_id: null,
                            assigned_by: currentUser.id,
                            due_date: dueDate,
                            is_active: true
                        })
                        .select()
                        .single();

                    if (error) throw error;
                    newAssignments.push(data);

                    // Notify portal to create assignment entry for grade integration
                    if (isEmbedded && test) {
                        window.parent.postMessage({
                            type: 'TEST_ASSIGNMENT_CREATED',
                            payload: {
                                testId: testId,
                                testTitle: test.title,
                                classId: classId,
                                dueDate: dueDate,
                                maxPoints: maxPoints,
                                testAssignmentId: data.id
                            }
                        }, '*');
                    }
                }

                // Update due date for existing assignments that remain
                const assignmentsToKeep = existingAssignments ?
                    existingAssignments.filter(a => classIds.includes(a.class_id)) : [];

                for (const assignment of assignmentsToKeep) {
                    await supabaseClient
                        .from('test_assignments')
                        .update({ due_date: dueDate })
                        .eq('id', assignment.id);
                }

                return newAssignments;
            } catch (error) {
                console.error('Error saving assignments:', error);
                throw error;
            }
        }

        async function saveSubmissionToDatabase(testId, answers, autoScore, status) {
            if (!supabaseClient || !authReady) return null;

            try {
                // Get test assignment ID
                const { data: assignments } = await supabaseClient
                    .from('test_assignments')
                    .select('id')
                    .eq('test_id', testId)
                    .limit(1);

                const testAssignmentId = assignments?.[0]?.id || null;

                // Calculate max possible score
                const test = testsDatabase.find(t => t.id === testId);
                const maxScore = test ? test.questions.reduce((sum, q) => sum + (q.maxPoints || 1), 0) : 100;

                // Check for existing submission
                const { data: existing } = await supabaseClient
                    .from('test_submissions')
                    .select('id, attempt_number')
                    .eq('test_id', testId)
                    .eq('student_id', currentUser.id)
                    .order('attempt_number', { ascending: false })
                    .limit(1);

                const attemptNumber = existing?.[0] ? existing[0].attempt_number + 1 : 1;

                const { data: submission, error } = await supabaseClient
                    .from('test_submissions')
                    .insert({
                        test_id: testId,
                        student_id: currentUser.id,
                        test_assignment_id: testAssignmentId,
                        answers: answers,
                        auto_score: autoScore,
                        final_score: status === 'graded' ? autoScore : null,
                        max_possible_score: maxScore,
                        status: status === 'graded' ? 'graded' : 'submitted',
                        submitted_at: new Date().toISOString(),
                        attempt_number: attemptNumber
                    })
                    .select()
                    .single();

                if (error) throw error;

                // Auto-grade MC questions
                if (test) {
                    const mcGrades = [];
                    test.questions.forEach(q => {
                        if (q.type === 'multiple-choice') {
                            const isCorrect = answers[q.id] === q.correctAnswer;
                            mcGrades.push({
                                submission_id: submission.id,
                                question_id: q.id,
                                points_earned: isCorrect ? (q.maxPoints || 1) : 0,
                                is_correct: isCorrect,
                                graded_at: new Date().toISOString()
                            });
                        }
                    });

                    if (mcGrades.length > 0) {
                        await supabaseClient.from('test_question_grades').insert(mcGrades);
                    }
                }

                // Notify portal
                if (isEmbedded) {
                    window.parent.postMessage({
                        type: 'TEST_SUBMISSION_COMPLETE',
                        payload: {
                            testId: testId,
                            submissionId: submission.id,
                            studentId: currentUser.id,
                            score: autoScore,
                            maxScore: maxScore,
                            testAssignmentId: testAssignmentId
                        }
                    }, '*');
                }

                return submission;
            } catch (error) {
                console.error('Error saving submission:', error);
                throw error;
            }
        }

        async function saveGradesToDatabase(submissionId, questionGrades, finalScore) {
            if (!supabaseClient || !authReady) return;

            try {
                // Update question grades
                for (const [questionId, grade] of Object.entries(questionGrades)) {
                    await supabaseClient
                        .from('test_question_grades')
                        .upsert({
                            submission_id: submissionId,
                            question_id: questionId,
                            points_earned: grade.score,
                            feedback: grade.feedback,
                            graded_by: currentUser.id,
                            graded_at: new Date().toISOString()
                        }, {
                            onConflict: 'submission_id,question_id'
                        });
                }

                // Get submission details for max score
                const { data: submission } = await supabaseClient
                    .from('test_submissions')
                    .select('max_possible_score, linked_submission_id')
                    .eq('id', submissionId)
                    .single();

                // Update submission with final score
                await supabaseClient
                    .from('test_submissions')
                    .update({
                        final_score: finalScore,
                        status: 'graded',
                        graded_at: new Date().toISOString(),
                        graded_by: currentUser.id
                    })
                    .eq('id', submissionId);

                // Notify portal
                if (isEmbedded) {
                    window.parent.postMessage({
                        type: 'TEST_GRADED',
                        payload: {
                            submissionId: submissionId,
                            finalScore: finalScore,
                            maxScore: submission?.max_possible_score || 100,
                            linkedSubmissionId: submission?.linked_submission_id
                        }
                    }, '*');
                }
            } catch (error) {
                console.error('Error saving grades:', error);
                throw error;
            }
        }

        // ==================== HELPER FUNCTIONS ====================
        function isStudentAssignedToTest(studentId, test) {
            // For authenticated students, RLS already filters to only assigned tests
            // So if the test was loaded from the database, the student can access it
            if (authReady && currentRole === 'student') {
                return true; // RLS did the filtering
            }

            // For teachers previewing or standalone mode, check assignments
            // Check if directly assigned
            if (test.assignedStudents && test.assignedStudents.includes(studentId)) return true;

            // Check class assignments - students in classesDatabase have id property
            for (const classId of (test.assignedClasses || [])) {
                const classObj = classesDatabase.find(c => c.id === classId);
                if (classObj && classObj.students) {
                    // Students can be objects with id, or just IDs
                    const studentIds = classObj.students.map(s => typeof s === 'object' ? s.id : s);
                    if (studentIds.includes(studentId)) return true;
                }
            }
            return false;
        }

        function getAssignedStudents(test) {
            const studentIds = new Set(test.assignedStudents || []);
            for (const classId of (test.assignedClasses || [])) {
                const classObj = classesDatabase.find(c => c.id === classId);
                if (classObj && classObj.students) {
                    classObj.students.forEach(s => {
                        const id = typeof s === 'object' ? s.id : s;
                        studentIds.add(id);
                    });
                }
            }
            return Array.from(studentIds);
        }

        function getStudentName(studentId) {
            // Check studentsDatabase first
            const student = studentsDatabase.find(s => s.id === studentId);
            if (student) return student.name;

            // Check in classes
            for (const classObj of classesDatabase) {
                if (classObj.students) {
                    const found = classObj.students.find(s =>
                        (typeof s === 'object' ? s.id : s) === studentId
                    );
                    if (found && typeof found === 'object') return found.name;
                }
            }
            return 'Unknown';
        }

        function getSubmission(testId, studentId) {
            return submissionsDatabase[`${testId}_${studentId}`];
        }

        // ==================== ROLE & UI UPDATE ====================
        function switchRole(role) {
            currentRole = role;

            const avatar = document.getElementById('userAvatar');
            const userName = document.getElementById('userName');
            const userRoleEl = document.getElementById('userRole');

            // Update user display
            const initials = currentUser.firstName && currentUser.lastName
                ? `${currentUser.firstName[0]}${currentUser.lastName[0]}`
                : '--';
            const fullName = currentUser.firstName && currentUser.lastName
                ? `${currentUser.firstName} ${currentUser.lastName}`
                : 'User';

            avatar.textContent = initials;
            avatar.className = role === 'teacher' ? 'avatar teacher' : 'avatar student';
            userName.textContent = fullName;

            if (role === 'teacher') {
                userRoleEl.textContent = currentUser.userType === 'admin' ? 'Admin' : 'Teacher';
            } else {
                userRoleEl.textContent = 'Student';
            }

            // Show appropriate dashboard
            document.getElementById('teacherDashboard').style.display = role === 'teacher' ? 'block' : 'none';
            document.getElementById('studentDashboard').style.display = role === 'student' ? 'block' : 'none';
            document.getElementById('testTakingView').style.display = 'none';
            document.getElementById('resultsView').style.display = 'none';

            renderTests();
        }

        // ==================== RENDERING ====================
        function renderTests() {
            if (currentRole === 'teacher') {
                renderTeacherTests();
            } else {
                renderStudentTests();
            }
            updateStats();
        }

        function renderTeacherTests() {
            const grid = document.getElementById('teacherTestsGrid');
            if (testsDatabase.length === 0) {
                grid.innerHTML = `<div class="empty-state" style="grid-column: 1 / -1;"><div class="empty-icon">📝</div><h3>No tests yet</h3><p>Create your first test to get started</p></div>`;
                return;
            }

            grid.innerHTML = testsDatabase.map((test, index) => {
                const assignedCount = getAssignedStudents(test).length;
                const submissionCount = Object.keys(submissionsDatabase).filter(k => k.startsWith(`${test.id}_`)).length;
                const pendingCount = Object.values(submissionsDatabase).filter(s => s.testId === test.id && s.status === 'pending_review').length;

                return `
                    <div class="test-card fade-in" style="animation-delay: ${index * 0.1}s">
                        <div class="test-card-header">
                            <div>
                                <h3 class="test-title">${test.title}</h3>
                                <div class="test-subject">${test.subject}</div>
                            </div>
                            <span class="test-status status-${test.status}">${test.status}</span>
                        </div>
                        <div class="test-meta">
                            <span>📝 ${test.questions.length} questions</span>
                            <span>⏱️ ${test.timeLimit} min</span>
                            <span>👥 ${assignedCount} assigned</span>
                            <span>📊 ${submissionCount} submitted</span>
                            ${pendingCount > 0 ? `<span style="color: var(--accent-warning);">⏳ ${pendingCount} pending</span>` : ''}
                        </div>
                        <div class="test-actions">
                            <button class="btn btn-secondary btn-sm" onclick="editTest('${test.id}')">Edit</button>
                            <button class="btn btn-secondary btn-sm" onclick="openAssignModal('${test.id}')">Assign</button>
                            ${submissionCount > 0 ? `<button class="btn btn-warning btn-sm" onclick="viewSubmissions('${test.id}')">Grade (${pendingCount})</button>` : ''}
                            ${submissionCount > 0 ? `<button class="btn btn-info btn-sm" onclick="viewAnalytics('${test.id}')">Analytics</button>` : ''}
                            <button class="btn btn-danger btn-sm" onclick="deleteTest('${test.id}')">Delete</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderStudentTests() {
            const grid = document.getElementById('studentTestsGrid');
            const assignedTests = testsDatabase.filter(t => 
                t.status === 'active' && isStudentAssignedToTest(currentStudentId, t)
            );

            if (assignedTests.length === 0) {
                grid.innerHTML = `<div class="empty-state" style="grid-column: 1 / -1;"><div class="empty-icon">✨</div><h3>No tests available</h3><p>You're all caught up! Check back later for new assignments.</p></div>`;
                return;
            }

            grid.innerHTML = assignedTests.map((test, index) => {
                const submission = getSubmission(test.id, currentStudentId);
                let statusClass = 'status-pending';
                let statusText = 'Pending';
                let scoreDisplay = '';

                if (submission) {
                    if (submission.status === 'graded') {
                        statusClass = 'status-graded';
                        statusText = 'Graded';
                        scoreDisplay = `<span>🎯 ${submission.finalScore}%</span>`;
                    } else {
                        statusClass = 'status-completed';
                        statusText = 'Submitted';
                        scoreDisplay = `<span>⏳ Awaiting grade</span>`;
                    }
                }

                return `
                    <div class="test-card fade-in" style="animation-delay: ${index * 0.1}s">
                        <div class="test-card-header">
                            <div>
                                <h3 class="test-title">${test.title}</h3>
                                <div class="test-subject">${test.subject}</div>
                            </div>
                            <span class="test-status ${statusClass}">${statusText}</span>
                        </div>
                        <div class="test-meta">
                            <span>📝 ${test.questions.length} questions</span>
                            <span>⏱️ ${test.timeLimit} min</span>
                            ${scoreDisplay}
                        </div>
                        <div class="test-actions">
                            ${submission ?
                                `<button class="btn btn-secondary btn-sm" onclick="viewStudentResults('${test.id}')">View Results</button>` :
                                `<button class="btn btn-primary btn-sm" onclick="startTest('${test.id}')">Start Test</button>`
                            }
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateStats() {
            document.getElementById('totalTests').textContent = testsDatabase.length;
            document.getElementById('activeTests').textContent = testsDatabase.filter(t => t.status === 'active').length;
            document.getElementById('pendingReviews').textContent = Object.values(submissionsDatabase).filter(s => s.status === 'pending_review').length;
            document.getElementById('totalStudents').textContent = studentsDatabase.length;

            const assignedTests = testsDatabase.filter(t => t.status === 'active' && isStudentAssignedToTest(currentStudentId, t));
            const completedTests = assignedTests.filter(t => getSubmission(t.id, currentStudentId));
            document.getElementById('pendingTests').textContent = assignedTests.length - completedTests.length;
            document.getElementById('completedTests').textContent = completedTests.length;

            const gradedSubmissions = completedTests.filter(t => {
                const sub = getSubmission(t.id, currentStudentId);
                return sub && sub.status === 'graded';
            });
            if (gradedSubmissions.length > 0) {
                const avg = Math.round(gradedSubmissions.reduce((sum, t) => sum + getSubmission(t.id, currentStudentId).finalScore, 0) / gradedSubmissions.length);
                document.getElementById('avgScore').textContent = avg + '%';
            } else {
                document.getElementById('avgScore').textContent = '--';
            }
        }

        // ==================== MODAL FUNCTIONS ====================
        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        function openCreateModal() {
            editingTestId = null;
            editingTestHasSubmissions = false;
            originalQuestionIds = [];
            document.getElementById('modalTitle').textContent = 'Create New Test';
            document.getElementById('testForm').reset();
            document.getElementById('questionsBuilder').innerHTML = '';
            addQuestion();
            document.getElementById('testModal').classList.add('active');
        }

        async function editTest(testId) {
            const test = testsDatabase.find(t => t.id === testId);
            if (!test) return;

            // Check if test has submissions
            editingTestHasSubmissions = await testHasSubmissions(testId);
            originalQuestionIds = test.questions.map(q => q.id);

            // Show warning if test has submissions
            if (editingTestHasSubmissions) {
                const proceed = confirm(
                    '⚠️ This test has student submissions.\n\n' +
                    'Editing limitations:\n' +
                    '• You can modify question text and point values\n' +
                    '• You can change correct answers for multiple choice\n' +
                    '• You can add NEW questions at the end\n' +
                    '• You CANNOT delete or reorder existing questions\n' +
                    '• You CANNOT change question types\n\n' +
                    'These restrictions prevent breaking existing student answers.\n\n' +
                    'Do you want to continue editing?'
                );
                if (!proceed) return;
            }

            editingTestId = testId;
            document.getElementById('modalTitle').textContent = editingTestHasSubmissions
                ? 'Edit Test (Limited - Has Submissions)'
                : 'Edit Test';
            document.getElementById('testTitle').value = test.title;
            document.getElementById('testSubject').value = test.subject;
            document.getElementById('testTime').value = test.timeLimit;
            document.getElementById('testStatus').value = test.status;
            document.getElementById('testDescription').value = test.description;

            document.getElementById('questionsBuilder').innerHTML = '';
            test.questions.forEach((q, idx) => addQuestion(q, editingTestHasSubmissions, idx));

            document.getElementById('testModal').classList.add('active');
        }

        // ==================== ASSIGN MODAL ====================
        function openAssignModal(testId) {
            assigningTestId = testId;
            const test = testsDatabase.find(t => t.id === testId);
            document.getElementById('assignTestTitle').textContent = test.title;

            // Request classes from portal if embedded and classes not loaded
            if (isEmbedded && classesDatabase.length === 0) {
                window.parent.postMessage({ type: 'TESTING_CENTER_REQUEST_CLASSES' }, '*');
            }

            populateAssignModal();
            document.getElementById('assignModal').classList.add('active');
        }

        function populateAssignModal() {
            const test = testsDatabase.find(t => t.id === assigningTestId);
            if (!test) return;

            // Populate class checkboxes
            const classCheckboxes = document.getElementById('classCheckboxes');
            if (classesDatabase.length === 0) {
                classCheckboxes.innerHTML = '<p style="color: var(--text-muted);">Loading classes...</p>';
            } else {
                // Pre-check classes that are already assigned
                const assignedClassIds = test.assignedClasses || [];
                classCheckboxes.innerHTML = classesDatabase.map(c => {
                    const studentCount = c.students ? c.students.length : 0;
                    const isChecked = assignedClassIds.includes(c.id);
                    return `
                        <label class="checkbox-item ${isChecked ? 'checked' : ''}">
                            <input type="checkbox" value="${c.id}" ${isChecked ? 'checked' : ''} onchange="updateCheckboxStyle(this)">
                            ${c.name} (${studentCount} students)
                        </label>
                    `;
                }).join('');
            }

            // Reset due date
            document.getElementById('assignDueDate').value = '';
        }

        function updateCheckboxStyle(checkbox) {
            const label = checkbox.closest('.checkbox-item');
            if (label) {
                label.classList.toggle('checked', checkbox.checked);
            }
        }

        async function saveAssignments() {
            const test = testsDatabase.find(t => t.id === assigningTestId);
            if (!test) return;

            // Get selected classes (multiple)
            const selectedClassIds = Array.from(document.querySelectorAll('#classCheckboxes input:checked')).map(cb => cb.value);
            if (selectedClassIds.length === 0) {
                showToast('Please select at least one class');
                return;
            }

            // Get due date - default to end of today if not provided
            const dueDateInput = document.getElementById('assignDueDate');
            let dueDate;
            if (dueDateInput?.value) {
                dueDate = new Date(dueDateInput.value).toISOString();
            } else {
                // Default to end of today (11:59 PM)
                const today = new Date();
                today.setHours(23, 59, 59, 999);
                dueDate = today.toISOString();
            }

            try {
                // Save to database if authenticated
                if (authReady && supabaseClient) {
                    await saveAssignmentsToDatabase(assigningTestId, selectedClassIds, dueDate);

                    // Also update test status to active
                    await supabaseClient
                        .from('tests')
                        .update({ status: 'active', published_at: new Date().toISOString() })
                        .eq('id', assigningTestId);
                }

                // Update local data
                test.assignedClasses = selectedClassIds;
                test.assignedStudents = [];
                test.status = 'active';

                closeModal('assignModal');
                renderTests();
                showToast(`Test assigned to ${selectedClassIds.length} class(es) successfully!`);
            } catch (error) {
                console.error('Error saving assignments:', error);
                showToast('Error assigning test: ' + error.message);
            }
        }

        // ==================== SUBMISSIONS & GRADING ====================
        let currentViewTestId = null;
        let currentViewClassId = null;
        let viewSubmissionsData = { classes: [], studentsByClass: {}, studentProfiles: {} };

        async function viewSubmissions(testId) {
            currentViewTestId = testId;
            const test = testsDatabase.find(t => t.id === testId);
            document.getElementById('submissionsTestTitle').textContent = test.title;
            document.getElementById('submissionsClassSelector').innerHTML = '';
            document.getElementById('submissionsList').innerHTML = '<p style="text-align: center; padding: 20px;">Loading...</p>';
            document.getElementById('submissionsModal').classList.add('active');

            try {
                // Refresh submissions for this test
                const { data: freshSubmissions, error: subError } = await supabaseClient
                    .from('test_submissions')
                    .select('*, test_question_grades (*)')
                    .eq('test_id', testId);

                if (!subError && freshSubmissions) {
                    freshSubmissions.forEach(s => {
                        const key = `${s.test_id}_${s.student_id}`;
                        const gradedAnswers = {};
                        (s.test_question_grades || []).forEach(g => {
                            gradedAnswers[g.question_id] = {
                                score: g.points_earned,
                                maxScore: 10,
                                feedback: g.feedback
                            };
                        });

                        submissionsDatabase[key] = {
                            id: s.id,
                            testId: s.test_id,
                            studentId: s.student_id,
                            answers: s.answers || {},
                            autoScore: s.auto_score,
                            finalScore: s.final_score,
                            gradedAnswers: gradedAnswers,
                            submittedAt: s.submitted_at,
                            status: s.status === 'graded' ? 'graded' : 'pending_review',
                            linkedSubmissionId: s.linked_submission_id,
                            testAssignmentId: s.test_assignment_id
                        };
                    });
                }

                // Get all assigned classes with their names
                const { data: assignments, error: assignError } = await supabaseClient
                    .from('test_assignments')
                    .select('class_id')
                    .eq('test_id', testId)
                    .eq('is_active', true);

                if (assignError) throw assignError;

                const classIds = [...new Set(assignments.filter(a => a.class_id).map(a => a.class_id))];

                // Load class names
                let classesData = [];
                if (classIds.length > 0) {
                    const { data: classes, error: classError } = await supabaseClient
                        .from('classes')
                        .select('id, name')
                        .in('id', classIds);

                    if (!classError && classes) {
                        classesData = classes;
                    }
                }

                // Load enrollments for each class
                const studentsByClass = {};
                for (const classId of classIds) {
                    const { data: enrollments } = await supabaseClient
                        .from('class_enrollments')
                        .select('student_id')
                        .eq('class_id', classId)
                        .eq('status', 'active');

                    studentsByClass[classId] = enrollments ? enrollments.map(e => e.student_id) : [];
                }

                // Also add students who submitted but might not be in enrollments we can see
                if (freshSubmissions) {
                    // Group submissions by which class they belong to
                    for (const sub of freshSubmissions) {
                        // Find which class this student is in by checking enrollments
                        const { data: studentEnrollments } = await supabaseClient
                            .from('class_enrollments')
                            .select('class_id')
                            .eq('student_id', sub.student_id)
                            .in('class_id', classIds)
                            .eq('status', 'active')
                            .limit(1);

                        if (studentEnrollments && studentEnrollments.length > 0) {
                            const classId = studentEnrollments[0].class_id;
                            if (!studentsByClass[classId]) studentsByClass[classId] = [];
                            if (!studentsByClass[classId].includes(sub.student_id)) {
                                studentsByClass[classId].push(sub.student_id);
                            }
                        }
                    }
                }

                // Load all student profiles
                const allStudentIds = [...new Set(Object.values(studentsByClass).flat())];
                let studentProfiles = {};

                if (allStudentIds.length > 0) {
                    const { data: profiles } = await supabaseClient
                        .from('user_profiles')
                        .select('id, first_name, last_name')
                        .in('id', allStudentIds);

                    if (profiles) {
                        profiles.forEach(p => {
                            studentProfiles[p.id] = `${p.first_name} ${p.last_name}`;
                        });
                    }
                }

                // Store data for rendering
                viewSubmissionsData = { classes: classesData, studentsByClass, studentProfiles };

                // Build class selector
                if (classesData.length > 1) {
                    const selectorHtml = `
                        <label style="font-weight: 500; margin-right: 10px;">Select Class:</label>
                        <select id="submissionsClassSelect" class="form-input" style="width: auto; display: inline-block;" onchange="renderSubmissionsForClass(this.value)">
                            ${classesData.map(c => `<option value="${c.id}">${c.name}</option>`).join('')}
                        </select>
                    `;
                    document.getElementById('submissionsClassSelector').innerHTML = selectorHtml;
                    currentViewClassId = classesData[0].id;
                } else if (classesData.length === 1) {
                    document.getElementById('submissionsClassSelector').innerHTML = `<p style="color: var(--text-muted);">Class: <strong>${classesData[0].name}</strong></p>`;
                    currentViewClassId = classesData[0].id;
                } else {
                    currentViewClassId = null;
                }

                // Render submissions for first class
                renderSubmissionsForClass(currentViewClassId);

            } catch (error) {
                console.error('Error loading submissions:', error);
                document.getElementById('submissionsList').innerHTML = '<p style="color: var(--accent-danger); text-align: center;">Error loading student data</p>';
            }
        }

        function renderSubmissionsForClass(classId) {
            currentViewClassId = classId;
            const { studentsByClass, studentProfiles } = viewSubmissionsData;

            const studentIds = classId ? (studentsByClass[classId] || []) : [];

            let html = `<table class="submissions-table">
                <thead><tr><th>Student</th><th>Status</th><th>Auto Score</th><th>Final Score</th><th>Submitted</th><th>Actions</th></tr></thead>
                <tbody>`;

            // Sort students by name
            const sortedStudentIds = [...studentIds].sort((a, b) => {
                const nameA = studentProfiles[a] || 'Unknown';
                const nameB = studentProfiles[b] || 'Unknown';
                return nameA.localeCompare(nameB);
            });

            sortedStudentIds.forEach(studentId => {
                const studentName = studentProfiles[studentId] || 'Unknown';
                const submission = getSubmission(currentViewTestId, studentId);

                if (submission) {
                    html += `<tr>
                        <td>${studentName}</td>
                        <td><span class="test-status status-${submission.status === 'graded' ? 'graded' : 'pending'}">${submission.status === 'graded' ? 'Graded' : 'Pending Review'}</span></td>
                        <td>${submission.autoScore}%</td>
                        <td>${submission.finalScore !== null ? submission.finalScore + '%' : '--'}</td>
                        <td>${new Date(submission.submittedAt).toLocaleDateString()}</td>
                        <td><button class="btn btn-primary btn-sm" onclick="openGradeModal('${currentViewTestId}', '${studentId}')">Grade</button></td>
                    </tr>`;
                } else {
                    html += `<tr>
                        <td>${studentName}</td>
                        <td><span class="test-status status-draft">Not Submitted</span></td>
                        <td>--</td><td>--</td><td>--</td><td>--</td>
                    </tr>`;
                }
            });

            if (sortedStudentIds.length === 0) {
                html += '<tr><td colspan="6" style="text-align: center;">No students in this class</td></tr>';
            }

            html += '</tbody></table>';
            document.getElementById('submissionsList').innerHTML = html;
        }

        function openGradeModal(testId, studentId) {
            gradingSubmissionKey = `${testId}_${studentId}`;
            const submission = submissionsDatabase[gradingSubmissionKey];
            const test = testsDatabase.find(t => t.id === testId);
            // Try viewSubmissionsData first, then fall back to studentsDatabase
            const studentName = viewSubmissionsData.studentProfiles[studentId] ||
                (studentsDatabase.find(s => s.id === studentId) || {}).name || 'Unknown Student';

            let html = `<h3 style="margin-bottom: 20px;">${studentName}'s Submission</h3>`;

            test.questions.forEach((q, i) => {
                const answer = submission.answers[q.id];
                const graded = submission.gradedAnswers[q.id] || {};

                html += `<div class="question-card">
                    <div class="question-header" style="margin-bottom: 12px;">
                        <span class="question-number">Question ${i + 1}</span>
                        <span class="question-type-badge">${q.type === 'multiple-choice' ? 'Multiple Choice' : 'Written Response'}</span>
                    </div>
                    <p class="question-text">${q.text}</p>`;

                if (q.type === 'multiple-choice') {
                    const isCorrect = answer === q.correctAnswer;
                    html += `<div style="margin-top: 12px;">`;
                    q.options.forEach((opt, j) => {
                        let cls = '';
                        if (j === q.correctAnswer) cls = 'correct';
                        else if (j === answer && !isCorrect) cls = 'incorrect';
                        html += `<div class="option-item ${cls}" style="cursor: default;">
                            <span class="option-marker">${String.fromCharCode(65 + j)}</span>
                            <span class="option-text">${opt}</span>
                            ${j === q.correctAnswer ? '<span style="margin-left:auto; color: var(--accent-success);">✓ Correct</span>' : ''}
                            ${j === answer && j !== q.correctAnswer ? '<span style="margin-left:auto; color: var(--accent-danger);">✗ Student\'s answer</span>' : ''}
                        </div>`;
                    });
                    html += `</div>`;
                } else {
                    html += `<div style="background: var(--bg-tertiary); padding: 16px; border-radius: 10px; margin: 12px 0;">
                        <div style="font-size: 12px; color: var(--text-muted); margin-bottom: 8px;">Student's Answer:</div>
                        <div style="white-space: pre-wrap;">${answer || '<em style="color: var(--text-muted);">No answer provided</em>'}</div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 16px; margin-top: 12px;">
                        <label style="font-size: 13px; color: var(--text-secondary);">Score:</label>
                        <input type="number" class="grade-input" id="grade-${q.id}" value="${graded.score ?? ''}" min="0" max="10" placeholder="0-10"> / 10
                    </div>
                    <textarea class="feedback-input" id="feedback-${q.id}" placeholder="Feedback for student...">${graded.feedback || ''}</textarea>`;
                }
                html += `</div>`;
            });

            document.getElementById('gradeModalBody').innerHTML = html;
            closeModal('submissionsModal');
            document.getElementById('gradeModal').classList.add('active');
        }

        async function saveGrades() {
            const submission = submissionsDatabase[gradingSubmissionKey];
            if (!submission) {
                showToast('Submission not found');
                return;
            }

            const test = testsDatabase.find(t => t.id === submission.testId);
            if (!test) {
                showToast('Test not found');
                return;
            }

            let totalWriteIn = 0, writeInScore = 0;
            const questionGrades = {};

            // Count question types
            const mcCount = test.questions.filter(q => q.type === 'multiple-choice').length;
            const writeInCount = test.questions.filter(q => q.type === 'write-in').length;

            // Collect write-in scores from the grading form
            test.questions.forEach(q => {
                if (q.type === 'write-in') {
                    const maxPoints = q.maxPoints || 1;
                    totalWriteIn += maxPoints;
                    const scoreInput = document.getElementById(`grade-${q.id}`);
                    const feedbackInput = document.getElementById(`feedback-${q.id}`);
                    const score = parseInt(scoreInput?.value) || 0;
                    writeInScore += score;

                    const gradeData = {
                        score,
                        maxScore: maxPoints,
                        feedback: feedbackInput?.value || ''
                    };

                    submission.gradedAnswers[q.id] = gradeData;
                    questionGrades[q.id] = gradeData;
                }
            });

            // Use the stored auto_score for MC (calculated correctly at submission time)
            // Don't recalculate - the question IDs/answers may have changed
            const mcWeight = submission.autoScore || 0;
            const writeInWeight = totalWriteIn > 0 ? (writeInScore / totalWriteIn) * 100 : 0;
            const total = mcCount + writeInCount;

            // Weighted average: MC questions weighted by count, write-in weighted by count
            const finalScore = Math.round((mcWeight * mcCount + writeInWeight * writeInCount) / total);
            submission.finalScore = finalScore;
            submission.status = 'graded';

            try {
                // Save to database if authenticated
                if (authReady && supabaseClient && submission.id) {
                    await saveGradesToDatabase(submission.id, questionGrades, finalScore);
                }

                closeModal('gradeModal');
                renderTests();
                showToast('Grades saved successfully!');

                // Reopen submissions modal with updated data
                if (currentViewTestId) {
                    await viewSubmissions(currentViewTestId);
                    // Restore the class selection
                    if (currentViewClassId) {
                        const selector = document.getElementById('submissionsClassSelect');
                        if (selector) {
                            selector.value = currentViewClassId;
                        }
                        renderSubmissionsForClass(currentViewClassId);
                    }
                }
            } catch (error) {
                console.error('Error saving grades:', error);
                showToast('Error saving grades');
            }
        }

        // ==================== ANALYTICS ====================
        let analyticsTestId = null;
        let analyticsClassId = null;
        let analyticsData = { classes: [], submissions: [], test: null };

        async function viewAnalytics(testId) {
            analyticsTestId = testId;
            const test = testsDatabase.find(t => t.id === testId);
            document.getElementById('analyticsTestTitle').textContent = test.title;
            document.getElementById('analyticsClassSelector').innerHTML = '';
            document.getElementById('analyticsContent').innerHTML = '<p style="text-align: center; padding: 20px;">Loading analytics...</p>';
            document.getElementById('analyticsModal').classList.add('active');

            try {
                // Get all submissions for this test
                const { data: submissions, error: subError } = await supabaseClient
                    .from('test_submissions')
                    .select('*')
                    .eq('test_id', testId);

                if (subError) throw subError;

                // Get assigned classes
                const { data: assignments, error: assignError } = await supabaseClient
                    .from('test_assignments')
                    .select('class_id')
                    .eq('test_id', testId)
                    .eq('is_active', true);

                if (assignError) throw assignError;

                const classIds = [...new Set(assignments.filter(a => a.class_id).map(a => a.class_id))];

                // Get class names
                let classesData = [];
                if (classIds.length > 0) {
                    const { data: classes } = await supabaseClient
                        .from('classes')
                        .select('id, name')
                        .in('id', classIds);
                    classesData = classes || [];
                }

                // Get enrollments to map students to classes
                const studentClassMap = {};
                for (const classId of classIds) {
                    const { data: enrollments } = await supabaseClient
                        .from('class_enrollments')
                        .select('student_id')
                        .eq('class_id', classId)
                        .eq('status', 'active');

                    if (enrollments) {
                        enrollments.forEach(e => {
                            studentClassMap[e.student_id] = classId;
                        });
                    }
                }

                // Add class_id to submissions based on enrollment
                submissions.forEach(s => {
                    s.class_id = studentClassMap[s.student_id] || null;
                });

                analyticsData = { classes: classesData, submissions, test };

                // Build class selector
                if (classesData.length > 1) {
                    const selectorHtml = `
                        <label style="font-weight: 500; margin-right: 10px;">Select Class:</label>
                        <select id="analyticsClassSelect" class="form-input" style="width: auto; display: inline-block;" onchange="renderAnalytics(this.value)">
                            <option value="all">All Classes (${submissions.length} submissions)</option>
                            ${classesData.map(c => {
                                const count = submissions.filter(s => s.class_id === c.id).length;
                                return `<option value="${c.id}">${c.name} (${count} submissions)</option>`;
                            }).join('')}
                        </select>
                    `;
                    document.getElementById('analyticsClassSelector').innerHTML = selectorHtml;
                    analyticsClassId = 'all';
                } else if (classesData.length === 1) {
                    document.getElementById('analyticsClassSelector').innerHTML = `<p style="color: var(--text-muted);">Class: <strong>${classesData[0].name}</strong> (${submissions.length} submissions)</p>`;
                    analyticsClassId = classesData[0].id;
                }

                renderAnalytics(analyticsClassId || 'all');

            } catch (error) {
                console.error('Error loading analytics:', error);
                document.getElementById('analyticsContent').innerHTML = '<p style="color: var(--accent-danger); text-align: center;">Error loading analytics</p>';
            }
        }

        function renderAnalytics(classId) {
            analyticsClassId = classId;
            const { submissions, test } = analyticsData;

            // Filter submissions by class
            const filteredSubmissions = classId === 'all'
                ? submissions
                : submissions.filter(s => s.class_id === classId);

            if (filteredSubmissions.length === 0) {
                document.getElementById('analyticsContent').innerHTML = '<p style="text-align: center; color: var(--text-muted);">No submissions yet</p>';
                return;
            }

            // Calculate overall stats
            const scores = filteredSubmissions.map(s => s.final_score ?? s.auto_score ?? 0);
            const avgScore = Math.round(scores.reduce((a, b) => a + b, 0) / scores.length);
            const highScore = Math.max(...scores);
            const lowScore = Math.min(...scores);

            // Calculate per-question stats
            const questionStats = test.questions.map((q, idx) => {
                let correct = 0, incorrect = 0, skipped = 0;

                filteredSubmissions.forEach(sub => {
                    const answer = sub.answers?.[q.id];
                    if (answer === undefined || answer === null || answer === '') {
                        skipped++;
                    } else if (q.type === 'multiple-choice') {
                        if (answer === q.correctAnswer) correct++;
                        else incorrect++;
                    } else {
                        // Write-in - count as answered (can't auto-determine correctness)
                        correct++; // Count as "answered" for now
                    }
                });

                const total = filteredSubmissions.length;
                const correctPct = Math.round((correct / total) * 100);

                return {
                    number: idx + 1,
                    text: q.text,
                    type: q.type,
                    correct,
                    incorrect,
                    skipped,
                    correctPct
                };
            });

            // Sort by difficulty (lowest correct % first)
            const hardestQuestions = [...questionStats].sort((a, b) => a.correctPct - b.correctPct);

            // Score distribution
            const distribution = { '90-100': 0, '80-89': 0, '70-79': 0, '60-69': 0, '50-59': 0, 'Below 50': 0 };
            scores.forEach(s => {
                if (s >= 90) distribution['90-100']++;
                else if (s >= 80) distribution['80-89']++;
                else if (s >= 70) distribution['70-79']++;
                else if (s >= 60) distribution['60-69']++;
                else if (s >= 50) distribution['50-59']++;
                else distribution['Below 50']++;
            });

            let html = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 16px; margin-bottom: 24px;">
                    <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 12px; text-align: center;">
                        <div style="font-size: 28px; font-weight: 700; color: var(--accent-primary);">${avgScore}%</div>
                        <div style="font-size: 12px; color: var(--text-muted);">Class Average</div>
                    </div>
                    <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 12px; text-align: center;">
                        <div style="font-size: 28px; font-weight: 700; color: var(--accent-success);">${highScore}%</div>
                        <div style="font-size: 12px; color: var(--text-muted);">Highest Score</div>
                    </div>
                    <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 12px; text-align: center;">
                        <div style="font-size: 28px; font-weight: 700; color: var(--accent-danger);">${lowScore}%</div>
                        <div style="font-size: 12px; color: var(--text-muted);">Lowest Score</div>
                    </div>
                    <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 12px; text-align: center;">
                        <div style="font-size: 28px; font-weight: 700; color: var(--text-primary);">${filteredSubmissions.length}</div>
                        <div style="font-size: 12px; color: var(--text-muted);">Submissions</div>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px; margin-bottom: 24px;">
                    <div>
                        <h4 style="margin-bottom: 12px; color: var(--text-secondary);">Score Distribution</h4>
                        <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 12px;">
                            ${Object.entries(distribution).map(([range, count]) => {
                                const pct = Math.round((count / filteredSubmissions.length) * 100);
                                const color = range === '90-100' ? 'var(--accent-success)' :
                                              range === '80-89' ? '#34d399' :
                                              range === '70-79' ? 'var(--accent-warning)' :
                                              range === '60-69' ? '#f59e0b' :
                                              range === '50-59' ? '#f97316' : 'var(--accent-danger)';
                                return `
                                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                                        <span style="width: 70px; font-size: 12px; color: var(--text-muted);">${range}</span>
                                        <div style="flex: 1; height: 20px; background: var(--bg-secondary); border-radius: 4px; overflow: hidden; margin-right: 8px;">
                                            <div style="width: ${pct}%; height: 100%; background: ${color}; transition: width 0.3s;"></div>
                                        </div>
                                        <span style="width: 40px; font-size: 12px; color: var(--text-secondary);">${count}</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                    <div>
                        <h4 style="margin-bottom: 12px; color: var(--text-secondary);">Hardest Questions</h4>
                        <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 12px; max-height: 200px; overflow-y: auto;">
                            ${hardestQuestions.slice(0, 5).map(q => `
                                <div style="display: flex; align-items: center; margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid var(--border-color);">
                                    <span style="width: 30px; font-weight: 600; color: var(--text-primary);">Q${q.number}</span>
                                    <div style="flex: 1; font-size: 12px; color: var(--text-muted); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-right: 8px;">${q.text.substring(0, 40)}...</div>
                                    <span style="font-weight: 600; color: ${q.correctPct < 50 ? 'var(--accent-danger)' : q.correctPct < 70 ? 'var(--accent-warning)' : 'var(--accent-success)'};">${q.correctPct}%</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>

                <h4 style="margin-bottom: 12px; color: var(--text-secondary);">Question Breakdown</h4>
                <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 12px; max-height: 400px; overflow-y: auto;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="border-bottom: 2px solid var(--border-color);">
                                <th style="text-align: left; padding: 8px; font-size: 12px; color: var(--text-muted);">#</th>
                                <th style="text-align: left; padding: 8px; font-size: 12px; color: var(--text-muted);">Question</th>
                                <th style="text-align: center; padding: 8px; font-size: 12px; color: var(--text-muted);">Type</th>
                                <th style="text-align: center; padding: 8px; font-size: 12px; color: var(--text-muted);">Correct</th>
                                <th style="text-align: center; padding: 8px; font-size: 12px; color: var(--text-muted);">Incorrect</th>
                                <th style="text-align: center; padding: 8px; font-size: 12px; color: var(--text-muted);">Skipped</th>
                                <th style="text-align: center; padding: 8px; font-size: 12px; color: var(--text-muted);">Success Rate</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${questionStats.map(q => `
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 10px 8px; font-weight: 600;">${q.number}</td>
                                    <td style="padding: 10px 8px; font-size: 13px; max-width: 250px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${q.text}</td>
                                    <td style="padding: 10px 8px; text-align: center;"><span class="question-type-badge">${q.type === 'multiple-choice' ? 'MC' : 'Written'}</span></td>
                                    <td style="padding: 10px 8px; text-align: center; color: var(--accent-success);">${q.correct}</td>
                                    <td style="padding: 10px 8px; text-align: center; color: var(--accent-danger);">${q.incorrect}</td>
                                    <td style="padding: 10px 8px; text-align: center; color: var(--text-muted);">${q.skipped}</td>
                                    <td style="padding: 10px 8px; text-align: center;">
                                        <div style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                                            <div style="width: 60px; height: 8px; background: var(--bg-secondary); border-radius: 4px; overflow: hidden;">
                                                <div style="width: ${q.correctPct}%; height: 100%; background: ${q.correctPct < 50 ? 'var(--accent-danger)' : q.correctPct < 70 ? 'var(--accent-warning)' : 'var(--accent-success)'};"></div>
                                            </div>
                                            <span style="font-weight: 600; color: ${q.correctPct < 50 ? 'var(--accent-danger)' : q.correctPct < 70 ? 'var(--accent-warning)' : 'var(--accent-success)'};">${q.correctPct}%</span>
                                        </div>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;

            document.getElementById('analyticsContent').innerHTML = html;
        }

        // ==================== QUESTION BUILDER ====================
        let questionCounter = 0;

        function addQuestion(existingQuestion = null, isLocked = false, originalIndex = -1) {
            questionCounter++;
            const qId = questionCounter;
            const container = document.getElementById('questionsBuilder');

            // Store original question ID if editing existing question with submissions
            const originalQId = existingQuestion?.id || null;
            const isExistingLocked = isLocked && originalIndex >= 0;

            const questionHtml = `
                <div class="question-item" id="question-${qId}" data-original-id="${originalQId || ''}" data-locked="${isExistingLocked}">
                    <div class="question-header">
                        <span class="question-number">Question ${container.children.length + 1}</span>
                        ${isExistingLocked
                            ? '<span style="color: var(--accent-warning); font-size: 12px;">🔒 Locked (has submissions)</span>'
                            : `<button type="button" class="btn btn-danger btn-sm" onclick="removeQuestion(${qId})">Remove</button>`
                        }
                    </div>
                    <div style="display: flex; gap: 12px;">
                        <div class="form-group" style="flex: 1;">
                            <label class="form-label">Question Type</label>
                            <select class="form-select" id="qType-${qId}" onchange="toggleQuestionType(${qId})" ${isExistingLocked ? 'disabled' : ''}>
                                <option value="multiple-choice" ${existingQuestion?.type === 'multiple-choice' ? 'selected' : ''}>Multiple Choice</option>
                                <option value="write-in" ${existingQuestion?.type === 'write-in' ? 'selected' : ''}>Write-in Answer</option>
                            </select>
                        </div>
                        <div class="form-group" style="width: 100px;">
                            <label class="form-label">Points</label>
                            <input type="number" class="form-input" id="qPoints-${qId}" value="${existingQuestion?.maxPoints || 1}" min="1" max="100" style="text-align: center;">
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Question Text</label>
                        <textarea class="form-textarea" id="qText-${qId}" placeholder="Enter your question...">${existingQuestion?.text || ''}</textarea>
                    </div>
                    <div id="mcOptions-${qId}" style="${existingQuestion?.type === 'write-in' ? 'display:none' : ''}">
                        <div class="form-group">
                            <label class="form-label">Options (click to mark correct answer)${isExistingLocked ? ' - Cannot add/remove options' : ''}</label>
                            <div id="optionsList-${qId}">${renderOptions(qId, existingQuestion, isExistingLocked)}</div>
                        </div>
                    </div>
                </div>`;

            container.insertAdjacentHTML('beforeend', questionHtml);
        }

        function renderOptions(qId, existingQuestion, isLocked = false) {
            const options = existingQuestion?.options || ['', ''];
            const correctAnswer = existingQuestion?.correctAnswer ?? -1;

            let html = options.map((opt, i) => `
                <div class="option-item ${i === correctAnswer ? 'selected' : ''}" onclick="selectCorrectAnswer(${qId}, ${i})" data-option-index="${i}">
                    <span class="option-marker">${String.fromCharCode(65 + i)}</span>
                    <input type="text" class="form-input" id="opt-${qId}-${i}" value="${opt}" placeholder="Option ${String.fromCharCode(65 + i)}" onclick="event.stopPropagation()" style="flex:1; margin:0;">
                    ${!isLocked && options.length > 2 ? `<button type="button" class="btn btn-danger btn-sm" onclick="event.stopPropagation(); removeOption(${qId}, ${i})" style="padding: 4px 8px;">✕</button>` : ''}
                </div>
            `).join('');

            if (!isLocked) {
                html += `<button type="button" class="btn btn-secondary btn-sm" onclick="addOption(${qId})" style="margin-top: 8px;">+ Add Option</button>`;
            }
            return html;
        }

        function addOption(qId) {
            const optionsList = document.getElementById(`optionsList-${qId}`);
            const currentOptions = optionsList.querySelectorAll('.option-item');
            if (currentOptions.length >= 8) { alert('Maximum 8 options'); return; }

            const values = [];
            let correctIndex = -1;
            currentOptions.forEach((item, i) => {
                values.push(document.getElementById(`opt-${qId}-${i}`)?.value || '');
                if (item.classList.contains('selected')) correctIndex = i;
            });
            values.push('');
            optionsList.innerHTML = renderOptionsFromValues(qId, values, correctIndex);
        }

        function removeOption(qId, removeIndex) {
            const optionsList = document.getElementById(`optionsList-${qId}`);
            const currentOptions = optionsList.querySelectorAll('.option-item');
            if (currentOptions.length <= 2) { alert('Minimum 2 options required'); return; }

            const values = [];
            let correctIndex = -1;
            currentOptions.forEach((item, i) => {
                if (i !== removeIndex) {
                    values.push(document.getElementById(`opt-${qId}-${i}`)?.value || '');
                    if (item.classList.contains('selected')) correctIndex = values.length - 1;
                }
            });
            optionsList.innerHTML = renderOptionsFromValues(qId, values, correctIndex);
        }

        function renderOptionsFromValues(qId, options, correctAnswer) {
            let html = options.map((opt, i) => `
                <div class="option-item ${i === correctAnswer ? 'selected' : ''}" onclick="selectCorrectAnswer(${qId}, ${i})" data-option-index="${i}">
                    <span class="option-marker">${String.fromCharCode(65 + i)}</span>
                    <input type="text" class="form-input" id="opt-${qId}-${i}" value="${opt}" placeholder="Option ${String.fromCharCode(65 + i)}" onclick="event.stopPropagation()" style="flex:1; margin:0;">
                    ${options.length > 2 ? `<button type="button" class="btn btn-danger btn-sm" onclick="event.stopPropagation(); removeOption(${qId}, ${i})" style="padding: 4px 8px;">✕</button>` : ''}
                </div>
            `).join('');
            html += `<button type="button" class="btn btn-secondary btn-sm" onclick="addOption(${qId})" style="margin-top: 8px;">+ Add Option</button>`;
            return html;
        }

        function selectCorrectAnswer(qId, optIndex) {
            document.getElementById(`optionsList-${qId}`).querySelectorAll('.option-item').forEach((item, i) => {
                item.classList.toggle('selected', i === optIndex);
            });
        }

        function toggleQuestionType(qId) {
            document.getElementById(`mcOptions-${qId}`).style.display = document.getElementById(`qType-${qId}`).value === 'write-in' ? 'none' : 'block';
        }

        function removeQuestion(qId) {
            document.getElementById(`question-${qId}`)?.remove();
            document.querySelectorAll('#questionsBuilder .question-item').forEach((item, i) => {
                item.querySelector('.question-number').textContent = `Question ${i + 1}`;
            });
        }

        // ==================== SAVE TEST ====================
        async function saveTest() {
            const title = document.getElementById('testTitle').value.trim();
            const subject = document.getElementById('testSubject').value.trim();
            const timeLimit = parseInt(document.getElementById('testTime').value) || 30;
            const status = document.getElementById('testStatus').value;
            const description = document.getElementById('testDescription').value.trim();

            if (!title) { alert('Please enter a test title'); return; }

            const questions = [];
            const collectedOriginalIds = [];
            document.querySelectorAll('#questionsBuilder .question-item').forEach((item, index) => {
                const qId = item.id.replace('question-', '');
                const type = document.getElementById(`qType-${qId}`).value;
                const text = document.getElementById(`qText-${qId}`).value.trim();
                if (!text) return;

                const points = parseInt(document.getElementById(`qPoints-${qId}`).value) || 1;
                const originalId = item.getAttribute('data-original-id') || null;
                const question = { id: index + 1, type, text, maxPoints: points, originalId };
                if (type === 'multiple-choice') {
                    const optionItems = item.querySelectorAll('.option-item');
                    question.options = Array.from(optionItems).map((_, i) => document.getElementById(`opt-${qId}-${i}`)?.value || '');
                    const selectedOption = item.querySelector('.option-item.selected');
                    question.correctAnswer = selectedOption ? Array.from(optionItems).indexOf(selectedOption) : 0;
                } else {
                    question.correctAnswer = null;
                }
                questions.push(question);
                collectedOriginalIds.push(originalId);
            });

            if (questions.length === 0) { alert('Please add at least one question'); return; }

            try {
                // Save to database if authenticated
                if (authReady && supabaseClient) {
                    const testId = await saveTestToDatabase(
                        { id: editingTestId, title, subject, timeLimit, status, description, questions },
                        editingTestHasSubmissions,
                        collectedOriginalIds
                    );

                    // Reload tests to get fresh data with proper IDs
                    await loadTests();
                } else {
                    // Standalone mode - save to local array
                    if (editingTestId) {
                        const testIndex = testsDatabase.findIndex(t => t.id === editingTestId);
                        if (testIndex > -1) {
                            testsDatabase[testIndex] = { ...testsDatabase[testIndex], title, subject, timeLimit, status, description, questions };
                        }
                    } else {
                        testsDatabase.push({
                            id: 'test-' + Date.now(), title, subject, description, timeLimit, status,
                            createdAt: new Date().toISOString().split('T')[0],
                            questions, assignedClasses: [], assignedStudents: []
                        });
                    }
                }

                closeModal('testModal');
                renderTests();
                showToast(editingTestId ? 'Test updated!' : 'Test created!');
            } catch (error) {
                console.error('Error saving test:', error);
                showToast('Error saving test');
            }
        }

        async function deleteTest(testId) {
            if (!confirm('Delete this test?')) return;

            try {
                if (authReady && supabaseClient) {
                    await deleteTestFromDatabase(testId);
                }
                testsDatabase = testsDatabase.filter(t => t.id !== testId);
                renderTests();
                showToast('Test deleted');
            } catch (error) {
                console.error('Error deleting test:', error);
                showToast('Error deleting test');
            }
        }

        // ==================== TEST TAKING ====================
        function startTest(testId) {
            currentTestId = testId;
            currentQuestionIndex = 0;
            studentAnswers = {};

            const test = testsDatabase.find(t => t.id === testId);
            document.getElementById('studentDashboard').style.display = 'none';
            document.getElementById('testTakingView').style.display = 'block';
            document.getElementById('takingTestTitle').textContent = test.title;
            document.getElementById('takingTestSubject').textContent = test.subject;

            renderCurrentQuestion();
        }

        function renderCurrentQuestion() {
            const test = testsDatabase.find(t => t.id === currentTestId);
            const question = test.questions[currentQuestionIndex];
            const total = test.questions.length;

            document.getElementById('questionProgress').textContent = `Question ${currentQuestionIndex + 1} of ${total}`;
            document.getElementById('progressFill').style.width = `${((currentQuestionIndex + 1) / total) * 100}%`;

            let html = `<div class="question-card">
                <div class="question-header" style="margin-bottom: 16px;">
                    <span class="question-number">Question ${currentQuestionIndex + 1}</span>
                    <span class="question-type-badge">${question.type === 'multiple-choice' ? 'Multiple Choice' : 'Written Response'}</span>
                </div>
                <p class="question-text">${question.text}</p>`;

            if (question.type === 'multiple-choice') {
                html += `<div class="options-list">`;
                question.options.forEach((opt, i) => {
                    html += `<div class="option-item ${studentAnswers[question.id] === i ? 'selected' : ''}" onclick="selectAnswer('${question.id}', ${i})">
                        <span class="option-marker">${String.fromCharCode(65 + i)}</span>
                        <span class="option-text">${opt}</span>
                    </div>`;
                });
                html += `</div>`;
            } else {
                html += `<textarea class="write-in-input" id="writeAnswer-${question.id}" placeholder="Type your answer here..." onchange="saveWriteInAnswer('${question.id}')">${studentAnswers[question.id] || ''}</textarea>`;
            }

            html += `</div>`;
            document.getElementById('questionsContainer').innerHTML = html;

            document.getElementById('prevBtn').style.display = currentQuestionIndex === 0 ? 'none' : 'inline-flex';
            document.getElementById('nextBtn').style.display = currentQuestionIndex === total - 1 ? 'none' : 'inline-flex';
            document.getElementById('submitBtn').style.display = currentQuestionIndex === total - 1 ? 'inline-flex' : 'none';
        }

        function selectAnswer(questionId, optionIndex) {
            studentAnswers[questionId] = optionIndex;
            renderCurrentQuestion();
        }

        function saveWriteInAnswer(questionId) {
            const textarea = document.getElementById(`writeAnswer-${questionId}`);
            if (textarea) studentAnswers[questionId] = textarea.value;
        }

        function previousQuestion() { if (currentQuestionIndex > 0) { currentQuestionIndex--; renderCurrentQuestion(); } }
        function nextQuestion() {
            const test = testsDatabase.find(t => t.id === currentTestId);
            if (currentQuestionIndex < test.questions.length - 1) { currentQuestionIndex++; renderCurrentQuestion(); }
        }

        async function submitTest() {
            const test = testsDatabase.find(t => t.id === currentTestId);
            if (!test) {
                showToast('Test not found');
                return;
            }

            let correct = 0, mcTotal = 0;

            test.questions.forEach(q => {
                if (q.type === 'multiple-choice') {
                    mcTotal++;
                    if (studentAnswers[q.id] === q.correctAnswer) correct++;
                }
            });

            const autoScore = mcTotal > 0 ? Math.round((correct / mcTotal) * 100) : 0;
            const hasWriteIn = test.questions.some(q => q.type === 'write-in');
            const status = hasWriteIn ? 'pending_review' : 'graded';

            try {
                // Save to database if authenticated
                if (authReady && supabaseClient) {
                    const submission = await saveSubmissionToDatabase(
                        currentTestId,
                        { ...studentAnswers },
                        autoScore,
                        status
                    );

                    // Update local cache
                    submissionsDatabase[`${currentTestId}_${currentStudentId}`] = {
                        id: submission?.id,
                        testId: currentTestId,
                        studentId: currentStudentId,
                        answers: { ...studentAnswers },
                        autoScore,
                        finalScore: hasWriteIn ? null : autoScore,
                        gradedAnswers: {},
                        submittedAt: new Date().toISOString(),
                        status
                    };
                } else {
                    // Standalone mode
                    submissionsDatabase[`${currentTestId}_${currentStudentId}`] = {
                        testId: currentTestId,
                        studentId: currentStudentId,
                        answers: { ...studentAnswers },
                        autoScore,
                        finalScore: hasWriteIn ? null : autoScore,
                        gradedAnswers: {},
                        submittedAt: new Date().toISOString(),
                        status
                    };
                }

                showStudentResults(test, autoScore, correct, mcTotal, hasWriteIn);
            } catch (error) {
                console.error('Error submitting test:', error);
                showToast('Error submitting test');
            }
        }

        function showStudentResults(test, score, correct, total, pendingReview) {
            document.getElementById('testTakingView').style.display = 'none';
            document.getElementById('resultsView').style.display = 'block';

            document.getElementById('finalScore').textContent = pendingReview ? '--' : `${score}%`;
            document.querySelector('.score-circle').style.setProperty('--score-percent', `${pendingReview ? 0 : score}%`);
            document.getElementById('resultsSubtitle').innerHTML = pendingReview ? 
                'Your written responses are pending teacher review' :
                `You answered ${correct} out of ${total} multiple choice questions correctly`;

            let html = '';
            test.questions.forEach((q, i) => {
                const answer = studentAnswers[q.id];
                html += `<div class="question-card">
                    <div class="question-header" style="margin-bottom: 16px;">
                        <span class="question-number">Question ${i + 1}</span>
                        <span class="question-type-badge">${q.type === 'multiple-choice' ? 'Multiple Choice' : 'Written Response'}</span>
                    </div>
                    <p class="question-text">${q.text}</p>`;

                if (q.type === 'multiple-choice') {
                    html += `<div class="options-list">`;
                    q.options.forEach((opt, j) => {
                        const isCorrect = j === q.correctAnswer;
                        const isSelected = answer === j;
                        let cls = '';
                        if (isSelected && isCorrect) cls = 'correct';
                        else if (isSelected) cls = 'incorrect';
                        else if (isCorrect) cls = 'correct';

                        html += `<div class="option-item ${cls}">
                            <span class="option-marker">${String.fromCharCode(65 + j)}</span>
                            <span class="option-text">${opt}</span>
                            ${isCorrect ? '<span style="margin-left:auto; color: var(--accent-success);">✓ Correct</span>' : ''}
                            ${isSelected && !isCorrect ? '<span style="margin-left:auto; color: var(--accent-danger);">✗ Your answer</span>' : ''}
                        </div>`;
                    });
                    html += `</div>`;
                } else {
                    html += `<div style="background: var(--bg-tertiary); padding: 16px; border-radius: 10px; margin-top: 12px;">
                        <div style="font-size: 12px; color: var(--text-muted); margin-bottom: 8px;">Your Answer:</div>
                        <div style="white-space: pre-wrap;">${answer || '<em style="color: var(--text-muted);">No answer provided</em>'}</div>
                    </div>
                    <div style="font-size: 13px; color: var(--text-muted); margin-top: 12px;">⏳ Pending teacher review</div>`;
                }
                html += `</div>`;
            });

            document.getElementById('resultsDetails').innerHTML = html;
        }

        function viewStudentResults(testId) {
            const test = testsDatabase.find(t => t.id === testId);
            const submission = getSubmission(testId, currentStudentId);
            if (!submission) return;

            studentAnswers = submission.answers;
            currentTestId = testId;

            document.getElementById('studentDashboard').style.display = 'none';
            document.getElementById('resultsView').style.display = 'block';

            const isGraded = submission.status === 'graded';
            document.getElementById('finalScore').textContent = isGraded ? `${submission.finalScore}%` : '--';
            document.querySelector('.score-circle').style.setProperty('--score-percent', `${isGraded ? submission.finalScore : 0}%`);
            document.getElementById('resultsSubtitle').textContent = isGraded ? 'Your test has been graded' : 'Awaiting teacher review';

            let html = '';
            test.questions.forEach((q, i) => {
                const answer = submission.answers[q.id];
                const graded = submission.gradedAnswers[q.id];

                html += `<div class="question-card">
                    <div class="question-header" style="margin-bottom: 16px;">
                        <span class="question-number">Question ${i + 1}</span>
                        <span class="question-type-badge">${q.type === 'multiple-choice' ? 'Multiple Choice' : 'Written Response'}</span>
                    </div>
                    <p class="question-text">${q.text}</p>`;

                if (q.type === 'multiple-choice') {
                    html += `<div class="options-list">`;
                    q.options.forEach((opt, j) => {
                        const isCorrect = j === q.correctAnswer;
                        const isSelected = answer === j;
                        let cls = '';
                        if (isSelected && isCorrect) cls = 'correct';
                        else if (isSelected) cls = 'incorrect';
                        else if (isCorrect) cls = 'correct';

                        html += `<div class="option-item ${cls}">
                            <span class="option-marker">${String.fromCharCode(65 + j)}</span>
                            <span class="option-text">${opt}</span>
                            ${isCorrect ? '<span style="margin-left:auto; color: var(--accent-success);">✓ Correct</span>' : ''}
                            ${isSelected && !isCorrect ? '<span style="margin-left:auto; color: var(--accent-danger);">✗ Your answer</span>' : ''}
                        </div>`;
                    });
                    html += `</div>`;
                } else {
                    html += `<div style="background: var(--bg-tertiary); padding: 16px; border-radius: 10px; margin-top: 12px;">
                        <div style="font-size: 12px; color: var(--text-muted); margin-bottom: 8px;">Your Answer:</div>
                        <div style="white-space: pre-wrap;">${answer || '<em style="color: var(--text-muted);">No answer provided</em>'}</div>
                    </div>`;
                    if (graded) {
                        html += `<div style="background: rgba(99, 102, 241, 0.1); padding: 12px; border-radius: 8px; margin-top: 12px; border-left: 3px solid var(--accent-primary);">
                            <div style="font-weight: 600; margin-bottom: 4px;">Score: ${graded.score}/${graded.maxScore}</div>
                            ${graded.feedback ? `<div style="font-size: 13px; color: var(--text-secondary);">${graded.feedback}</div>` : ''}
                        </div>`;
                    } else {
                        html += `<div style="font-size: 13px; color: var(--text-muted); margin-top: 12px;">⏳ Pending teacher review</div>`;
                    }
                }
                html += `</div>`;
            });

            document.getElementById('resultsDetails').innerHTML = html;
        }

        function backToDashboard() {
            document.getElementById('resultsView').style.display = 'none';
            document.getElementById('testTakingView').style.display = 'none';
            document.getElementById(currentRole === 'teacher' ? 'teacherDashboard' : 'studentDashboard').style.display = 'block';
            currentTestId = null;
            studentAnswers = {};
        }

        // ==================== UTILITIES ====================
        function showToast(message) {
            const toast = document.getElementById('toast');
            document.getElementById('toastMessage').textContent = message;
            toast.classList.add('show', 'success');
            setTimeout(() => toast.classList.remove('show', 'success'), 3000);
        }

        // ==================== INIT ====================
        document.addEventListener('DOMContentLoaded', () => {
            if (isEmbedded) {
                // Running in iframe - wait for auth from parent portal
                console.log('Testing Center: Waiting for auth from parent portal...');

                // Show loading state
                document.getElementById('teacherDashboard').style.display = 'none';
                document.getElementById('studentDashboard').style.display = 'none';

                // Set a timeout to show error if auth doesn't arrive
                setTimeout(() => {
                    if (!authReady) {
                        console.warn('Testing Center: Auth timeout - no auth received from parent');
                        // Could show a message to the user here
                    }
                }, 10000);
            } else {
                // Standalone mode - show auth required message
                console.log('Testing Center: Running in standalone mode - auth required');
                initializeStandaloneMode();
            }
        });

        // Standalone mode - show error (must be accessed via portal)
        function initializeStandaloneMode() {
            document.querySelector('.main-content').innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 60vh; text-align: center;">
                    <div style="font-size: 64px; margin-bottom: 20px;">🔒</div>
                    <h2 style="margin-bottom: 10px; color: var(--text-primary);">Authentication Required</h2>
                    <p style="color: var(--text-secondary); max-width: 400px;">
                        The Testing Center must be accessed through the Student Portal.
                        Please log in to the portal and navigate to the Testing tab.
                    </p>
                </div>
            `;
            document.getElementById('userName').textContent = 'Not Authenticated';
            document.getElementById('userRole').textContent = '--';
        }
    </script>
</body>
</html>
