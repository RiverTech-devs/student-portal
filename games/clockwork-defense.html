<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clockwork Tower Defense</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@400;700&family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto Slab', serif;
            touch-action: none;
            /* Reverted to the default system cursor */
            cursor: auto;
        }
        canvas {
            background-color: #f0e6d2;
            border-radius: 0.5rem;
            border: 4px solid #4a3f35;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }
        /* Hide the cursor when placing a weapon, as the weapon itself acts as the cursor */
        canvas.placing-weapon {
            cursor: none;
        }
        .ui-panel {
            background-color: rgba(74, 63, 53, 0.85);
            backdrop-filter: blur(5px);
            border-bottom: 4px solid #4a3f35;
        }
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(5px);
        }
        /* New class for a prettier, unified modal style */
        .modal-box {
            background-color: #6b5a4b;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            border: 4px solid #4a3f35;
            text-align: center;
            width: 90%;
            max-width: 500px;
        }
        #puzzle-clock-canvas {
            border-radius: 50%;
            border: 3px solid #4a3f35;
        }
        #puzzle-clock-canvas.interactive {
            cursor: grab;
        }
        #puzzle-clock-canvas.interactive:active {
            cursor: grabbing;
        }
        .digital-font {
            font-family: 'Orbitron', sans-serif;
        }
        .btn-primary {
            @apply bg-yellow-600 hover:bg-yellow-700 text-black font-bold py-3 px-8 rounded transition-colors text-xl shadow-md;
        }
         .btn-secondary {
            @apply bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded transition-colors shadow-md;
        }
    </style>
</head>
<body class="bg-gray-800 flex flex-col items-center justify-center h-screen overflow-hidden">

    <!-- Game UI Panel -->
    <div id="ui-panel" class="ui-panel text-white p-2 w-full max-w-4xl flex justify-between items-center z-10 rounded-t-lg">
        <div class="flex items-center space-x-4">
            <div><span class="font-bold">Gold:</span> <span id="gold-display">100</span></div>
            <div><span class="font-bold">Time:</span> <span id="time-survived-display" class="digital-font">0</span></div>
        </div>
        <div class="flex items-center space-x-2">
             <button id="build-btn" class="bg-yellow-600 hover:bg-yellow-700 text-black font-bold py-2 px-6 rounded transition-colors text-lg">Build</button>
             <button id="pause-btn" class="btn-secondary py-2 px-4 text-lg">Pause</button>
        </div>
    </div>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- Start Screen Modal -->
    <div id="start-modal" class="modal-backdrop absolute inset-0 flex flex-col items-center justify-center text-white z-30">
        <div class="modal-box">
            <h1 class="text-5xl md:text-6xl font-bold mb-4" style="font-family: 'Roboto Slab', serif;">Clockwork Defense</h1>
            <p class="text-lg mb-8">Protect the Grand Clock Tower from the rogue mechanisms!</p>
            <div class="space-y-4">
                <button id="start-game-btn" class="btn-primary w-64">Start Game</button>
                <button id="tutorial-btn" class="btn-secondary w-64">Tutorial</button>
            </div>
        </div>
    </div>

    <!-- Tutorial Modal -->
    <div id="tutorial-modal" class="modal-backdrop hidden absolute inset-0 flex-col items-center justify-center text-white z-40">
        <div class="modal-box max-w-lg text-left">
            <h2 class="text-3xl font-bold mb-4 text-center">How to Play</h2>
            <ul class="list-disc list-inside space-y-2 mb-6">
                <li>Your goal is to protect the central <strong>Clock Tower</strong> on the left.</li>
                <li>Click the <strong>Build</strong> button to open a puzzle.</li>
                <li>Solving the time puzzle correctly allows you to place a weapon.</li>
                <li>Place <strong>Clock Turrets</strong> off the path to shoot enemies automatically.</li>
                <li>Place <strong>Time Bombs</strong> on the path to create a large explosion after a countdown.</li>
                <li>The power of the weapon depends on the time you set in the puzzle!</li>
                <li>Enemies that reach the tower will damage it. If its health reaches zero, the game is over.</li>
            </ul>
            <div class="text-center">
                 <button id="close-tutorial-btn" class="btn-primary">Got It!</button>
            </div>
        </div>
    </div>

    <!-- Pause Modal -->
    <div id="pause-modal" class="modal-backdrop hidden absolute inset-0 flex-col items-center justify-center text-white z-20">
        <div class="modal-box">
            <h2 class="text-6xl font-bold mb-8">Paused</h2>
            <div class="space-y-4">
                <button id="resume-btn" class="btn-primary w-64">Resume</button>
                <button id="restart-pause-btn" class="btn-secondary w-64">Restart</button>
            </div>
        </div>
    </div>
    
    <!-- Unified Puzzle Modal -->
    <div id="puzzle-modal" class="modal-backdrop hidden absolute inset-0 flex-col items-center justify-center text-white z-20">
        <div class="modal-box max-w-sm">
            <h2 id="puzzle-title" class="text-2xl font-bold mb-2">Set The Time!</h2>
            <p id="puzzle-prompt" class="mb-4">Drag on the clock to set the time.</p>
            <canvas id="puzzle-clock-canvas" width="200" height="200" class="mx-auto"></canvas>
            <div id="digital-time-display" class="digital-font text-5xl text-yellow-300 my-4">03:45</div>
            <input type="text" id="digital-time-input" class="digital-font text-center text-3xl bg-gray-900 text-red-500 p-2 rounded my-4 w-40 mx-auto" placeholder="HHMM">
            <p id="puzzle-error-message" class="text-red-400 h-6 mt-2"></p>
            <div class="mt-4 flex justify-center space-x-4">
                <button id="confirm-puzzle-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded">Confirm</button>
                <button id="cancel-puzzle-btn" class="btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="modal-backdrop hidden absolute inset-0 flex-col items-center justify-center text-white z-20">
        <div class="modal-box">
            <h2 class="text-6xl font-bold mb-4">Game Over</h2>
            <p class="text-2xl mb-8">You survived for <span id="final-time-survived" class="digital-font">0</span> seconds!</p>
            <button id="restart-btn" class="btn-primary">Play Again</button>
        </div>
    </div>

    <script>
        // --- SETUP ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const goldDisplay = document.getElementById('gold-display');
        const timeSurvivedDisplay = document.getElementById('time-survived-display');
        const finalTimeSurvivedDisplay = document.getElementById('final-time-survived');
        const buildBtn = document.getElementById('build-btn');
        const restartBtn = document.getElementById('restart-btn');
        const gameOverModal = document.getElementById('game-over-modal');
        const startModal = document.getElementById('start-modal');
        const startGameBtn = document.getElementById('start-game-btn');
        const tutorialBtn = document.getElementById('tutorial-btn');
        const tutorialModal = document.getElementById('tutorial-modal');
        const closeTutorialBtn = document.getElementById('close-tutorial-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const pauseModal = document.getElementById('pause-modal');
        const resumeBtn = document.getElementById('resume-btn');
        const restartPauseBtn = document.getElementById('restart-pause-btn');
        const puzzleModal = document.getElementById('puzzle-modal');
        const puzzleTitle = document.getElementById('puzzle-title');
        const puzzlePrompt = document.getElementById('puzzle-prompt');
        const puzzleCanvas = document.getElementById('puzzle-clock-canvas');
        const puzzleCtx = puzzleCanvas.getContext('2d');
        const digitalTimeDisplay = document.getElementById('digital-time-display');
        const digitalTimeInput = document.getElementById('digital-time-input');
        const puzzleErrorMessage = document.getElementById('puzzle-error-message');
        const confirmPuzzleBtn = document.getElementById('confirm-puzzle-btn');
        const cancelPuzzleBtn = document.getElementById('cancel-puzzle-btn');

        let canvasWidth, canvasHeight, path = [];

        // --- GAME STATE ---
        let gameState = 'start'; // 'start', 'playing', 'paused', 'gameover'
        let gold = 100, totalGameTime = 0;
        let enemies = [], turrets = [], projectiles = [], bombs = [], explosions = [];
        let decorations = []; // For cosmetic elements
        let gameOver = false;
        let mouse = { x: 0, y: 0 };
        let placingWeaponConfig = null;
        let spawnTimer = 0;

        // --- PUZZLE STATE ---
        let activePuzzleType = null;
        let puzzleTargetTime = { hour: 0, minute: 0 };
        let puzzleTimeInMinutes = 0;
        let isDraggingTime = false;
        let lastDragAngle = 0;

        // --- GAME CONFIG ---
        const TOWER_HEALTH_MAX = 180;
        let towerHealth = TOWER_HEALTH_MAX;
        const PATH_WIDTH = 40;
        const clockTower = { x: 60, y: 0, radius: 50 };

        // --- UTILITY & SETUP ---
        function resizeCanvas() {
            const container = canvas.parentElement;
            const panelHeight = document.getElementById('ui-panel').offsetHeight;
            let newWidth = container.clientWidth, newHeight = (window.innerHeight - panelHeight);
            canvas.width = newWidth; canvas.height = newHeight;
            canvasWidth = canvas.width; canvasHeight = canvas.height;
            clockTower.y = canvasHeight / 2;
            definePath();
        }

        function definePath() {
            path = [];
            const paddingY = 60;
            const minSegmentLengthX = canvasWidth * 0.15;
            const maxSegmentLengthX = canvasWidth * 0.3;
            const maxSegmentLengthY = canvasHeight * 0.4;
            let currentPoint = { x: canvasWidth + 20, y: Math.random() * (canvasHeight - paddingY * 2) + paddingY };
            path.push(currentPoint);
            while (currentPoint.x > clockTower.x + maxSegmentLengthX) {
                const nextX = currentPoint.x - (Math.random() * (maxSegmentLengthX - minSegmentLengthX) + minSegmentLengthX);
                const horizontalPoint = { x: Math.max(clockTower.x, nextX), y: currentPoint.y };
                path.push(horizontalPoint);
                currentPoint = horizontalPoint;
                if (currentPoint.x <= clockTower.x + maxSegmentLengthX) break;
                const yChange = (Math.random() * 2 - 1) * maxSegmentLengthY;
                let nextY = currentPoint.y + yChange;
                nextY = Math.max(paddingY, Math.min(canvasHeight - paddingY, nextY));
                const verticalPoint = { x: currentPoint.x, y: nextY };
                path.push(verticalPoint);
                currentPoint = verticalPoint;
            }
            path.push({ x: clockTower.x, y: currentPoint.y });
            path.push({ x: clockTower.x, y: clockTower.y });
            
            generateDecorations();
        }

        function generateDecorations() {
            decorations = [];
            const decorationTypes = ['rock', 'bush', 'cactus', 'pebble_cluster'];
            const density = 0.4; // decorations per 100 pixels

            for (let i = 0; i < path.length - 1; i++) {
                const p1 = path[i];
                const p2 = path[i+1];
                const segmentLength = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                const numDecorations = Math.floor(segmentLength / 100 * density);

                for (let j = 0; j < numDecorations; j++) {
                    const t = Math.random();
                    const pointOnPath = { x: p1.x + (p2.x - p1.x) * t, y: p1.y + (p2.y - p1.y) * t };
                    const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                    const perpendicularAngle = angle + Math.PI / 2 * (Math.random() > 0.5 ? 1 : -1);
                    const offset = (PATH_WIDTH / 2) + 20 + Math.random() * 80;

                    const decoration = {
                        type: decorationTypes[Math.floor(Math.random() * decorationTypes.length)],
                        x: pointOnPath.x + Math.cos(perpendicularAngle) * offset,
                        y: pointOnPath.y + Math.sin(perpendicularAngle) * offset,
                        size: Math.random() * 10 + 8,
                        rotation: Math.random() * Math.PI * 2
                    };
                    if (!isPositionOnPath(decoration.x, decoration.y, decoration.size)) {
                         decorations.push(decoration);
                    }
                }
            }
        }

        function isPositionOnPath(x, y, buffer = 15) {
            for (let i = 0; i < path.length - 1; i++) {
                const p1 = path[i], p2 = path[i + 1];
                const dx = p2.x - p1.x, dy = p2.y - p1.y;
                const lenSq = dx * dx + dy * dy;
                if (lenSq === 0) continue;
                let t = ((x - p1.x) * dx + (y - p1.y) * dy) / lenSq;
                t = Math.max(0, Math.min(1, t));
                const closestX = p1.x + t * dx, closestY = p1.y + t * dy;
                if (Math.hypot(x - closestX, y - closestY) < (PATH_WIDTH / 2 + buffer)) return true;
            }
            return false;
        }

        function updateGold(amount) {
            gold += amount;
            goldDisplay.textContent = gold;
        }

        // --- DRAWING FUNCTIONS ---
        function drawDecorations() {
            decorations.forEach(d => {
                ctx.save();
                ctx.translate(d.x, d.y);
                ctx.rotate(d.rotation);
                switch(d.type) {
                    case 'rock': drawRock(d.size); break;
                    case 'bush': drawBush(d.size); break;
                    case 'cactus': drawCactus(d.size); break;
                    case 'pebble_cluster': drawPebbleCluster(d.size); break;
                }
                ctx.restore();
            });
        }
        function drawRock(size) {
            ctx.fillStyle = '#a19d94'; ctx.strokeStyle = '#5a5854'; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(size, 0);
            for(let i = 1; i < 7; i++) {
                const angle = i * (Math.PI * 2 / 7);
                const radius = size * (0.8 + Math.random() * 0.4);
                ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
            }
            ctx.closePath(); ctx.fill(); ctx.stroke();
        }
        function drawBush(size) {
            ctx.fillStyle = '#6b8e23';
            for(let i=0; i<5; i++) {
                ctx.beginPath();
                ctx.arc((Math.random() - 0.5) * size * 0.8, (Math.random() - 0.5) * size * 0.8, size * 0.6, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        function drawCactus(size) {
            ctx.fillStyle = '#556b2f'; ctx.strokeStyle = '#2f4f4f'; ctx.lineWidth = 2;
            const bodyWidth = size * 0.8;
            const bodyHeight = size * 2.5;
            ctx.beginPath();
            ctx.rect(-bodyWidth/2, -bodyHeight/2, bodyWidth, bodyHeight);
            ctx.rect(-bodyWidth * 1.2, -bodyHeight * 0.1, bodyWidth, bodyHeight * 0.5);
            ctx.rect(bodyWidth * 0.2, -bodyHeight * 0.3, bodyWidth, bodyHeight * 0.5);
            ctx.fill(); ctx.stroke();
        }
        function drawPebbleCluster(size) {
            for(let i=0; i<3; i++) {
                ctx.save();
                ctx.translate((Math.random() - 0.5) * size, (Math.random() - 0.5) * size);
                drawRock(size * 0.5);
                ctx.restore();
            }
        }

        function drawPath() {
            ctx.strokeStyle = '#8a795d'; ctx.lineWidth = PATH_WIDTH + 6; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y); for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y); ctx.stroke();
            ctx.strokeStyle = '#c7b299'; ctx.lineWidth = PATH_WIDTH;
            ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y); for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y); ctx.stroke();
        }

        function drawClockFace(c, x, y, radius) {
            c.save(); c.translate(x, y);
            c.fillStyle = '#f0e6d2'; c.beginPath(); c.arc(0, 0, radius * 0.95, 0, Math.PI * 2); c.fill();
            c.fillStyle = '#4a3f35'; c.font = `${Math.max(10, radius * 0.2)}px 'Roboto Slab'`; c.textAlign = 'center'; c.textBaseline = 'middle';
            for (let i = 1; i <= 12; i++) {
                const angle = (i - 3) * (Math.PI / 6);
                c.fillText(i, Math.cos(angle) * radius * 0.75, Math.sin(angle) * radius * 0.75);
            }
            c.restore();
        }

        function drawClockHands(c, x, y, radius, hourAngle, minuteAngle, color = '#4a3f35', lineWidth = 3) {
            c.save(); c.translate(x, y); c.strokeStyle = color; c.lineCap = 'round';
            c.lineWidth = lineWidth + 1; c.beginPath(); c.moveTo(0, 0); c.rotate(hourAngle); c.lineTo(0, -radius * 0.5); c.stroke(); c.rotate(-hourAngle);
            c.lineWidth = lineWidth; c.beginPath(); c.moveTo(0, 0); c.rotate(minuteAngle); c.lineTo(0, -radius * 0.8); c.stroke();
            c.restore();
        }

        function drawClockTower() {
            const barWidth = clockTower.radius * 1.5;
            const barHeight = 10;
            const barX = clockTower.x - barWidth / 2;
            const barY = clockTower.y - clockTower.radius - 20;
            const healthPercentage = Math.max(0, towerHealth / TOWER_HEALTH_MAX);
            ctx.fillStyle = '#5a3d2b';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            ctx.fillStyle = '#22c55e';
            ctx.fillRect(barX, barY, barWidth * healthPercentage, barHeight);
            ctx.strokeStyle = '#4a3f35';
            ctx.lineWidth = 2;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
            ctx.save(); ctx.translate(clockTower.x, clockTower.y);
            ctx.fillStyle = '#6b5a4b'; ctx.beginPath(); ctx.arc(0, 0, clockTower.radius, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = '#4a3f35'; ctx.lineWidth = 5; ctx.stroke();
            ctx.restore();
            drawClockFace(ctx, clockTower.x, clockTower.y, clockTower.radius);
            const minuteAngle = (totalGameTime * 60 * (Math.PI / 30)); const hourAngle = (totalGameTime * 60 * (Math.PI / 360));
            drawClockHands(ctx, clockTower.x, clockTower.y, clockTower.radius, hourAngle, minuteAngle);
            ctx.save(); ctx.translate(clockTower.x, clockTower.y);
            ctx.fillStyle = '#4a3f35'; ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
        }
        
        // --- GAME OBJECTS (UNCHANGED) ---
        class Enemy { constructor(type) { this.x = path[0].x; this.y = path[0].y; this.pathIndex = 0; this.radius = type === 'gear' ? 12 : 10; this.type = type; this.speed = type === 'gear' ? 1 : 1.5; this.maxHealth = type === 'gear' ? 100 : 50; this.health = this.maxHealth; this.rotation = 0; } update() { if (this.pathIndex >= path.length - 1) { towerHealth -= 10; if (towerHealth < 0) towerHealth = 0; this.health = 0; if (towerHealth <= 0 && !gameOver) endGame(); return; } const target = path[this.pathIndex + 1]; const dx = target.x - this.x, dy = target.y - this.y; const angle = Math.atan2(dy, dx); this.x += Math.cos(angle) * this.speed; this.y += Math.sin(angle) * this.speed; this.rotation += 0.05; if (Math.hypot(target.x - this.x, target.y - this.y) < this.speed) { this.pathIndex++; } } draw() { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation); if (this.type === 'gear') { ctx.fillStyle = '#888'; ctx.strokeStyle = '#555'; ctx.lineWidth = 2; ctx.beginPath(); for (let i = 0; i < 6; i++) { const angle = (i / 6) * Math.PI * 2; ctx.rect(Math.cos(angle) * this.radius * 0.8 - 4, Math.sin(angle) * this.radius * 0.8 - 4, 8, 8); } ctx.fill(); ctx.beginPath(); ctx.arc(0, 0, this.radius * 0.7, 0, Math.PI * 2); ctx.fillStyle = '#aaa'; ctx.fill(); ctx.stroke(); } else { ctx.fillStyle = '#3a86ff'; ctx.strokeStyle = '#0050c8'; ctx.lineWidth = 2; ctx.fillRect(-this.radius, -this.radius / 2, this.radius * 2, this.radius); ctx.strokeRect(-this.radius, -this.radius / 2, this.radius * 2, this.radius); ctx.fillStyle = '#fb5607'; ctx.fillRect(this.radius - 2, -this.radius / 4, 4, this.radius / 2); } ctx.restore(); const hp = this.health / this.maxHealth; ctx.fillStyle = 'red'; ctx.fillRect(this.x - this.radius, this.y - this.radius - 8, this.radius * 2, 4); ctx.fillStyle = 'green'; ctx.fillRect(this.x - this.radius, this.y - this.radius - 8, this.radius * 2 * hp, 4); } }
        class Turret { constructor(x, y, hourAngle, minuteAngle) { this.x = x; this.y = y; this.radius = 15; this.range = 120; this.fireRate = 90; this.fireCooldown = 0; this.hourAngle = hourAngle; this.minuteAngle = minuteAngle; } update() { this.fireCooldown--; if (this.fireCooldown <= 0) { projectiles.push(new Projectile(this.x, this.y, this.hourAngle)); projectiles.push(new Projectile(this.x, this.y, this.minuteAngle)); this.fireCooldown = this.fireRate; } } draw() { ctx.save(); ctx.translate(this.x, this.y); ctx.fillStyle = '#a16e4b'; ctx.strokeStyle = '#5a3d2b'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.restore(); drawClockFace(ctx, this.x, this.y, this.radius); drawClockHands(ctx, this.x, this.y, this.radius, this.hourAngle, this.minuteAngle, '#333', 2); ctx.save(); ctx.translate(this.x, this.y); ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(0, 0, 2, 0, Math.PI * 2); ctx.fill(); ctx.restore(); } }
        class Projectile { constructor(x, y, angle) { this.x = x; this.y = y; this.radius = 3; this.speed = 4; this.damage = 15; this.vx = Math.cos(angle - Math.PI / 2) * this.speed; this.vy = Math.sin(angle - Math.PI / 2) * this.speed; } update() { this.x += this.vx; this.y += this.vy; } draw() { ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); } }
        class TimeBomb { constructor(x, y, duration) { this.x = x; this.y = y; this.countdown = duration; this.radius = 18; this.explosionRadius = 120; this.damage = 150; } update(delta) { this.countdown -= delta; if (this.countdown <= 0) { this.explode(); } } draw() { ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#555'; ctx.beginPath(); ctx.arc(this.x, this.y - this.radius + 2, 4, 0, Math.PI * 2); ctx.fill(); ctx.font = `bold 18px 'Orbitron'`; ctx.fillStyle = 'red'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.countdown.toFixed(1), this.x, this.y + 2); } explode() { explosions.push(new Explosion(this.x, this.y, this.explosionRadius)); enemies.forEach(enemy => { const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y); if (dist < this.explosionRadius) { enemy.health -= this.damage; if (enemy.health <= 0) updateGold(enemy.type === 'gear' ? 10 : 5); } }); } }
        class Explosion { constructor(x, y, radius) { this.x = x; this.y = y; this.maxRadius = radius; this.life = 1; } update(delta) { this.life -= delta * 3; } draw() { ctx.globalAlpha = this.life; ctx.fillStyle = 'orange'; ctx.beginPath(); ctx.arc(this.x, this.y, this.maxRadius * (1 - this.life), 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; } }

        // --- PUZZLE LOGIC (UNCHANGED) ---
        function openBuildPuzzle() { activePuzzleType = Math.random() > 0.5 ? 'digital-to-analog' : 'analog-to-digital'; puzzleTargetTime.hour = Math.floor(Math.random() * 12) + 1; puzzleTargetTime.minute = Math.floor(Math.random() * 12) * 5; puzzleErrorMessage.textContent = ''; if (activePuzzleType === 'digital-to-analog') { puzzleTitle.textContent = 'Set The Time!'; puzzlePrompt.textContent = 'Drag on the clock to match the time below.'; digitalTimeDisplay.textContent = `${String(puzzleTargetTime.hour).padStart(2, '0')}:${String(puzzleTargetTime.minute).padStart(2, '0')}`; digitalTimeDisplay.classList.remove('hidden'); digitalTimeInput.classList.add('hidden'); puzzleCanvas.classList.add('interactive'); puzzleTimeInMinutes = 0; drawPuzzleClockHands(); } else { puzzleTitle.textContent = 'Identify The Time!'; puzzlePrompt.textContent = 'Enter the time shown on the clock below.'; digitalTimeDisplay.classList.add('hidden'); digitalTimeInput.classList.remove('hidden'); digitalTimeInput.value = ''; digitalTimeInput.focus(); puzzleCanvas.classList.remove('interactive'); drawPuzzleClockHands(); } puzzleModal.classList.remove('hidden'); }
        function drawPuzzleClockHands() { const radius = puzzleCanvas.width / 2; puzzleCtx.clearRect(0, 0, 200, 200); drawClockFace(puzzleCtx, radius, radius, radius); let hourAngle, minuteAngle; if (activePuzzleType === 'digital-to-analog') { const minute = puzzleTimeInMinutes % 60; const hourWithFraction = puzzleTimeInMinutes / 60; minuteAngle = (minute / 60) * Math.PI * 2; hourAngle = (hourWithFraction / 12) * Math.PI * 2; } else { const minute = puzzleTargetTime.minute; const hourWithFraction = puzzleTargetTime.hour % 12 + minute / 60; minuteAngle = (minute / 60) * Math.PI * 2; hourAngle = (hourWithFraction / 12) * Math.PI * 2; } drawClockHands(puzzleCtx, radius, radius, radius, hourAngle, minuteAngle, '#333', 4); puzzleCtx.fillStyle = '#333'; puzzleCtx.beginPath(); puzzleCtx.arc(radius, radius, 5, 0, Math.PI * 2); puzzleCtx.fill(); }
        function handleTimeDrag(e) { if (!isDraggingTime || activePuzzleType !== 'digital-to-analog') return; e.preventDefault(); const pos = getCanvasMousePos(e, puzzleCanvas); const dx = pos.x - puzzleCanvas.width / 2; const dy = pos.y - puzzleCanvas.height / 2; const currentAngle = Math.atan2(dx, -dy); let deltaAngle = currentAngle - lastDragAngle; if (deltaAngle > Math.PI) deltaAngle -= Math.PI * 2; if (deltaAngle < -Math.PI) deltaAngle += Math.PI * 2; const deltaMinutes = deltaAngle / (Math.PI * 2) * 720; puzzleTimeInMinutes += deltaMinutes; if (puzzleTimeInMinutes < 0) puzzleTimeInMinutes += 720; puzzleTimeInMinutes %= 720; lastDragAngle = currentAngle; drawPuzzleClockHands(); }

        // --- GAME LOGIC (UNCHANGED) ---
        function handleEnemySpawning(delta) { spawnTimer += delta; const currentMinute = Math.floor(totalGameTime / 60); const enemiesPerMinute = 6 * Math.pow(1.2, currentMinute); const spawnInterval = 60 / enemiesPerMinute; if (spawnTimer >= spawnInterval) { spawnTimer -= spawnInterval; enemies.push(new Enemy(Math.random() > 0.3 ? 'gear' : 'battery')); } }
        function handleEnemies() { enemies.forEach(e => { e.update(); e.draw(); }); enemies = enemies.filter(e => e.health > 0); }
        function handleTurrets() { turrets.forEach(t => { t.update(); t.draw(); }); }
        function handleProjectiles() { for (let i = projectiles.length - 1; i >= 0; i--) { const p = projectiles[i]; p.update(); p.draw(); let hit = false; for (let j = enemies.length - 1; j >= 0; j--) { if (Math.hypot(p.x - enemies[j].x, p.y - enemies[j].y) < enemies[j].radius) { enemies[j].health -= p.damage; if (enemies[j].health <= 0) updateGold(enemies[j].type === 'gear' ? 10 : 5); hit = true; break; } } if (hit || p.x < 0 || p.x > canvasWidth || p.y < 0 || p.y > canvasHeight) projectiles.splice(i, 1); } }
        function handleBombs(delta) { for (let i = bombs.length - 1; i >= 0; i--) { const bomb = bombs[i]; bomb.update(delta); if (bomb.countdown <= 0) { bombs.splice(i, 1); } else { bomb.draw(); } } }
        function handleExplosions(delta) { for (let i = explosions.length - 1; i >= 0; i--) { const exp = explosions[i]; exp.update(delta); if (exp.life <= 0) { explosions.splice(i, 1); } else { exp.draw(); } } }
        function pauseGame() { if (gameState !== 'playing') return; gameState = 'paused'; pauseModal.classList.remove('hidden'); }
        function resumeGame() { if (gameState !== 'paused') return; gameState = 'playing'; pauseModal.classList.add('hidden'); lastTime = performance.now(); }
        function endGame() { gameOver = true; gameState = 'gameover'; finalTimeSurvivedDisplay.textContent = Math.floor(totalGameTime); gameOverModal.classList.remove('hidden'); }
        function resetGame() { gold = 100; totalGameTime = 0; towerHealth = TOWER_HEALTH_MAX; enemies = []; turrets = []; projectiles = []; bombs = []; explosions = []; gameOver = false; placingWeaponConfig = null; spawnTimer = 0; goldDisplay.textContent = gold; gameOverModal.classList.add('hidden'); pauseModal.classList.add('hidden'); definePath(); lastTime = performance.now(); }

        // --- MAIN GAME LOOP ---
        let lastTime = 0;
        function gameLoop(timestamp) {
            if (gameState === 'playing') {
                const delta = (timestamp - lastTime) / 1000 || 0;
                lastTime = timestamp;
                totalGameTime += delta;
                timeSurvivedDisplay.textContent = Math.floor(totalGameTime);
                handleEnemySpawning(delta);
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                drawDecorations(); // Draw decorations first
                drawPath();
                drawClockTower();
                handleEnemies();
                handleTurrets();
                handleProjectiles();
                handleBombs(delta);
                handleExplosions(delta);
                if (placingWeaponConfig) {
                    ctx.globalAlpha = 0.6;
                    const onPath = isPositionOnPath(mouse.x, mouse.y, 0);
                    if (onPath) {
                        new TimeBomb(mouse.x, mouse.y, placingWeaponConfig.duration).draw();
                        ctx.beginPath(); ctx.arc(mouse.x, mouse.y, 120, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)'; ctx.lineWidth = 2; ctx.stroke();
                    } else {
                        new Turret(mouse.x, mouse.y, placingWeaponConfig.hourAngle, placingWeaponConfig.minuteAngle).draw();
                        ctx.beginPath(); ctx.arc(mouse.x, mouse.y, 120, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)'; ctx.lineWidth = 2; ctx.stroke();
                    }
                    ctx.globalAlpha = 1.0;
                }
            }
            requestAnimationFrame(gameLoop);
        }

        // --- EVENT LISTENERS (UNCHANGED) ---
        function getCanvasMousePos(e, c = canvas) { const rect = c.getBoundingClientRect(); const scaleX = c.width / rect.width, scaleY = c.height / rect.height; const clientX = e.clientX || e.touches[0].clientX, clientY = e.clientY || e.touches[0].clientY; return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY }; }
        startGameBtn.addEventListener('click', () => { startModal.classList.add('hidden'); gameState = 'playing'; resetGame(); });
        tutorialBtn.addEventListener('click', () => tutorialModal.classList.remove('hidden'));
        closeTutorialBtn.addEventListener('click', () => tutorialModal.classList.add('hidden'));
        pauseBtn.addEventListener('click', pauseGame);
        resumeBtn.addEventListener('click', resumeGame);
        restartPauseBtn.addEventListener('click', () => { gameState = 'playing'; resetGame(); });
        buildBtn.addEventListener('click', () => { if (gameState !== 'playing') return; openBuildPuzzle(); });
        restartBtn.addEventListener('click', () => { gameState = 'playing'; resetGame(); });
        cancelPuzzleBtn.addEventListener('click', () => puzzleModal.classList.add('hidden'));
        confirmPuzzleBtn.addEventListener('click', () => { let success = false; let solvedHour, solvedMinute; if (activePuzzleType === 'digital-to-analog') { let targetHour = puzzleTargetTime.hour; if (targetHour === 12) targetHour = 0; const targetTotalMinutes = targetHour * 60 + puzzleTargetTime.minute; const userTotalMinutes = puzzleTimeInMinutes % 720; let diff = Math.abs(targetTotalMinutes - userTotalMinutes); if (diff > 360) diff = 720 - diff; if (diff <= 5) { success = true; solvedMinute = Math.round(userTotalMinutes % 60); solvedHour = Math.floor(userTotalMinutes / 60); if (solvedHour === 0) solvedHour = 12; } } else { const rawInput = digitalTimeInput.value.replace(':', '').trim(); if (/^\d{3,4}$/.test(rawInput)) { const paddedInput = rawInput.padStart(4, '0'); const userHour = parseInt(paddedInput.slice(0, 2)); const userMinute = parseInt(paddedInput.slice(2, 4)); if (userHour === puzzleTargetTime.hour && userMinute === puzzleTargetTime.minute) { success = true; solvedHour = userHour; solvedMinute = userMinute; } } } if (success) { const minuteAngle = (solvedMinute / 60) * Math.PI * 2; const hourWithFraction = solvedHour % 12 + solvedMinute / 60; const hourAngle = (hourWithFraction / 12) * Math.PI * 2; placingWeaponConfig = { hour: solvedHour, minute: solvedMinute, hourAngle: hourAngle, minuteAngle: minuteAngle, duration: solvedHour + solvedMinute / 60 }; puzzleModal.classList.add('hidden'); canvas.classList.add('placing-weapon'); } else { puzzleErrorMessage.textContent = 'Incorrect. Try again.'; } });
        puzzleCanvas.addEventListener('pointerdown', (e) => { if (activePuzzleType !== 'digital-to-analog') return; isDraggingTime = true; const pos = getCanvasMousePos(e, puzzleCanvas); const dx = pos.x - puzzleCanvas.width / 2; const dy = pos.y - puzzleCanvas.height / 2; lastDragAngle = Math.atan2(dx, -dy); e.target.setPointerCapture(e.pointerId); });
        window.addEventListener('pointermove', (e) => { if (isDraggingTime) handleTimeDrag(e); if (placingWeaponConfig) mouse = getCanvasMousePos(e); });
        window.addEventListener('pointerup', (e) => { if(isDraggingTime) { isDraggingTime = false; try { e.target.releasePointerCapture(e.pointerId); } catch(err) {} } });
        canvas.addEventListener('click', (e) => { if (!placingWeaponConfig) return; const pos = getCanvasMousePos(e); if (isPositionOnPath(pos.x, pos.y, 0)) { bombs.push(new TimeBomb(pos.x, pos.y, placingWeaponConfig.duration)); } else { turrets.push(new Turret(pos.x, pos.y, placingWeaponConfig.hourAngle, placingWeaponConfig.minuteAngle)); } placingWeaponConfig = null; canvas.classList.remove('placing-weapon'); });
        window.addEventListener('keydown', (e) => { if (!puzzleModal.classList.contains('hidden')) { if (e.key === 'Enter') { e.preventDefault(); confirmPuzzleBtn.click(); } else if (e.key === 'Escape') { cancelPuzzleBtn.click(); } return; } if (e.key === 'Escape') { if (gameState === 'playing') { pauseGame(); } else if (gameState === 'paused') { resumeGame(); } } });

        window.addEventListener('resize', resizeCanvas);
        // --- INITIALIZE GAME ---
        resizeCanvas();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
