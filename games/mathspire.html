<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Mathspire</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            position: fixed;
            -webkit-text-size-adjust: 100%;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
            margin: 0;
            padding: 0;
            -webkit-overflow-scrolling: touch;
        }
        
        #game-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            position: fixed;
            top: 0;
            left: 0;
            overflow: hidden;
        }
        
        #game-header {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #4a90e2;
            flex-shrink: 0;
            position: relative; 
            z-index: 100; 
        }
        
        #game-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
            min-height: 0;
        }
        
        /* ===== VIEW DISPLAY RULES ===== */
        #starting-choices-view,
        #map-view,
        #reward-view,
        #event-view,
        #shop-view,
        #rest-view,
        #treasure-view,
        #elite-reward-view,
        #boss-relic-view {
            display: none;
            width: 100%;
            height: 100%;
        }

        #combat-view {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }
        
        /* Consistent active state for all views */
        #seed-view.active,
        #starting-choices-view.active,
        #map-view.active,
        #combat-view.active,
        #reward-view.active,
        #event-view.active,
        #shop-view.active,
        #rest-view.active,
        #treasure-view.active,
        #elite-reward-view.active,
        #boss-relic-view.active {
            display: flex !important;
            flex-direction: column;
        }
        
        /* Seed View */
        #seed-view {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            min-height: 100vh;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            justify-content: center; 
            align-items: center;
            padding: 40px 20px; 
            z-index: 1;
        }
        
        #seed-view > div,
        #seed-view > * {
            max-width: 500px;
            width: 100%;
        }
        
        /* Starting Choices View */
        #starting-choices-view {
            padding: 40px 20px;
            text-align: center;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }
        
        .starting-choices-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
            padding-bottom: 40px;
        }
        
        .starting-choices-title {
            font-size: 42px;
            margin-bottom: 20px;
            color: #4a90e2;
            text-shadow: 0 0 20px rgba(74, 144, 226, 0.5);
        }
        
        .starting-choices-subtitle {
            font-size: 20px;
            margin-bottom: 40px;
            color: #888;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .starting-choice {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.6) 0%, rgba(20, 20, 40, 0.6) 100%);
            border: 3px solid #4a90e2;
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            position: relative;
            width: 100%;
            box-sizing: border-box;
            flex-shrink: 0;
        }
        
        .starting-choice:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(74, 144, 226, 0.4);
            border-color: #5dade2;
        }
        
        .starting-choice-icon {
            font-size: 64px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .starting-choice-name {
            font-size: 24px;
            font-weight: bold;
            color: #4a90e2;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .starting-choice-benefits {
            margin-bottom: 15px;
        }
        
        .starting-choice-benefit {
            font-size: 16px;
            color: #2ecc71;
            margin: 8px 0;
            padding-left: 20px;
            position: relative;
        }
        
        .starting-choice-benefit::before {
            content: '‚úì';
            position: absolute;
            left: 0;
            color: #2ecc71;
            font-weight: bold;
        }
        
        .starting-choice-drawbacks {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(231, 76, 60, 0.3);
        }
        
        .starting-choice-drawback {
            font-size: 16px;
            color: #e74c3c;
            margin: 8px 0;
            padding-left: 20px;
            position: relative;
        }
        
        .starting-choice-drawback::before {
            content: '‚úó';
            position: absolute;
            left: 0;
            color: #e74c3c;
            font-weight: bold;
        }
        
        .starting-choice.balanced {
            border-color: #9b59b6;
        }
        
        .starting-choice.balanced .starting-choice-name {
            color: #9b59b6;
        }
        
        .starting-choice.risky {
            border-color: #f39c12;
        }
        
        .starting-choice.risky .starting-choice-name {
            color: #f39c12;
        }
        
        .starting-choice.safe {
            border-color: #2ecc71;
        }
        
        .starting-choice.safe .starting-choice-name {
            color: #2ecc71;
        }
        
        .starting-choice.extreme {
            border-color: #e74c3c;
        }
        
        .starting-choice.extreme .starting-choice-name {
            color: #e74c3c;
        }
        
        .starting-choice-flavor {
            font-size: 14px;
            color: #888;
            font-style: italic;
            margin-top: 15px;
            text-align: center;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* ===== HEADER ===== */
        .stat-display {
            display: flex;
            gap: 15px;
            font-size: 14px;
            flex-wrap: wrap;
        }
        
        .stat {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .stat-label {
            color: #888;
            font-size: 12px;
        }
        
        .stat-value {
            color: #fff;
            font-weight: bold;
            font-size: 14px;
        }
        
        .hp-bar {
            width: 100px;
            height: 15px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #666;
        }
        
        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #c0392b);
            transition: width 0.3s ease;
        }
        
        .floor-indicator {
            font-size: 14px;
            color: #f39c12;
        }
        
        /* ===== MAP VIEW ===== */
        #map-view {
            padding: 20px;
            overflow-y: auto; 
            overflow-x: hidden; 
            -webkit-overflow-scrolling: touch; 
        }
        
        .map-title {
            font-size: 28px;
            text-align: center;
            margin-bottom: 15px;
            color: #4a90e2;
            text-shadow: 0 0 20px rgba(74, 144, 226, 0.5);
        }
        
        .map-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 800px;
            margin: 0 auto;
            position: relative;
            padding-bottom: 40px;
        }
        
        .map-row {
            display: flex;
            justify-content: center;
            gap: 15px;
            position: relative;
            padding: 15px 0;
        }
        
        .map-row::before {
            content: attr(data-floor-label);
            position: absolute;
            left: -80px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 14px;
            color: rgba(74, 144, 226, 0.6);
            font-weight: bold;
            white-space: nowrap;
        }
        
        .map-row::after {
            content: '‚Üë';
            position: absolute;
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            color: rgba(74, 144, 226, 0.4);
        }
        
        .map-row:first-child::before {
            color: #2ecc71;
        }
        
        .map-row:last-child::before {
            color: #f39c12;
        }
        
        .map-row:last-child::after {
            content: 'üëë SUMMIT';
            top: auto;
            bottom: -30px;
            font-size: 14px;
            color: #f39c12;
            font-weight: bold;
        }
        
        .map-node {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
            background: rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            touch-action: manipulation;
        }
        
        .map-node:active {
            transform: scale(0.9);
            filter: brightness(1.3);
        }
        
        .map-node:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(74, 144, 226, 0.6);
        }
        
        .map-node.enemy {
            width: 55px !important;
            height: 55px !important;
            border-radius: 8px !important;
            border-color: #e74c3c !important;
            background: rgba(231, 76, 60, 0.2) !important;
        }
        
        .map-node.enemy:hover {
            transform: scale(1.08) !important;
        }
        
        .map-node.elite {
            width: 65px;
            height: 65px;
            border-radius: 50%;
            border-color: #9b59b6;
            background: rgba(155, 89, 182, 0.2);
        }
        
        .map-node.event {
            border-color: #f39c12;
            background: rgba(243, 156, 18, 0.2);
        }
        
        .map-node.shop {
            border-color: #2ecc71;
            background: rgba(46, 204, 113, 0.2);
        }
        
        .map-node.rest {
            border-color: #3498db;
            background: rgba(52, 152, 219, 0.2);
        }
        
        .map-node.treasure {
            border-color: #f39c12;
            background: rgba(243, 156, 18, 0.25);
            box-shadow: 0 0 15px rgba(243, 156, 18, 0.4);
        }
        
        .map-node.boss {
            width: 80px;
            height: 80px;
            border-color: #c0392b;
            background: rgba(192, 57, 43, 0.3);
            animation: pulse 2s infinite;
        }

        @keyframes flash-blue {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        @keyframes flash-red {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        @keyframes flash-gray {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(192, 57, 43, 0.6); }
            50% { box-shadow: 0 0 40px rgba(192, 57, 43, 1); }
        }
        
        /* ===== COMBAT VIEW ===== */
        #enemy-area {
            flex: 0 0 auto;
            min-height: 200px;
            max-height: 40vh;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            padding: 40px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .enemy {
            position: relative;
            background: rgba(0, 0, 0, 0.5);
            border: 3px solid #e74c3c;
            border-radius: 15px;
            padding: 20px;
            min-width: 200px;
            text-align: center;
            flex-shrink: 0;
        }
        
        .enemy-name {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #e74c3c;
        }
        
        .enemy-hp-bar {
            width: 100%;
            height: 15px;
            background: #333;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .enemy-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #c0392b);
            transition: width 0.3s ease;
        }
        
        .enemy-intent {
            font-size: 16px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            margin-top: 10px;
        }
        
        .intent-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }
        
        .enemy-sprite {
            font-size: 64px;
            margin: 15px 0;
        }
        
        #player-area {
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            background: rgba(0, 0, 0, 0.4);
            padding: 20px;
            border-top: 2px solid #4a90e2;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch; 
        }
        
        #player-debuffs {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        
        .player-debuff {
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .debuff-confused {
            background: rgba(155, 89, 182, 0.4);
            border: 2px solid #9b59b6;
        }
        
        .debuff-exposed {
            background: rgba(231, 76, 60, 0.4);
            border: 2px solid #e74c3c;
        }
        
        .debuff-distracted {
            background: rgba(52, 152, 219, 0.4);
            border: 2px solid #3498db;
        }
        
        .debuff-slowed {
            background: rgba(149, 165, 166, 0.4);
            border: 2px solid #95a5a6;
        }
        
        #hand {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            min-height: 180px;
            align-items: flex-end;
            flex-wrap: nowrap;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            padding: 10px 5px;
        }
        
        .card {
            width: 140px;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border: 2px solid #4a90e2;
            border-radius: 10px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            flex-shrink: 0;
        }
        
        .card:hover {
            transform: translateY(-15px);
            box-shadow: 0 10px 30px rgba(74, 144, 226, 0.5);
        }
        
        .card:active {
            transform: translateY(-5px) scale(0.98);
        }
        
        .card.unplayable {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .card.unplayable:hover {
            transform: none;
        }
        
        .card-energy {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 30px;
            height: 30px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            border: 2px solid #fff;
        }
        
        .card-name {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 6px;
            color: #4a90e2;
        }
        
        .card-type {
            font-size: 11px;
            color: #888;
            margin-bottom: 8px;
            text-transform: uppercase;
        }
        
        .card-description {
            font-size: 12px;
            line-height: 1.3;
            color: #ccc;
        }
        
        .card.attack {
            border-color: #e74c3c;
        }
        
        .card.attack .card-name {
            color: #e74c3c;
        }
        
        .card.skill {
            border-color: #2ecc71;
        }
        
        .card.skill .card-name {
            color: #2ecc71;
        }
        
        .card.power {
            border-color: #9b59b6;
        }
        
        .card.power .card-name {
            color: #9b59b6;
        }
        
        .card.utility {
            border-color: #f39c12;
        }
        
        .card.utility .card-name {
            color: #f39c12;
        }
        
        .card.curse {
            border-color: #8b0000;
            background: linear-gradient(135deg, #2c1a1a 0%, #1a0a0a 100%);
        }
        
        .card.curse .card-name {
            color: #8b0000;
        }
        
        .card.curse .card-energy {
            background: linear-gradient(135deg, #8b0000, #5a0000);
        }
        
        #combat-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        
        .btn {
            padding: 12px 30px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            min-height: 44px;
        }
        
        .btn:active {
            transform: scale(0.95);
        }
        
        .btn-end-turn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }
        
        .btn-end-turn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.4);
        }
        
        .btn-end-turn:active {
            transform: translateY(0) scale(0.98);
        }
        
        /* ===== REWARD VIEW ===== */
        #reward-view {
            padding: 60px;
            text-align: center;
        }
        
        .reward-title {
            font-size: 42px;
            margin-bottom: 40px;
            color: #2ecc71;
            text-shadow: 0 0 20px rgba(46, 204, 113, 0.5);
        }
        
        #card-rewards {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 40px;
            flex-wrap: wrap;
        }
        
        .reward-card {
            width: 200px;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border: 3px solid #4a90e2;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .reward-card:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 40px rgba(74, 144, 226, 0.6);
        }
        
        /* ===== EVENT VIEW ===== */
        #event-view {
            padding: 60px;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .event-title {
            font-size: 36px;
            margin-bottom: 30px;
            color: #f39c12;
            text-align: center;
        }
        
        .event-description {
            font-size: 18px;
            line-height: 1.8;
            margin-bottom: 40px;
            text-align: center;
        }
        
        .event-choices {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .event-choice {
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #4a90e2;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 44px;
        }
        
        .event-choice:hover {
            background: rgba(74, 144, 226, 0.3);
            transform: translateX(10px);
        }
        
        /* ===== SHOP VIEW ===== */
        #shop-view {
            padding: 40px;
        }
        
        .shop-title {
            font-size: 36px;
            text-align: center;
            margin-bottom: 40px;
            color: #2ecc71;
        }
        
        .shop-items {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 30px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .shop-item {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #2ecc71;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .shop-item:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(46, 204, 113, 0.4);
        }
        
        .shop-item-price {
            font-size: 24px;
            color: #f39c12;
            margin-top: 15px;
            font-weight: bold;
        }
        
        /* ===== REST VIEW ===== */
        #rest-view {
            padding: 60px;
            text-align: center;
        }
        
        .rest-title {
            font-size: 36px;
            margin-bottom: 40px;
            color: #3498db;
        }
        
        .rest-options {
            display: flex;
            justify-content: center;
            gap: 40px;
            flex-wrap: wrap;
        }
        
        .rest-option {
            width: 300px;
            padding: 40px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #3498db;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .rest-option:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(52, 152, 219, 0.5);
        }
        
        .rest-option-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }
        
        .rest-option-title {
            font-size: 24px;
            margin-bottom: 15px;
            color: #3498db;
        }
        
        /* ===== TREASURE VIEW ===== */
        #treasure-view {
            padding: 60px;
            text-align: center;
        }
        
        .treasure-title {
            font-size: 42px;
            margin-bottom: 20px;
            color: #f39c12;
            text-shadow: 0 0 30px rgba(243, 156, 18, 0.6);
        }
        
        .treasure-subtitle {
            font-size: 20px;
            margin-bottom: 40px;
            color: #888;
        }
        
        .treasure-choices {
            display: flex;
            justify-content: center;
            gap: 50px;
            flex-wrap: wrap;
        }
        
        .treasure-relic {
            width: 280px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.15) 0%, rgba(255, 140, 0, 0.15) 100%);
            border: 3px solid #f39c12;
            border-radius: 15px;
            padding: 40px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(243, 156, 18, 0.3);
        }
        
        .treasure-relic:hover {
            transform: scale(1.08) translateY(-5px);
            box-shadow: 0 15px 50px rgba(243, 156, 18, 0.6);
            border-color: #ffd700;
        }
        
        .treasure-relic-icon {
            font-size: 90px;
            margin-bottom: 25px;
            filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.5));
        }
        
        .treasure-relic-name {
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 15px;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }
        
        .treasure-relic-desc {
            font-size: 17px;
            color: #e0e0e0;
            line-height: 1.5;
        }
        
        /* ===== ELITE REWARD VIEW ===== */
        #elite-reward-view {
            padding: 60px;
            text-align: center;
        }
        
        .elite-reward-title {
            font-size: 42px;
            margin-bottom: 20px;
            color: #9b59b6;
            text-shadow: 0 0 20px rgba(155, 89, 182, 0.5);
        }
        
        .elite-reward-subtitle {
            font-size: 20px;
            margin-bottom: 40px;
            color: #888;
        }
        
        #relic-choices {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-bottom: 40px;
            flex-wrap: wrap;
        }
        
        .relic-choice {
            width: 250px;
            background: rgba(255, 215, 0, 0.1);
            border: 3px solid #f39c12;
            border-radius: 15px;
            padding: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .relic-choice:hover {
            transform: scale(1.08);
            box-shadow: 0 10px 40px rgba(243, 156, 18, 0.6);
        }
        
        .relic-choice-icon {
            font-size: 80px;
            margin-bottom: 20px;
        }
        
        .relic-choice-name {
            font-size: 22px;
            font-weight: bold;
            color: #f39c12;
            margin-bottom: 15px;
        }
        
        .relic-choice-desc {
            font-size: 16px;
            color: #ccc;
            line-height: 1.4;
        }
        
        /* ===== BOSS RELIC VIEW ===== */
        #boss-relic-view {
            padding: 60px;
            text-align: center;
        }
        
        .boss-relic-title {
            font-size: 48px;
            margin-bottom: 20px;
            color: #f39c12;
            text-shadow: 0 0 30px rgba(243, 156, 18, 0.8);
            animation: boss-glow 2s infinite;
        }
        
        @keyframes boss-glow {
            0%, 100% { text-shadow: 0 0 30px rgba(243, 156, 18, 0.8); }
            50% { text-shadow: 0 0 50px rgba(243, 156, 18, 1), 0 0 80px rgba(243, 156, 18, 0.6); }
        }
        
        .boss-relic-subtitle {
            font-size: 22px;
            margin-bottom: 40px;
            color: #e74c3c;
            font-weight: bold;
        }
        
        #boss-relic-choices {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-bottom: 40px;
            flex-wrap: wrap;
        }
        
        .boss-relic-choice {
            width: 280px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.15) 0%, rgba(255, 140, 0, 0.15) 100%);
            border: 4px solid #f39c12;
            border-radius: 15px;
            padding: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 5px 20px rgba(243, 156, 18, 0.3);
        }
        
        .boss-relic-choice::before {
            content: '‚ö†Ô∏è';
            position: absolute;
            top: -15px;
            right: -15px;
            font-size: 32px;
            background: #e74c3c;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 3px solid #fff;
            animation: warning-pulse 1.5s infinite;
        }
        
        @keyframes warning-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .boss-relic-choice:hover {
            transform: scale(1.05) translateY(-5px);
            box-shadow: 0 15px 50px rgba(243, 156, 18, 0.6);
            border-color: #ffd700;
        }
        
        .boss-relic-choice-icon {
            font-size: 90px;
            margin-bottom: 20px;
            filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.5));
        }
        
        .boss-relic-choice-name {
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 15px;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }
        
        .boss-relic-choice-desc {
            font-size: 16px;
            color: #e0e0e0;
            line-height: 1.5;
            margin-bottom: 15px;
        }
        
        .boss-relic-drawback {
            font-size: 14px;
            color: #e74c3c;
            font-weight: bold;
            padding: 10px;
            background: rgba(231, 76, 60, 0.2);
            border-radius: 8px;
            border: 1px solid #e74c3c;
        }
        
        /* ===== RELICS ===== */
        #relics-display {
            display: flex;
            gap: 10px;
        }
        
        .relic {
            width: 40px;
            height: 40px;
            background: rgba(255, 215, 0, 0.2);
            border: 2px solid #f39c12;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .relic:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(243, 156, 18, 0.6);
        }
        
        /* ===== MODALS ===== */
        .game-over {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .game-over.active {
            display: flex;
        }
        
        .game-over-content {
            text-align: center;
            padding: 60px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid;
            border-radius: 20px;
            max-width: 90%;
        }
        
        .game-over.victory .game-over-content {
            border-color: #2ecc71;
        }
        
        .game-over.defeat .game-over-content {
            border-color: #e74c3c;
        }
        
        .game-over-title {
            font-size: 72px;
            margin-bottom: 30px;
        }
        
        .game-over.victory .game-over-title {
            color: #2ecc71;
        }
        
        .game-over.defeat .game-over-title {
            color: #e74c3c;
        }
        
        #deck-viewer,
        #card-removal-modal,
        #relic-viewer {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        #deck-viewer.active,
        #card-removal-modal.active,
        #relic-viewer.active {
            display: block;
        }
        
        .deck-viewer-content,
        .removal-modal-content,
        .relic-viewer-content {
            max-width: 1200px;
            margin: 40px auto;
            padding: 20px;
        }
        
        .deck-viewer-header,
        .relic-viewer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }
        
        .deck-viewer-title {
            font-size: 36px;
            color: #9b59b6;
        }
        
        .relic-viewer-title {
            font-size: 36px;
            color: #f39c12;
        }
        
        .removal-modal-title {
            font-size: 32px;
            color: #e74c3c;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .deck-viewer-close,
        .relic-viewer-close {
            font-size: 36px;
            color: #e74c3c;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            line-height: 1;
            transition: transform 0.2s;
        }
        
        .deck-viewer-close:hover,
        .relic-viewer-close:hover {
            transform: scale(1.2);
        }
        
        .deck-viewer-stats {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
            font-size: 18px;
        }
        
        .deck-viewer-cards,
        .removal-cards {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 20px;
        }
        
        .deck-viewer-card {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border: 2px solid #4a90e2;
            border-radius: 10px;
            padding: 12px;
            position: relative;
        }
        
        .deck-card-count {
            position: absolute;
            top: -8px;
            left: -8px;
            width: 30px;
            height: 30px;
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            border: 2px solid #fff;
        }
        
        .removal-card {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .removal-card:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(231, 76, 60, 0.5);
        }
        
        .relic-viewer-relics {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
        }
        
        .relic-viewer-item {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid #f39c12;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .relic-viewer-item:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(243, 156, 18, 0.4);
        }
        
        .relic-viewer-icon {
            font-size: 64px;
            margin-bottom: 15px;
        }
        
        .relic-viewer-name {
            font-size: 18px;
            font-weight: bold;
            color: #f39c12;
            margin-bottom: 10px;
        }
        
        .relic-viewer-desc {
            font-size: 14px;
            color: #ccc;
            line-height: 1.4;
        }
        
        /* ===== COLLECTION VIEWER ===== */
        #collection-viewer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 3000;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            display: none;
        }
        
        #collection-viewer.active {
            display: block;
        }
        
        .collection-viewer-content {
            max-width: 1400px;
            margin: 40px auto;
            padding: 20px;
        }
        
        .collection-viewer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }
        
        .collection-viewer-title {
            font-size: 36px;
            color: #9b59b6;
        }
        
        .collection-viewer-close {
            font-size: 36px;
            color: #e74c3c;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            line-height: 1;
            transition: transform 0.2s;
        }
        
        .collection-viewer-close:hover {
            transform: scale(1.2);
        }
        
        .collection-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 2px solid #4a90e2;
        }
        
        .collection-tab {
            padding: 15px 30px;
            background: transparent;
            border: none;
            color: #888;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }
        
        .collection-tab:hover {
            color: #fff;
        }
        
        .collection-tab.active {
            color: #9b59b6;
            border-bottom-color: #9b59b6;
        }
        
        .collection-tab-content {
            min-height: 500px;
        }
        
        #collection-cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
        }
        
        .collection-card {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border: 2px solid #4a90e2;
            border-radius: 10px;
            padding: 15px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .collection-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(74, 144, 226, 0.5);
        }
        
        .collection-card.starter {
            border-color: #95a5a6;
        }
        
        .collection-card.common {
            border-color: #bdc3c7;
        }
        
        .collection-card.uncommon {
            border-color: #3498db;
        }
        
        .collection-card.rare {
            border-color: #f39c12;
        }
        
        .collection-card.attack {
            border-color: #e74c3c;
        }
        
        .collection-card.skill {
            border-color: #2ecc71;
        }
        
        .collection-card.power {
            border-color: #9b59b6;
        }
        
        .collection-card.utility {
            border-color: #f39c12;
        }
        
        .collection-card-energy {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 30px;
            height: 30px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            border: 2px solid #fff;
        }
        
        .collection-card-name {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #4a90e2;
        }
        
        .collection-card-type {
            font-size: 11px;
            color: #888;
            margin-bottom: 10px;
            text-transform: uppercase;
        }
        
        .collection-card-description {
            font-size: 13px;
            line-height: 1.4;
            color: #ccc;
        }
        
        #collection-relics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
        }
        
        .collection-relic {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid #f39c12;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .collection-relic:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(243, 156, 18, 0.4);
        }
        
        .collection-relic.boss {
            border-color: #c0392b;
            background: rgba(192, 57, 43, 0.1);
        }
        
        .collection-relic-icon {
            font-size: 64px;
            margin-bottom: 15px;
        }
        
        .collection-relic-name {
            font-size: 18px;
            font-weight: bold;
            color: #f39c12;
            margin-bottom: 10px;
        }
        
        .collection-relic.boss .collection-relic-name {
            color: #c0392b;
        }
        
        .collection-relic-tier {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 10px;
        }
        
        .collection-relic-desc {
            font-size: 14px;
            color: #ccc;
            line-height: 1.4;
        }
        
        /* ===== ANIMATIONS ===== */
        @keyframes damage-flash {
            0%, 100% { background-color: transparent; }
            50% { background-color: rgba(231, 76, 60, 0.5); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        @keyframes enemy-shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
            20%, 40%, 60%, 80% { transform: translateX(3px); }
        }
        
        @keyframes damage-float {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -150%);
            }
        }
        
        .damage-flash {
            animation: damage-flash 0.3s;
        }
        
        /* ===== TOUCH IMPROVEMENTS ===== */
        button,
        .btn,
        .card,
        .map-node,
        .enemy,
        .starting-choice,
        .event-choice,
        .shop-item,
        .rest-option,
        .reward-card,
        .relic-choice,
        .treasure-relic,
        .boss-relic-choice,
        input,
        select {
            -webkit-tap-highlight-color: rgba(74, 144, 226, 0.3);
            -webkit-touch-callout: none;
            touch-action: manipulation;
            cursor: pointer;
            user-select: none;
        }
        
        button,
        .btn {
            position: relative;
            z-index: 10;
            -webkit-user-select: none;
            user-select: none;
        }
        
        button,
        .btn,
        input[type="button"],
        input[type="submit"] {
            -webkit-appearance: none;
            appearance: none;
            border-radius: 8px;
        }
        
        * {
            touch-action: manipulation;
        }
        
        body {
            -webkit-overflow-scrolling: touch;
            overflow-scrolling: touch;
        }
        
        #game-main,
        #seed-view,
        #starting-choices-view,
        #map-view,
        #combat-view,
        #reward-view,
        #event-view,
        #shop-view,
        #rest-view,
        #treasure-view,
        #elite-reward-view,
        #boss-relic-view {
            -webkit-overflow-scrolling: touch;
        }
        
        /* ===== MOBILE RESPONSIVE - CONSOLIDATED ===== */
        @media (max-width: 768px) {
            html, body {
                overflow: hidden !important;
                position: fixed !important;
                width: 100% !important;
                height: 100% !important;
            }
            
             #game-container {
                overflow: hidden !important;
            }
            
            /* Header */
            #game-header {
                padding: 8px 10px;
                flex-wrap: wrap;
                gap: 8px;
                min-height: 50px;
            }
            
            .stat-display {
                gap: 8px;
                font-size: 12px;
                flex-wrap: wrap;
                flex: 1 1 auto;
            }
            
            .stat-label {
                font-size: 10px;
            }
            
            .stat-value {
                font-size: 12px;
            }
            
            .hp-bar {
                width: 60px;
                height: 12px;
            }
            
            .floor-indicator {
                font-size: 11px;
                flex: 1 1 100%;
                text-align: center;
            }
        
            #view-deck-btn,
            #view-relics-btn {
                padding: 6px 10px !important;
                font-size: 11px !important;
                min-height: 32px !important;
            }

            #relics-display {
                gap: 5px;
            }
            
            .relic {
                width: 30px;
                height: 30px;
                font-size: 16px;
            }
        
            /* Seed View */
            #seed-view {
                justify-content: flex-start !important;
                padding: 15px 10px !important;
                overflow-y: auto !important;
            }
            
            #seed-view h1 {
                font-size: 28px !important;
                margin: 5px 0 !important;
            }
            
            #seed-view p {
                font-size: 14px !important;
                margin: 5px 0 !important;
            }

            #seed-view input[type="text"],
            #seed-view input[type="range"] {
                font-size: 14px !important;
            }
            
            #seed-view button {
                font-size: 14px !important;
                padding: 12px 20px !important;
            }
        
            /* Starting Choices */
            #starting-choices-view {
                padding: 15px 10px !important;
                overflow-y: auto !important;
            }
            
            .starting-choices-title {
                font-size: 24px !important;
                margin-bottom: 10px !important;
            }
            
            .starting-choices-subtitle {
                font-size: 14px !important;
                margin-bottom: 20px !important;
            }
            
            .starting-choices-grid {
                gap: 15px !important;
            }
            
            .starting-choice {
                padding: 15px !important;
            }
            
            .starting-choice-icon {
                font-size: 40px !important;
                margin-bottom: 10px !important;
            }
            
            .starting-choice-name {
                font-size: 18px !important;
            }
            
            .starting-choice-benefit,
            .starting-choice-drawback {
                font-size: 13px !important;
            }
            
            .starting-choice-flavor {
                font-size: 12px !important;
                margin-top: 10px !important;
                padding-top: 10px !important;
            }
        
            /* Map */
            #map-view {
                padding: 10px 5px !important;
                overflow-y: auto !important;
            }
            
            .map-title {
                font-size: 18px;
                margin-bottom: 5px;
            }
            
            .map-grid {
                padding: 0 5px 40px 60px;
            }
            
            .map-row {
                padding: 10px 0;
                gap: 8px;
                justify-content: flex-start;
                flex-wrap: wrap;
            }
        
            .map-row::before {
                left: -55px;
                font-size: 10px;
            }
            
            .map-row::after {
                font-size: 14px;
                top: -15px;
            }

            #map-subtitle {
                font-size: 12px !important;
                padding: 0 5px;
                line-height: 1.3;
            }
            
            .map-row:last-child::after {
                font-size: 12px;
                bottom: -25px;
            }
            
            .map-node {
                width: 45px;
                height: 45px;
                font-size: 18px;
                border: 2px solid transparent;
            }
        
            .map-node.enemy {
                width: 50px !important;
                height: 50px !important;
                border-radius: 6px !important;
            }
            
            .map-node.elite {
                width: 50px;
                height: 50px;
            }
            
            .map-node.boss {
                width: 60px;
                height: 60px;
            }
        
            /* Combat */
            #combat-view {
                height: 100% !important;
            }
            
            #enemy-area {
                flex: 0 0 auto !important;
                min-height: 140px !important;
                max-height: 30vh !important;
                gap: 10px;
                padding: 10px;
                overflow-x: auto;
            }
            
            .card {
                width: 110px !important;
                min-width: 110px !important;
                padding: 10px;
                flex-shrink: 0 !important;
            }
        
             .enemy {
                min-width: 160px;
                padding: 15px;
            }
            
            .enemy-name {
                font-size: 14px;
            }
            
            .enemy-hp-bar {
                height: 10px;
                margin-bottom: 6px;
            }
            
            .enemy-intent {
                font-size: 12px;
                padding: 5px;
            }
            
            .intent-icon {
                font-size: 18px;
                margin-bottom: 3px;
            }
            
            .enemy-sprite {
                font-size: 32px;
                margin: 8px 0;
            }
        
            #player-area {
                flex: 1 !important;
                padding: 10px 8px;
                overflow-y: visible !important;
                display: flex !important;
                flex-direction: column !important;
            }
        
            .player-debuff {
                padding: 8px;
                min-height: 30px;
            }
            
            #combat-controls {
                gap: 10px;
                margin-top: auto; /* Push to bottom */
                padding-top: 10px;
            }
        
            #hand {
                gap: 6px !important;
                min-height: 140px !important;
                max-height: 160px !important;
                padding: 5px !important;
                margin-bottom: 10px !important;
                flex-wrap: nowrap !important;
                overflow-x: auto !important;
                overflow-y: hidden !important;
                -webkit-overflow-scrolling: touch !important;
            }
            
            .card {
                width: 100px !important;
                min-width: 100px !important;
                padding: 8px;
                flex-shrink: 0 !important;
            }
            
            .card:hover,
            .card:active {
                transform: translateY(-8px) !important;
            }
            
            .card-energy {
                width: 24px;
                height: 24px;
                font-size: 13px;
                top: -5px;
                right: -5px;
            }
            
            .card-name {
                font-size: 11px;
                margin-bottom: 4px;
            }
            
            .card-type {
                font-size: 9px;
                margin-bottom: 5px;
            }
            
            .card-description {
                font-size: 9px;
                line-height: 1.2;
            }
        
            #combat-controls {
                gap: 10px;
                margin-top: auto;
                padding-top: 10px;
            }
        
            .btn {
                padding: 10px 20px;
                font-size: 14px;
                min-height: 44px;
            }
        
            /* Rewards */
            #reward-view,
            #event-view,
            #rest-view,
            #treasure-view,
            #elite-reward-view,
            #boss-relic-view,
            #shop-view {
                padding: 20px 10px;
                overflow-y: auto;
            }
        
            .reward-title,
            .event-title,
            .rest-title,
            .treasure-title,
            .elite-reward-title,
            .boss-relic-title,
            .shop-title {
                font-size: 24px;
                margin-bottom: 20px;
            }
            
            #card-rewards {
                gap: 15px;
                margin-bottom: 20px;
            }

            /* Modals */
            .deck-viewer-content,
            .removal-modal-content,
            .relic-viewer-content,
            .collection-viewer-content {
                margin: 15px auto;
                padding: 15px;
            }
            
            .deck-viewer-title,
            .removal-modal-title,
            .relic-viewer-title,
            .collection-viewer-title {
                font-size: 22px;
            }
            
            .reward-card {
                width: 150px;
                padding: 15px;
            }
        
            .event-title {
                font-size: 24px;
                margin-bottom: 20px;
            }
            
            .event-description {
                font-size: 16px;
                line-height: 1.6;
                margin-bottom: 25px;
            }
            
            .event-choice {
                padding: 15px;
            }
        
            #shop-view {
                padding: 20px 15px;
            }
            
            .shop-title {
                font-size: 24px;
                margin-bottom: 20px;
            }
            
            .shop-items {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 15px;
            }
            
            .shop-item {
                padding: 15px;
            }
            
            .shop-item-price {
                font-size: 20px;
                margin-top: 10px;
            }
        
            .rest-title {
                font-size: 24px;
                margin-bottom: 25px;
            }
            
            .rest-options {
                gap: 20px;
            }
            
            .rest-option {
                width: 250px;
                padding: 30px 20px;
            }
            
            .rest-option-icon {
                font-size: 48px;
                margin-bottom: 15px;
            }
            
            .rest-option-title {
                font-size: 20px;
                margin-bottom: 10px;
            }
        
            .treasure-title {
                font-size: 28px;
                margin-bottom: 15px;
            }
        
            .treasure-subtitle {
                font-size: 16px;
                margin-bottom: 25px;
            }
        
            .treasure-choices {
                gap: 25px;
            }
        
            .treasure-relic {
                width: 240px;
                padding: 30px 20px;
            }
        
            .treasure-relic-icon {
                font-size: 70px;
                margin-bottom: 20px;
            }
        
            .treasure-relic-name {
                font-size: 20px;
            }
        
            .treasure-relic-desc {
                font-size: 15px;
            }
        
            .elite-reward-title {
                font-size: 28px;
                margin-bottom: 15px;
            }
        
            .elite-reward-subtitle {
                font-size: 16px;
                margin-bottom: 25px;
            }
        
            #relic-choices {
                gap: 20px;
                margin-bottom: 25px;
            }
        
            .relic-choice {
                width: 200px;
                padding: 20px;
            }
        
            .relic-choice-icon {
                font-size: 60px;
                margin-bottom: 15px;
            }
        
            .relic-choice-name {
                font-size: 18px;
                margin-bottom: 10px;
            }
        
            .relic-choice-desc {
                font-size: 14px;
            }
        
            .boss-relic-title {
                font-size: 32px;
                margin-bottom: 15px;
            }
        
            .boss-relic-subtitle {
                font-size: 16px;
                margin-bottom: 25px;
            }
        
            #boss-relic-choices {
                gap: 20px;
            }
        
            .boss-relic-choice {
                width: 240px;
                padding: 20px;
            }
        
            .boss-relic-choice::before {
                font-size: 24px;
                width: 35px;
                height: 35px;
                top: -12px;
                right: -12px;
            }
        
            .boss-relic-choice-icon {
                font-size: 70px;
            }
        
            .boss-relic-choice-name {
                font-size: 20px;
            }
        
            .boss-relic-choice-desc {
                font-size: 14px;
            }
        
            /* Modals */
            .game-over-content {
                padding: 30px 20px;
            }
            
            .game-over-title {
                font-size: 48px;
                margin-bottom: 20px;
            }
        
            .deck-viewer-content,
            .removal-modal-content,
            .relic-viewer-content {
                margin: 20px auto;
                padding: 15px;
            }
        
            .deck-viewer-title {
                font-size: 24px;
            }
        
            .deck-viewer-close,
            .relic-viewer-close {
                font-size: 28px;
            }
        
            .deck-viewer-stats {
                gap: 15px;
                font-size: 14px;
                flex-wrap: wrap;
            }
        
            .deck-viewer-cards {
                grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
                gap: 12px;
            }
        
            .relic-viewer-title {
                font-size: 24px;
            }
        
            .relic-viewer-relics {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 15px;
            }
        
            .relic-viewer-item {
                padding: 15px;
            }
        
            .relic-viewer-icon {
                font-size: 48px;
                margin-bottom: 10px;
            }
        
            .relic-viewer-name {
                font-size: 16px;
            }
        
            .relic-viewer-desc {
                font-size: 12px;
            }
        
            /* Collection */
            .collection-viewer-content {
                margin: 20px auto;
                padding: 15px;
            }
        
            .collection-viewer-title {
                font-size: 24px;
            }
        
            .collection-viewer-close {
                font-size: 28px;
            }
        
            #collection-cards-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 15px;
            }
        
            #collection-relics-grid {
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                gap: 15px;
            }
        }
        
        /* Extra small phones */
        @media (max-width: 400px) {
            #game-header {
                padding: 6px 8px;
            }
            
            .stat-display {
                font-size: 11px;
                gap: 6px;
            }
            
            .map-node {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }
            
            .card {
                width: 90px !important;
                min-width: 90px !important;
                padding: 6px;
            }
            
            .card-name {
                font-size: 10px;
            }
            
            .card-description {
                font-size: 8px;
            }
            
            #hand {
                min-height: 130px !important;
            }
        }
        
        /* Landscape mobile - compact layout */
        @media screen and (orientation: landscape) and (max-height: 500px) {
            #seed-view,
            #starting-choices-view {
                padding: 10px !important;
            }
            
            #seed-view h1 {
                font-size: 28px !important;
                margin: 5px 0 !important;
            }
            
            #seed-view p {
                font-size: 16px !important;
                margin: 5px 0 !important;
            }
            
            #seed-view > div {
                gap: 8px !important;
            }
            
            #seed-view button {
                padding: 10px 16px !important;
                font-size: 14px !important;
                margin: 3px 0 !important;
            }
            
            #seed-view input[type="text"] {
                padding: 10px !important;
                font-size: 14px !important;
            }
            
            #seed-view label {
                font-size: 14px !important;
                margin-bottom: 5px !important;
            }
            
            #ascension-selector {
                margin-bottom: 8px !important;
            }
            
            #ascension-current {
                font-size: 32px !important;
            }
            
            #ascension-description {
                padding: 10px !important;
            }
            
            #ascension-description h4 {
                font-size: 16px !important;
                margin-bottom: 5px !important;
            }
            
            #ascension-description p {
                font-size: 12px !important;
            }
            
            .starting-choices-title {
                font-size: 20px !important;
                margin-bottom: 8px !important;
            }
            
            .starting-choices-subtitle {
                font-size: 12px !important;
                margin-bottom: 10px !important;
            }
            
            .starting-choices-grid {
                gap: 12px !important;
            }
            
            .starting-choice {
                padding: 12px !important;
            }
            
            .starting-choice-icon {
                font-size: 36px !important;
                margin-bottom: 8px !important;
            }
            
            .starting-choice-name {
                font-size: 16px !important;
                margin-bottom: 8px !important;
            }
            
            .starting-choice-benefit,
            .starting-choice-drawback {
                font-size: 12px !important;
                margin: 4px 0 !important;
                padding-left: 16px !important;
            }
            
            .starting-choice-flavor {
                font-size: 11px !important;
                margin-top: 8px !important;
                padding-top: 8px !important;
            }
        }
        </style>
</head>
<body>
    <div id="game-container">
        <!-- Header -->
        <div id="game-header">
            <div class="stat-display">
                <div class="stat">
                    <span class="stat-label">HP:</span>
                    <div class="hp-bar">
                        <div class="hp-fill" id="player-hp-fill"></div>
                    </div>
                    <span class="stat-value" id="player-hp-text">80/80</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Energy:</span>
                    <span class="stat-value" id="player-energy">3/3</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Gold:</span>
                    <span class="stat-value" id="player-gold">üí∞ 0</span>
                </div>
                <div class="stat" id="seed-display-container" style="display: none;">
                    <span class="stat-label">Seed:</span>
                    <span class="stat-value" id="seed-display" style="cursor: pointer; user-select: all;" title="Click to copy">-</span>
                </div>
            </div>
            <div class="floor-indicator">Act 1: Arithmetic Floor</div>
            <div style="display: flex; align-items: center; gap: 15px;">
                <button class="btn" id="view-deck-btn" style="padding: 8px 15px; font-size: 14px; background: linear-gradient(135deg, #9b59b6, #8e44ad); min-height: 36px;">
                    üìö Deck
                </button>
                <button class="btn" id="view-relics-btn" style="padding: 8px 15px; font-size: 14px; background: linear-gradient(135deg, #f39c12, #e67e22); min-height: 36px;">
                    ‚ú® Relics
                </button>
                <div id="relics-display"></div>
            </div>
        </div>

        <!-- Main Game Area -->
        <div id="game-main">
            <!-- Seed Selection View -->
            <div id="seed-view" style="
                display: flex; 
                flex-direction: column; 
                justify-content: flex-start; 
                align-items: center; 
                height: 100vh;
                height: calc(var(--vh, 1vh) * 100);
                overflow-y: auto;
                overflow-x: hidden;
                -webkit-overflow-scrolling: touch;
                padding: 20px 20px 30px;
            ">
                <div style="max-width: 500px; width: 100%; display: flex; flex-direction: column; gap: 15px;">
                    <!-- Title -->
                    <h1 style="font-size: 48px; margin: 10px 0; color: #4a90e2; text-align: center;">üè∞ Mathspire üè∞</h1>
                    <p style="font-size: 20px; margin: 5px 0 20px; color: #888; text-align: center;">Enter the Tower of Mathematical Mastery</p>
                    
                    <!-- Seed Input -->
                    <div style="margin-bottom: 10px;">
                        <label for="seed-input" style="display: block; margin-bottom: 10px; font-size: 16px;">
                            Enter Seed (optional):
                        </label>
                        <input 
                            type="text" 
                            id="seed-input" 
                            placeholder="Leave blank for random seed"
                            style="width: 100%; padding: 12px; font-size: 16px; background: rgba(0,0,0,0.3); border: 2px solid #4a90e2; border-radius: 8px; color: #fff;"
                        />
                    </div>
                    
                    <!-- Ascension Level Selector -->
                    <div id="ascension-selector" style="margin-bottom: 10px; display: none;">
                        <label style="display: block; margin-bottom: 10px; font-size: 16px;">
                            üî• Ascension Level:
                        </label>
                        
                        <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                            <button id="ascension-decrease" class="btn" style="width: 50px; height: 50px; font-size: 24px; padding: 0;">
                                ‚àí
                            </button>
                            
                            <div style="flex: 1; text-align: center;">
                                <div id="ascension-current" style="font-size: 48px; font-weight: bold; color: #ffd36a;">
                                    0
                                </div>
                                <div id="ascension-max-display" style="font-size: 14px; color: #888; margin-top: 5px;">
                                    Max: 0
                                </div>
                            </div>
                            
                            <button id="ascension-increase" class="btn" style="width: 50px; height: 50px; font-size: 24px; padding: 0;">
                                +
                            </button>
                        </div>
                        
                        <!-- Ascension Slider -->
                        <input 
                            type="range" 
                            id="ascension-slider" 
                            min="0" 
                            max="0" 
                            value="0"
                            style="width: 100%; margin-bottom: 15px;"
                        />
                        
                        <!-- Ascension Info -->
                        <div id="ascension-description" style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; border: 1px solid #4a90e2;">
                            <h4 style="margin-bottom: 10px; color: #4a90e2;">Ascension 0</h4>
                            <p style="font-size: 14px; color: #ccc; line-height: 1.5;">
                                Standard difficulty. No modifiers.
                            </p>
                        </div>
                        
                        <!-- Skills Progress Display -->
                        <div id="skills-progress-display" style="margin-top: 15px; padding: 12px; background: rgba(139, 255, 176, 0.1); border: 1px solid rgba(139, 255, 176, 0.3); border-radius: 6px; text-align: center;">
                            <p style="font-size: 14px; color: #8bffb0;">
                                üìö <span id="completed-skills-count">0</span> skills completed
                            </p>
                            <p style="font-size: 12px; color: #888; margin-top: 5px;">
                                Complete more skills to unlock higher ascensions!
                            </p>
                        </div>
                    </div>
                    
                    <!-- Buttons Container -->
                    <div style="display: flex; flex-direction: column; gap: 10px; width: 100%; margin-top: 10px;">
                        <!-- View Collection Button -->
                        <button id="view-collection-btn" class="btn btn-secondary" style="width: 100%; font-size: 18px; padding: 15px; background: linear-gradient(135deg, #9b59b6, #8e44ad);">
                            üìö View Collection
                        </button>
                        
                        <button id="start-with-seed-btn" class="btn btn-end-turn" style="width: 100%; font-size: 18px; padding: 15px;">
                            üéÆ Start with Seed
                        </button>
                        
                        <button id="random-seed-btn" class="btn btn-secondary" style="width: 100%; font-size: 18px; padding: 15px;">
                            üé≤ Random Seed
                        </button>
                    </div>
                </div>
            </div>

            <!-- Collection Viewer Modal -->
            <div id="collection-viewer" style="display: none;">
                <div class="collection-viewer-content">
                    <div class="collection-viewer-header">
                        <h2 class="collection-viewer-title">üìö Card & Relic Collection</h2>
                        <button class="collection-viewer-close" onclick="closeCollectionViewer()">‚úï</button>
                    </div>
                    
                    <div class="collection-tabs">
                        <button class="collection-tab active" onclick="showCollectionTabStatic('cards')">
                            üÉè Cards
                        </button>
                        <button class="collection-tab" onclick="showCollectionTabStatic('relics')">
                            ‚ú® Relics
                        </button>
                    </div>
                    
                    <div id="collection-cards-tab" class="collection-tab-content">
                        <div id="collection-cards-grid"></div>
                    </div>
                    
                    <div id="collection-relics-tab" class="collection-tab-content" style="display: none;">
                        <div id="collection-relics-grid"></div>
                    </div>
                </div>
            </div>

            <!-- Starting Choices View -->
            <div id="starting-choices-view">
                <h1 class="starting-choices-title">üìù Placement Test üìù</h1>
                <p class="starting-choices-subtitle">
                    Before entering the Tower of Mastery, choose your starting advantage.<br/>
                    Each path offers unique benefits and challenges!
                </p>
                <div class="starting-choices-grid" id="starting-choices-grid"></div>
            </div>

            <!-- Map View -->
            <div id="map-view">
                <h1 class="map-title">üè∞ The Tower of Mastery üè∞</h1>
                <div id="map-subtitle" style="text-align: center; font-size: 18px; color: #888; margin-bottom: 20px;">
                    Climb upward to face Mr. PEMDAS at the summit! ‚¨ÜÔ∏è
                </div>
                <div id="map-grid" class="map-grid"></div>
                <div style="text-align: center; font-size: 24px; color: #4a90e2; margin-top: 20px; font-weight: bold;">
                    üìç START HERE
                </div>
            </div>

            <!-- Combat View -->
            <div id="combat-view">
                <div id="enemy-area"></div>
                <div id="player-area">
                    <div id="player-debuffs"></div>
                    <div id="hand"></div>
                    <div id="combat-controls">
                        <button class="btn btn-end-turn" onclick="game.endTurn()">End Turn</button>
                    </div>
                </div>
            </div>

            <!-- Reward View -->
            <div id="reward-view">
                <h1 class="reward-title">Victory!</h1>
                <p style="font-size: 20px; margin-bottom: 30px;">Choose one card to add to your deck:</p>
                <div id="card-rewards"></div>
                <button class="btn btn-end-turn" onclick="game.skipReward()">Skip Reward</button>
            </div>

            <!-- Event View -->
            <div id="event-view">
                <h1 class="event-title" id="event-title"></h1>
                <p class="event-description" id="event-description"></p>
                <div class="event-choices" id="event-choices"></div>
            </div>

            <!-- Shop View -->
            <div id="shop-view">
                <h1 class="shop-title">üè™ The Math Merchant</h1>
                <div class="shop-items" id="shop-items"></div>
                <button class="btn btn-end-turn" onclick="game.leaveShop()" style="margin-top: 30px;">Leave Shop</button>
            </div>

            <!-- Rest View -->
            <div id="rest-view">
                <h1 class="rest-title">üî• Rest Site</h1>
                <div class="rest-options">
                    <div class="rest-option" onclick="game.restHeal()">
                        <div class="rest-option-icon">‚ù§Ô∏è</div>
                        <div class="rest-option-title">Rest</div>
                        <p>Restore 30% of your max HP</p>
                    </div>
                    <div class="rest-option" onclick="game.restUpgrade()">
                        <div class="rest-option-icon">‚≠ê</div>
                        <div class="rest-option-title">Review Concepts</div>
                        <p>Upgrade a card in your deck</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Treasure View -->
        <div id="treasure-view">
            <h1 class="treasure-title">‚ú® Treasure Room ‚ú®</h1>
            <p class="treasure-subtitle">Choose one relic to take with you</p>
            <div class="treasure-choices" id="treasure-choices"></div>
            <button class="btn btn-end-turn" onclick="game.skipTreasure()" style="margin-top: 30px; background: linear-gradient(135deg, #95a5a6, #7f8c8d);">
                Leave Empty-Handed
            </button>
        </div>

        <!-- Game Over Screens -->
        <div id="victory-screen" class="game-over victory">
            <div class="game-over-content">
                <div class="game-over-title">üéâ VICTORY! üéâ</div>
                <p style="font-size: 24px; margin-bottom: 20px;">You defeated Mr. PEMDAS!</p>
                <p style="font-size: 16px; margin-bottom: 30px; color: #888;" id="victory-seed">
                    Seed: <span id="victory-seed-value" style="user-select: all; cursor: pointer; color: #4a90e2;" onclick="game.copySeed()" title="Click to copy"></span>
                </p>
                <div style="display: flex; gap: 15px; justify-content: center;">
                    <button class="btn btn-end-turn" onclick="location.reload()">New Run</button>
                    <button class="btn btn-end-turn" onclick="game.copySeed()" style="background: linear-gradient(135deg, #3498db, #2980b9);">
                        üìã Copy Seed
                    </button>
                </div>
            </div>
        </div>

        <div id="defeat-screen" class="game-over defeat">
            <div class="game-over-content">
                <div class="game-over-title">üíÄ DEFEAT üíÄ</div>
                <p style="font-size: 24px; margin-bottom: 20px;">The tower proved too challenging...</p>
                <p style="font-size: 16px; margin-bottom: 30px; color: #888;" id="defeat-seed">
                    Seed: <span id="defeat-seed-value" style="user-select: all; cursor: pointer; color: #4a90e2;" onclick="game.copySeed()" title="Click to copy"></span>
                </p>
                <div style="display: flex; gap: 15px; justify-content: center;">
                    <button class="btn btn-end-turn" onclick="location.reload()">Try Again</button>
                    <button class="btn btn-end-turn" onclick="game.copySeed()" style="background: linear-gradient(135deg, #3498db, #2980b9);">
                        üìã Copy Seed
                    </button>
                </div>
            </div>
        </div>

        <!-- Deck Viewer -->
        <div id="deck-viewer">
            <div class="deck-viewer-content">
                <div class="deck-viewer-header">
                    <h1 class="deck-viewer-title">üìö Your Deck</h1>
                    <button class="deck-viewer-close" onclick="game.hideDeckViewer()">‚úñ</button>
                </div>
                <div class="deck-viewer-stats">
                    <div><strong>Total Cards:</strong> <span id="deck-total-count">0</span></div>
                    <div><strong>Attack:</strong> <span id="deck-attack-count">0</span></div>
                    <div><strong>Skill:</strong> <span id="deck-skill-count">0</span></div>
                    <div><strong>Power:</strong> <span id="deck-power-count">0</span></div>
                    <div><strong>Utility:</strong> <span id="deck-utility-count">0</span></div>
                    <div style="color: #8b0000;"><strong>Curses:</strong> <span id="deck-curse-count">0</span></div>
                </div>
                <div class="deck-viewer-cards" id="deck-viewer-cards"></div>
            </div>
        </div>

        <!-- Card Removal Modal -->
        <div id="card-removal-modal">
            <div class="removal-modal-content">
                <h2 class="removal-modal-title">üóëÔ∏è Remove a Card</h2>
                <p style="text-align: center; font-size: 18px; margin-bottom: 10px;">
                    Select a card to remove from your deck
                </p>
                <p style="text-align: center; font-size: 16px; color: #f39c12; margin-bottom: 20px;">
                    Cost: <span id="removal-cost">75</span> Gold
                </p>
                <div class="removal-cards" id="removal-cards"></div>
                <div style="text-align: center; margin-top: 30px;">
                    <button class="btn btn-end-turn" onclick="game.closeRemovalModal()">Cancel</button>
                </div>
            </div>
        </div>

        <!-- Relic Viewer -->
        <div id="relic-viewer">
            <div class="relic-viewer-content">
                <div class="relic-viewer-header">
                    <h1 class="relic-viewer-title">‚ú® Your Relics</h1>
                    <button class="relic-viewer-close" onclick="game.hideRelicViewer()">‚úñ</button>
                </div>
                <div class="relic-viewer-relics" id="relic-viewer-relics"></div>
            </div>
        </div>

        <!-- Elite Reward View -->
        <div id="elite-reward-view">
            <h1 class="elite-reward-title">üíé Elite Victory! üíé</h1>
            <p class="elite-reward-subtitle">Choose a powerful relic as your reward</p>
            <div id="relic-choices"></div>
            <button class="btn btn-end-turn" onclick="game.skipRelicReward()">Skip Relic</button>
        </div>

        <!-- Boss Relic Reward View -->
        <div id="boss-relic-view">
            <h1 class="boss-relic-title">üëë BOSS DEFEATED! üëë</h1>
            <p class="boss-relic-subtitle">‚ö†Ô∏è Choose ONE Powerful Boss Relic - Great power comes with a price! ‚ö†Ô∏è</p>
            <div id="boss-relic-choices"></div>
            <button class="btn btn-end-turn" onclick="game.skipBossRelic()" style="background: linear-gradient(135deg, #95a5a6, #7f8c8d);">
                Skip (Keep Current Build)
            </button>
        </div>
    </div>

    <script>
        // Mobile viewport fix - MUST BE FIRST
        (function() {
            // Set proper viewport height
            function setViewportHeight() {
                const vh = window.innerHeight * 0.01;
                document.documentElement.style.setProperty('--vh', `${vh}px`);
            }
            
            setViewportHeight();
            window.addEventListener('resize', setViewportHeight);
            window.addEventListener('orientationchange', () => {
                setTimeout(setViewportHeight, 100); // Small delay after orientation change
            });
            
            // Gentler double-tap prevention - only prevent on non-interactive elements
            let lastTouchEnd = 0;
            document.addEventListener('touchend', function(event) {
                const now = Date.now();
                const target = event.target;
                
                // Only prevent double-tap zoom on non-button/input elements
                if (now - lastTouchEnd <= 300 && 
                    !target.matches('button, .btn, .card, .map-node, input, select, .starting-choice')) {
                    event.preventDefault();
                }
                lastTouchEnd = now;
            }, false);
        })();

        // Convert string seed to number
        function seedToNumber(seedStr) {
            // If no seed provided or empty, generate random
            if (seedStr === undefined || seedStr === null || seedStr === '') {
                return Math.floor(Math.random() * 2147483647);
            }
            
            // Convert string to hash
            let hash = 0;
            for (let i = 0; i < seedStr.length; i++) {
                hash = ((hash << 5) - hash) + seedStr.charCodeAt(i);
                hash = hash & hash; // Convert to 32-bit integer
            }
            return Math.abs(hash);
        }

        // Game Data
        const CARD_DATABASE = {
            // Addition Node
            sumItUp: {
                name: "Sum It Up",
                type: "utility",
                energy: 1,
                description: "+2 to all numeric effects this turn",
                rarity: "common",
                effect: (game) => {
                    game.addModifier('numericBonus', 2);
                }
            },
            cumulativeStrike: {
                name: "Cumulative Strike",
                type: "attack",
                energy: 1,
                description: "Deal 4 damage. +2 damage per attack played this turn.",
                rarity: "uncommon",
                effect: (game) => {
                    let damage = 4 + (game.attacksPlayedThisTurn * 2);
                    game.dealDamage(damage);
                    game.attacksPlayedThisTurn++;
                }
            },
            overflow: {
                name: "Overflow",
                type: "attack",
                energy: 2,
                description: "Repeat your last attack",
                rarity: "rare",
                effect: (game) => {
                    if (game.lastAttackCard) {
                        game.lastAttackCard.effect(game);
                    }
                }
            },

            // Subtraction Node
            subtractBlock: {
                name: "Subtract Block",
                type: "skill",
                energy: 1,
                description: "Gain 7 Block",
                rarity: "common",
                effect: (game) => {
                    game.gainBlock(7);
                }
            },
            negativeSpace: {
                name: "Negative Space",
                type: "skill",
                energy: 2,
                description: "Next enemy attack deals half damage",
                rarity: "uncommon",
                effect: (game) => {
                    game.addModifier('halfDamage', 1);
                }
            },
            cancelOut: {
                name: "Cancel Out",
                type: "utility",
                energy: 2,
                description: "Remove all enemy buffs",
                rarity: "rare",
                effect: (game) => {
                    game.removeAllEnemyBuffs();
                }
            },

            // Multiplication Node
            powerStrike: {
                name: "Power Strike",
                type: "attack",
                energy: 1,
                description: "Deal 10 damage",
                rarity: "common",
                effect: (game) => {
                    game.dealDamage(10);
                }
            },
            chainMultiply: {
                name: "Chain Multiply",
                type: "skill",
                energy: 2,
                description: "Each attack this turn deals +50% damage",
                rarity: "uncommon",
                effect: (game) => {
                    game.addModifier('damageMultiplier', 0.5);
                }
            },
            exponentialBurst: {
                name: "Exponential Burst",
                type: "power",
                energy: 3,
                description: "Double attack damage (lasts 2 turns)",
                rarity: "rare",
                effect: (game) => {
                    game.addModifier('doubleAttack', 2);
                }
            },

            // Division Node
            evenSplit: {
                name: "Even Split",
                type: "attack",
                energy: 1,
                description: "Deal 8 damage split among all enemies",
                rarity: "common",
                effect: (game) => {
                    const damagePerEnemy = Math.ceil(8 / game.enemies.length);
                    game.enemies.forEach(enemy => {
                        game.dealDamageToEnemy(enemy, damagePerEnemy);
                    });
                }
            },
            reduceFraction: {
                name: "Reduce Fraction",
                type: "skill",
                energy: 1,
                description: "Remove 1 debuff and gain 6 Block",
                rarity: "uncommon",
                effect: (game) => {
                    game.removeDebuff();
                    game.gainBlock(6);
                }
            },
            remainderBoost: {
                name: "Remainder Boost",
                type: "power",
                energy: 2,
                description: "Unplayable cards grant +1 Energy",
                rarity: "rare",
                effect: (game) => {
                    game.addModifier('remainderBoost', -1); // -1 means permanent
                }
            },
            cleanse: {
                name: "Cleanse",
                type: "skill",
                energy: 1,
                description: "Remove all debuffs. Gain 4 Block.",
                rarity: "rare",
                effect: (game) => {
                    game.player.debuffs = {};
                    game.gainBlock(4);
                }
            },

            // PEMDAS Node
            parenthesis: {
                name: "Parenthesis",
                type: "skill",
                energy: 1,
                description: "Play a card twice this turn",
                rarity: "common",
                effect: (game) => {
                    game.addModifier('doubleNext', 1);
                }
            },
            sequenceStep: {
                name: "Sequence Step",
                type: "utility",
                energy: 1,
                description: "Draw 2 cards",
                rarity: "uncommon",
                effect: (game) => {
                    game.drawCards(2);
                }
            },
            equationBurst: {
                name: "Equation Burst",
                type: "attack",
                energy: 3,
                description: "Deal 7 damage 3 times",
                rarity: "rare",
                effect: (game) => {
                    for (let i = 0; i < 3; i++) {
                        game.dealDamage(7);
                    }
                }
            },

            // Basic Strikes and Defends
            strike: {
                name: "Strike",
                type: "attack",
                energy: 1,
                description: "Deal 6 damage",
                rarity: "basic",
                effect: (game) => {
                    game.dealDamage(6);
                }
            },
            defend: {
                name: "Defend",
                type: "skill",
                energy: 1,
                description: "Gain 5 Block",
                rarity: "basic",
                effect: (game) => {
                    game.gainBlock(5);
                }
            },

            // Curse Cards
            doubt: {
                name: "Doubt",
                type: "curse",
                energy: -1,
                description: "Unplayable. Clogs your hand.",
                rarity: "curse",
                effect: (game) => {
                    // Cannot be played
                }
            },
            confusion: {
                name: "Confusion",
                type: "curse",
                energy: 1,
                description: "Exhaust. Does nothing.",
                rarity: "curse",
                effect: (game) => {
                    // Just wastes energy
                }
            },
            pain: {
                name: "Pain",
                type: "curse",
                energy: -1,
                description: "Unplayable. At end of turn, lose 2 HP.",
                rarity: "curse",
                effect: (game) => {
                    // Cannot be played, damage applied at end of turn
                }
            },
            regret: {
                name: "Regret",
                type: "curse",
                energy: -1,
                description: "Unplayable. All cards cost 1 more energy this turn.",
                rarity: "curse",
                effect: (game) => {
                    // Cannot be played, effect applied passively
                }
            },
            frustration: {
                name: "Frustration",
                type: "curse",
                energy: 2,
                description: "Cannot be removed at shops. Does nothing.",
                rarity: "curse",
                effect: (game) => {
                    // Wastes energy and can't be removed easily
                }
            },
            burden: {
                name: "Burden",
                type: "curse",
                energy: -1,
                description: "Unplayable. Draw 1 less card at start of turn.",
                rarity: "curse",
                effect: (game) => {
                    // Cannot be played, effect applied passively
                }
            }
        };

        const ENEMY_DATABASE = {
            // ===== BASIC ENEMIES (Small/Simple) - 20-30 HP =====
            plusBug: {
                name: "Plus Bug",
                hp: 22,
                maxHp: 22,
                sprite: "üêõ",
                tier: "basic",
                patterns: [
                    { intent: "attack", value: 4 },
                    { intent: "attack", value: 5 },
                    { intent: "defend", value: 3 }
                ]
            },
            minusMite: {
                name: "Minus Mite",
                hp: 25,
                maxHp: 25,
                sprite: "ü¶ü",
                tier: "basic",
                patterns: [
                    { intent: "attack", value: 5 },
                    { intent: "attack", value: 6 },
                    { intent: "defend", value: 4 }
                ]
            },
            divisionDot: {
                name: "Division Dot",
                hp: 20,
                maxHp: 20,
                sprite: "‚Ä¢",
                tier: "basic",
                patterns: [
                    { intent: "attack", value: 3 },
                    { intent: "attack", value: 3 },
                    { intent: "attack", value: 6 }
                ]
            },

            // ===== MEDIUM ENEMIES - 35-50 HP =====
            timesToad: {
                name: "Times Toad",
                hp: 38,
                maxHp: 38,
                sprite: "üê∏",
                tier: "medium",
                patterns: [
                    { intent: "attack", value: 6 },
                    { intent: "attack", value: 9 },
                    { intent: "debuff", value: 1, debuffType: "exposed", debuffName: "Exposed" }
                ]
            },
            equationBat: {
                name: "Equation Bat",
                hp: 42,
                maxHp: 42,
                sprite: "ü¶á",
                tier: "medium",
                patterns: [
                    { intent: "attack", value: 5, debuff: "confused", debuffStacks: 1 },
                    { intent: "defend", value: 6 },
                    { intent: "attack", value: 7 }
                ]
            },
            factorialFox: {
                name: "Factorial Fox",
                hp: 45,
                maxHp: 45,
                sprite: "ü¶ä",
                tier: "medium",
                patterns: [
                    { intent: "attack", value: 4 },
                    { intent: "attack", value: 8 },
                    { intent: "attack", value: 12 },
                    { intent: "defend", value: 5 }
                ]
            },

            // ===== LARGE ENEMIES - 50-65 HP =====
            divvySlime: {
                name: "Divvy Slime",
                hp: 55,
                maxHp: 55,
                sprite: "ü¶†",
                tier: "large",
                patterns: [
                    { intent: "attack", value: 8 },
                    { intent: "defend", value: 10 },
                    { intent: "debuff", value: 2, debuffType: "slowed", debuffName: "Slowed" },
                    { intent: "attack", value: 6, debuff: "distracted", debuffStacks: 1 }
                ]
            },
            exponentEagle: {
                name: "Exponent Eagle",
                hp: 50,
                maxHp: 50,
                sprite: "ü¶Ö",
                tier: "large",
                patterns: [
                    { intent: "attack", value: 7 },
                    { intent: "attack", value: 10, debuff: "exposed", debuffStacks: 1 },
                    { intent: "buff", value: 2 },
                    { intent: "attack", value: 14 }
                ]
            },
            rootRhino: {
                name: "Root Rhino",
                hp: 65,
                maxHp: 65,
                sprite: "ü¶è",
                tier: "large",
                patterns: [
                    { intent: "defend", value: 12 },
                    { intent: "attack", value: 12 },
                    { intent: "attack", value: 8, debuff: "slowed", debuffStacks: 1 },
                    { intent: "attack", value: 15 }
                ]
            },

            // ===== ELITE ENEMIES - 70-90 HP =====
            conceptGuardian: {
                name: "Concept Guardian",
                hp: 75,
                maxHp: 75,
                sprite: "üõ°Ô∏è",
                tier: "elite",
                hasPersistentBlock: true,
                patterns: [
                    { intent: "defend", value: 12 },  // Builds up block
                    { intent: "attack", value: 10, debuff: "exposed", debuffStacks: 1 },
                    { intent: "defend", value: 15 },  // More block
                    { intent: "attack", value: 12 },
                    { intent: "buff", value: 3 },
                    { intent: "debuff", value: 2, debuffType: "distracted", debuffName: "Distracted" }
                ]
            },
            variableViper: {
                name: "Variable Viper",
                hp: 70,
                maxHp: 70,
                sprite: "üêç",
                tier: "elite",
                patterns: [
                    { intent: "attack", value: 8, debuff: "confused", debuffStacks: 2 },
                    { intent: "debuff", value: 2, debuffType: "exposed", debuffName: "Exposed" },
                    { intent: "attack", value: 11 },
                    { intent: "attack", value: 6, debuff: "slowed", debuffStacks: 1 },
                    { intent: "special", value: 15, name: "Variable Strike", debuff: "confused", debuffStacks: 1, additionalDebuff: "distracted", additionalStacks: 1 }
                ]
            },
            theoremTitan: {
                name: "Theorem Titan",
                hp: 90,
                maxHp: 90,
                sprite: "üóø",
                tier: "elite",
                hasPersistentBlock: true,
                patterns: [
                    { intent: "defend", value: 18 },  // Heavy block
                    { intent: "attack", value: 14, debuff: "exposed", debuffStacks: 2 },
                    { intent: "defend", value: 20 },  // More heavy block
                    { intent: "buff", value: 4 },
                    { intent: "attack", value: 10, debuff: "slowed", debuffStacks: 2 },
                    { intent: "attack", value: 16 }
                ]
            },
            
            // ===== BOSS ENEMIES - 100-150 HP =====
            mrPemdas: {
                name: "Mr. PEMDAS",
                hp: 120,
                maxHp: 120,
                sprite: "üëî",
                tier: "boss",
                hasPersistentBlock: true,
                patterns: [
                    { intent: "attack", value: 9, debuff: "confused", debuffStacks: 1 },
                    { intent: "defend", value: 12 },  // Builds defensive stance
                    { intent: "attack", value: 12 },
                    { intent: "defend", value: 15 },  // More defense
                    { intent: "attack", value: 15, debuff: "exposed", debuffStacks: 2 },
                    { intent: "special", value: 22, name: "Order of Operations", debuff: "confused", debuffStacks: 2, additionalDebuff: "exposed", additionalStacks: 2 },
                    { intent: "debuff", value: 3, debuffType: "slowed", debuffName: "Slowed" }
                ]
            },
            professorCalculus: {
                name: "Professor Calculus",
                hp: 140,
                maxHp: 140,
                sprite: "üë®‚Äçüè´",
                tier: "boss",
                patterns: [
                    { intent: "attack", value: 10, debuff: "distracted", debuffStacks: 2 },
                    { intent: "defend", value: 20 },
                    { intent: "buff", value: 5 },
                    { intent: "attack", value: 14, debuff: "confused", debuffStacks: 2 },
                    { intent: "special", value: 8, name: "Derivative Strike", debuff: "slowed", debuffStacks: 3 },
                    { intent: "attack", value: 18 },
                    { intent: "special", value: 25, name: "Integration Blast", debuff: "exposed", debuffStacks: 3, additionalDebuff: "confused", additionalStacks: 2 }
                ]
            },
            theInfinity: {
                name: "The Infinity",
                hp: 100,
                maxHp: 100,
                sprite: "‚àû",
                tier: "boss",
                patterns: [
                    { intent: "attack", value: 12 },
                    { intent: "attack", value: 8, debuff: "confused", debuffStacks: 1 },
                    { intent: "buff", value: 3 },
                    { intent: "debuff", value: 2, debuffType: "exposed", debuffName: "Exposed" },
                    { intent: "special", value: 20, name: "Endless Loop", debuff: "slowed", debuffStacks: 2, additionalDebuff: "distracted", additionalStacks: 2 },
                    { intent: "defend", value: 25 },
                    { intent: "attack", value: 16, debuff: "exposed", debuffStacks: 2 },
                    { intent: "special", value: 30, name: "Infinity Collapse" }
                ]
            },
            // ACT 2 ENEMIES - More advanced math concepts
            logarithmLion: {
                name: 'Logarithm Lion',
                hp: 55,
                tier: 'medium',
                sprite: 'ü¶Å',
                patterns: [
                    { type: 'attack', damage: 10, intent: '‚öîÔ∏è Attack 10' },
                    { type: 'attack', damage: 10, intent: '‚öîÔ∏è Attack 10' },
                    { type: 'debuff', effect: 'confused', duration: 2, intent: 'üòµ Confuse' }
                ]
            },

            matrixMammoth: {
                name: 'Matrix Mammoth',
                hp: 70,
                tier: 'large',
                sprite: 'ü¶£',
                patterns: [
                    { type: 'attack', damage: 14, intent: '‚öîÔ∏è Attack 14' },
                    { type: 'attack', damage: 14, intent: '‚öîÔ∏è Attack 14' },
                    { type: 'defend', block: 15, intent: 'üõ°Ô∏è Block 15' }
                ]
            },

            derivativeDragon: {
                name: 'Derivative Dragon',
                hp: 65,
                tier: 'large',
                sprite: 'üêâ',
                patterns: [
                    { type: 'attack', damage: 12, intent: '‚öîÔ∏è Attack 12' },
                    { type: 'attack', damage: 16, intent: '‚öîÔ∏è Attack 16' },
                    { type: 'attack', damage: 20, intent: '‚öîÔ∏è Attack 20' }
                ]
            },

            integralIguana: {
                name: 'Integral Iguana',
                hp: 60,
                tier: 'medium',
                sprite: 'ü¶é',
                patterns: [
                    { type: 'attack', damage: 8, intent: '‚öîÔ∏è Attack 8' },
                    { type: 'attack', damage: 8, intent: '‚öîÔ∏è Attack 8' },
                    { type: 'buff', effect: 'strength', amount: 3, intent: 'üí™ Gain 3 Strength' }
                ]
            },

            vectorVulture: {
                name: 'Vector Vulture',
                hp: 50,
                tier: 'medium',
                sprite: 'ü¶Ö',
                patterns: [
                    { type: 'attack', damage: 11, intent: '‚öîÔ∏è Attack 11' },
                    { type: 'attack', damage: 11, intent: '‚öîÔ∏è Attack 11' },
                    { type: 'debuff', effect: 'exposed', duration: 2, intent: 'üéØ Expose' }
                ]
            },

            probabilityPanther: {
                name: 'Probability Panther',
                hp: 58,
                tier: 'medium',
                sprite: 'üêÜ',
                patterns: [
                    { type: 'attack', damage: 9, intent: '‚öîÔ∏è Attack 9' },
                    { type: 'attack', damage: 15, intent: '‚öîÔ∏è Attack 15' },
                    { type: 'attack', damage: 9, intent: '‚öîÔ∏è Attack 9' }
                ]
            },

            // ACT 2 ELITES
            complexityColossus: {
                name: 'Complexity Colossus',
                hp: 120,
                tier: 'elite',
                sprite: 'üóø',
                hasPersistentBlock: true,
                patterns: [
                    { intent: 'defend', value: 20 },  // Heavy armor
                    { intent: 'attack', value: 18 },
                    { intent: 'defend', value: 15 },  // Maintains defense
                    { intent: 'attack', value: 12, multi: 2 },
                    { intent: 'debuff', value: 3, debuffType: 'confused', debuffName: 'Massive Confusion' }
                ]
            },
            
            recursionReaper: {
                name: 'Recursion Reaper',
                hp: 110,
                tier: 'elite',
                sprite: 'üíÄ',
                patterns: [
                    { intent: 'attack', value: 15 },
                    { intent: 'attack', value: 15 },
                    { intent: 'attack', value: 8, multi: 3 },
                    { intent: 'buff', value: 4 }
                ]
            },
            
            theoremTyrant: {
                name: 'Theorem Tyrant',
                hp: 115,
                tier: 'elite',
                sprite: 'üëπ',
                hasPersistentBlock: true,
                patterns: [
                    { intent: 'defend', value: 25 },  // Strong defense
                    { intent: 'attack', value: 20 },
                    { intent: 'defend', value: 18 },  // Maintains armor
                    { intent: 'debuff', value: 2, debuffType: 'slowed', debuffName: 'Slow' },
                    { intent: 'attack', value: 10, multi: 2 }
                ]
            },

            // ACT 2 BOSSES
            doctorDiophantus: {
                name: 'Doctor Diophantus',
                hp: 250,
                tier: 'boss',
                sprite: 'üßô‚Äç‚ôÇÔ∏è',
                patterns: [
                    { type: 'attack', damage: 25, intent: '‚öîÔ∏è Powerful Strike 25' },
                    { type: 'attack', damage: 15, multi: 2, intent: '‚öîÔ∏è‚öîÔ∏è Double Cast 15 x2' },
                    { type: 'defend', block: 30, intent: 'üõ°Ô∏è Barrier 30' },
                    { type: 'debuff', effect: 'confused', duration: 3, intent: 'üòµ Mind Warp' },
                    { type: 'buff', effect: 'strength', amount: 5, intent: 'üí™ Power Up 5' },
                    { type: 'attack', damage: 35, intent: '‚öîÔ∏è Devastating Blow 35' }
                ]
            },

            ladyLaplace: {
                name: 'Lady Laplace',
                hp: 230,
                tier: 'boss',
                sprite: 'üë∏',
                patterns: [
                    { type: 'attack', damage: 20, intent: '‚öîÔ∏è Strike 20' },
                    { type: 'attack', damage: 12, multi: 3, intent: '‚öîÔ∏è‚öîÔ∏è‚öîÔ∏è Triple Strike 12 x3' },
                    { type: 'debuff', effect: 'exposed', duration: 3, intent: 'üéØ Weakness' },
                    { type: 'defend', block: 25, intent: 'üõ°Ô∏è Shield 25' },
                    { type: 'attack', damage: 30, intent: '‚öîÔ∏è Royal Decree 30' },
                    { type: 'debuff', effect: 'distracted', duration: 2, intent: 'üí´ Distract' }
                ]
            },

            sirSigma: {
                name: 'Sir Sigma',
                hp: 270,
                tier: 'boss',
                sprite: '‚öîÔ∏èüë§',
                patterns: [
                    { type: 'attack', damage: 28, intent: '‚öîÔ∏è Slash 28' },
                    { type: 'attack', damage: 18, multi: 2, intent: '‚öîÔ∏è‚öîÔ∏è Double Slash 18 x2' },
                    { type: 'buff', effect: 'strength', amount: 6, intent: 'üí™ Summon Power 6' },
                    { type: 'defend', block: 35, intent: 'üõ°Ô∏è Iron Defense 35' },
                    { type: 'debuff', effect: 'slowed', duration: 3, intent: 'üêå Temporal Slow' },
                    { type: 'attack', damage: 40, intent: '‚öîÔ∏è Summation Strike 40' }
                ]
            }
        };

        const EVENTS = [
            {
                name: "Pop Quiz!",
                description: "A glowing equation appears before you: What is 7 √ó 8?",
                choices: [
                    { text: "Answer: 56", outcome: () => game.gainGold(15), result: "Correct! You gain 15 gold." },
                    { text: "Answer: 54", outcome: () => game.addCurse('doubt'), result: "Wrong! Doubt clouds your mind. A curse is added to your deck." },
                    { text: "Skip", outcome: () => {}, result: "You move on without answering." }
                ]
            },
            {
                name: "Forgotten Formula",
                description: "You discover an ancient mathematical scroll on the ground.",
                choices: [
                    { text: "Study it (add random card)", outcome: () => game.addRandomCard(), result: "You memorize a new technique!" },
                    { text: "Sell it", outcome: () => game.gainGold(25), result: "You sell the scroll for 25 gold." },
                    { text: "Leave it", outcome: () => game.heal(10), result: "You rest instead and heal 10 HP." }
                ]
            },
            {
                name: "Broken Calculator",
                description: "An old calculator lies broken on the floor. It might contain a useful relic...",
                choices: [
                    { text: "Repair it (-8 HP, gain relic)", outcome: () => { game.takeDamage(8); game.addRandomRelic(); }, result: "You cut yourself on the parts but fix it!" },
                    { text: "Leave it", outcome: () => {}, result: "You decide it's not worth the risk." }
                ]
            },
            {
                name: "Study Buddy",
                description: "A friendly student offers to help you with your studies.",
                choices: [
                    { text: "Share notes (add random card)", outcome: () => game.addRandomCard(), result: "You learn a new technique together!" },
                    { text: "Study alone (+8 HP)", outcome: () => game.heal(8), result: "You focus and regain your energy." }
                ]
            },
            {
                name: "Mysterious Equation",
                description: "An ominous equation hovers in the air: What is 144 √∑ 12?",
                choices: [
                    { text: "Answer: 12", outcome: () => game.addRandomRelic(), result: "Correct! The equation rewards your wisdom with a relic!" },
                    { text: "Answer: 14", outcome: () => game.addCurse('confusion'), result: "Wrong! Your mind becomes confused. A curse is added to your deck." },
                    { text: "Ignore it", outcome: () => game.addCurse('doubt'), result: "The equation punishes your cowardice with doubt." }
                ]
            },
            {
                name: "The Pressure Test",
                description: "A timer appears, rushing you to solve: 13¬≤ = ?",
                choices: [
                    { text: "Answer: 169", outcome: () => { game.gainGold(30); game.addRandomCard(); }, result: "Correct! Your quick thinking is rewarded!" },
                    { text: "Answer: 139", outcome: () => { game.addCurse('pain'); game.takeDamage(5); }, result: "Wrong! The pressure overwhelms you. Pain and damage!" },
                    { text: "Give up", outcome: () => game.addCurse('regret'), result: "You give up. Regret fills your heart." }
                ]
            },
            {
                name: "The Dark Bargain",
                description: "A shadowy figure offers you power... for a price.",
                choices: [
                    { text: "Accept (+2 rare cards, +2 curses)", outcome: () => { 
                        for(let i = 0; i < 2; i++) {
                            const rareCards = Object.keys(CARD_DATABASE).filter(id => CARD_DATABASE[id].rarity === 'rare');
                            game.deck.push(game.rng.choice(rareCards));
                        }
                        game.addCurse('pain');
                        game.addCurse('regret');
                    }, result: "You accept. Power courses through you... but at what cost?" },
                    { text: "Refuse", outcome: () => game.heal(15), result: "You refuse. Peace of mind is reward enough." }
                ]
            },
            {
                name: "Test Anxiety",
                description: "You encounter a difficult problem. Your hands shake...",
                choices: [
                    { text: "Push through (-10 HP, gain gold)", outcome: () => { game.takeDamage(10); game.gainGold(40); }, result: "You power through the anxiety and earn 40 gold." },
                    { text: "Take a break (+10 HP)", outcome: () => game.heal(10), result: "Rest helps clear your mind." },
                    { text: "Panic", outcome: () => { game.addCurse('frustration'); game.addCurse('doubt'); }, result: "You panic! Multiple curses cloud your judgment." }
                ]
            },
            {
                name: "Mental Fog",
                description: "A strange mist clouds your thinking. You feel... distracted.",
                choices: [
                    { text: "Fight it (-2 Confused, gain rare card)", outcome: () => { 
                        game.applyDebuff('confused', 2);
                        game.showDebuffNotification('confused', 2);
                        const rareCards = Object.keys(CARD_DATABASE).filter(id => CARD_DATABASE[id].rarity === 'rare');
                        game.deck.push(game.rng.choice(rareCards));
                    }, result: "You gain a powerful card, but confusion lingers." },
                    { text: "Accept it (-3 Distracted)", outcome: () => { 
                        game.applyDebuff('distracted', 3);
                        game.showDebuffNotification('distracted', 3);
                    }, result: "The fog settles in. You feel unfocused." },
                    { text: "Meditate (remove all debuffs)", outcome: () => { game.player.debuffs = {}; }, result: "You clear your mind completely." }
                ]
            },
            // ACT 2 EVENTS
            {
                name: 'The Equation Puzzle',
                description: 'You find a mysterious door with an equation lock. It reads: "2x + 5 = 13". What do you do?',
                choices: [
                    {
                        text: 'Solve it correctly (x = 4)',
                        outcome: () => {
                            game.gainGold(40);
                        },
                        result: 'The door opens! You find 40 gold inside! üí∞'
                    },
                    {
                        text: 'Try random numbers',
                        outcome: () => {
                            game.takeDamage(10);
                        },
                        result: 'The lock shocks you! You take 10 damage. ‚ö°'
                    },
                    {
                        text: 'Leave it alone',
                        outcome: () => {},
                        result: 'You walk away cautiously.'
                    }
                ]
            },

            {
                name: 'The Graph Master',
                description: 'A wise mathematician offers to teach you advanced techniques... for a price.',
                choices: [
                    {
                        text: 'Pay 50 gold for a lesson',
                        outcome: () => {
                            if (game.player.gold >= 50) {
                                game.spendGold(50);
                                game.player.maxHp += 10;
                                game.player.hp = Math.min(game.player.hp + 10, game.player.maxHp);
                                game.updateUI();
                            } else {
                                alert('Not enough gold!');
                            }
                        },
                        result: 'You learn valuable techniques! Max HP +10, and you heal 10 HP! üìö'
                    },
                    {
                        text: 'Challenge them to a duel',
                        outcome: () => {
                            // Triggers a fight
                        },
                        result: 'They accept your challenge! ‚öîÔ∏è'
                    },
                    {
                        text: 'Politely decline',
                        outcome: () => {},
                        result: 'You continue on your journey.'
                    }
                ]
            },

            {
                name: 'The Variable Vortex',
                description: 'A swirling portal of mathematical energy appears before you. It seems unstable.',
                choices: [
                    {
                        text: 'Jump through boldly!',
                        outcome: () => {
                            const roll = game.rng.next();
                            if (roll < 0.5) {
                                game.gainGold(60);
                                return 'You emerge in a treasure room! +60 gold! üí∞';
                            } else {
                                game.takeDamage(15);
                                return 'The vortex tears at you! Take 15 damage! üí´';
                            }
                        },
                        result: ''
                    },
                    {
                        text: 'Study it carefully first',
                        outcome: () => {
                            game.player.maxEnergy += 1;
                            game.player.energy = game.player.maxEnergy;
                            game.updateUI();
                        },
                        result: 'You harness its energy! Gain 1 Max Energy! ‚ö°'
                    },
                    {
                        text: 'Avoid it entirely',
                        outcome: () => {},
                        result: 'You carefully walk around the vortex.'
                    }
                ]
            },

            {
                name: 'The Proof Library',
                description: 'You discover an ancient library filled with mathematical proofs and theorems.',
                choices: [
                    {
                        text: 'Study the advanced texts',
                        outcome: () => {
                            // Add a random rare card
                            const rareCards = Object.keys(CARDS).filter(id => 
                                CARDS[id].rarity === 'rare'
                            );
                            const randomRare = game.rng.choice(rareCards);
                            game.deck.push(randomRare);
                        },
                        result: 'You gain deep insights! A rare card is added to your deck! üìñ'
                    },
                    {
                        text: 'Look for treasure maps',
                        outcome: () => {
                            game.gainGold(35);
                        },
                        result: 'You find 35 gold hidden in an old book! üí∞'
                    },
                    {
                        text: 'Rest and meditate here',
                        outcome: () => {
                            game.heal(20);
                        },
                        result: 'The peaceful atmosphere restores 20 HP! üßò'
                    }
                ]
            }
        ];

        const RELICS = {
            // ===== COMMON RELICS (Tier 1) =====
            calculatorWatch: {
                name: "Calculator Watch",
                icon: "‚åö",
                description: "+1 Energy every 5 turns",
                tier: "common",
                effect: "turnBasedEnergy"
            },
            numberLineCharm: {
                name: "Number Line Charm",
                icon: "üìè",
                description: "First attack each battle +3 damage",
                tier: "common",
                effect: "firstAttackBonus"
            },
            fractionPendant: {
                name: "Fraction Pendant",
                icon: "üî¢",
                description: "Gain +1 Block per enemy each turn",
                tier: "common",
                effect: "blockPerEnemy"
            },
            goldenCompass: {
                name: "Golden Compass",
                icon: "üß≠",
                description: "Gain 3 gold after each combat",
                tier: "common",
                effect: "goldPerCombat"
            },
            luckyDice: {
                name: "Lucky Dice",
                icon: "üé≤",
                description: "Enemies drop 50% more gold",
                tier: "common",
                effect: "bonusGold"
            },
            steelProtractor: {
                name: "Steel Protractor",
                icon: "üìê",
                description: "Start each combat with 5 Block",
                tier: "common",
                effect: "startingBlock"
            },

            // ===== UNCOMMON RELICS (Tier 2) =====
            timesTableTotem: {
                name: "Times Table Totem",
                icon: "‚úñÔ∏è",
                description: "Multiplication cards +20% damage",
                tier: "uncommon",
                effect: "multiplyBonus"
            },
            eraserOfMistakes: {
                name: "Eraser of Mistakes",
                icon: "üßπ",
                description: "Negate 1 status effect per fight",
                tier: "uncommon",
                effect: "negateStatus"
            },
            focusLens: {
                name: "Focus Lens",
                icon: "üîç",
                description: "Debuffs last 1 turn less (min 1)",
                tier: "uncommon",
                effect: "debuffReduction"
            },
            studyGuide: {
                name: "Study Guide",
                icon: "üìñ",
                description: "Draw 1 additional card each turn",
                tier: "uncommon",
                effect: "extraDraw"
            },
            balancedEquation: {
                name: "Balanced Equation",
                icon: "‚öñÔ∏è",
                description: "Gain 2 Block whenever you play an Attack",
                tier: "uncommon",
                effect: "attackBlock"
            },
            
            // ===== RARE RELICS (Tier 3) =====
            ancientAbacus: {
                name: "Ancient Abacus",
                icon: "üßÆ",
                description: "Gain 1 Energy at start of combat",
                tier: "rare",
                effect: "startingEnergy"
            },
            wisdomCrown: {
                name: "Wisdom Crown",
                icon: "üëë",
                description: "Start with +1 max Energy",
                tier: "rare",
                effect: "permanentEnergy"
            },
            fortifiedFormula: {
                name: "Fortified Formula",
                icon: "üõ°Ô∏è",
                description: "Increase max HP by 15",
                tier: "rare",
                effect: "maxHpBoost"
            },
            recursiveRing: {
                name: "Recursive Ring",
                icon: "üíç",
                description: "First card each turn costs 0",
                tier: "rare",
                effect: "freeFirstCard"
            },

            // ===== BOSS RELICS (Tier 4) - POWERFUL WITH DRAWBACKS =====
            infinityStone: {
                name: "Infinity Stone",
                icon: "‚ôæÔ∏è",
                description: "Start each combat with +2 Energy. Lose 5 max HP.",
                tier: "boss",
                effect: "infinityStone",
                drawback: true
            },
            perfectFormula: {
                name: "Perfect Formula",
                icon: "‚ú®",
                description: "Draw 2 extra cards each turn. -1 max Energy.",
                tier: "boss",
                effect: "perfectFormula",
                drawback: true
            },
            theoremThrone: {
                name: "Theorem Throne",
                icon: "ü™ë",
                description: "All attacks deal double damage. Take 50% more damage.",
                tier: "boss",
                effect: "theoremThrone",
                drawback: true
            },
            masteryMedal: {
                name: "Mastery Medal",
                icon: "üèÖ",
                description: "+2 max Energy. Start each combat with 2 Confused.",
                tier: "boss",
                effect: "masteryMedal",
                drawback: true
            },
            dimensionDice: {
                name: "Dimension Dice",
                icon: "üé∞",
                description: "At turn start, gain a random buff or debuff.",
                tier: "boss",
                effect: "dimensionDice",
                drawback: true
            },
            calculusCodex: {
                name: "Calculus Codex",
                icon: "üìö",
                description: "Upgrade all cards. Cards cost 1 more Energy.",
                tier: "boss",
                effect: "calculusCodex",
                drawback: true
            },
            proofPendant: {
                name: "Proof Pendant",
                icon: "üìú",
                description: "+25 max HP. Healing is 50% effective.",
                tier: "boss",
                effect: "proofPendant",
                drawback: true
            },
            axiomAmulet: {
                name: "Axiom Amulet",
                icon: "üîÆ",
                description: "Gain 10 Block at turn start. Cannot gain Block from cards.",
                tier: "boss",
                effect: "axiomAmulet",
                drawback: true
            },
            hypothesisHeart: {
                name: "Hypothesis Heart",
                icon: "üíù",
                description: "Heal 3 HP after each combat. Max HP reduced to 60.",
                tier: "boss",
                effect: "hypothesisHeart",
                drawback: true
            }
        };

        const STARTING_CHOICES = [
            {
                id: 'scholarPath',
                name: "Scholar's Path",
                icon: "üìö",
                type: "balanced",
                flavor: "Knowledge is power, but mastery takes time.",
                benefits: [
                    "Start with Study Guide relic (draw +1 card)",
                    "Gain 50 gold"
                ],
                drawbacks: [
                    "Start with -10 max HP"
                ],
                apply: (game) => {
                    game.relics.push('studyGuide');
                    game.player.gold = 50;
                    game.player.maxHp = 70;
                    game.player.hp = 70;
                }
            },
            {
                id: 'wealthPath',
                name: "Merchant's Fortune",
                icon: "üí∞",
                type: "balanced",
                flavor: "Gold opens many doors in the tower.",
                benefits: [
                    "Start with 150 gold",
                    "Start with Lucky Dice relic (50% more gold)"
                ],
                drawbacks: [
                    "Remove 2 Strikes from deck"
                ],
                apply: (game) => {
                    game.player.gold = 150;
                    game.relics.push('luckyDice');
                    // Remove 2 strikes
                    for (let i = 0; i < 2; i++) {
                        const index = game.deck.indexOf('strike');
                        if (index > -1) game.deck.splice(index, 1);
                    }
                }
            },
            {
                id: 'athletePath',
                name: "Athlete's Training",
                icon: "üí™",
                type: "safe",
                flavor: "Physical strength and endurance will see you through.",
                benefits: [
                    "+20 max HP (100 total)",
                    "Start with Steel Protractor (5 Block at combat start)"
                ],
                drawbacks: [
                    "Start with -25 gold"
                ],
                apply: (game) => {
                    game.player.maxHp = 100;
                    game.player.hp = 100;
                    game.relics.push('steelProtractor');
                    game.player.gold = -25; // Will be 0 since we start at 0
                }
            },
            {
                id: 'minimalistPath',
                name: "Minimalist's Focus",
                icon: "üéØ",
                type: "risky",
                flavor: "Quality over quantity. Precision over volume.",
                benefits: [
                    "Remove 5 cards from your deck",
                    "Upgrade 2 random Strikes",
                    "Start with Balanced Equation relic"
                ],
                drawbacks: [
                    "Start with -15 max HP"
                ],
                apply: (game) => {
                    // Remove 5 cards (prioritize Strikes and Defends)
                    for (let i = 0; i < 5 && game.deck.length > 10; i++) {
                        const toRemove = game.deck.indexOf('strike') !== -1 ? 'strike' : 
                                        game.deck.indexOf('defend') !== -1 ? 'defend' : 
                                        game.deck[0];
                        const index = game.deck.indexOf(toRemove);
                        if (index > -1) game.deck.splice(index, 1);
                    }
                    game.relics.push('balancedEquation');
                    game.player.maxHp = 65;
                    game.player.hp = 65;
                }
            },
            {
                id: 'gamblerPath',
                name: "Gambler's Luck",
                icon: "üé≤",
                type: "extreme",
                flavor: "Fortune favors the bold... or punishes the foolish.",
                benefits: [
                    "Choose 1 of 3 random RARE relics",
                    "Start with 100 gold"
                ],
                drawbacks: [
                    "Start with -20 max HP",
                    "Add 2 random curses to deck"
                ],
                apply: (game) => {
                    game.player.maxHp = 60;
                    game.player.hp = 60;
                    game.player.gold = 100;
                    
                    // Add 2 random curses
                    const curses = ['doubt', 'confusion', 'pain', 'regret'];
                    for (let i = 0; i < 2; i++) {
                        game.deck.push(game.rng.choice(curses));
                    }
                    
                    // Show rare relic selection
                    game.showStartingRelicChoice();
                }
            },
            {
                id: 'energyPath',
                name: "Overachiever's Ambition",
                icon: "‚ö°",
                type: "extreme",
                flavor: "Do more, achieve more, risk more.",
                benefits: [
                    "+1 max Energy (4 total)",
                    "Start with Ancient Abacus (+1 energy at combat start)"
                ],
                drawbacks: [
                    "Start with -25 max HP",
                    "Draw 1 less card each turn"
                ],
                apply: (game) => {
                    game.player.maxEnergy = 4;
                    game.player.energy = 4;
                    game.relics.push('ancientAbacus');
                    game.player.maxHp = 55;
                    game.player.hp = 55;
                    game.startingDrawPenalty = 1; // Flag for drawing 1 less
                }
            },
            {
                id: 'balancedPath',
                name: "Balanced Approach",
                icon: "‚öñÔ∏è",
                type: "safe",
                flavor: "The middle path avoids extremes and embraces harmony.",
                benefits: [
                    "Remove 1 Strike, remove 1 Defend",
                    "Gain 75 gold",
                    "Choose 1 of 3 common relics"
                ],
                drawbacks: [
                    "None - a safe, steady start"
                ],
                apply: (game) => {
                    const strikeIndex = game.deck.indexOf('strike');
                    if (strikeIndex > -1) game.deck.splice(strikeIndex, 1);
                    const defendIndex = game.deck.indexOf('defend');
                    if (defendIndex > -1) game.deck.splice(defendIndex, 1);
                    
                    game.player.gold = 75;
                    
                    // Show common relic selection
                    game.showStartingRelicChoice('common');
                }
            },
            {
                id: 'cursedPath',
                name: "Cursed Knowledge",
                icon: "üìñ",
                type: "extreme",
                flavor: "Dark secrets grant terrible power.",
                benefits: [
                    "Start with 2 BOSS relics of your choice",
                    "Start with 200 gold"
                ],
                drawbacks: [
                    "Add 3 random curses to deck",
                    "Start with -30 max HP"
                ],
                apply: (game) => {
                    game.player.maxHp = 50;
                    game.player.hp = 50;
                    game.player.gold = 200;
                    
                    // Add 3 random curses
                    const curses = ['doubt', 'confusion', 'pain', 'regret', 'frustration', 'burden'];
                    for (let i = 0; i < 3; i++) {
                        game.deck.push(game.rng.choice(curses));
                    }
                    
                    // Show boss relic selection - we'll need to implement double selection
                    game.cursedPathBossRelicsRemaining = 2;
                    game.showStartingRelicChoice('boss');
                }
            }
        ];

        // Seeded Random Number Generator
        class SeededRNG {
            constructor(seed) {
                this.seed = this.hashString(seed);
            }
            
            hashString(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32bit integer
                }
                return Math.abs(hash);
            }
            
            next() {
                // Linear Congruential Generator
                this.seed = (this.seed * 1103515245 + 12345) & 0x7fffffff;
                return this.seed / 0x7fffffff;
            }
            
            nextInt(min, max) {
                return Math.floor(this.next() * (max - min)) + min;
            }
            
            choice(array) {
                return array[this.nextInt(0, array.length)];
            }
            
            shuffle(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = this.nextInt(0, i + 1);
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }
        }

        class AscensionController {
            constructor() {
                this.currentAscension = 0;
                this.maxAscension = 0;
                this.skillStats = { completed: 0, unlocked: 0, total: 0 };
                
                this.setupEventListeners();
            }
            
            initialize() {
                // Calculate max ascension from skill tree
                if (window.parent && window.parent.portal && window.parent.portal.skillTreeIntegration) {
                    const skillTree = window.parent.portal.skillTreeIntegration;
                    this.skillStats = skillTree.getTotalStats();
                    this.maxAscension = Math.min(Math.floor(this.skillStats.completed / 5), 20);
                    
                    // Show the selector if max ascension > 0
                    if (this.maxAscension > 0) {
                        document.getElementById('ascension-selector').style.display = 'block';
                    }
                    
                    // Update UI
                    this.updateUI();
                }
            }
            
            setupEventListeners() {
                // Decrease button
                document.getElementById('ascension-decrease')?.addEventListener('click', () => {
                    if (this.currentAscension > 0) {
                        this.currentAscension--;
                        this.updateUI();
                    }
                });
                
                // Increase button
                document.getElementById('ascension-increase')?.addEventListener('click', () => {
                    if (this.currentAscension < this.maxAscension) {
                        this.currentAscension++;
                        this.updateUI();
                    }
                });
                
                // Slider
                document.getElementById('ascension-slider')?.addEventListener('input', (e) => {
                    this.currentAscension = parseInt(e.target.value);
                    this.updateUI();
                });
            }
            
            updateUI() {
                // Update current ascension display
                const currentEl = document.getElementById('ascension-current');
                if (currentEl) {
                    currentEl.textContent = this.currentAscension;
                    
                    // Color-code based on level
                    const color = this.currentAscension === 0 ? '#888' :
                                this.currentAscension >= 15 ? '#ff6a6a' :
                                this.currentAscension >= 10 ? '#ffd36a' :
                                this.currentAscension >= 5 ? '#ffb366' :
                                '#8bffb0';
                    currentEl.style.color = color;
                }
                
                // Update max display
                const maxEl = document.getElementById('ascension-max-display');
                if (maxEl) {
                    maxEl.textContent = `Max: ${this.maxAscension}`;
                }
                
                // Update slider
                const slider = document.getElementById('ascension-slider');
                if (slider) {
                    slider.max = this.maxAscension;
                    slider.value = this.currentAscension;
                }
                
                // Update description
                this.updateDescription();
                
                // Update skills count
                const skillsCount = document.getElementById('completed-skills-count');
                if (skillsCount) {
                    skillsCount.textContent = this.skillStats.completed;
                }
                
                // Update button states
                const decreaseBtn = document.getElementById('ascension-decrease');
                const increaseBtn = document.getElementById('ascension-increase');
                
                if (decreaseBtn) {
                    decreaseBtn.disabled = this.currentAscension === 0;
                    decreaseBtn.style.opacity = this.currentAscension === 0 ? '0.5' : '1';
                }
                
                if (increaseBtn) {
                    increaseBtn.disabled = this.currentAscension >= this.maxAscension;
                    increaseBtn.style.opacity = this.currentAscension >= this.maxAscension ? '0.5' : '1';
                }
            }
            
            updateDescription() {
                const descEl = document.getElementById('ascension-description');
                if (!descEl) return;
                
                const level = this.currentAscension;
                
                if (level === 0) {
                    descEl.innerHTML = `
                        <h4 style="margin-bottom: 10px; color: #888;">Ascension 0</h4>
                        <p style="font-size: 14px; color: #ccc; line-height: 1.5;">
                            Standard difficulty. No modifiers.
                        </p>
                    `;
                    return;
                }
                
                // Calculate modifiers
                const enemyHp = Math.round(level * 12);
                const enemyDmg = Math.round(level * 10);
                const goldReduction = Math.round(level * 3);
                const hpReduction = level * 2;
                const startGold = Math.max(50, 100 - (level * 3));
                
                const modifiers = [];
                modifiers.push(`üî¥ Enemies: +${enemyHp}% HP, +${enemyDmg}% damage`);
                modifiers.push(`üí∞ Rewards: -${goldReduction}% gold`);
                modifiers.push(`‚ù§Ô∏è Starting: ${70 - hpReduction} HP, ${startGold} gold`);
                
                if (level >= 5) {
                    modifiers.push(`‚ö° Elite encounters more frequent`);
                }
                if (level >= 10) {
                    modifiers.push(`üòà Curses may appear in events`);
                }
                if (level >= 15) {
                    modifiers.push(`üíÄ Elites may curse you`);
                }
                
                const color = level >= 15 ? '#ff6a6a' :
                            level >= 10 ? '#ffd36a' :
                            level >= 5 ? '#ffb366' :
                            '#8bffb0';
                
                descEl.innerHTML = `
                    <h4 style="margin-bottom: 10px; color: ${color};">Ascension ${level}</h4>
                    <div style="font-size: 13px; color: #ccc; line-height: 1.7;">
                        ${modifiers.map(m => `<div>‚Ä¢ ${m}</div>`).join('')}
                    </div>
                `;
            }
            
            getSelectedAscension() {
                return this.currentAscension;
            }
        }

        // Initialize ascension controller
        let ascensionController;
        document.addEventListener('DOMContentLoaded', () => {
            ascensionController = new AscensionController();
            
            // Wait a bit for parent portal to load, then initialize
            setTimeout(() => {
                ascensionController.initialize();
            }, 500);
        });

        // Game State
        class Game {
            constructor(seed, selectedAscension = 0) {
                // Seed setup
                this.seed = seed || this.generateSeed();
                this.seedString = String(this.seed);
                this.rng = new SeededRNG(this.seed);
                
                // Ascension system
                this.maxAscensionLevel = 0;
                this.selectedAscension = selectedAscension;
                this.ascensionLevel = selectedAscension;
                this.calculateMaxAscension();
                this.difficultyMultipliers = this.getDifficultyMultipliers();
                
                // Game state - will be initialized properly in startRun()
                this.player = null; // Set in startRun()
                this.deck = [];
                this.relics = [];
                this.enemies = [];
                this.hand = [];
                this.drawPile = [];
                this.discardPile = [];
                this.currentNode = -1;
                this.enteringNode = null;
                this.modifiers = {};
                this.attacksPlayedThisTurn = 0;
                this.lastAttackCard = null;
                this.turnCount = 0;
                this.currentAct = 1;
                this.map = [];
                this.mapConnections = {};
                this.wasEventElite = false;
                this.targetingActive = false;
                this.targetingCard = null;
                this.targetingCardIndex = null;
                this.currentTarget = 0;
                
                // Don't show anything yet - wait for startRun()
            }

            calculateMaxAscension() {
                // Check if we can access the skill tree from parent portal
                if (window.parent && window.parent.portal && window.parent.portal.skillTreeIntegration) {
                    const skillTree = window.parent.portal.skillTreeIntegration;
                    const stats = skillTree.getTotalStats();
                    
                    // Calculate max ascension based on completed skills
                    // Every 5 completed skills = +1 Max Ascension Level
                    this.maxAscensionLevel = Math.floor(stats.completed / 5);
                    
                    // Cap at Ascension 20 for balance
                    this.maxAscensionLevel = Math.min(this.maxAscensionLevel, 20);
                    
                    console.log(`üî• Max Ascension Available: ${this.maxAscensionLevel}`);
                    console.log(`üìä Skills: ${stats.completed}/${stats.unlocked} completed`);
                    
                    // Store stats for display
                    this.skillStats = stats;
                } else {
                    console.log('‚ö†Ô∏è Skill tree not accessible - Ascension 0 only');
                    this.maxAscensionLevel = 0;
                }
                
                // Ensure selected ascension doesn't exceed max
                this.ascensionLevel = Math.min(this.selectedAscension, this.maxAscensionLevel);
            }

            getDifficultyMultipliers() {
                const level = this.ascensionLevel;
                
                return {
                    // Enemy scaling
                    enemyHpMultiplier: 1 + (level * 0.12),        // +12% HP per level
                    enemyDamageMultiplier: 1 + (level * 0.10),    // +10% damage per level
                    
                    // Elite/Boss scaling
                    eliteHpMultiplier: 1 + (level * 0.15),        // +15% elite HP
                    bossHpMultiplier: 1 + (level * 0.18),         // +18% boss HP
                    
                    // Map generation
                    eliteFrequency: 1 + (level * 0.08),           // More elites
                    eventCombatChance: 0.2 + (level * 0.02),      // Events more likely to be combat
                    
                    // Rewards (decrease)
                    goldMultiplier: Math.max(0.5, 1 - (level * 0.03)),     // -3% gold per level (min 50%)
                    cardRewardCount: Math.max(2, 3 - Math.floor(level / 5)), // Fewer card choices at high ascension
                    
                    // Curses
                    curseChance: level * 0.03,                    // 3% chance per level for curses in events
                    eliteCurseChance: Math.min(0.5, level * 0.05), // Up to 50% chance for curse from elites
                    
                    // Starting resources
                    startingHp: Math.max(50, 70 - (level * 2)),   // -2 HP per level (min 50)
                    startingGold: Math.max(50, 100 - (level * 3)), // -3 gold per level (min 50)
                    
                    // Card costs
                    removeCostMultiplier: 1 + (level * 0.10),     // +10% removal cost per level
                    shopPriceMultiplier: 1 + (level * 0.05)       // +5% shop prices per level
                };
            }

            generateSeed() {
                // Generate a random seed string
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                let seed = '';
                for (let i = 0; i < 8; i++) {
                    seed += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return seed;
            }

            startWithSeed(seed, selectedAscension = 0) {
                console.log('=== START WITH SEED CALLED ===');
                console.log('Seed:', seed);
                console.log('Selected Ascension:', selectedAscension);
                
                try {
                    // Initialize seed and RNG
                    this.seed = seed || this.generateSeed();
                    this.rng = new SeededRNG(this.seed);
                    console.log('Using seed:', this.seed);
                    
                    // Ascension system
                    this.selectedAscension = selectedAscension;
                    this.maxAscensionLevel = 0;
                    this.ascensionLevel = selectedAscension;
                    this.calculateMaxAscension();
                    this.difficultyMultipliers = this.getDifficultyMultipliers();
                    
                    console.log(`üî• Playing at Ascension ${this.ascensionLevel}`);
                    
                    // Hide ALL views first
                    this.hideAllViews();
                    console.log('All views hidden');
                    
                    // NOW show and populate starting choices
                    this.showStartingChoices(); // <-- ADD THIS LINE!
                    console.log('Starting choices populated and shown');
                    
                    // Reset buttons
                    const startBtn = document.getElementById('start-with-seed-btn');
                    const randomBtn = document.getElementById('random-seed-btn');
                    if (startBtn) {
                        startBtn.textContent = 'üéÆ Start with Seed';
                        startBtn.disabled = false;
                    }
                    if (randomBtn) {
                        randomBtn.textContent = 'üé≤ Random Seed';
                        randomBtn.disabled = false;
                    }
                    
                } catch (error) {
                    console.error('!!! ERROR IN START WITH SEED !!!');
                    console.error(error);
                    console.error('Stack:', error.stack);
                }
            }

            startRun(selectedPath) {
                console.log('=== START RUN CALLED ===');
                console.log('Selected path:', selectedPath);
                
                const multipliers = this.difficultyMultipliers;
                
                // Initialize player with ascension-adjusted stats
                this.player = {
                    maxHp: multipliers.startingHp,
                    hp: multipliers.startingHp,
                    maxEnergy: 3,
                    energy: 3,
                    block: 0,
                    gold: multipliers.startingGold,
                    debuffs: {}
                };
                
                console.log(`Player initialized: ${this.player.hp} HP, ${this.player.gold} gold (A${this.ascensionLevel})`);
                
                // Apply starting path bonuses
                if (selectedPath === 'balanced') {
                    this.player.maxHp += 10;
                    this.player.hp += 10;
                    this.player.gold += 20;
                    this.deck = [
                        'strike', 'strike', 'strike', 'strike',
                        'defend', 'defend', 'defend', 'defend',
                        'sumItUp', 'quickMath'
                    ];
                } else if (selectedPath === 'risky') {
                    this.player.maxHp -= 10;
                    this.player.hp -= 10;
                    this.player.gold += 50;
                    this.deck = [
                        'strike', 'strike', 'strike', 'strike', 'strike',
                        'defend', 'defend',
                        'sumItUp', 'powerPlay'
                    ];
                } else if (selectedPath === 'safe') {
                    this.player.maxHp += 20;
                    this.player.hp += 20;
                    this.player.gold = Math.max(0, this.player.gold - 20);
                    this.deck = [
                        'strike', 'strike', 'strike', 'strike',
                        'defend', 'defend', 'defend', 'defend', 'defend',
                        'sumItUp'
                    ];
                } else {
                    // Standard path - basic starter deck
                    this.deck = [
                        'strike', 'strike', 'strike', 'strike', 'strike',
                        'defend', 'defend', 'defend', 'defend',
                        'sumItUp'
                    ];
                }
                
                console.log(`After path: ${this.player.hp}/${this.player.maxHp} HP, ${this.player.gold} gold`);
                console.log('Deck:', this.deck);
                
                // Initialize relics
                this.relics = [];
                
                // Generate the map
                this.initMap();
                
                // Show the map
                this.hideAllViews();
                document.getElementById('map-view').classList.add('active');
                
                this.updateUI();
                
                console.log('=== RUN STARTED SUCCESSFULLY ===');
            }

            showStartingChoices() {
                console.log('showStartingChoices called');
                this.hideAllViews();
                
                const choicesView = document.getElementById('starting-choices-view');
                const choicesGrid = document.getElementById('starting-choices-grid');
                
                if (!choicesView || !choicesGrid) {
                    console.error('Starting choices view not found!');
                    return;
                }
                
                // Show and activate view
                choicesView.style.display = 'flex'; // Explicitly set flex
                choicesView.classList.add('active');
                
                choicesGrid.innerHTML = '';
                
                STARTING_CHOICES.forEach(choice => {
                    const choiceEl = document.createElement('div');
                    choiceEl.className = `starting-choice ${choice.type}`;
                    
                    let benefitsHTML = '';
                    choice.benefits.forEach(benefit => {
                        benefitsHTML += `<div class="starting-choice-benefit">${benefit}</div>`;
                    });
                    
                    let drawbacksHTML = '';
                    if (choice.drawbacks && choice.drawbacks.length > 0 && choice.drawbacks[0] !== "None - a safe, steady start") {
                        drawbacksHTML = '<div class="starting-choice-drawbacks">';
                        choice.drawbacks.forEach(drawback => {
                            drawbacksHTML += `<div class="starting-choice-drawback">${drawback}</div>`;
                        });
                        drawbacksHTML += '</div>';
                    }
                    
                    choiceEl.innerHTML = `
                        <div class="starting-choice-icon">${choice.icon}</div>
                        <div class="starting-choice-name">${choice.name}</div>
                        <div class="starting-choice-benefits">${benefitsHTML}</div>
                        ${drawbacksHTML}
                        <div class="starting-choice-flavor">${choice.flavor}</div>
                    `;
                    
                    // Use standard click handler (touch is handled automatically)
                    choiceEl.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('Starting choice clicked:', choice.name);
                        this.applyStartingChoice(choice);
                    });
                    
                    choicesGrid.appendChild(choiceEl);
                });
                
                console.log('Starting choices rendered:', choicesGrid.children.length);
            }

           applyStartingChoice(choice) {
                console.log('Applying starting choice:', choice.name);
                
                // Initialize player with ascension-adjusted base stats
                const multipliers = this.difficultyMultipliers;
                this.player = {
                    maxHp: multipliers.startingHp,
                    hp: multipliers.startingHp,
                    maxEnergy: 3,
                    energy: 3,
                    block: 0,
                    gold: multipliers.startingGold,
                    debuffs: {}
                };
                
                // Initialize empty deck and relics
                this.deck = [
                    'strike', 'strike', 'strike', 'strike', 'strike',
                    'defend', 'defend', 'defend', 'defend', 'defend'
                ];
               
                this.relics = [];
                
                console.log(`Base stats (A${this.ascensionLevel}): ${this.player.hp} HP, ${this.player.gold} gold`);
                
                // Apply the choice's modifications (this adds to deck, modifies HP/gold, etc.)
                choice.apply(this);
                
                console.log(`After ${choice.name}: ${this.player.hp}/${this.player.maxHp} HP, ${this.player.gold} gold`);
                console.log('Deck:', this.deck);
                
                // If the choice doesn't require additional selection, go to map
                if (choice.id !== 'gamblerPath' && choice.id !== 'balancedPath' && choice.id !== 'cursedPath') {
                    this.renderRelics();
                    this.updateUI();
                    
                    // Generate map before showing it
                    this.initMap();
                    
                    // Now show the map
                    this.proceedToMap();
                }
                // Otherwise, the choice's apply function will handle the next step
            }

            showStartingRelicChoice(tier = 'rare') {
                // Create a modal for relic selection
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.95);
                    z-index: 3000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    overflow-y: auto;
                `;
                
                const content = document.createElement('div');
                content.style.cssText = `
                    padding: 40px;
                    max-width: 1200px;
                    text-align: center;
                `;
                
                const title = document.createElement('h2');
                title.style.cssText = `
                    font-size: 36px;
                    color: #f39c12;
                    margin-bottom: 30px;
                `;
                title.textContent = tier === 'boss' ? 'üëë Choose a Boss Relic' : 
                                tier === 'common' ? '‚ú® Choose a Common Relic' : 
                                'üíé Choose a Rare Relic';
                
                const choicesContainer = document.createElement('div');
                choicesContainer.style.cssText = `
                    display: flex;
                    gap: 30px;
                    justify-content: center;
                    flex-wrap: wrap;
                `;
                
                // Get 3 random relics of the specified tier
                const availableRelics = Object.keys(RELICS).filter(id => RELICS[id].tier === tier);
                const choices = [];
                for (let i = 0; i < 3 && i < availableRelics.length; i++) {
                    const relicId = this.rng.choice(availableRelics.filter(id => !choices.includes(id)));
                    choices.push(relicId);
                }
                
                choices.forEach(relicId => {
                    const relic = RELICS[relicId];
                    const relicEl = document.createElement('div');
                    relicEl.className = tier === 'boss' ? 'boss-relic-choice' : 'relic-choice';
                    relicEl.style.cssText = `
                        width: 250px;
                        background: rgba(255, 215, 0, 0.1);
                        border: 3px solid #f39c12;
                        border-radius: 15px;
                        padding: 30px;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    `;
                    
                    relicEl.innerHTML = `
                        <div style="font-size: 80px; margin-bottom: 20px;">${relic.icon}</div>
                        <div style="font-size: 22px; font-weight: bold; color: #f39c12; margin-bottom: 15px;">${relic.name}</div>
                        <div style="font-size: 16px; color: #ccc;">${relic.description}</div>
                    `;
                    
                    relicEl.onmouseover = () => {
                        relicEl.style.transform = 'scale(1.05)';
                        relicEl.style.boxShadow = '0 10px 40px rgba(243, 156, 18, 0.6)';
                    };
                    relicEl.onmouseout = () => {
                        relicEl.style.transform = 'scale(1)';
                        relicEl.style.boxShadow = 'none';
                    };
                    
                    relicEl.onclick = () => {
                        this.relics.push(relicId);
                        this.applyPermanentRelicEffects(relicId);
                        document.body.removeChild(modal);
                        
                        // Check if this is the cursed path and we need another boss relic
                        if (this.cursedPathBossRelicsRemaining && this.cursedPathBossRelicsRemaining > 1) {
                            this.cursedPathBossRelicsRemaining--;
                            this.showStartingRelicChoice('boss');
                        } else {
                            delete this.cursedPathBossRelicsRemaining;
                            this.renderRelics();
                            this.updateUI();
                            this.proceedToMap();
                        }
                    };
                    
                    choicesContainer.appendChild(relicEl);
                });
                
                content.appendChild(title);
                content.appendChild(choicesContainer);
                modal.appendChild(content);
                document.body.appendChild(modal);
            }

            proceedToMap() {
                this.hideAllViews();
                
                const mapView = document.getElementById('map-view');
                if (mapView) {
                    mapView.style.display = 'flex';
                    mapView.classList.add('active');
                }
                
                this.renderMap();
                this.updateUI();
            }

            initMap() {
                console.log('=== INIT MAP CALLED ===');
                console.log('RNG status:', this.rng);
                
                try {
                // Determine which act we're in
                const currentAct = this.currentAct || 1;
                
                // Define enemy pools by act and tier
                let basicEnemies, mediumEnemies, largeEnemies, eliteEnemies, bossEnemies;
                
                if (currentAct === 1) {
                    // ACT 1 ENEMIES
                    basicEnemies = ['plusBug', 'minusMite', 'divisionDot'];
                    mediumEnemies = ['timesToad', 'equationBat', 'factorialFox'];
                    largeEnemies = ['divvySlime', 'exponentEagle', 'rootRhino'];
                    eliteEnemies = ['conceptGuardian', 'variableViper', 'theoremTitan'];
                    bossEnemies = ['mrPemdas', 'professorCalculus', 'theInfinity'];
                } else {
                    // ACT 2 ENEMIES
                    basicEnemies = ['logarithmLion', 'vectorVulture', 'probabilityPanther'];
                    mediumEnemies = ['matrixMammoth', 'integralIguana', 'derivativeDragon'];
                    largeEnemies = ['matrixMammoth', 'derivativeDragon', 'integralIguana'];
                    eliteEnemies = ['complexityColossus', 'recursionReaper', 'theoremTyrant'];
                    bossEnemies = ['doctorDiophantus', 'ladyLaplace', 'sirSigma'];
                }
                
                console.log('Enemy pools initialized for Act', currentAct);
                    
                    // PROCEDURALLY GENERATE MAP
                    this.map = [];
                    this.mapConnections = {};
                    
                    const NUM_FLOORS = 15;
                    
                    // Generate floor configurations procedurally
                    const floorsConfig = [];
                    
                    for (let floorNum = 0; floorNum < NUM_FLOORS; floorNum++) {
                        let config = {};
                        
                        if (floorNum === 0) {
                            // Starting floor: Always 3 battles
                            config = {
                                count: 3,
                                types: ['enemy', 'enemy', 'enemy']
                            };
                        } else if (floorNum === 7) {
                            // Mid-act treasure floor: 2-3 treasure chests
                            const treasureCount = this.rng.nextInt(2, 4);
                            config = {
                                count: treasureCount,
                                types: Array(treasureCount).fill('treasure')
                            };
                        } else if (floorNum === NUM_FLOORS - 1) {
                            // Boss floor: Always 1 boss
                            config = {
                                count: 1,
                                types: ['boss']
                            };
                        } else {
                            // Random floor: 3-5 nodes with random types (more branching!)
                            const nodeCount = this.rng.nextInt(3, 6);  
                            const types = [];
                            
                            // Define node type pool based on floor progression
                            let enemyWeight, eventWeight, shopWeight, restWeight, eliteWeight;

                            if (floorNum <= 3) {
                                // Early floors: mostly events/exploration, NO ELITES
                                enemyWeight = 20;
                                eventWeight = 50;
                                shopWeight = 15;
                                restWeight = 15;
                                eliteWeight = 0; // NO elites early!
                            } else if (floorNum <= 6) {
                                // Mid-early: events dominate, rare elites
                                enemyWeight = 15;
                                eventWeight = 50;
                                shopWeight = 15;
                                restWeight = 15;
                                eliteWeight = 5;
                            } else if (floorNum <= 10) {
                                // Mid-late: still mostly events, more elites
                                enemyWeight = 20;
                                eventWeight = 40;
                                shopWeight = 15;
                                restWeight = 15;
                                eliteWeight = 10;
                            } else {
                                // Late floors: prepare for boss
                                enemyWeight = 25;
                                eventWeight = 35;
                                shopWeight = 15;
                                restWeight = 10;
                                eliteWeight = 15;
                            }
                            
                            // Generate types based on weights
                            for (let i = 0; i < nodeCount; i++) {
                                const roll = this.rng.nextInt(0, 100);
                                let type;
                                
                                if (roll < enemyWeight) {
                                    type = 'enemy';
                                } else if (roll < enemyWeight + eventWeight) {
                                    type = 'event';
                                } else if (roll < enemyWeight + eventWeight + shopWeight) {
                                    type = 'shop';
                                } else if (roll < enemyWeight + eventWeight + shopWeight + restWeight) {
                                    type = 'rest';
                                } else {
                                    type = 'elite';
                                }
                                
                                types.push(type);
                            }
                            
                            // Ensure floor has at least 1 enemy (unless it's all utility)
                            if (!types.includes('enemy') && nodeCount > 1 && this.rng.next() < 0.7) {
                                types[this.rng.nextInt(0, types.length)] = 'enemy';
                            }
                            
                            config = {
                                count: nodeCount,
                                types: types
                            };
                        }
                        
                        floorsConfig.push(config);
                    }
                    
                    // GUARANTEE ELITES: Ensure map has at least 2-3 elite encounters
                    let eliteCount = 0;
                    floorsConfig.forEach(config => {
                        eliteCount += config.types.filter(t => t === 'elite').length;
                    });

                    console.log('Initial elite count:', eliteCount);

                    // If we have fewer than 2 elites, add some
                    const minElites = 2;
                    const maxElites = 4;
                    let elitesToAdd = Math.max(0, minElites - eliteCount);

                    while (elitesToAdd > 0 && eliteCount < maxElites) {
                        // Pick a random floor between 6 and 13 (avoid early/late/special floors)
                        const targetFloor = this.rng.nextInt(6, 13);
                        const floorConfig = floorsConfig[targetFloor];
                        
                        // Skip treasure and boss floors
                        if (targetFloor === 7 || targetFloor === 14) continue;
                        
                        // Find an enemy node to replace with elite
                        const enemyIndices = [];
                        floorConfig.types.forEach((type, idx) => {
                            if (type === 'enemy') enemyIndices.push(idx);
                        });
                        
                        if (enemyIndices.length > 0) {
                            const replaceIdx = this.rng.choice(enemyIndices);
                            floorConfig.types[replaceIdx] = 'elite';
                            elitesToAdd--;
                            eliteCount++;
                        } else {
                            // No enemies to replace, add a new elite node if floor isn't too crowded
                            if (floorConfig.count < 4) {
                                floorConfig.types.push('elite');
                                floorConfig.count++;
                                elitesToAdd--;
                                eliteCount++;
                            }
                        }
                    }

                    console.log('Final elite count:', eliteCount);

                    console.log('Generated floor configs:', floorsConfig);
                    
                    // Build all nodes
                    let nodeIndex = 0;
                    const floorNodes = []; // Track nodes by floor for connection purposes
                    
                    floorsConfig.forEach((floorConfig, floorNum) => {
                        floorNodes[floorNum] = [];
                        
                        // SHUFFLE the types so node positions are randomized!
                        const shuffledTypes = this.rng.shuffle([...floorConfig.types]);
                        
                        for (let i = 0; i < floorConfig.count; i++) {
                            const nodeType = shuffledTypes[i];
                            let node = { 
                                type: nodeType,
                                floor: floorNum,
                                index: nodeIndex,
                                x: i // Position in the row
                            };
                            
                            // Assign enemies based on floor
                            if (nodeType === 'enemy') {
                                if (floorNum <= 2) {
                                    // Early floors: basic enemies
                                    node.enemies = [this.rng.choice(basicEnemies)];
                                } else if (floorNum <= 5) {
                                    // Mid-early: basic + medium mix
                                    if (this.rng.next() < 0.5) {
                                        node.enemies = [this.rng.choice(basicEnemies), this.rng.choice(basicEnemies)];
                                    } else {
                                        node.enemies = [this.rng.choice(mediumEnemies)];
                                    }
                                } else if (floorNum <= 9) {
                                    // Mid: medium enemies
                                    node.enemies = [this.rng.choice(mediumEnemies)];
                                } else if (floorNum <= 13) {
                                    // Late: large enemies and medium groups
                                    if (this.rng.next() < 0.6) {
                                        node.enemies = [this.rng.choice(largeEnemies)];
                                    } else {
                                        node.enemies = [this.rng.choice(mediumEnemies), this.rng.choice(mediumEnemies)];
                                    }
                                }
                            } else if (nodeType === 'elite') {
                                node.enemies = [this.rng.choice(eliteEnemies)];
                            } else if (nodeType === 'boss') {
                                const selectedBoss = this.rng.choice(bossEnemies);
                                node.enemies = [selectedBoss];
                                // Store the boss for display purposes
                                this.selectedBoss = selectedBoss;
                            }
                            
                            this.map.push(node);
                            floorNodes[floorNum].push(nodeIndex);
                            nodeIndex++;
                        }
                    });
                    
                    // Build connections between floors - PARTITION-BASED to guarantee no crossing
                    floorsConfig.forEach((floorConfig, floorNum) => {
                        if (floorNum >= floorsConfig.length - 1) return; // No connections from last floor
                        
                        const currentFloor = floorNodes[floorNum];
                        const nextFloor = floorNodes[floorNum + 1];
                        
                        currentFloor.forEach((currentNodeIndex, posInFloor) => {
                            this.mapConnections[currentNodeIndex] = [];
                            
                            // Special case: next floor has only 1 node
                            if (nextFloor.length === 1) {
                                this.mapConnections[currentNodeIndex] = [nextFloor[0]];
                                return;
                            }
                            
                            // Special case: current floor has only 1 node
                            if (currentFloor.length === 1) {
                                // Connect to 2-3 middle nodes
                                const mid = Math.floor(nextFloor.length / 2);
                                const connections = [nextFloor[mid]];
                                if (mid > 0) connections.push(nextFloor[mid - 1]);
                                if (mid < nextFloor.length - 1 && connections.length < 3) {
                                    connections.push(nextFloor[mid + 1]);
                                }
                                this.mapConnections[currentNodeIndex] = connections;
                                return;
                            }
                            
                            // STRICT PARTITIONING: Divide next floor into zones
                            // Each node on current floor gets an exclusive zone on next floor
                            
                            // Calculate this node's zone boundaries
                            const zoneSize = nextFloor.length / currentFloor.length;
                            const zoneStart = Math.floor(posInFloor * zoneSize);
                            const zoneEnd = Math.floor((posInFloor + 1) * zoneSize);
                            
                            // Collect all positions in this node's zone
                            const zonePositions = [];
                            for (let i = zoneStart; i < zoneEnd && i < nextFloor.length; i++) {
                                zonePositions.push(i);
                            }
                            
                            // Edge case: if zone is empty (rounding issues), take the closest position
                            if (zonePositions.length === 0) {
                                const closestPos = Math.min(nextFloor.length - 1, Math.round(posInFloor * zoneSize));
                                zonePositions.push(closestPos);
                            }
                            
                            // ALLOW BORROWING from adjacent zones (but carefully)
                            // Leftmost node can also connect to position left of its zone
                            if (posInFloor === 0 && zoneStart > 0) {
                                zonePositions.unshift(zoneStart - 1);
                            }
                            // Rightmost node can also connect to position right of its zone
                            if (posInFloor === currentFloor.length - 1 && zoneEnd < nextFloor.length) {
                                zonePositions.push(zoneEnd);
                            }
                            
                            // Choose 1-2 connections from this zone
                            const numConnections = Math.min(
                                this.rng.nextInt(1, 3),
                                zonePositions.length
                            );
                            
                            const shuffled = this.rng.shuffle(zonePositions);
                            const selectedPositions = shuffled.slice(0, numConnections);
                            
                            // Convert positions to node indices
                            const connections = selectedPositions.map(pos => nextFloor[pos]);
                            
                            this.mapConnections[currentNodeIndex] = connections;
                        });
                    });
                    
                    // Ensure every node on next floor is reachable (should already be true with partitioning)
                    floorsConfig.forEach((floorConfig, floorNum) => {
                        if (floorNum >= floorsConfig.length - 1) return;
                        
                        const currentFloor = floorNodes[floorNum];
                        const nextFloor = floorNodes[floorNum + 1];
                        
                        nextFloor.forEach((nextNodeIndex, nextPos) => {
                            let isReachable = false;
                            
                            currentFloor.forEach(currentNodeIndex => {
                                if (this.mapConnections[currentNodeIndex] && 
                                    this.mapConnections[currentNodeIndex].includes(nextNodeIndex)) {
                                    isReachable = true;
                                }
                            });
                            
                            // If not reachable, find the node that should own this position
                            if (!isReachable && currentFloor.length > 0) {
                                const zoneSize = nextFloor.length / currentFloor.length;
                                const ownerPos = Math.floor(nextPos / zoneSize);
                                const clampedOwner = Math.max(0, Math.min(currentFloor.length - 1, ownerPos));
                                const ownerNode = currentFloor[clampedOwner];
                                
                                if (!this.mapConnections[ownerNode]) {
                                    this.mapConnections[ownerNode] = [];
                                }
                                
                                if (!this.mapConnections[ownerNode].includes(nextNodeIndex)) {
                                    this.mapConnections[ownerNode].push(nextNodeIndex);
                                }
                            }
                        });
                    });
                    
                    console.log('Map generated:', this.map.length, 'nodes across', NUM_FLOORS, 'floors');
                    console.log('Connections:', this.mapConnections);

                    console.log('Calling renderMap...');
                    this.renderMap();
                    console.log('=== MAP INITIALIZED SUCCESSFULLY ===');
                } catch (error) {
                    console.error('!!! ERROR IN INIT MAP !!!');
                    console.error('Error:', error);
                    console.error('Stack:', error.stack);
                    throw error;
                }
            }

            renderMap() {
                console.log('=== RENDER MAP CALLED ===');
                const mapGrid = document.getElementById('map-grid');
                console.log('Map grid element:', mapGrid);
                
                if (!mapGrid) {
                    console.error('Map grid element not found!');
                    return;
                }
                
                mapGrid.innerHTML = '';
                console.log('Map grid cleared');

                // Update boss name in subtitle
                if (this.selectedBoss) {
                    const bossNames = {
                        // Act 1
                        'mrPemdas': 'Mr. PEMDAS',
                        'professorCalculus': 'Professor Calculus',
                        'theInfinity': 'The Infinity',
                        // Act 2
                        'doctorDiophantus': 'Doctor Diophantus',
                        'ladyLaplace': 'Lady Laplace',
                        'sirSigma': 'Sir Sigma'
                    };
                    
                    const currentAct = this.currentAct || 1;
                    const bossName = bossNames[this.selectedBoss] || 'the Boss';
                    
                    // Update map subtitle
                    const subtitle = document.getElementById('map-subtitle');
                    if (subtitle) {
                        subtitle.textContent = `Act ${currentAct}: Climb upward to face ${bossName} at the summit! ‚¨ÜÔ∏è`;
                    }
                }

                // Group nodes by floor
                const floors = {};
                this.map.forEach(node => {
                    if (!floors[node.floor]) floors[node.floor] = [];
                    floors[node.floor].push(node);
                });
                
                const maxFloor = Math.max(...Object.keys(floors).map(Number));
                console.log('Max floor:', maxFloor);
                console.log('Current completed node:', this.currentNode);
                
                // Get list of accessible nodes
                const accessibleNodes = this.getAccessibleNodes();
                console.log('Accessible nodes:', accessibleNodes);
                
                // Create SVG for connection lines (remove old one first)
                let svg = mapGrid.querySelector('svg');
                if (!svg) {
                    svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        pointer-events: none;
                        z-index: 0;
                    `;
                    mapGrid.appendChild(svg);
                } else {
                    // Clear existing lines
                    svg.innerHTML = '';
                }
                
                // Render floors from top (boss) to bottom (start)
                for (let floorNum = maxFloor; floorNum >= 0; floorNum--) {
                    const floorNodes = floors[floorNum];
                    if (!floorNodes) continue;
                    
                    const row = document.createElement('div');
                    row.className = 'map-row';
                    row.style.position = 'relative';
                    row.style.zIndex = '1';
                    
                    // Add floor label
                    if (floorNum === maxFloor) {
                        row.setAttribute('data-floor-label', 'üëë BOSS');
                    } else if (floorNum === 0) {
                        row.setAttribute('data-floor-label', 'üìç START');
                    } else {
                        row.setAttribute('data-floor-label', `Floor ${floorNum}`);
                    }
                    
                    floorNodes.forEach(node => {
                        const nodeEl = document.createElement('div');
                        nodeEl.className = `map-node ${node.type}`;
                        nodeEl.setAttribute('data-node-index', node.index);
                        
                        const icons = {
                            enemy: '‚öîÔ∏è',
                            elite: 'üíÄ',
                            event: 'üé≤',
                            shop: 'üè™',
                            rest: 'üî•',
                            boss: 'üëë',
                             treasure: 'üì¶'
                        };
                        
                        nodeEl.textContent = icons[node.type];
                        
                        // Determine node state
                        const isCompleted = node.index <= this.currentNode;
                        const isAccessible = accessibleNodes.includes(node.index);
                        const isCurrent = node.index === this.currentNode;
                        
                        console.log(`Node ${node.index} (floor ${floorNum}): completed=${isCompleted}, accessible=${isAccessible}, current=${isCurrent}`);
                        
                        // Add click handler
                        nodeEl.addEventListener('click', (e) => {
                            e.preventDefault();
                            console.log('=== NODE CLICKED ===', node.index);
                            this.enterNode(node.index);
                        });
                        
                        nodeEl.addEventListener('touchend', (e) => {
                            e.preventDefault();
                            console.log('=== NODE TOUCHED ===', node.index);
                            this.enterNode(node.index);
                        });
                        
                        if (isCompleted) {
                            nodeEl.style.opacity = '0.3';
                            nodeEl.style.pointerEvents = 'none';
                            nodeEl.style.filter = 'grayscale(1)';
                        } else if (isAccessible) {
                            nodeEl.style.opacity = '1';
                            nodeEl.style.pointerEvents = 'auto';
                            nodeEl.style.boxShadow = '0 0 20px rgba(74, 144, 226, 0.8)';
                            nodeEl.style.animation = 'pulse 2s infinite';
                        } else {
                            nodeEl.style.opacity = '0.5';
                            nodeEl.style.pointerEvents = 'none';
                        }
                        
                        row.appendChild(nodeEl);
                    });
                    
                    mapGrid.appendChild(row);
                }
                
                // Draw connection lines after nodes are rendered
                setTimeout(() => this.drawConnections(), 50);
                
                console.log('=== RENDER MAP COMPLETE ===');
            }

            getAccessibleNodes() {
                // Starting condition - can choose any node on floor 0
                if (this.currentNode === -1) {
                    return this.map.filter(node => node.floor === 0).map(node => node.index);
                }
                
                // Otherwise, return nodes connected to current node
                return this.mapConnections[this.currentNode] || [];
            }

            drawConnections() {
                const mapGrid = document.getElementById('map-grid');
                const svg = mapGrid.querySelector('svg');
                if (!svg) return;
                
                svg.innerHTML = '';
                
                const accessibleNodes = this.getAccessibleNodes();
                
                // Draw all connections
                Object.keys(this.mapConnections).forEach(fromIndexStr => {
                    const fromIndex = parseInt(fromIndexStr);
                    const fromNode = this.map[fromIndex];
                    const toIndices = this.mapConnections[fromIndex];
                    
                    const fromEl = mapGrid.querySelector(`[data-node-index="${fromIndex}"]`);
                    if (!fromEl) return;
                    
                    toIndices.forEach(toIndex => {
                        const toNode = this.map[toIndex];
                        const toEl = mapGrid.querySelector(`[data-node-index="${toIndex}"]`);
                        if (!toEl) return;
                        
                        const fromRect = fromEl.getBoundingClientRect();
                        const toRect = toEl.getBoundingClientRect();
                        const gridRect = mapGrid.getBoundingClientRect();
                        
                        const x1 = fromRect.left - gridRect.left + fromRect.width / 2;
                        const y1 = fromRect.top - gridRect.top + fromRect.height / 2;
                        const x2 = toRect.left - gridRect.left + toRect.width / 2;
                        const y2 = toRect.top - gridRect.top + toRect.height / 2;
                        
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', x1);
                        line.setAttribute('y1', y1);
                        line.setAttribute('x2', x2);
                        line.setAttribute('y2', y2);
                        
                        // Determine line style based on state
                        let strokeColor = 'rgba(74, 144, 226, 0.2)';
                        let strokeWidth = '2';
                        
                        if (fromIndex === this.currentNode && accessibleNodes.includes(toIndex)) {
                            // Active path from current node
                            strokeColor = 'rgba(74, 144, 226, 0.8)';
                            strokeWidth = '4';
                        } else if (fromIndex <= this.currentNode) {
                            // Completed path
                            strokeColor = 'rgba(74, 144, 226, 0.3)';
                            strokeWidth = '2';
                        }
                        
                        line.setAttribute('stroke', strokeColor);
                        line.setAttribute('stroke-width', strokeWidth);
                        line.setAttribute('stroke-linecap', 'round');
                        
                        svg.appendChild(line);
                    });
                });
            }

           enterNode(index) {
                console.log('=== ENTER NODE CALLED ===');
                console.log('Requested node index:', index);
                console.log('Current completed node:', this.currentNode);
                
                // Can't select already completed nodes
                if (index <= this.currentNode) {
                    console.log('Cannot select completed node');
                    return;
                }
                
                // Check if node is accessible via connections
                const accessibleNodes = this.getAccessibleNodes();
                if (!accessibleNodes.includes(index)) {
                    console.log('Node not accessible from current position');
                    return;
                }

                const node = this.map[index];
                console.log('Node data:', node);
                
                // Store which node we're entering (will be marked as current after completion)
                this.enteringNode = index;
                console.log('Entering node:', this.enteringNode);
                
                this.hideAllViews();
                console.log('All views hidden');

                if (node.type === 'enemy' || node.type === 'elite' || node.type === 'boss') {
                    console.log('Starting combat with enemies:', node.enemies);
                    this.startCombat(node.enemies);
                } else if (node.type === 'event') {
                    console.log('Starting random event');
                    this.startEvent();
                } else if (node.type === 'shop') {
                    console.log('Opening shop');
                    this.showShop();
                } else if (node.type === 'rest') {
                    console.log('Showing rest site');
                    this.showRest();
                } else if (node.type === 'treasure') {
                    console.log('Opening treasure chest');
                    this.showTreasure();
                }
                
                console.log('=== ENTER NODE COMPLETE ===');
            }

            startCombat(enemyIds) {
                console.log('=== START COMBAT CALLED ===');
                console.log('Enemy IDs:', enemyIds);
                
                this.enemies = enemyIds.map(id => {
                    const template = ENEMY_DATABASE[id];
                    console.log('Creating enemy from template:', id, template);
                    return {
                        ...template,
                        hp: template.hp,
                        maxHp: template.maxHp,
                        block: 0,
                        patternIndex: 0,
                        nextIntent: null,
                        buffs: [],
                        persistentBlock: template.hasPersistentBlock || false  // Add this line
                    };
                });
                
                console.log('Enemies created:', this.enemies.length);
            
                this.setupCombat();
                console.log('Combat setup complete');
                
                this.setEnemyIntents();
                console.log('Enemy intents set');
                
                this.hideAllViews();
                
                const combatView = document.getElementById('combat-view');
                console.log('Combat view element:', combatView);
                
                if (combatView) {
                    combatView.style.display = 'flex';
                    combatView.style.flexDirection = 'column';
                    combatView.classList.add('active');
                    console.log('Combat view shown');
                } else {
                    console.error('Combat view element not found!');
                }
                
                // Render after a small delay to ensure view is visible
                setTimeout(() => {
                    this.renderCombat();
                    console.log('=== START COMBAT COMPLETE ===');
                }, 50);
            }

            setupCombat() {
                this.drawPile = this.rng.shuffle(this.deck);
                this.discardPile = [];
                this.hand = [];
                this.player.energy = this.player.maxEnergy;
                this.player.block = 0;
                this.player.debuffs = {};
                this.modifiers = {};
                this.attacksPlayedThisTurn = 0;
                this.turnCount = 0;
                this.hasPlayedCardThisTurn = false;
                
                // Apply Ancient Abacus relic - +1 energy at start of combat
                if (this.hasRelic('ancientAbacus')) {
                    this.player.energy++;
                }
                
                // Apply Infinity Stone boss relic - +2 energy at start of combat
                if (this.hasRelic('infinityStone')) {
                    this.player.energy += 2;
                }
                
                // Apply Mastery Medal boss relic - start with 2 Confused
                if (this.hasRelic('masteryMedal')) {
                    this.applyDebuff('confused', 2);
                }
                
                // Apply Steel Protractor relic - start with 5 block
                if (this.hasRelic('steelProtractor')) {
                    this.player.block = 5;
                }
                
                // Draw cards (Study Guide adds +1 draw, Perfect Formula adds +2)
                let drawCount = 5;
                if (this.hasRelic('studyGuide')) {
                    drawCount += 1;
                }
                if (this.hasRelic('perfectFormula')) {
                    drawCount += 2;
                }

                console.log('=== COMBAT SETUP ===');
                console.log('Draw pile:', this.drawPile.length);
                console.log('Drawing', drawCount, 'cards');
                
                this.drawCards(drawCount);

                console.log('Hand after draw:', this.hand);
            }

            setEnemyIntents() {
                this.enemies.forEach(enemy => {
                    const pattern = enemy.patterns[enemy.patternIndex % enemy.patterns.length];
                    enemy.nextIntent = pattern;
                    enemy.patternIndex++;
                });
            }

           drawCards(count) {
                // Check for Burden curse - draw 1 less card
                let drawCount = count;
               
                if (this.hand.some(cardId => cardId === 'burden')) {
                    drawCount = Math.max(1, count - 1);
                }
                
                // Check for starting draw penalty from Overachiever's Ambition
                if (this.startingDrawPenalty) {
                    drawCount = Math.max(1, drawCount - this.startingDrawPenalty);
                }
                
                for (let i = 0; i < drawCount; i++) {
                    if (this.drawPile.length === 0) {
                        if (this.discardPile.length === 0) break;
                        this.drawPile = this.rng.shuffle(this.discardPile);
                        this.discardPile = [];
                    }
                    
                    if (this.drawPile.length > 0) {
                        const card = this.drawPile.pop();
                        this.hand.push(card);
                        console.log('Drew card:', card);
                    }
                }
               console.log('Final hand:', this.hand);
                this.renderHand();
            }

            renderCombat() {
                console.log('=== RENDER COMBAT CALLED ===');
                console.log('Enemies to render:', this.enemies.length);
                
                // Render enemies
                const enemyArea = document.getElementById('enemy-area');
                console.log('Enemy area element:', enemyArea);
                
                if (!enemyArea) {
                    console.error('Enemy area not found!');
                    return;
                }
                
                enemyArea.innerHTML = '';

                this.enemies.forEach((enemy, index) => {
                    console.log(`Rendering enemy ${index}:`, enemy.name);
                    
                    const enemyEl = document.createElement('div');
                    enemyEl.className = 'enemy';
                    
                    const intentIcon = {
                        attack: '‚öîÔ∏è',
                        defend: 'üõ°Ô∏è',
                        buff: 'üí™',
                        debuff: 'üíÄ',
                        special: 'üí•'
                    }[enemy.nextIntent.intent] || '‚ùì';

                    // Build intent text
                    let intentText = '';
                    if (enemy.nextIntent.intent === 'attack') {
                        intentText = `${enemy.nextIntent.value} damage`;
                        if (enemy.nextIntent.debuff) {
                            intentText += ` + ${enemy.nextIntent.debuffStacks} ${enemy.nextIntent.debuff}`;
                        }
                    } else if (enemy.nextIntent.intent === 'defend') {
                        intentText = `${enemy.nextIntent.value} block`;
                    } else if (enemy.nextIntent.intent === 'buff') {
                        intentText = `+${enemy.nextIntent.value} strength`;
                    } else if (enemy.nextIntent.intent === 'debuff') {
                        intentText = `${enemy.nextIntent.value} ${enemy.nextIntent.debuffName}`;
                    } else if (enemy.nextIntent.intent === 'special') {
                        intentText = enemy.nextIntent.name || 'Special';
                    }

                    enemyEl.innerHTML = `
                        <div class="enemy-name">${enemy.name}</div>
                        <div class="enemy-sprite">${enemy.sprite}</div>
                        <div class="enemy-hp-bar">
                            <div class="enemy-hp-fill" style="width: ${(enemy.hp / enemy.maxHp) * 100}%"></div>
                        </div>
                        <div style="font-size: 14px;">${enemy.hp}/${enemy.maxHp} HP</div>
                        ${enemy.block > 0 ? `<div style="color: #2ecc71; margin-top: 5px;">üõ°Ô∏è ${enemy.block}</div>` : ''}
                        <div class="enemy-intent">
                            <div class="intent-icon">${intentIcon}</div>
                            ${intentText}
                        </div>
                    `;
                    
                    enemyArea.appendChild(enemyEl);
                });

                console.log('Enemies rendered');
                this.renderPlayerDebuffs();
                this.renderHand();
                console.log('=== RENDER COMBAT COMPLETE ===');
            }

            renderHand() {
                console.log('=== RENDER HAND ===');
                console.log('Hand contents:', this.hand);
                
                const handEl = document.getElementById('hand');
                if (!handEl) {
                    console.error('Hand element not found!');
                    return;
                }
                
                handEl.innerHTML = '';
            
                if (!this.hand || this.hand.length === 0) {
                    console.warn('Hand is empty!');
                    handEl.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #888; padding: 20px;">No cards in hand</div>';
                    return;
                }
                
                // Check if Regret curse is in hand - increases all card costs by 1
                const hasRegret = this.hand.some(cardId => cardId === 'regret');
            
                this.hand.forEach((cardId, index) => {
                    const card = CARD_DATABASE[cardId];
                    if (!card) {
                        console.error('Card not found in database:', cardId);
                        return;
                    }
                    
                    const cardEl = document.createElement('div');
                    cardEl.className = `card ${card.type}`;
                    
                    // Calculate effective energy cost
                    let effectiveEnergy = card.energy;
                    if (hasRegret && card.type !== 'curse' && effectiveEnergy >= 0) {
                        effectiveEnergy += 1;
                    }
                    
                    // Mark unplayable cards
                    if (effectiveEnergy < 0 || effectiveEnergy > this.player.energy) {
                        cardEl.classList.add('unplayable');
                    }
            
                    // Display energy (show "X" for unplayable curses)
                    const energyDisplay = effectiveEnergy < 0 ? 'X' : effectiveEnergy;
                    
                    cardEl.innerHTML = `
                        <div class="card-energy">${energyDisplay}</div>
                        <div class="card-name">${card.name}</div>
                        <div class="card-type">${card.type}</div>
                        <div class="card-description">${card.description}</div>
                    `;
            
                    // Use both click and touchend for better mobile support
                    const playCardHandler = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.playCard(index);
                    };
                    
                    cardEl.addEventListener('click', playCardHandler);
                    cardEl.addEventListener('touchend', playCardHandler);
                    
                    handEl.appendChild(cardEl);
                });
                console.log('Rendered', this.hand.length, 'cards');
            }

            renderPlayerDebuffs() {
                const debuffsEl = document.getElementById('player-debuffs');
                debuffsEl.innerHTML = '';
            
                const debuffInfo = {
                    confused: { 
                        icon: 'üòµ', 
                        name: 'Confused', 
                        color: '#9b59b6', 
                        desc: 'Deal 25% less damage' 
                    },
                    exposed: { 
                        icon: 'üéØ', 
                        name: 'Exposed', 
                        color: '#e74c3c', 
                        desc: 'Take 50% more damage' 
                    },
                    distracted: { 
                        icon: 'üí≠', 
                        name: 'Distracted', 
                        color: '#3498db', 
                        desc: 'Gain 25% less block' 
                    },
                    slowed: { 
                        icon: 'üêå', 
                        name: 'Slowed', 
                        color: '#95a5a6', 
                        desc: 'Start with 1 less energy next turn' 
                    }
                };
            
                Object.keys(this.player.debuffs).forEach(debuffType => {
                    const stacks = this.player.debuffs[debuffType];
                    if (stacks > 0) {
                        const info = debuffInfo[debuffType];
                        const debuffEl = document.createElement('div');
                        debuffEl.className = `player-debuff debuff-${debuffType}`;
                        debuffEl.style.background = `${info.color}40`;
                        debuffEl.style.border = `2px solid ${info.color}`;
                        debuffEl.style.color = '#fff';
                        debuffEl.style.cursor = 'pointer';
                        debuffEl.innerHTML = `${info.icon} ${info.name} ${stacks}`;
                        
                        // Desktop hover tooltip
                        debuffEl.title = `${info.desc} (${stacks} turn${stacks > 1 ? 's' : ''} remaining)`;
                        
                        // Mobile tap tooltip
                        const showDebuffTooltip = (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            
                            // Remove any existing tooltips
                            document.querySelectorAll('.debuff-tooltip').forEach(tt => tt.remove());
                            
                            // Create tooltip
                            const tooltip = document.createElement('div');
                            tooltip.className = 'debuff-tooltip';
                            tooltip.style.cssText = `
                                position: fixed;
                                top: 50%;
                                left: 50%;
                                transform: translate(-50%, -50%);
                                background: rgba(0, 0, 0, 0.95);
                                border: 3px solid ${info.color};
                                border-radius: 15px;
                                padding: 25px;
                                max-width: 90%;
                                z-index: 3000;
                                text-align: center;
                                box-shadow: 0 10px 40px rgba(0,0,0,0.8);
                            `;
                            
                            tooltip.innerHTML = `
                                <div style="font-size: 56px; margin-bottom: 15px;">${info.icon}</div>
                                <div style="font-size: 26px; color: ${info.color}; margin-bottom: 10px; font-weight: bold;">${info.name}</div>
                                <div style="font-size: 18px; color: #ccc; line-height: 1.6; margin-bottom: 15px;">${info.desc}</div>
                                <div style="font-size: 16px; color: ${info.color}; margin-bottom: 20px;">Duration: ${stacks} turn${stacks > 1 ? 's' : ''}</div>
                                <button class="btn btn-end-turn" style="padding: 10px 30px; background: linear-gradient(135deg, ${info.color}, ${info.color}cc);">Close</button>
                            `;
                            
                            // Backdrop
                            const backdrop = document.createElement('div');
                            backdrop.style.cssText = `
                                position: fixed;
                                top: 0;
                                left: 0;
                                width: 100%;
                                height: 100%;
                                background: rgba(0, 0, 0, 0.7);
                                z-index: 2999;
                            `;
                            
                            const closeTooltip = () => {
                                tooltip.remove();
                                backdrop.remove();
                            };
                            
                            tooltip.querySelector('button').onclick = closeTooltip;
                            backdrop.onclick = closeTooltip;
                            
                            document.body.appendChild(backdrop);
                            document.body.appendChild(tooltip);
                        };
                        
                        // Add touch and click handlers
                        debuffEl.addEventListener('click', showDebuffTooltip);
                        debuffEl.addEventListener('touchstart', showDebuffTooltip);
                        
                        debuffsEl.appendChild(debuffEl);
                    }
                });
            }

            playCard(handIndex) {
                const cardId = this.hand[handIndex];
                const card = CARD_DATABASE[cardId];

                // Check if Regret curse is in hand
                const hasRegret = this.hand.some(id => id === 'regret');
                let effectiveEnergy = card.energy;
                if (hasRegret && card.type !== 'curse' && effectiveEnergy >= 0) {
                    effectiveEnergy += 1;
                }

                // Recursive Ring relic - first card each turn costs 0
                if (this.hasRelic('recursiveRing') && !this.hasPlayedCardThisTurn) {
                    effectiveEnergy = 0;
                    this.hasPlayedCardThisTurn = true;
                }

                // Can't play unplayable cards
                if (effectiveEnergy < 0 || effectiveEnergy > this.player.energy) return;

                // NEW: If it's an attack card and there are multiple enemies, enable targeting
                if (card.type === 'attack' && this.enemies.length > 1) {
                    this.startTargeting(handIndex, effectiveEnergy);
                    return;
                }

                // Execute the card immediately (single enemy or non-attack)
                this.executeCard(handIndex, effectiveEnergy, 0);
            }

            startTargeting(handIndex, effectiveEnergy) {
                this.targetingActive = true;
                this.targetingHandIndex = handIndex;
                this.targetingEffectiveEnergy = effectiveEnergy;

                // Add escape key handler
                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        this.cancelTargeting();
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);
                
                // Add click-outside-to-cancel
                const cancelHandler = (e) => {
                    if (!e.target.closest('.enemy') && !e.target.closest('.card')) {
                        this.cancelTargeting();
                        document.removeEventListener('click', cancelHandler);
                    }
                };
                setTimeout(() => document.addEventListener('click', cancelHandler), 100);
                
                // Highlight enemies as targetable
                document.querySelectorAll('.enemy').forEach((enemyEl, index) => {
                    enemyEl.classList.add('targetable');
                    enemyEl.style.cursor = 'pointer';
                    enemyEl.style.transform = 'scale(1.05)';
                    enemyEl.style.boxShadow = '0 0 20px rgba(231, 76, 60, 0.8)';
                    
                    // Add click handler for targeting
                    enemyEl.onclick = () => this.selectTarget(index);
                });
                
                // Show targeting UI message
                const message = document.createElement('div');
                message.id = 'targeting-message';
                message.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.9);
                    border: 3px solid #e74c3c;
                    border-radius: 15px;
                    padding: 20px 40px;
                    font-size: 24px;
                    color: #e74c3c;
                    z-index: 1000;
                    pointer-events: none;
                    animation: pulse 1s infinite;
                `;
                message.textContent = 'üéØ Select a Target';
                document.body.appendChild(message);
            }

            selectTarget(enemyIndex) {
                if (!this.targetingActive) return;
                
                // Execute the card on the selected enemy
                this.executeCard(this.targetingHandIndex, this.targetingEffectiveEnergy, enemyIndex);
                
                // Clear targeting state
                this.cancelTargeting();
            }

            cancelTargeting() {
                this.targetingActive = false;
                this.targetingHandIndex = null;
                this.targetingEffectiveEnergy = null;
                
                // Remove targeting visuals
                document.querySelectorAll('.enemy').forEach(enemyEl => {
                    enemyEl.classList.remove('targetable');
                    enemyEl.style.cursor = '';
                    enemyEl.style.transform = '';
                    enemyEl.style.boxShadow = '';
                    enemyEl.onclick = null;
                });
                
                // Remove targeting message
                const message = document.getElementById('targeting-message');
                if (message) {
                    message.remove();
                }
            }

            executeCard(handIndex, effectiveEnergy, targetIndex = 0) {
                const cardId = this.hand[handIndex];
                const card = CARD_DATABASE[cardId];

                // Check for double next modifier
                const playTwice = this.modifiers.doubleNext > 0;
                if (playTwice) {
                    this.modifiers.doubleNext--;
                }

                this.player.energy -= effectiveEnergy;
                
                if (card.type === 'attack') {
                    this.lastAttackCard = card;
                }

                // Store target for card effect to use
                this.currentTarget = targetIndex;
                card.effect(this);

                if (playTwice && card.type !== 'curse') {
                    card.effect(this);
                }

                this.hand.splice(handIndex, 1);
                
                // Confusion exhausts (removed from deck permanently)
                if (cardId === 'confusion') {
                    const deckIndex = this.deck.indexOf(cardId);
                    if (deckIndex > -1) {
                        this.deck.splice(deckIndex, 1);
                    }
                } else {
                    this.discardPile.push(cardId);
                }

                this.renderPlayerDebuffs();
                this.renderHand();
                this.updateUI();

                // Check for enemy deaths
                this.enemies = this.enemies.filter(enemy => enemy.hp > 0);
                if (this.enemies.length === 0) {
                    this.winCombat();
                } else {
                    this.renderCombat();
                }
            }

            dealDamage(amount, targetIndex = null) {
                // Use provided target, or stored target, or default to first enemy
                if (targetIndex === null) {
                    targetIndex = this.currentTarget !== undefined ? this.currentTarget : 0;
                }
                
                if (targetIndex >= this.enemies.length) targetIndex = 0;
                
                let finalDamage = amount;

                // Apply modifiers
                if (this.modifiers.numericBonus) {
                    finalDamage += this.modifiers.numericBonus;
                }
                if (this.modifiers.damageMultiplier) {
                    finalDamage = Math.floor(finalDamage * (1 + this.modifiers.damageMultiplier));
                }
                if (this.modifiers.doubleAttack > 0) {
                    finalDamage *= 2;
                }

                // Apply Confused debuff - reduces damage by 25%
                if (this.player.debuffs.confused > 0) {
                    finalDamage = Math.floor(finalDamage * 0.75);
                }

                // Apply Exposed debuff on enemy - increases damage by 50%
                const enemy = this.enemies[targetIndex];
                if (enemy && enemy.exposed > 0) {
                    finalDamage = Math.floor(finalDamage * 1.5);
                }

                // Balanced Equation relic - gain 2 block when playing attack
                if (this.hasRelic('balancedEquation')) {
                    this.player.block += 2;
                }

                // Deal damage to the targeted enemy
                if (enemy) {
                    this.dealDamageToEnemy(enemy, finalDamage, targetIndex);
                }
            }

            dealDamageToEnemy(enemy, amount, targetIndex) {
                const damageBlocked = Math.min(amount, enemy.block);
                const damageToHealth = Math.max(0, amount - enemy.block);
                
                enemy.block = Math.max(0, enemy.block - amount);
                enemy.hp = Math.max(0, enemy.hp - damageToHealth);
                
                // Get the enemy element
                const enemyElements = document.querySelectorAll('.enemy');
                const enemyEl = enemyElements[targetIndex];
                
                if (enemyEl) {
                    // Flash effect
                    enemyEl.classList.add('damage-flash');
                    
                    // Shake effect
                    enemyEl.style.animation = 'enemy-shake 0.3s ease-in-out';
                    
                    // Create floating damage number
                    const damageNum = document.createElement('div');
                    damageNum.style.cssText = `
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        font-size: 32px;
                        font-weight: bold;
                        color: ${damageToHealth > 0 ? '#e74c3c' : '#95a5a6'};
                        text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
                        pointer-events: none;
                        z-index: 100;
                        animation: damage-float 0.8s ease-out forwards;
                    `;
                    
                    if (damageToHealth > 0) {
                        damageNum.textContent = `-${damageToHealth}`;
                    } else if (damageBlocked > 0) {
                        damageNum.textContent = 'BLOCKED';
                        damageNum.style.fontSize = '24px';
                        damageNum.style.color = '#3498db';
                    }
                    
                    enemyEl.style.position = 'relative';
                    enemyEl.appendChild(damageNum);
                    
                    // Clean up after animation
                    setTimeout(() => {
                        enemyEl.classList.remove('damage-flash');
                        enemyEl.style.animation = '';
                        damageNum.remove();
                    }, 800);
                }
                
                console.log(`Dealt ${damageToHealth} damage to ${enemy.name} (${damageBlocked} blocked). ${enemy.hp}/${enemy.maxHp} HP remaining`);
                
                this.renderCombat();
            }

            gainBlock(amount) {
                let finalBlock = amount;
                if (this.modifiers.numericBonus) {
                    finalBlock += this.modifiers.numericBonus;
                }
                
                // Apply Distracted debuff - reduces block by 25%
                if (this.player.debuffs.distracted > 0) {
                    finalBlock = Math.floor(finalBlock * 0.75);
                }
                
                this.player.block += finalBlock;
                
                // Blue flash effect for gaining block
                this.flashScreen('blue');
                
                this.updateUI();
            }
            
            flashScreen(color) {
                const flash = document.createElement('div');
                flash.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 9999;
                    animation: flash-${color} 0.3s ease-out;
                `;
                
                // Add color-specific styles
                if (color === 'blue') {
                    flash.style.background = 'rgba(52, 152, 219, 0.5)';
                } else if (color === 'red') {
                    flash.style.background = 'rgba(231, 76, 60, 0.6)';
                } else if (color === 'gray') {
                    flash.style.background = 'rgba(149, 165, 166, 0.4)';
                }
                
                document.body.appendChild(flash);
                
                setTimeout(() => {
                    flash.remove();
                }, 300);
            }

            addModifier(type, value) {
                if (value === -1) {
                    // Permanent modifier
                    this.modifiers[type] = -1;
                } else {
                    this.modifiers[type] = (this.modifiers[type] || 0) + value;
                }
            }

            async endTurn() {
                // Apply Pain curse damage for each Pain in hand
                const painCount = this.hand.filter(cardId => cardId === 'pain').length;
                if (painCount > 0) {
                    this.takeDamage(painCount * 2);
                }
                
                // Discard hand
                this.discardPile.push(...this.hand);
                this.hand = [];
            
                // Enemy turn - now async
                await this.enemyTurn();
                
                // Only continue if player is still alive
                if (this.player.hp <= 0) {
                    return;
                }
            
                // Reset enemy block at start of player turn (unless they have persistent block ability)
                this.enemies.forEach(enemy => {
                    if (!enemy.persistentBlock) {
                        enemy.block = 0;
                    }
                });
            
                // Start new turn
                let maxEnergy = this.player.maxEnergy;
                
                // Apply Slowed debuff - reduces energy by 1
                if (this.player.debuffs.slowed > 0) {
                    maxEnergy = Math.max(1, maxEnergy - 1);
                }
                
                this.player.energy = maxEnergy;
                this.player.block = 0; // Block doesn't carry over
                this.turnCount++;
                this.attacksPlayedThisTurn = 0;
                this.hasPlayedCardThisTurn = false; // Reset for Recursive Ring relic
            
                // Decay debuffs
                Object.keys(this.player.debuffs).forEach(debuffType => {
                    this.player.debuffs[debuffType]--;
                    if (this.player.debuffs[debuffType] <= 0) {
                        delete this.player.debuffs[debuffType];
                    }
                });
            
                // Apply relic effects
                if (this.hasRelic('calculatorWatch') && this.turnCount % 5 === 0) {
                    this.player.energy++;
                    this.player.maxEnergy++;
                }
                if (this.hasRelic('fractionPendant')) {
                    this.player.block += this.enemies.length;
                }
                // Apply Axiom Amulet boss relic - gain 10 block at turn start
                if (this.hasRelic('axiomAmulet')) {
                    this.player.block += 10;
                }
            
                // Decay turn-based modifiers
                for (let key in this.modifiers) {
                    if (this.modifiers[key] > 0 && key !== 'remainderBoost') {
                        this.modifiers[key]--;
                        if (this.modifiers[key] === 0) {
                            delete this.modifiers[key];
                        }
                    }
                }
            
                this.drawCards(5);
                
                // Study Guide relic - draw 1 additional card
                if (this.hasRelic('studyGuide')) {
                    this.drawCards(1);
                }
                
                // Perfect Formula boss relic - draw 2 extra cards
                if (this.hasRelic('perfectFormula')) {
                    this.drawCards(2);
                }
                
                this.setEnemyIntents();
                this.renderCombat();
                this.updateUI();
            }

            async enemyTurn() {
                // Disable end turn button during enemy turn
                const endTurnBtn = document.querySelector('.btn-end-turn');
                if (endTurnBtn) {
                    endTurnBtn.disabled = true;
                    endTurnBtn.style.opacity = '0.5';
                }
                
                // Process each enemy sequentially (left to right)
                for (let i = 0; i < this.enemies.length; i++) {
                    const enemy = this.enemies[i];
                    const intent = enemy.nextIntent;
                    
                    // Highlight the attacking enemy
                    const enemyElements = document.querySelectorAll('.enemy');
                    if (enemyElements[i]) {
                        enemyElements[i].style.boxShadow = '0 0 30px rgba(231, 76, 60, 1)';
                        enemyElements[i].style.transform = 'scale(1.1)';
                    }
                    
                    // Wait a moment to show which enemy is acting
                    await this.wait(400);
                    
                    if (intent.intent === 'attack') {
                        let damage = intent.value;
                        
                        // Apply half damage modifier
                        if (this.modifiers.halfDamage > 0) {
                            damage = Math.floor(damage / 2);
                            this.modifiers.halfDamage--;
                        }
            
                        // Apply Exposed debuff - player takes 50% more damage
                        if (this.player.debuffs.exposed > 0) {
                            damage = Math.floor(damage * 1.5);
                        }
            
                        // Calculate damage blocked vs actual damage taken
                        const damageBlocked = Math.min(damage, this.player.block);
                        const damageToHealth = Math.max(0, damage - this.player.block);
                        
                        this.player.block = Math.max(0, this.player.block - damage);
                        this.player.hp = Math.max(0, this.player.hp - damageToHealth);
            
                        console.log(`Enemy ${enemy.name} dealt ${damage} damage (${damageBlocked} blocked, ${damageToHealth} to HP). Player HP: ${this.player.hp}`);
            
                        // Visual feedback based on damage type
                        if (damageToHealth > 0) {
                            // Red flash - took damage to HP
                            this.flashScreen('red');
                            // Shake the screen
                            this.shakeScreen();
                        } else if (damageBlocked > 0) {
                            // Gray/blue flash - fully blocked
                            this.flashScreen('gray');
                        }
                        
                        // Update UI to show damage immediately
                        this.updateUI();
            
                        // Apply debuff if attack has debuff attached
                        if (intent.debuff) {
                            this.applyDebuff(intent.debuff, intent.debuffStacks);
                            this.renderPlayerDebuffs();
                        }
                    } else if (intent.intent === 'defend') {
                        enemy.block += intent.value;
                    } else if (intent.intent === 'buff') {
                        enemy.buffs.push({ type: 'strength', value: intent.value });
                    } else if (intent.intent === 'debuff') {
                        // Pure debuff move
                        this.applyDebuff(intent.debuffType, intent.value);
                        this.renderPlayerDebuffs();
                    } else if (intent.intent === 'special') {
                        // Special attacks can have multiple debuffs
                        let damage = intent.value;
                        
                        if (this.player.debuffs.exposed > 0) {
                            damage = Math.floor(damage * 1.5);
                        }
            
                        const damageBlocked = Math.min(damage, this.player.block);
                        const damageToHealth = Math.max(0, damage - this.player.block);
                        
                        this.player.block = Math.max(0, this.player.block - damage);
                        this.player.hp = Math.max(0, this.player.hp - damageToHealth);
            
                        console.log(`Enemy ${enemy.name} used special attack for ${damage} damage (${damageBlocked} blocked, ${damageToHealth} to HP). Player HP: ${this.player.hp}`);
            
                        // Visual feedback
                        if (damageToHealth > 0) {
                            this.flashScreen('red');
                            this.shakeScreen();
                        } else if (damageBlocked > 0) {
                            this.flashScreen('gray');
                        }
                        
                        this.updateUI();
            
                        if (intent.debuff) {
                            this.applyDebuff(intent.debuff, intent.debuffStacks);
                            this.renderPlayerDebuffs();
                        }
                        if (intent.additionalDebuff) {
                            this.applyDebuff(intent.additionalDebuff, intent.additionalStacks);
                            this.renderPlayerDebuffs();
                        }
                    }
                    
                    // Remove highlight from enemy
                    if (enemyElements[i]) {
                        enemyElements[i].style.boxShadow = '';
                        enemyElements[i].style.transform = '';
                    }
                    
                    // Wait between enemy attacks
                    await this.wait(600);
                    
                    // Update combat display after each enemy
                    this.renderCombat();
                    
                    // Check if player died
                    if (this.player.hp <= 0) {
                        console.log('Player died during enemy turn');
                        await this.wait(800);
                        this.gameOver();
                        return; // Stop processing more enemies
                    }
                }
            
                // Re-enable end turn button
                if (endTurnBtn) {
                    endTurnBtn.disabled = false;
                    endTurnBtn.style.opacity = '1';
                }
            }
            
            // Helper function to wait/delay
            wait(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            shakeScreen() {
                const container = document.getElementById('game-container');
                if (container) {
                    container.style.animation = 'shake 0.3s ease-in-out';
                    setTimeout(() => {
                        container.style.animation = '';
                    }, 300);
                }
            }

            applyDebuff(debuffType, stacks) {
                if (!this.player.debuffs[debuffType]) {
                    this.player.debuffs[debuffType] = 0;
                }
                
                let finalStacks = stacks;
                
                // Focus Lens relic reduces debuff duration by 1 (minimum 1)
                if (this.hasRelic('focusLens')) {
                    finalStacks = Math.max(1, stacks - 1);
                }
                
                this.player.debuffs[debuffType] += finalStacks;
                
                // Re-render debuffs if in combat
                if (document.getElementById('combat-view').classList.contains('active')) {
                    this.renderPlayerDebuffs();
                }
            }

            showDebuffNotification(debuffType, stacks) {
                const debuffInfo = {
                    confused: { icon: 'üòµ', name: 'Confused', color: '#9b59b6' },
                    exposed: { icon: 'üéØ', name: 'Exposed', color: '#e74c3c' },
                    distracted: { icon: 'üí≠', name: 'Distracted', color: '#3498db' },
                    slowed: { icon: 'üêå', name: 'Slowed', color: '#95a5a6' }
                };

                const info = debuffInfo[debuffType];
                
                // Create a visual debuff display
                const debuffDisplay = document.createElement('div');
                debuffDisplay.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    z-index: 2000;
                    background: linear-gradient(135deg, rgba(0,0,0,0.9) 0%, rgba(20,20,20,0.9) 100%);
                    border: 3px solid ${info.color};
                    border-radius: 12px;
                    padding: 30px;
                    box-shadow: 0 20px 60px rgba(0,0,0,0.8);
                    text-align: center;
                    max-width: 90%;
                `;
                
                debuffDisplay.innerHTML = `
                    <h2 style="color: ${info.color}; margin-bottom: 20px; font-size: 48px;">${info.icon}</h2>
                    <h3 style="color: ${info.color}; margin-bottom: 10px; font-size: 24px;">${info.name} Applied!</h3>
                    <p style="color: #ccc; font-size: 18px;">Duration: ${stacks} turn${stacks > 1 ? 's' : ''}</p>
                    <button class="btn btn-end-turn" style="margin-top: 20px; background: linear-gradient(135deg, ${info.color}, ${info.color}80);">Continue</button>
                `;
                
                // Create backdrop
                const backdrop = document.createElement('div');
                backdrop.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    z-index: 1999;
                `;
                
                document.body.appendChild(backdrop);
                document.body.appendChild(debuffDisplay);
                
                // Close on button click or backdrop click
                const closeDisplay = () => {
                    debuffDisplay.remove();
                    backdrop.remove();
                };
                
                debuffDisplay.querySelector('button').onclick = closeDisplay;
                backdrop.onclick = closeDisplay;
            }

            winCombat() {
                // Check if this was an elite or boss fight
                const wasElite = this.enemies.some(enemy => enemy.tier === 'elite') || this.wasEventElite;
                const wasBoss = this.enemies.some(enemy => enemy.tier === 'boss');
                
                // Clear event elite flag
                this.wasEventElite = false;
                
                this.hideAllViews();
                
                // Gain gold with seeded random
                let goldGained = 10 + this.rng.nextInt(0, 20);
                
                // Lucky Dice relic - 50% more gold
                if (this.hasRelic('luckyDice')) {
                    goldGained = Math.floor(goldGained * 1.5);
                }
                
                // Golden Compass relic - +3 gold per combat
                if (this.hasRelic('goldenCompass')) {
                    goldGained += 3;
                }
                
                this.gainGold(goldGained);

                // Show appropriate rewards
                if (wasBoss) {
                    // Show boss relic selection FIRST
                    this.hideAllViews();
                    document.getElementById('boss-relic-view').classList.add('active');
                    this.showBossRelicRewards();
                    // Store that we need to transition after relic selection
                    this.pendingActTransition = (this.currentAct || 1) === 1;
                } else if (wasElite) {
                    document.getElementById('elite-reward-view').classList.add('active');
                    this.showRelicRewards();
                } else {
                    document.getElementById('reward-view').classList.add('active');
                    this.showCardRewards();
                }
            }

            showCardRewards() {
                const rewardEl = document.getElementById('card-rewards');
                rewardEl.innerHTML = '';

                // Get available cards (exclude basic and curse cards)
                const availableCards = Object.keys(CARD_DATABASE).filter(id => 
                    CARD_DATABASE[id].rarity !== 'basic' && CARD_DATABASE[id].type !== 'curse'
                );
                
                const rewards = [];
                for (let i = 0; i < 3; i++) {
                    const cardId = this.rng.choice(availableCards);
                    rewards.push(cardId);
                }

                rewards.forEach(cardId => {
                    const card = CARD_DATABASE[cardId];
                    const cardEl = document.createElement('div');
                    cardEl.className = `reward-card ${card.type}`;
                    cardEl.innerHTML = `
                        <div class="card-energy">${card.energy}</div>
                        <div class="card-name">${card.name}</div>
                        <div class="card-type">${card.type}</div>
                        <div class="card-description">${card.description}</div>
                    `;
                    cardEl.onclick = () => {
                        this.deck.push(cardId);
                        this.proceedAfterReward();
                    };
                    rewardEl.appendChild(cardEl);
                });
            }

            skipReward() {
                this.proceedAfterReward();
            }

            proceedAfterReward() {
                console.log('=== PROCEED AFTER REWARD ===');
                console.log('Current node before:', this.currentNode);
                console.log('Entering node:', this.enteringNode);

                // Check if we need to handle act transition
                if (this.pendingActTransition) {
                    this.pendingActTransition = false;
                    this.showActTransition();
                    return;
                }
                
                // Check if we completed Act 2 (victory)
                if (this.currentAct === 2 && this.currentNode >= this.map.length - 1) {
                    this.victory();
                    return;
                }
                
                // Mark the node we just completed as current
                if (this.enteringNode !== undefined) {
                    this.currentNode = this.enteringNode;
                    console.log('Updated current node to:', this.currentNode);
                }
                
                if (this.currentNode >= this.map.length - 1) {
                    console.log('Reached end of map - victory!');
                    this.victory();
                } else {
                    console.log('Returning to map');
                    this.hideAllViews();
                    
                    const mapView = document.getElementById('map-view');
                    if (mapView) {
                        mapView.style.display = 'block';
                        mapView.classList.add('active');
                    }
                    
                    this.renderMap();
                    this.updateUI();
                    console.log('Map shown, current node:', this.currentNode);
                }
            }

            showActTransition() {
                this.hideAllViews();
                
                const actTransition = document.createElement('div');
                actTransition.className = 'game-over active';
                actTransition.style.background = 'linear-gradient(135deg, #1a1a2e 0%, #16213e 100%)';
                
                actTransition.innerHTML = `
                    <div class="game-over-content" style="border-color: #f39c12;">
                        <h1 style="font-size: 64px; color: #f39c12; margin-bottom: 30px;">
                            üèÜ ACT 1 COMPLETE! üèÜ
                        </h1>
                        <p style="font-size: 24px; margin-bottom: 40px; color: #e0e0e0;">
                            You have conquered the lower floors of the Tower of Mastery!
                        </p>
                        <p style="font-size: 20px; margin-bottom: 50px; color: #888;">
                            But greater challenges await above...
                        </p>
                        <button class="btn btn-end-turn" onclick="game.startAct2()" style="font-size: 24px; padding: 20px 50px;">
                            Ascend to Act 2 ‚Üí
                        </button>
                    </div>
                `;
                
                document.getElementById('game-container').appendChild(actTransition);
            }

            startAct2() {
                // Remove transition screen
                const transition = document.querySelector('.game-over');
                if (transition) {
                    transition.remove();
                }
                
                // Set current act
                this.currentAct = 2;
                
                // Full heal and restore energy
                this.player.hp = this.player.maxHp;
                this.player.energy = this.player.maxEnergy;
                
                // Bonus reward for completing Act 1
                this.gainGold(100);
                alert('You gain 100 gold for completing Act 1! üí∞');
                
                // Reset map progress
                this.currentNode = -1;
                this.enteringNode = null;
                
                // Generate Act 2 map
                this.initMap();
                
                // Show map
                this.hideAllViews();
                document.getElementById('map-view').classList.add('active');
                
                this.updateUI();
            }

            startEvent() {
                // Events are like Slay the Spire's ? nodes - could be ANYTHING!
                const eventTypes = [
                    'combat',      // Surprise fight
                    'combat',      // Weight it more
                    'elite',       // Rare elite encounter
                    'shop',        // Merchant appears
                    'rest',        // Lucky rest spot
                    'treasure',    // Found treasure!
                    'event',       // Actual event
                    'event',       // Weight events more
                    'event'
                ];
                
                const selectedType = this.rng.choice(eventTypes);
                
                // Handle the random event type
                if (selectedType === 'combat') {
                    // Random combat encounter
                    this.showEventSurpriseCombat();
                } else if (selectedType === 'elite') {
                    // Rare elite encounter
                    this.showEventEliteCombat();
                } else if (selectedType === 'shop') {
                    // Merchant appears
                    alert("A traveling merchant appears!");
                    this.showShop();
                } else if (selectedType === 'rest') {
                    // Lucky rest spot
                    alert("You find a peaceful clearing to rest.");
                    this.showRest();
                } else if (selectedType === 'treasure') {
                    // Found treasure!
                    alert("You discover a hidden treasure chest!");
                    this.showTreasure();
                } else {
                    // Regular event
                    this.showRegularEvent();
                }
            }

            showEventSurpriseCombat() {
                // Show a warning, then start combat
                const proceed = confirm("‚ö†Ô∏è You hear noises ahead... prepare for battle!");
                
                if (proceed) {
                    // Generate appropriate enemy based on current floor
                    const currentFloor = this.map[this.enteringNode].floor;
                    
                    let enemyPool;
                    if (currentFloor <= 2) {
                        enemyPool = ['plusBug', 'minusMite', 'divisionDot'];
                    } else if (currentFloor <= 5) {
                        enemyPool = ['timesToad', 'equationBat', 'factorialFox'];
                    } else if (currentFloor <= 9) {
                        enemyPool = ['divvySlime', 'exponentEagle', 'rootRhino'];
                    } else {
                        enemyPool = ['divvySlime', 'exponentEagle', 'rootRhino'];
                    }
                    
                    const enemy = this.rng.choice(enemyPool);
                    this.startCombat([enemy]);
                }
            }

            showEventEliteCombat() {
                const proceed = confirm("‚ö†Ô∏è An elite enemy blocks your path! Fight for great rewards?");
                
                if (proceed) {
                    const eliteEnemies = ['conceptGuardian', 'variableViper', 'theoremTitan'];
                    const enemy = this.rng.choice(eliteEnemies);
                    
                    // Store that this was an elite encounter
                    this.wasEventElite = true;
                    this.startCombat([enemy]);
                } else {
                    // Skip the elite
                    this.proceedAfterReward();
                }
            }

            showRegularEvent() {
                const event = this.rng.choice(EVENTS);
                
                document.getElementById('event-title').textContent = event.name;
                document.getElementById('event-description').textContent = event.description;
                
                const choicesEl = document.getElementById('event-choices');
                choicesEl.innerHTML = '';

                event.choices.forEach(choice => {
                    const choiceEl = document.createElement('div');
                    choiceEl.className = 'event-choice';
                    choiceEl.innerHTML = `<strong>${choice.text}</strong>`;
                    choiceEl.onclick = () => {
                        choice.outcome();
                        alert(choice.result);
                        this.proceedAfterReward();
                    };
                    choicesEl.appendChild(choiceEl);
                });

                document.getElementById('event-view').classList.add('active');
            }

            showShop() {
                const shopItems = document.getElementById('shop-items');
                shopItems.innerHTML = '';

                // Generate shop items (exclude basic and curse cards)
                const availableCards = Object.keys(CARD_DATABASE).filter(id => 
                    CARD_DATABASE[id].rarity !== 'basic' && CARD_DATABASE[id].type !== 'curse'
                );

                for (let i = 0; i < 5; i++) {
                    const cardId = this.rng.choice(availableCards);
                    const card = CARD_DATABASE[cardId];
                    const price = card.rarity === 'common' ? 50 : card.rarity === 'uncommon' ? 75 : 100;

                    const itemEl = document.createElement('div');
                    itemEl.className = 'shop-item';
                    itemEl.innerHTML = `
                        <div class="card-name">${card.name}</div>
                        <div class="card-type">${card.type}</div>
                        <div class="card-description">${card.description}</div>
                        <div class="shop-item-price">üí∞ ${price}</div>
                    `;
                    itemEl.onclick = () => {
                        if (this.player.gold >= price) {
                            this.player.gold -= price;
                            this.deck.push(cardId);
                            alert(`Purchased ${card.name}!`);
                            itemEl.remove();
                            this.updateUI();
                        } else {
                            alert("Not enough gold!");
                        }
                    };
                    shopItems.appendChild(itemEl);
                }

                // Add curse removal option (cheaper, only removes curses)
                const curseCount = this.deck.filter(id => CARD_DATABASE[id].type === 'curse').length;
                if (curseCount > 0) {
                    const curseRemovalPrice = 50;
                    const curseRemovalEl = document.createElement('div');
                    curseRemovalEl.className = 'shop-item';
                    curseRemovalEl.style.borderColor = '#9b59b6';
                    curseRemovalEl.innerHTML = `
                        <div class="card-name" style="color: #9b59b6;">Curse Removal</div>
                        <div class="card-type">SERVICE</div>
                        <div class="card-description">Remove a curse from your deck (${curseCount} curse${curseCount > 1 ? 's' : ''})</div>
                        <div class="shop-item-price">üí∞ ${curseRemovalPrice}</div>
                    `;
                    curseRemovalEl.onclick = () => {
                        if (this.player.gold >= curseRemovalPrice) {
                            this.showRemovalModal(curseRemovalPrice, true);
                        } else {
                            alert("Not enough gold!");
                        }
                    };
                    shopItems.appendChild(curseRemovalEl);
                }

                // Add card removal option
                const removalPrice = 75;
                const removalEl = document.createElement('div');
                removalEl.className = 'shop-item';
                removalEl.style.borderColor = '#e74c3c';
                removalEl.innerHTML = `
                    <div class="card-name" style="color: #e74c3c;">Card Removal</div>
                    <div class="card-type">SERVICE</div>
                    <div class="card-description">Remove any card from your deck permanently</div>
                    <div class="shop-item-price">üí∞ ${removalPrice}</div>
                `;
                removalEl.onclick = () => {
                    if (this.player.gold >= removalPrice) {
                        this.showRemovalModal(removalPrice, false);
                    } else {
                        alert("Not enough gold!");
                    }
                };
                shopItems.appendChild(removalEl);

                document.getElementById('shop-view').classList.add('active');
            }

            leaveShop() {
                this.proceedAfterReward();
            }

            showRest() {
                document.getElementById('rest-view').classList.add('active');
            }

            restHeal() {
                const healAmount = Math.floor(this.player.maxHp * 0.3);
                this.heal(healAmount);
                alert(`You rest and recover ${healAmount} HP.`);
                this.proceedAfterReward();
            }

            restUpgrade() {
                this.showUpgradeModal();
            }

            showUpgradeModal() {
                // Create upgrade modal
                const modal = document.createElement('div');
                modal.id = 'upgrade-modal';
                modal.style.cssText = `
                    display: block;
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.9);
                    z-index: 2000;
                    overflow-y: auto;
                    -webkit-overflow-scrolling: touch;
                `;
                
                const content = document.createElement('div');
                content.className = 'removal-modal-content';
                content.style.cssText = `
                    max-width: 1200px;
                    margin: 40px auto;
                    padding: 20px;
                `;
                
                const title = document.createElement('h2');
                title.className = 'removal-modal-title';
                title.style.color = '#3498db';
                title.textContent = '‚≠ê Upgrade a Card';
                
                const subtitle = document.createElement('p');
                subtitle.style.cssText = `
                    text-align: center;
                    font-size: 18px;
                    margin-bottom: 20px;
                    color: #888;
                `;
                subtitle.textContent = 'Select a card to upgrade (improves its effects)';
                
                // Count upgradeable cards (exclude curses and already upgraded cards)
                const cardCounts = {};
                this.deck.forEach(cardId => {
                    const card = CARD_DATABASE[cardId];
                    if (card.type !== 'curse' && !cardId.includes('+')) {
                        cardCounts[cardId] = (cardCounts[cardId] || 0) + 1;
                    }
                });
                
                if (Object.keys(cardCounts).length === 0) {
                    subtitle.textContent = 'No cards available to upgrade!';
                }
                
                // Render cards
                const cardsContainer = document.createElement('div');
                cardsContainer.className = 'removal-cards';
                cardsContainer.style.cssText = `
                    display: grid;
                    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
                    gap: 20px;
                `;
                
                // Sort unique card IDs
                const uniqueCardIds = Object.keys(cardCounts).sort((a, b) => {
                    const cardA = CARD_DATABASE[a];
                    const cardB = CARD_DATABASE[b];
                    if (cardA.type !== cardB.type) {
                        const typeOrder = ['attack', 'skill', 'power', 'utility'];
                        return typeOrder.indexOf(cardA.type) - typeOrder.indexOf(cardB.type);
                    }
                    return cardA.name.localeCompare(cardB.name);
                });
                
                uniqueCardIds.forEach(cardId => {
                    const card = CARD_DATABASE[cardId];
                    const count = cardCounts[cardId];
                    const cardEl = document.createElement('div');
                    cardEl.className = `deck-viewer-card removal-card ${card.type}`;
                    cardEl.style.cssText = `
                        cursor: pointer;
                        transition: all 0.3s ease;
                    `;
                    
                    const energyDisplay = card.energy < 0 ? 'X' : card.energy;
                    cardEl.innerHTML = `
                        ${count > 1 ? `<div class="deck-card-count">${count}</div>` : ''}
                        <div class="card-energy">${energyDisplay}</div>
                        <div class="card-name">${card.name}</div>
                        <div class="card-type">${card.type}</div>
                        <div class="card-description">${card.description}</div>
                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.2); font-size: 11px; color: #2ecc71;">
                            ‚ú® Click to upgrade
                        </div>
                    `;
                    
                    cardEl.onmouseover = () => {
                        cardEl.style.transform = 'scale(1.05)';
                        cardEl.style.boxShadow = '0 10px 30px rgba(52, 152, 219, 0.5)';
                    };
                    cardEl.onmouseout = () => {
                        cardEl.style.transform = 'scale(1)';
                        cardEl.style.boxShadow = 'none';
                    };
                    
                    cardEl.onclick = () => this.upgradeCard(cardId, modal);
                    
                    cardsContainer.appendChild(cardEl);
                });
                
                const cancelBtn = document.createElement('button');
                cancelBtn.className = 'btn btn-end-turn';
                cancelBtn.textContent = 'Cancel';
                cancelBtn.style.cssText = `
                    display: block;
                    margin: 30px auto 0;
                    background: linear-gradient(135deg, #95a5a6, #7f8c8d);
                `;
                cancelBtn.onclick = () => {
                    document.body.removeChild(modal);
                    this.proceedAfterReward();
                };
                
                content.appendChild(title);
                content.appendChild(subtitle);
                content.appendChild(cardsContainer);
                content.appendChild(cancelBtn);
                modal.appendChild(content);
                document.body.appendChild(modal);
            }
            
            upgradeCard(cardId, modal) {
                const card = CARD_DATABASE[cardId];
                const index = this.deck.indexOf(cardId);
                
                if (index > -1) {
                    // Create upgraded version with ACTUAL improved effect
                    const upgradedId = cardId + '+';
                    
                    // Create upgraded card with improved effect function
                    CARD_DATABASE[upgradedId] = this.createUpgradedCard(card, cardId);
                    
                    // Replace in deck
                    this.deck[index] = upgradedId;
                    
                    alert(`Upgraded "${card.name}" to "${card.name}+"!\n\n${this.getUpgradeDetails(card)}`);
                    
                    document.body.removeChild(modal);
                    this.proceedAfterReward();
                }
            }
            
            createUpgradedCard(baseCard, baseId) {
                const upgraded = {
                    ...baseCard,
                    name: baseCard.name + '+',
                    upgraded: true
                };
                
                // Improve description and effect based on card type and specific card
                if (baseCard.type === 'attack') {
                    // Increase damage in description
                    upgraded.description = baseCard.description.replace(/(\d+) damage/gi, (match, num) => {
                        return (parseInt(num) + 3) + ' damage';
                    });
                    
                    // Create improved effect function
                    if (baseId === 'strike') {
                        upgraded.effect = (game) => {
                            game.dealDamage(9); // Was 6, now 9
                        };
                    } else if (baseId === 'powerStrike') {
                        upgraded.effect = (game) => {
                            game.dealDamage(13); // Was 10, now 13
                        };
                    } else if (baseId === 'cumulativeStrike') {
                        upgraded.effect = (game) => {
                            let damage = 7 + (game.attacksPlayedThisTurn * 2); // Was 4, now 7
                            game.dealDamage(damage);
                            game.attacksPlayedThisTurn++;
                        };
                    } else if (baseId === 'overflow') {
                        upgraded.effect = baseCard.effect; // Doesn't need damage boost
                    } else if (baseId === 'evenSplit') {
                        upgraded.effect = (game) => {
                            const damagePerEnemy = Math.ceil(11 / game.enemies.length); // Was 8, now 11
                            game.enemies.forEach(enemy => {
                                game.dealDamageToEnemy(enemy, damagePerEnemy);
                            });
                        };
                    } else if (baseId === 'equationBurst') {
                        upgraded.effect = (game) => {
                            for (let i = 0; i < 3; i++) {
                                game.dealDamage(10); // Was 7, now 10
                            }
                        };
                    } else {
                        // Generic attack upgrade
                        upgraded.effect = (game) => {
                            game.dealDamage(parseInt(baseCard.description.match(/\d+/)[0]) + 3);
                        };
                    }
                } else if (baseCard.type === 'skill') {
                    // Increase block in description
                    upgraded.description = baseCard.description.replace(/(\d+) Block/gi, (match, num) => {
                        return (parseInt(num) + 3) + ' Block';
                    });
                    
                    // Create improved effect function
                    if (baseId === 'defend') {
                        upgraded.effect = (game) => {
                            game.gainBlock(8); // Was 5, now 8
                        };
                    } else if (baseId === 'subtractBlock') {
                        upgraded.effect = (game) => {
                            game.gainBlock(10); // Was 7, now 10
                        };
                    } else if (baseId === 'negativeSpace') {
                        upgraded.effect = baseCard.effect; // Doesn't scale with numbers
                    } else if (baseId === 'reduceFraction') {
                        upgraded.effect = (game) => {
                            game.removeDebuff();
                            game.gainBlock(9); // Was 6, now 9
                        };
                    } else if (baseId === 'cleanse') {
                        upgraded.effect = (game) => {
                            game.player.debuffs = {};
                            game.gainBlock(7); // Was 4, now 7
                        };
                    } else {
                        // Generic skill upgrade
                        upgraded.effect = baseCard.effect;
                    }
                } else if (baseCard.type === 'utility') {
                    // Improve utility effects
                    upgraded.description = baseCard.description.replace(/\+(\d+)/g, (match, num) => {
                        return '+' + (parseInt(num) + 2);
                    }).replace(/(\d+) card/gi, (match, num) => {
                        return (parseInt(num) + 1) + ' card';
                    });
                    
                    if (baseId === 'sumItUp') {
                        upgraded.effect = (game) => {
                            game.addModifier('numericBonus', 4); // Was 2, now 4
                        };
                    } else if (baseId === 'sequenceStep') {
                        upgraded.effect = (game) => {
                            game.drawCards(3); // Was 2, now 3
                        };
                    } else if (baseId === 'parenthesis') {
                        upgraded.effect = baseCard.effect; // Already powerful
                    } else if (baseId === 'cancelOut') {
                        upgraded.effect = baseCard.effect; // Effect doesn't scale
                    } else {
                        upgraded.effect = baseCard.effect;
                    }
                } else if (baseCard.type === 'power') {
                    // Improve power duration/strength
                    upgraded.description = baseCard.description.replace(/(\d+) turn/gi, (match, num) => {
                        return (parseInt(num) + 1) + ' turn';
                    });
                    
                    if (baseId === 'exponentialBurst') {
                        upgraded.effect = (game) => {
                            game.addModifier('doubleAttack', 3); // Was 2, now 3
                        };
                    } else if (baseId === 'remainderBoost') {
                        upgraded.effect = baseCard.effect; // Already permanent
                    } else if (baseId === 'chainMultiply') {
                        upgraded.effect = (game) => {
                            game.addModifier('damageMultiplier', 0.75); // Was 0.5, now 0.75
                        };
                    } else {
                        upgraded.effect = baseCard.effect;
                    }
                } else {
                    // Keep original effect for other types
                    upgraded.effect = baseCard.effect;
                }
                
                return upgraded;
            }
            
            getUpgradeDetails(card) {
                if (card.type === 'attack') {
                    return 'Damage increased by 3!';
                } else if (card.type === 'skill') {
                    return 'Block increased by 3!';
                } else if (card.type === 'power') {
                    return 'Duration or power increased!';
                } else if (card.type === 'utility') {
                    return 'Effects enhanced by 2!';
                }
                return 'Card improved!';
            }
            
            getUpgradedDescription(card) {
                // Improve the card based on type
                const desc = card.description;
                
                if (card.type === 'attack') {
                    // Increase damage numbers by 3-4
                    return desc.replace(/(\d+) damage/g, (match, num) => {
                        return (parseInt(num) + 3) + ' damage';
                    });
                } else if (card.type === 'skill') {
                    // Increase block by 2-3
                    return desc.replace(/(\d+) Block/g, (match, num) => {
                        return (parseInt(num) + 3) + ' Block';
                    });
                } else if (card.type === 'power' || card.type === 'utility') {
                    // Improve other effects
                    return desc.replace(/(\d+)/g, (match, num) => {
                        return (parseInt(num) + 2).toString();
                    });
                }
                
                return desc + ' (Improved!)';
            }
            
            getUpgradeDetails(card) {
                if (card.type === 'attack') {
                    return 'Damage increased by 3!';
                } else if (card.type === 'skill') {
                    return 'Block increased by 3!';
                } else if (card.type === 'power') {
                    return 'Effects improved!';
                } else if (card.type === 'utility') {
                    return 'Effects enhanced!';
                }
                return 'Card improved!';
            }

            showTreasure() {
                this.hideAllViews();
                document.getElementById('treasure-view').classList.add('active');
                
                const treasureChoices = document.getElementById('treasure-choices');
                treasureChoices.innerHTML = '';
                
                // Get all relics player doesn't have
                const availableRelics = Object.keys(RELICS).filter(id => 
                    !this.relics.includes(id) && RELICS[id].tier !== 'boss' // No boss relics in treasure
                );
                
                if (availableRelics.length === 0) {
                    treasureChoices.innerHTML = '<p style="font-size: 20px; color: #888;">The treasure chest is empty... you have all the relics!</p>';
                    return;
                }
                
                // Show 2 random relics
                const choices = [];
                for (let i = 0; i < 2 && i < availableRelics.length; i++) {
                    const relicId = this.rng.choice(availableRelics.filter(id => !choices.includes(id)));
                    choices.push(relicId);
                }
                
                choices.forEach(relicId => {
                    const relic = RELICS[relicId];
                    const relicEl = document.createElement('div');
                    relicEl.className = 'treasure-relic';
                    
                    relicEl.innerHTML = `
                        <div class="treasure-relic-icon">${relic.icon}</div>
                        <div class="treasure-relic-name">${relic.name}</div>
                        <div class="treasure-relic-desc">${relic.description}</div>
                    `;
                    
                    relicEl.onclick = () => {
                        this.relics.push(relicId);
                        this.applyPermanentRelicEffects(relicId);
                        this.renderRelics();
                        this.proceedAfterReward();
                    };
                    
                    treasureChoices.appendChild(relicEl);
                });
            }

            skipTreasure() {
                this.proceedAfterReward();
            }

            heal(amount) {
                this.player.hp = Math.min(this.player.maxHp, this.player.hp + amount);
                this.updateUI();
            }

            takeDamage(amount) {
                this.player.hp = Math.max(0, this.player.hp - amount);
                this.updateUI();
                
                console.log('Player took', amount, 'damage. HP:', this.player.hp);
                
                if (this.player.hp <= 0) {
                    console.log('Player HP reached 0, triggering game over');
                    setTimeout(() => {
                        this.gameOver();
                    }, 500); // Small delay so player can see HP reach 0
                }
            }

            gainGold(amount) {
                this.player.gold += amount;
                this.updateUI();
            }

            addRandomCard() {
                const availableCards = Object.keys(CARD_DATABASE).filter(id => 
                    CARD_DATABASE[id].rarity !== 'basic' && CARD_DATABASE[id].type !== 'curse'
                );
                const cardId = this.rng.choice(availableCards);
                const card = CARD_DATABASE[cardId];
                this.deck.push(cardId);
                
                // Create a visual card display
                const cardDisplay = document.createElement('div');
                cardDisplay.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    z-index: 2000;
                    background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
                    border: 3px solid #2ecc71;
                    border-radius: 12px;
                    padding: 30px;
                    box-shadow: 0 20px 60px rgba(0,0,0,0.8);
                    text-align: center;
                    max-width: 90%;
                `;
                
                cardDisplay.innerHTML = `
                    <h2 style="color: #2ecc71; margin-bottom: 20px; font-size: 28px;">‚ú® Card Added! ‚ú®</h2>
                    <div class="card ${card.type}" style="width: 200px; margin: 0 auto 20px auto; pointer-events: none; transform: none; box-shadow: none;">
                        <div class="card-energy">${card.energy}</div>
                        <div class="card-name">${card.name}</div>
                        <div class="card-type">${card.type}</div>
                        <div class="card-description">${card.description}</div>
                    </div>
                    <button class="btn btn-end-turn" style="margin-top: 10px;">Continue</button>
                `;
                
                // Create backdrop
                const backdrop = document.createElement('div');
                backdrop.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    z-index: 1999;
                `;
                
                document.body.appendChild(backdrop);
                document.body.appendChild(cardDisplay);
                
                // Close on button click or backdrop click
                const closeDisplay = () => {
                    cardDisplay.remove();
                    backdrop.remove();
                };
                
                cardDisplay.querySelector('button').onclick = closeDisplay;
                backdrop.onclick = closeDisplay;
                
                console.log('Added card:', card.name);
            }

            addCurse(curseId) {
                const curse = CARD_DATABASE[curseId];
                this.deck.push(curseId);
                
                // Create a visual curse display
                const curseDisplay = document.createElement('div');
                curseDisplay.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    z-index: 2000;
                    background: linear-gradient(135deg, #2c1a1a 0%, #1a0a0a 100%);
                    border: 3px solid #8b0000;
                    border-radius: 12px;
                    padding: 30px;
                    box-shadow: 0 20px 60px rgba(0,0,0,0.8);
                    text-align: center;
                    max-width: 90%;
                `;
                
                curseDisplay.innerHTML = `
                    <h2 style="color: #8b0000; margin-bottom: 20px; font-size: 28px;">üíÄ CURSED! üíÄ</h2>
                    <div class="card curse" style="width: 200px; margin: 0 auto 20px auto; pointer-events: none; transform: none; box-shadow: none;">
                        <div class="card-energy">${curse.energy < 0 ? 'X' : curse.energy}</div>
                        <div class="card-name">${curse.name}</div>
                        <div class="card-type">${curse.type}</div>
                        <div class="card-description">${curse.description}</div>
                    </div>
                    <button class="btn btn-end-turn" style="margin-top: 10px; background: linear-gradient(135deg, #8b0000, #5a0000);">Accept Fate</button>
                `;
                
                // Create backdrop
                const backdrop = document.createElement('div');
                backdrop.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.9);
                    z-index: 1999;
                `;
                
                document.body.appendChild(backdrop);
                document.body.appendChild(curseDisplay);
                
                // Close on button click or backdrop click
                const closeDisplay = () => {
                    curseDisplay.remove();
                    backdrop.remove();
                };
                
                curseDisplay.querySelector('button').onclick = closeDisplay;
                backdrop.onclick = closeDisplay;
                
                console.log('Added curse:', curse.name);
            }

            addRandomRelic() {
                const availableRelics = Object.keys(RELICS);
                const relicId = this.rng.choice(availableRelics);
                if (!this.relics.includes(relicId)) {
                    this.relics.push(relicId);
                    this.applyPermanentRelicEffects(relicId);
                    alert(`Gained relic: ${RELICS[relicId].name}!`);
                    this.renderRelics();
                }
            }

            showRelicRewards() {
                const relicChoices = document.getElementById('relic-choices');
                relicChoices.innerHTML = '';

                // Get 3 random relics that the player doesn't have
                const availableRelics = Object.keys(RELICS).filter(id => !this.relics.includes(id));
                
                // If player has all relics, just skip
                if (availableRelics.length === 0) {
                    this.skipRelicReward();
                    return;
                }

                const numChoices = Math.min(3, availableRelics.length);
                const choices = [];
                for (let i = 0; i < numChoices; i++) {
                    const relicId = this.rng.choice(availableRelics.filter(id => !choices.includes(id)));
                    choices.push(relicId);
                }

                choices.forEach(relicId => {
                    const relic = RELICS[relicId];
                    const relicEl = document.createElement('div');
                    relicEl.className = 'relic-choice';
                    relicEl.innerHTML = `
                        <div class="relic-choice-icon">${relic.icon}</div>
                        <div class="relic-choice-name">${relic.name}</div>
                        <div class="relic-choice-desc">${relic.description}</div>
                    `;
                    relicEl.onclick = () => {
                        this.relics.push(relicId);
                        this.applyPermanentRelicEffects(relicId);
                        this.renderRelics();
                        this.proceedAfterReward();
                    };
                    relicChoices.appendChild(relicEl);
                });
            }

            showBossRelicRewards() {
                const bossRelicChoices = document.getElementById('boss-relic-choices');
                bossRelicChoices.innerHTML = '';

                // Get all boss relics that the player doesn't have
                const availableBossRelics = Object.keys(RELICS).filter(id => 
                    RELICS[id].tier === 'boss' && !this.relics.includes(id)
                );
                
                // If player has all boss relics somehow, just skip
                if (availableBossRelics.length === 0) {
                    this.skipBossRelic();
                    return;
                }

                // Show 3 random boss relics
                const numChoices = Math.min(3, availableBossRelics.length);
                const choices = [];
                for (let i = 0; i < numChoices; i++) {
                    const relicId = this.rng.choice(availableBossRelics.filter(id => !choices.includes(id)));
                    choices.push(relicId);
                }

                choices.forEach(relicId => {
                    const relic = RELICS[relicId];
                    const relicEl = document.createElement('div');
                    relicEl.className = 'boss-relic-choice';
                    
                    // Parse description to separate benefit and drawback
                    const [benefit, drawback] = relic.description.split('. ');
                    
                    relicEl.innerHTML = `
                        <div class="boss-relic-choice-icon">${relic.icon}</div>
                        <div class="boss-relic-choice-name">${relic.name}</div>
                        <div class="boss-relic-choice-desc">${benefit}</div>
                        ${drawback ? `<div class="boss-relic-drawback">‚ö†Ô∏è ${drawback}</div>` : ''}
                    `;
                    relicEl.onclick = () => {
                        this.relics.push(relicId);
                        this.applyPermanentRelicEffects(relicId);
                        this.renderRelics();
                        this.proceedAfterReward();
                    };
                    bossRelicChoices.appendChild(relicEl);
                });
            }

            skipBossRelic() {
                this.proceedAfterReward();
            }

            applyPermanentRelicEffects(relicId) {
                const relic = RELICS[relicId];
                
                // Apply permanent stat changes for certain relics
                if (relicId === 'wisdomCrown') {
                    this.player.maxEnergy++;
                    this.player.energy++;
                }
                if (relicId === 'fortifiedFormula') {
                    this.player.maxHp += 15;
                    this.player.hp += 15;
                }
                
                // Boss relic effects
                if (relicId === 'infinityStone') {
                    this.player.maxHp -= 5;
                    this.player.hp = Math.min(this.player.hp, this.player.maxHp);
                }
                if (relicId === 'perfectFormula') {
                    this.player.maxEnergy = Math.max(1, this.player.maxEnergy - 1);
                    this.player.energy = this.player.maxEnergy;
                }
                if (relicId === 'masteryMedal') {
                    this.player.maxEnergy += 2;
                    this.player.energy += 2;
                }
                if (relicId === 'proofPendant') {
                    this.player.maxHp += 25;
                    this.player.hp += 25;
                }
                if (relicId === 'hypothesisHeart') {
                    this.player.maxHp = 60;
                    this.player.hp = Math.min(this.player.hp, 60);
                }
                
                this.updateUI();
            }

            skipRelicReward() {
                this.proceedAfterReward();
            }

            showRelicViewer() {
                const relicViewer = document.getElementById('relic-viewer');
                relicViewer.classList.add('active');
                
                const relicsContainer = document.getElementById('relic-viewer-relics');
                relicsContainer.innerHTML = '';

                if (this.relics.length === 0) {
                    relicsContainer.innerHTML = '<p style="grid-column: 1/-1; text-align: center; color: #888; font-size: 18px; padding: 40px;">No relics collected yet. Defeat elite enemies to earn relics!</p>';
                    return;
                }

                this.relics.forEach(relicId => {
                    const relic = RELICS[relicId];
                    const relicEl = document.createElement('div');
                    relicEl.className = 'relic-viewer-item';
                    relicEl.innerHTML = `
                        <div class="relic-viewer-icon">${relic.icon}</div>
                        <div class="relic-viewer-name">${relic.name}</div>
                        <div class="relic-viewer-desc">${relic.description}</div>
                    `;
                    relicsContainer.appendChild(relicEl);
                });
            }

            hideRelicViewer() {
                document.getElementById('relic-viewer').classList.remove('active');
            }

            hasRelic(relicId) {
                return this.relics.includes(relicId);
            }

            removeAllEnemyBuffs() {
                this.enemies.forEach(enemy => {
                    enemy.buffs = [];
                    enemy.block = 0;
                });
                this.renderCombat();
            }

            removeDebuff() {
                // Remove one stack of the first debuff found
                const debuffTypes = Object.keys(this.player.debuffs);
                if (debuffTypes.length > 0) {
                    const debuffToRemove = debuffTypes[0];
                    this.player.debuffs[debuffToRemove]--;
                    if (this.player.debuffs[debuffToRemove] <= 0) {
                        delete this.player.debuffs[debuffToRemove];
                    }
                }
            }

            renderRelics() {
                const relicsEl = document.getElementById('relics-display');
                relicsEl.innerHTML = '';
                
                this.relics.forEach(relicId => {
                    const relic = RELICS[relicId];
                    const relicEl = document.createElement('div');
                    relicEl.className = 'relic';
                    relicEl.textContent = relic.icon;
                    relicEl.setAttribute('data-relic-name', relic.name);
                    relicEl.setAttribute('data-relic-desc', relic.description);
                    
                    // Desktop hover
                    relicEl.title = `${relic.name}: ${relic.description}`;
                    
                    // Mobile tap to show tooltip
                    const showTooltip = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // Remove any existing tooltips
                        document.querySelectorAll('.relic-tooltip').forEach(tt => tt.remove());
                        
                        // Create tooltip
                        const tooltip = document.createElement('div');
                        tooltip.className = 'relic-tooltip';
                        tooltip.style.cssText = `
                            position: fixed;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            background: rgba(0, 0, 0, 0.95);
                            border: 3px solid #f39c12;
                            border-radius: 15px;
                            padding: 20px;
                            max-width: 90%;
                            z-index: 3000;
                            text-align: center;
                        `;
                        
                        tooltip.innerHTML = `
                            <div style="font-size: 48px; margin-bottom: 15px;">${relic.icon}</div>
                            <div style="font-size: 22px; color: #f39c12; margin-bottom: 10px; font-weight: bold;">${relic.name}</div>
                            <div style="font-size: 16px; color: #ccc; line-height: 1.5; margin-bottom: 20px;">${relic.description}</div>
                            <button class="btn btn-end-turn" style="padding: 10px 30px;">Close</button>
                        `;
                        
                        // Backdrop
                        const backdrop = document.createElement('div');
                        backdrop.style.cssText = `
                            position: fixed;
                            top: 0;
                            left: 0;
                            width: 100%;
                            height: 100%;
                            background: rgba(0, 0, 0, 0.7);
                            z-index: 2999;
                        `;
                        
                        const closeTooltip = () => {
                            tooltip.remove();
                            backdrop.remove();
                        };
                        
                        tooltip.querySelector('button').onclick = closeTooltip;
                        backdrop.onclick = closeTooltip;
                        
                        document.body.appendChild(backdrop);
                        document.body.appendChild(tooltip);
                    };
                    
                    // Use touchstart for mobile, click for desktop
                    relicEl.addEventListener('click', showTooltip);
                    relicEl.addEventListener('touchstart', showTooltip);
                    
                    relicsEl.appendChild(relicEl);
                });
            }

            updateUI() {
                // Update HP
                document.getElementById('player-hp-text').textContent = 
                    `${this.player.hp}/${this.player.maxHp}`;
                document.getElementById('player-hp-fill').style.width = 
                    `${(this.player.hp / this.player.maxHp) * 100}%`;
            
                // Update Energy
                document.getElementById('player-energy').textContent = 
                    `${this.player.energy}/${this.player.maxEnergy}`;
            
                // Update Gold
                document.getElementById('player-gold').textContent = `üí∞ ${this.player.gold}`;
                
                // Update Block Display (show shield next to HP)
                const hpStat = document.querySelector('.stat');
                if (hpStat && this.player.block > 0) {
                    // Add block display if it doesn't exist
                    let blockDisplay = hpStat.querySelector('.block-display');
                    if (!blockDisplay) {
                        blockDisplay = document.createElement('span');
                        blockDisplay.className = 'block-display';
                        blockDisplay.style.cssText = `
                            color: #2ecc71;
                            font-weight: bold;
                            margin-left: 8px;
                            font-size: 14px;
                        `;
                        hpStat.appendChild(blockDisplay);
                    }
                    blockDisplay.textContent = `üõ°Ô∏è ${this.player.block}`;
                } else {
                    // Remove block display if block is 0
                    const blockDisplay = hpStat?.querySelector('.block-display');
                    if (blockDisplay) {
                        blockDisplay.remove();
                    }
                }
                
                // Update seed display
                const seedDisplayContainer = document.getElementById('seed-display-container');
                const seedDisplay = document.getElementById('seed-display');
                if (this.seedString && seedDisplayContainer && seedDisplay) {
                    seedDisplayContainer.style.display = 'flex';
                    seedDisplay.textContent = this.seedString;
                }
                
                // Update floor indicator
                const floorIndicator = document.querySelector('.floor-indicator');
                if (floorIndicator) {
                    const currentAct = this.currentAct || 1;
                    if (this.selectedBoss && this.currentNode >= 0) {
                        const bossNames = {
                            // Act 1
                            'mrPemdas': 'Mr. PEMDAS',
                            'professorCalculus': 'Prof. Calculus',
                            'theInfinity': 'The Infinity',
                            // Act 2
                            'doctorDiophantus': 'Dr. Diophantus',
                            'ladyLaplace': 'Lady Laplace',
                            'sirSigma': 'Sir Sigma'
                        };
                        const bossName = bossNames[this.selectedBoss] || 'the Boss';
                        floorIndicator.textContent = `Act ${currentAct} - Floor ${this.map[this.currentNode]?.floor || 0} - Boss: ${bossName}`;
                    } else {
                        floorIndicator.textContent = `Act ${currentAct}: Arithmetic Floor`;
                    }
                }
            }

            hideAllViews() {
                const views = [
                    'seed-view',
                    'starting-choices-view',
                    'map-view',
                    'combat-view',
                    'reward-view',
                    'elite-reward-view',
                    'boss-relic-view',
                    'treasure-view',
                    'event-view',
                    'shop-view',
                    'rest-view',
                    'deck-viewer',
                    'relic-viewer',
                    'card-removal-modal',
                    'collection-viewer'
                ];
                
                views.forEach(viewId => {
                    const view = document.getElementById(viewId);
                    if (view) {
                        view.style.display = 'none';
                        view.classList.remove('active');
                    }
                });
                
                // Also hide any game-over screens
                const gameOverScreens = document.querySelectorAll('.game-over');
                gameOverScreens.forEach(screen => {
                    screen.classList.remove('active');
                    screen.style.display = 'none';
                });
            }

            victory() {
                document.getElementById('victory-seed-value').textContent = this.seedString;
                document.getElementById('victory-screen').classList.add('active');
            }

            gameOver() {
                console.log('=== GAME OVER ===');
                console.log('Player HP:', this.player.hp);
                
                this.hideAllViews();
                
                document.getElementById('defeat-seed-value').textContent = this.seedString;
                
                const defeatScreen = document.getElementById('defeat-screen');
                if (defeatScreen) {
                    defeatScreen.style.display = 'flex';
                    defeatScreen.classList.add('active');
                }
                
                console.log('Defeat screen shown');
            }

            copySeed() {
                navigator.clipboard.writeText(this.seedString).then(() => {
                    alert(`Seed "${this.seedString}" copied!\n\nShare this seed with friends so they can play the same tower!`);
                }).catch(() => {
                    // Fallback if clipboard fails
                    alert(`Seed: ${this.seedString}\n\nShare this seed with friends!`);
                });
            }

            showDeckViewer() {
                const deckViewer = document.getElementById('deck-viewer');
                deckViewer.classList.add('active');
                
                // Count cards by type
                const cardCounts = {};
                const typeCounts = { attack: 0, skill: 0, power: 0, utility: 0, curse: 0 };
                
                this.deck.forEach(cardId => {
                    cardCounts[cardId] = (cardCounts[cardId] || 0) + 1;
                    const card = CARD_DATABASE[cardId];
                    if (card.type in typeCounts) {
                        typeCounts[card.type]++;
                    }
                });
                
                // Update stats
                document.getElementById('deck-total-count').textContent = this.deck.length;
                document.getElementById('deck-attack-count').textContent = typeCounts.attack;
                document.getElementById('deck-skill-count').textContent = typeCounts.skill;
                document.getElementById('deck-power-count').textContent = typeCounts.power;
                document.getElementById('deck-utility-count').textContent = typeCounts.utility;
                document.getElementById('deck-curse-count').textContent = typeCounts.curse;
                
                // Render cards
                const cardsContainer = document.getElementById('deck-viewer-cards');
                cardsContainer.innerHTML = '';
                
                // Sort unique card IDs by type and name
                const uniqueCardIds = Object.keys(cardCounts).sort((a, b) => {
                    const cardA = CARD_DATABASE[a];
                    const cardB = CARD_DATABASE[b];
                    if (cardA.type !== cardB.type) {
                        const typeOrder = ['attack', 'skill', 'power', 'utility', 'curse'];
                        return typeOrder.indexOf(cardA.type) - typeOrder.indexOf(cardB.type);
                    }
                    return cardA.name.localeCompare(cardB.name);
                });
                
                uniqueCardIds.forEach(cardId => {
                    const card = CARD_DATABASE[cardId];
                    const count = cardCounts[cardId];
                    const cardEl = document.createElement('div');
                    cardEl.className = `deck-viewer-card ${card.type}`;
                    const energyDisplay = card.energy < 0 ? 'X' : card.energy;
                    cardEl.innerHTML = `
                        ${count > 1 ? `<div class="deck-card-count">${count}</div>` : ''}
                        <div class="card-energy">${energyDisplay}</div>
                        <div class="card-name">${card.name}</div>
                        <div class="card-type">${card.type}</div>
                        <div class="card-description">${card.description}</div>
                    `;
                    cardsContainer.appendChild(cardEl);
                });
            }

            hideDeckViewer() {
                document.getElementById('deck-viewer').classList.remove('active');
            }

            showRemovalModal(cost, cursesOnly = false) {
                const modal = document.getElementById('card-removal-modal');
                modal.classList.add('active');
                
                document.getElementById('removal-cost').textContent = cost;
                
                // Count cards
                const cardCounts = {};
                this.deck.forEach(cardId => {
                    // Filter based on cursesOnly flag
                    const card = CARD_DATABASE[cardId];
                    if (cursesOnly && card.type !== 'curse') return;
                    
                    cardCounts[cardId] = (cardCounts[cardId] || 0) + 1;
                });
                
                // Render cards
                const cardsContainer = document.getElementById('removal-cards');
                cardsContainer.innerHTML = '';
                
                // Update modal title based on type
                document.querySelector('.removal-modal-title').textContent = 
                    cursesOnly ? '‚ú® Remove a Curse' : 'üóëÔ∏è Remove a Card';
                
                // Sort unique card IDs
                const uniqueCardIds = Object.keys(cardCounts).sort((a, b) => {
                    const cardA = CARD_DATABASE[a];
                    const cardB = CARD_DATABASE[b];
                    if (cardA.type !== cardB.type) {
                        const typeOrder = ['attack', 'skill', 'power', 'utility', 'curse'];
                        return typeOrder.indexOf(cardA.type) - typeOrder.indexOf(cardB.type);
                    }
                    return cardA.name.localeCompare(cardB.name);
                });
                
                uniqueCardIds.forEach(cardId => {
                    const card = CARD_DATABASE[cardId];
                    const count = cardCounts[cardId];
                    const cardEl = document.createElement('div');
                    cardEl.className = `deck-viewer-card removal-card ${card.type}`;
                    
                    // Frustration curse cannot be removed
                    const canRemove = cardId !== 'frustration';
                    if (!canRemove) {
                        cardEl.style.opacity = '0.5';
                        cardEl.style.cursor = 'not-allowed';
                    }
                    
                    const energyDisplay = card.energy < 0 ? 'X' : card.energy;
                    cardEl.innerHTML = `
                        ${count > 1 ? `<div class="deck-card-count">${count}</div>` : ''}
                        <div class="card-energy">${energyDisplay}</div>
                        <div class="card-name">${card.name}${!canRemove ? ' üîí' : ''}</div>
                        <div class="card-type">${card.type}</div>
                        <div class="card-description">${card.description}</div>
                    `;
                    
                    if (canRemove) {
                        cardEl.onclick = () => this.removeCardFromDeck(cardId, cost);
                    } else {
                        cardEl.onclick = () => alert("Frustration cannot be removed at shops!");
                    }
                    cardsContainer.appendChild(cardEl);
                });
            }

            closeRemovalModal() {
                document.getElementById('card-removal-modal').classList.remove('active');
            }

            removeCardFromDeck(cardId, cost) {
                if (this.player.gold < cost) {
                    alert("Not enough gold!");
                    return;
                }
                
                const card = CARD_DATABASE[cardId];
                const index = this.deck.indexOf(cardId);
                
                if (index > -1) {
                    this.deck.splice(index, 1);
                    this.player.gold -= cost;
                    alert(`Removed "${card.name}" from your deck!`);
                    this.closeRemovalModal();
                    this.updateUI();
                } else {
                    alert("Card not found in deck!");
                }
            }

            showCollection() {
            const viewer = document.getElementById('collection-viewer');
            if (viewer) {
                viewer.style.display = 'block';
                viewer.classList.add('active');
            }
            
            // Render cards by default
            this.renderCollectionCards();
        }

        closeCollection() {
            const viewer = document.getElementById('collection-viewer');
            if (viewer) {
                viewer.style.display = 'none';
                viewer.classList.remove('active');
            }
        }

        showCollectionTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.collection-tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.textContent.toLowerCase().includes(tabName)) {
                    tab.classList.add('active');
                }
            });
            
            // Show appropriate content
            document.getElementById('collection-cards-tab').style.display = tabName === 'cards' ? 'block' : 'none';
            document.getElementById('collection-relics-tab').style.display = tabName === 'relics' ? 'block' : 'none';
            
            // Render content
            if (tabName === 'cards') {
                this.renderCollectionCards();
            } else {
                this.renderCollectionRelics();
            }
        }

        renderCollectionCards() {
            const grid = document.getElementById('collection-cards-grid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            // Group cards by rarity
            const rarities = ['starter', 'common', 'uncommon', 'rare'];
            
            rarities.forEach(rarity => {
                const cards = Object.entries(CARD_DATABASE).filter(([id, card]) => card.rarity === rarity);
                
                if (cards.length > 0) {
                    const section = document.createElement('div');
                    section.style.gridColumn = '1 / -1';
                    section.style.marginTop = '20px';
                    section.innerHTML = `<h3 style="color: #9b59b6; text-transform: capitalize; margin-bottom: 15px;">${rarity} Cards (${cards.length})</h3>`;
                    grid.appendChild(section);
                    
                    cards.forEach(([cardId, card]) => {
                        const cardEl = document.createElement('div');
                        cardEl.className = `collection-card ${card.type} ${card.rarity}`;
                        
                        cardEl.innerHTML = `
                            <div class="collection-card-energy">${card.energy}</div>
                            <div class="collection-card-name">${card.name}</div>
                            <div class="collection-card-type">${card.type}</div>
                            <div class="collection-card-description">${card.description}</div>
                        `;
                        
                        grid.appendChild(cardEl);
                    });
                }
            });
        }

        renderCollectionRelics() {
            const grid = document.getElementById('collection-relics-grid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            // Group relics by tier
            const tiers = ['common', 'uncommon', 'rare', 'boss'];
            
            tiers.forEach(tier => {
                const relics = Object.entries(RELICS).filter(([id, relic]) => relic.tier === tier);
                
                if (relics.length > 0) {
                    const section = document.createElement('div');
                    section.style.gridColumn = '1 / -1';
                    section.style.marginTop = '20px';
                    section.innerHTML = `<h3 style="color: #f39c12; text-transform: capitalize; margin-bottom: 15px;">${tier} Relics (${relics.length})</h3>`;
                    grid.appendChild(section);
                    
                    relics.forEach(([relicId, relic]) => {
                        const relicEl = document.createElement('div');
                        relicEl.className = `collection-relic ${relic.tier}`;
                        
                        relicEl.innerHTML = `
                            <div class="collection-relic-icon">${relic.icon}</div>
                            <div class="collection-relic-name">${relic.name}</div>
                            <div class="collection-relic-tier">${relic.tier}</div>
                            <div class="collection-relic-desc">${relic.description}</div>
                        `;
                        
                        grid.appendChild(relicEl);
                    });
                }
            });
        }
    }

        // Start the game (but don't initialize map yet - wait for seed)
        console.log('Creating game instance...');
        const game = new Game();
        console.log('Game instance created');

        // Show seed view initially
        window.addEventListener('load', () => {
            console.log('Page loaded, showing seed view');
            const seedView = document.getElementById('seed-view');
            if (seedView) {
                seedView.style.display = 'block';
                console.log('Seed view display set to block');
            }
        });
        
        // Show collection viewer (doesn't require game instance)
        function showCollectionViewer() {
            const viewer = document.getElementById('collection-viewer');
            if (viewer) {
                viewer.style.display = 'block';
                viewer.classList.add('active');
                
                // Render using static data
                renderCollectionStatic();
            }
        }
        
        // Close collection viewer (doesn't require game instance)
        function closeCollectionViewer() {
            const viewer = document.getElementById('collection-viewer');
            if (viewer) {
                viewer.style.display = 'none';
                viewer.classList.remove('active');
            }
        }
        // Switch collection tabs (doesn't require game instance)
        function showCollectionTabStatic(tabName) {
            // Update tab buttons
            document.querySelectorAll('.collection-tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.textContent.toLowerCase().includes(tabName)) {
                    tab.classList.add('active');
                }
            });
            
            // Show appropriate content
            document.getElementById('collection-cards-tab').style.display = tabName === 'cards' ? 'block' : 'none';
            document.getElementById('collection-relics-tab').style.display = tabName === 'relics' ? 'block' : 'none';
        }
        // Standalone collection rendering (doesn't require game instance)
        function renderCollectionStatic() {
            // Render cards tab
            const cardsGrid = document.getElementById('collection-cards-grid');
            if (cardsGrid) {
                cardsGrid.innerHTML = '';
                
                // Group cards by rarity
                const rarities = ['starter', 'common', 'uncommon', 'rare'];
                
                rarities.forEach(rarity => {
                    const cards = Object.entries(CARD_DATABASE).filter(([id, card]) => card.rarity === rarity);
                    
                    if (cards.length > 0) {
                        const section = document.createElement('div');
                        section.style.gridColumn = '1 / -1';
                        section.style.marginTop = '20px';
                        section.innerHTML = `<h3 style="color: #9b59b6; text-transform: capitalize; margin-bottom: 15px;">${rarity} Cards (${cards.length})</h3>`;
                        cardsGrid.appendChild(section);
                        
                        cards.forEach(([cardId, card]) => {
                            const cardEl = document.createElement('div');
                            cardEl.className = `collection-card ${card.type} ${card.rarity}`;
                            
                            const energyDisplay = card.energy < 0 ? 'X' : card.energy;
                            
                            cardEl.innerHTML = `
                                <div class="collection-card-energy">${energyDisplay}</div>
                                <div class="collection-card-name">${card.name}</div>
                                <div class="collection-card-type">${card.type}</div>
                                <div class="collection-card-description">${card.description}</div>
                            `;
                            
                            cardsGrid.appendChild(cardEl);
                        });
                    }
                });
            }
            
            // Render relics tab
            const relicsGrid = document.getElementById('collection-relics-grid');
            if (relicsGrid) {
                relicsGrid.innerHTML = '';
                
                // Group relics by tier
                const tiers = ['common', 'uncommon', 'rare', 'boss'];
                
                tiers.forEach(tier => {
                    const relics = Object.entries(RELICS).filter(([id, relic]) => relic.tier === tier);
                    
                    if (relics.length > 0) {
                        const section = document.createElement('div');
                        section.style.gridColumn = '1 / -1';
                        section.style.marginTop = '20px';
                        section.innerHTML = `<h3 style="color: #f39c12; text-transform: capitalize; margin-bottom: 15px;">${tier} Relics (${relics.length})</h3>`;
                        relicsGrid.appendChild(section);
                        
                        relics.forEach(([relicId, relic]) => {
                            const relicEl = document.createElement('div');
                            relicEl.className = `collection-relic ${relic.tier}`;
                            
                            relicEl.innerHTML = `
                                <div class="collection-relic-icon">${relic.icon}</div>
                                <div class="collection-relic-name">${relic.name}</div>
                                <div class="collection-relic-tier">${relic.tier}</div>
                                <div class="collection-relic-desc">${relic.description}</div>
                            `;
                            
                            relicsGrid.appendChild(relicEl);
                        });
                    }
                });
            }
        }

        // Setup event handlers for seed view buttons
        function setupEventHandlers() {
            console.log('Setting up event handlers...');
            
            // Start with seed button
            const startBtn = document.getElementById('start-with-seed-btn');
            if (startBtn) {
                const startHandler = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const seedInput = document.getElementById('seed-input');
                    const seed = seedInput.value.trim() || game.generateSeed();
                    const selectedAscension = ascensionController ? ascensionController.getSelectedAscension() : 0;
                    
                    console.log('Start button clicked with seed:', seed, 'ascension:', selectedAscension);
                    startBtn.textContent = '‚è≥ Starting...';
                    startBtn.disabled = true;
                    
                    game.startWithSeed(seed, selectedAscension);
                };
                
                startBtn.addEventListener('click', startHandler);
                startBtn.addEventListener('touchend', startHandler);
                console.log('Start button handler attached');
            }
            
            // Random seed button
            const randomBtn = document.getElementById('random-seed-btn');
            if (randomBtn) {
                const randomHandler = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const seed = game.generateSeed();
                    const selectedAscension = ascensionController ? ascensionController.getSelectedAscension() : 0;
                    
                    console.log('Random button clicked, generated seed:', seed, 'ascension:', selectedAscension);
                    randomBtn.textContent = '‚è≥ Starting...';
                    randomBtn.disabled = true;
                    
                    game.startWithSeed(seed, selectedAscension);
                };
                
                randomBtn.addEventListener('click', randomHandler);
                randomBtn.addEventListener('touchend', randomHandler);
                console.log('Random button handler attached');
            }
            
            // View collection button
            const collectionBtn = document.getElementById('view-collection-btn');
            if (collectionBtn) {
                const collectionHandler = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Collection button clicked');
                    showCollectionViewer();
                };
                
                collectionBtn.addEventListener('click', collectionHandler);
                collectionBtn.addEventListener('touchend', collectionHandler);
                console.log('Collection button handler attached');
            }
            
            // View deck button - use both click and touchend
            const deckBtn = document.getElementById('view-deck-btn');
            if (deckBtn) {
                const deckHandler = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Deck button clicked/touched');
                    if (game && game.showDeckViewer) {
                        game.showDeckViewer();
                    }
                };
                
                deckBtn.addEventListener('click', deckHandler);
                deckBtn.addEventListener('touchend', deckHandler);
                console.log('Deck button handler attached');
            }
            
            // View relics button - use both click and touchend
            const relicsBtn = document.getElementById('view-relics-btn');
            if (relicsBtn) {
                const relicsHandler = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Relics button clicked/touched');
                    if (game && game.showRelicViewer) {
                        game.showRelicViewer();
                    }
                };
                
                relicsBtn.addEventListener('click', relicsHandler);
                relicsBtn.addEventListener('touchend', relicsHandler);
                console.log('Relics button handler attached');
            }
            
            // Seed display click to copy
            const seedDisplay = document.getElementById('seed-display');
            if (seedDisplay) {
                const seedHandler = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (game && game.copySeed) {
                        game.copySeed();
                    }
                };
                
                seedDisplay.addEventListener('click', seedHandler);
                seedDisplay.addEventListener('touchend', seedHandler);
            }
            
            console.log('All event handlers setup complete');
        }
        
        // ===== GLOBAL INITIALIZATION CODE (NOT A FUNCTION!) =====
        if (document.readyState === 'loading') {
            console.log('DOM still loading, waiting for DOMContentLoaded...');
            document.addEventListener('DOMContentLoaded', () => {
                console.log('Initializing game views...');
                
                // Hide all views
                const allViews = document.querySelectorAll('[id$="-view"]');
                allViews.forEach(view => {
                    view.style.display = 'none';
                    view.classList.remove('active');
                });
                
                // Explicitly hide combat view
                const combatView = document.getElementById('combat-view');
                if (combatView) {
                    combatView.style.display = 'none';
                    combatView.classList.remove('active');
                }
                
                // Show only seed view
                const seedView = document.getElementById('seed-view');
                if (seedView) {
                    seedView.style.display = 'flex';
                    seedView.classList.add('active');
                    console.log('Seed view shown');
                }
                
                // Initialize ascension controller
                ascensionController = new AscensionController();
                setTimeout(() => {
                    ascensionController.initialize();
                    setupEventHandlers();
                }, 100);
            });
        } else {
            console.log('DOM already loaded, setting up immediately');
            
            // Hide all views
            const allViews = document.querySelectorAll('[id$="-view"]');
            allViews.forEach(view => {
                view.style.display = 'none';
                view.classList.remove('active');
            });
            
            // Show seed view
            const seedView = document.getElementById('seed-view');
            if (seedView) {
                seedView.style.display = 'flex';
                seedView.classList.add('active');
            }
            
            // Setup
            ascensionController = new AscensionController();
            setTimeout(() => {
                ascensionController.initialize();
                setupEventHandlers();
            }, 100);
        }
        
        window.addEventListener('message', function(event) {
            if (event.data.type === 'ENABLE_TOUCH') {
                console.log('Touch events enabled from parent');
                document.body.style.touchAction = 'auto';
                document.body.style.pointerEvents = 'auto';
            }
        });
    </script>
</body>
</html>
