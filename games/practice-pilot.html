<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Practice Pilot</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #00ffff;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            width: 100vw;
            position: fixed;
            top: 0;
            left: 0;
            touch-action: none; /* Prevents scrolling on mobile */
        }
        
        #gameCanvas {
            display: block;
            background: linear-gradient(45deg, #001122 0%, #000511 50%, #001122 100%);
            cursor: none;
            width: 100vw;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height */
            position: fixed;
            top: 0;
            left: 0;
        }
        
        #player-stats {
            position: absolute;
            top: 20px;
            left: 10px;
            z-index: 10;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }

        #player-stats .speed {
             color: #00aaff;
             text-shadow: 0 0 10px #00aaff;
        }

        #game-stats {
            position: absolute;
            top: 20px;
            right: 10px;
            z-index: 10;
            color: #ff3333;
            text-shadow: 0 0 10px #ff3333;
            text-align: right;
        }
        
        #gameOverScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 40, 0.95);
            border: 3px solid #00ffff;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            color: #00ffff;
            font-family: 'Courier New', monospace;
            z-index: 100;
            display: none;
        }
        
        #gameOverScreen h1 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #ff0000;
            text-shadow: 0 0 15px #ff0000;
        }
        
        #gameOverScreen button {
            background: #003366;
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 10px;
            touch-action: manipulation;
            user-select: none;
        }
        
        #gameOverScreen button:hover {
            background: #004488;
        }
        
        #gameOverScreen button:active {
            background: #005599;
            transform: scale(0.98);
        }
        
        #currentAnswer {
            font-size: 24px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            margin-bottom: 10px;
        }
        
        #pauseMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 40, 0.95);
            border: 3px solid #00ffff;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            color: #00ffff;
            font-family: 'Courier New', monospace;
            z-index: 100;
            display: none;
        }
        
        #pauseMenu h2 {
            font-size: 28px;
            margin-bottom: 20px;
            color: #00ffff;
            text-shadow: 0 0 15px #00ffff;
        }
        
        #pauseMenu button {
            background: #003366;
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            margin: 5px;
            display: block;
            width: 150px;
            margin: 10px auto;
            touch-action: manipulation;
            user-select: none;
        }
        
        #pauseMenu button:hover {
            background: #004488;
        }
        
        #pauseMenu button:active {
            background: #005599;
            transform: scale(0.98);
        }
        
        #startMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 40, 0.95);
            border: 3px solid #00ffff;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            color: #00ffff;
            font-family: 'Courier New', monospace;
            z-index: 100;
            display: block;
        }
        
        #startMenu h1 {
            font-size: 42px;
            margin-bottom: 10px;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        
        #startMenu .subtitle {
            font-size: 16px;
            margin-bottom: 30px;
            color: #0088ff;
            font-style: italic;
        }
        
        #startMenu button {
            background: #003366;
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 15px 30px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            cursor: pointer;
            border-radius: 8px;
            margin: 10px;
            display: block;
            width: 220px;
            margin: 15px auto;
            touch-action: manipulation;
            user-select: none;
            transition: all 0.2s;
        }
        
        #startMenu button:hover {
            background: #004488;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        #startMenu button:active {
            background: #005599;
            transform: scale(0.98);
        }
        
        #tutorialScreen, #mathPracticeMenu, #spanishPracticeMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 40, 0.95);
            border: 3px solid #00ffff;
            border-radius: 10px;
            padding: 30px;
            color: #00ffff;
            font-family: 'Courier New', monospace;
            z-index: 100;
            display: none;
            max-width: 90vw;
            width: 700px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        #tutorialScreen h2, #mathPracticeMenu h2, #spanishPracticeMenu h2 {
            font-size: 28px;
            margin-bottom: 20px;
            color: #00ffff;
            text-shadow: 0 0 15px #00ffff;
            text-align: center;
        }
        
        #tutorialScreen h3 {
            font-size: 18px;
            margin: 15px 0 8px 0;
            color: #00aaff;
        }
        
        #tutorialScreen p {
            font-size: 14px;
            line-height: 1.4;
            margin-bottom: 10px;
            color: #ccddff;
        }
        
        #tutorialScreen .highlight {
            color: #ffff00;
            font-weight: bold;
        }
        
        #tutorialScreen button, #mathPracticeMenu button, #spanishPracticeMenu button {
            background: #003366;
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 20px;
            display: block;
            margin: 20px auto 0 auto;
            touch-action: manipulation;
            user-select: none;
        }
        
        .start-game-btn {
             background: #006633 !important;
             border-color: #00ff88 !important;
             color: #00ff88 !important;
        }

        #tutorialScreen button:hover, #mathPracticeMenu button:hover, #spanishPracticeMenu button:hover {
            background: #004488;
        }
        
        #tutorialScreen button:active, #mathPracticeMenu button:active, #spanishPracticeMenu button:active {
            background: #005599;
            transform: scale(0.98);
        }

        .setup-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            background: #001122;
            padding: 10px;
            border-radius: 8px;
        }

        .setup-controls label {
            margin-right: 10px;
        }
        .setup-controls select, .setup-controls .toggle-switch, .setup-controls button {
            background: #002244;
            color: #00ffff;
            border: 1px solid #00ffff;
            padding: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
        }
        .toggle-switch {
            padding: 5px 10px;
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .category h3 {
            display: flex;
            align-items: center;
            font-size: 18px;
            color: #00aaff;
            margin-bottom: 5px;
        }
        .category-controls {
            padding-left: 30px;
            margin-bottom: 10px;
        }
        .category-controls button {
            font-size: 10px !important;
            padding: 2px 5px !important;
            margin: 0 5px 0 0 !important;
            display: inline-block !important;
        }

        .category h3 input {
            margin-right: 10px;
            width: 20px;
            height: 20px;
        }

        .sub-options {
            padding-left: 30px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
        }
        
        .sub-options label {
            display: flex;
            align-items: center;
            font-size: 14px;
        }
         .sub-options input {
            margin-right: 5px;
         }
        
        #roundTransition, #shopMenu, #powerupConfirmation, #errorMessage, #hintMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 40, 0.95);
            border: 3px solid #00ffff;
            border-radius: 15px;
            padding: 30px 50px;
            text-align: center;
            color: #00ffff;
            font-family: 'Courier New', monospace;
            z-index: 200;
            display: none;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }

        #errorMessage {
            border-color: #ff3333;
            color: #ff3333;
        }
        
        #hintMessage {
            border-color: #ffff00;
            color: #ffff00;
            background: rgba(40, 20, 0, 0.95);
            box-shadow: 0 0 30px rgba(255, 255, 0, 0.5);
        }
        #hintMessage h2 {
            font-size: 36px;
            margin: 0;
            color: #ffff00;
            text-shadow: 0 0 20px #ffff00;
        }
        
        #roundTransition h2, #shopMenu h2, #powerupConfirmation h2 {
            font-size: 36px;
            margin-bottom: 10px;
            color: #ffff00;
            text-shadow: 0 0 20px #ffff00;
            animation: pulse 1s ease-in-out;
        }
        
        #roundTransition p {
            font-size: 16px;
            color: #00aaff;
            margin: 5px 0;
        }

        #shopMenu button {
            background: #003366;
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 15px 30px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            cursor: pointer;
            border-radius: 8px;
            margin: 10px;
            display: block;
            width: 300px;
            margin: 15px auto;
            touch-action: manipulation;
            user-select: none;
            transition: all 0.2s;
        }

        #shopMenu button:hover {
            background: #004488;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        #pauseButton {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 50, 100, 0.8);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            z-index: 10;
            display: none;
            touch-action: manipulation;
            user-select: none;
        }
        
        #pauseButton:hover {
            background: rgba(0, 70, 120, 0.9);
        }
        
        @media (max-width: 768px) {
            #pauseButton {
                display: block;
            }
        }
        
        #mobileKeyboard {
            position: fixed;
            bottom: 50px;
            right: 10px;
            background: rgba(0, 20, 40, 0.95);
            border: 2px solid #00ffff;
            border-radius: 8px;
            padding: 12px;
            padding-bottom: calc(12px + env(safe-area-inset-bottom)); /* Safe area for iOS */
            display: none;
            z-index: 20;
            overflow: hidden;
            width: 220px;
        }
        
        #mobileKeyboard .keyboard-row {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
        }
        
        #mobileKeyboard .keyboard-row.control-row {
            margin-top: 6px;
        }
        
        #mobileKeyboard button {
            background: rgba(0, 50, 100, 0.8);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 15px;
            margin: 3px;
            font-family: 'Courier New', monospace;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 6px;
            user-select: none;
            touch-action: manipulation;
            width: 55px;
            height: 55px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #mobileKeyboard button:active {
            background: rgba(0, 70, 120, 0.9);
            transform: scale(0.95);
        }
        
        #mobileKeyboard .enter-btn {
            background: rgba(0, 100, 50, 0.8);
            border-color: #00ff88;
            color: #00ff88;
            font-size: 16px;
            width: 55px;
        }
        
        #mobileKeyboard .backspace-btn {
            background: rgba(100, 50, 0, 0.8);
            border-color: #ff8800;
            color: #ff8800;
            font-size: 16px;
            width: 55px;
        }
        
        @media (pointer: coarse) {
            #mobileKeyboard {
                display: block !important;
            }
        }
        
        @media (max-width: 768px) {
            #controls {
                bottom: 75px;
            }
            #mathDisplay {
                top: 45px;
            }
        }
        
        @media (max-width: 480px) {
            #mobileKeyboard {
                padding: 2px;
            }
            #mobileKeyboard button {
                font-size: 11px;
                padding: 6px 2px;
                margin: 0.5px;
                max-width: 40px;
            }
            #mobileKeyboard .number-row button {
                font-size: 13px;
                padding: 8px 2px;
            }
            #mobileKeyboard .enter-btn,
            #mobileKeyboard .backspace-btn {
                font-size: 9px;
                padding: 5px 6px;
                max-width: 60px;
            }
            #controls { bottom: 65px; font-size: 10px; }
            #mathDisplay { top: 40px; }
            #currentAnswer { font-size: 20px; }
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 10;
            color: #0088ff;
            font-size: 12px;
        }
        
        #mathDisplay {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            color: #00ffff;
            font-family: 'Courier New', monospace;
            margin-top: 90px;
        }
        
        .damage-flash {
            animation: damageFlash 0.5s ease-out;
        }
        
        @keyframes damageFlash {
            0%, 100% { background-color: rgba(0, 0, 0, 0); }
            50% { background-color: rgba(255, 0, 0, 0.3); }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="player-stats">
        <div>SHIELD: <span id="shield">100</span></div>
        <div>SCORE: <span id="score">0</span></div>
        <div class="speed">SPEED: <span id="playerSpeed">0.0</span></div>
    </div>
    <div id="game-stats">
        <div>ROUND: <span id="round">1</span></div>
        <div>ENEMIES: <span id="enemiesLeft">0</span></div>
        <div>ENEMY DMG: <span id="enemyDamage">10</span></div>
    </div>
    <div id="controls">
        Move towards cursor/finger | Hold click/touch to boost | Type to answer problems
    </div>
    <div id="mathDisplay">
        <div id="currentAnswer">Answer: </div>
    </div>
    
    <div id="gameOverScreen">
        <h1>GAME OVER</h1>
        <div id="finalRound">Round: 1</div>
        <div id="finalScore">Final Score: 0</div>
        <button onclick="backToPracticeMenu()">PLAY AGAIN</button>
    </div>
    
    <div id="pauseMenu">
        <h2>PAUSED</h2>
        <button onclick="resumeGame()">RESUME</button>
        <button onclick="restartFromPause()">RESTART</button>
    </div>
    
    <button id="pauseButton" onclick="pauseGame()">⏸️</button>
    
    <div id="startMenu">
        <h1>Practice Pilot</h1>
        <div class="subtitle">Navigate • Calculate • Survive</div>
        <button onclick="showMathPractice()">MATH PRACTICE</button>
        <button onclick="showSpanishPractice()">SPANISH PRACTICE</button>
        <button onclick="showTutorial()">TUTORIAL</button>
    </div>

    <div id="mathPracticeMenu">
        <h2>Math Practice Setup</h2>
        <div class="setup-controls">
            <div>
                <label for="math-start-round">Start on Round:</label>
                <select id="math-start-round">
                    <!-- JS will populate this -->
                </select>
            </div>
             <div>
                <button onclick="checkAllCategories('math', true)">Check All</button>
                <button onclick="checkAllCategories('math', false)">Uncheck All</button>
            </div>
        </div>
        <div class="options-grid">
            <div class="category">
                <h3><input type="checkbox" id="add-check" onchange="toggleSubOptions('add')"> Addition</h3>
                <div class="category-controls">
                    <button onclick="checkAllInCategory('add', 'math', true)">All</button>
                    <button onclick="checkAllInCategory('add', 'math', false)">None</button>
                </div>
                <div class="sub-options" id="add-options" style="display:none;">
                    <label><input type="checkbox" value="1"> 1-Digit</label>
                    <label><input type="checkbox" value="2"> 2-Digit</label>
                    <label><input type="checkbox" value="3"> 3-Digit</label>
                </div>
            </div>
            <div class="category">
                <h3><input type="checkbox" id="sub-check" onchange="toggleSubOptions('sub')"> Subtraction</h3>
                <div class="category-controls">
                    <button onclick="checkAllInCategory('sub', 'math', true)">All</button>
                    <button onclick="checkAllInCategory('sub', 'math', false)">None</button>
                </div>
                <div class="sub-options" id="sub-options" style="display:none;">
                    <label><input type="checkbox" value="1"> 1-Digit</label>
                    <label><input type="checkbox" value="2"> 2-Digit</label>
                    <label><input type="checkbox" value="3"> 3-Digit</label>
                </div>
            </div>
            <div class="category">
                <h3><input type="checkbox" id="mul-check" onchange="toggleSubOptions('mul')"> Multiplication</h3>
                 <div class="category-controls">
                    <button onclick="checkAllInCategory('mul', 'math', true)">All</button>
                    <button onclick="checkAllInCategory('mul', 'math', false)">None</button>
                </div>
                <div class="sub-options" id="mul-options" style="display:none;">
                    <!-- JS will populate this -->
                </div>
            </div>
            <div class="category">
                <h3><input type="checkbox" id="div-check" onchange="toggleSubOptions('div')"> Division</h3>
                 <div class="category-controls">
                    <button onclick="checkAllInCategory('div', 'math', true)">All</button>
                    <button onclick="checkAllInCategory('div', 'math', false)">None</button>
                </div>
                <div class="sub-options" id="div-options" style="display:none;">
                    <!-- JS will populate this -->
                </div>
            </div>
        </div>
        <button class="start-game-btn" onclick="startPracticeGame('math')">START GAME</button>
        <button onclick="hideMathPractice()">BACK TO MENU</button>
    </div>

    <div id="spanishPracticeMenu">
        <h2>Spanish Practice Setup</h2>
         <div class="setup-controls">
            <div>
                <label for="spanish-start-round">Start on Round:</label>
                <select id="spanish-start-round">
                    <!-- JS will populate this -->
                </select>
            </div>
            <button id="translation-toggle" class="toggle-switch" onclick="toggleTranslationDirection()">ENG → ESP</button>
        </div>
        <div class="setup-controls">
            <button onclick="checkAllCategories('spanish', true)">Check All</button>
            <button onclick="checkAllCategories('spanish', false)">Uncheck All</button>
            <button onclick="checkAllByRank('1-10')">All 1-10</button>
            <button onclick="checkAllByRank('11-20')">All 11-20</button>
        </div>
        <div id="spanish-options-grid" class="options-grid">
            <!-- JS will populate all categories and options -->
        </div>
        <button class="start-game-btn" onclick="startPracticeGame('spanish')">START GAME</button>
        <button onclick="hideSpanishPractice()">BACK TO MENU</button>
    </div>
    
    <div id="tutorialScreen">
        <h2>HOW TO PLAY</h2>
        <div id="tutorialContent">
            <!-- Content will be dynamically generated -->
        </div>
        <button onclick="hideTutorial()">BACK TO MENU</button>
    </div>
    
    <div id="roundTransition">
        <h2>ROUND <span id="roundNumber">2</span></h2>
        <p>Enemies are getting stronger!</p>
    </div>

    <div id="shopMenu">
        <h2>UPGRADES</h2>
        <button onclick="purchaseShield()">FORTIFY SHIELD (+20% Max Shield)</button>
        <button onclick="purchaseSpeed()">TUNE ENGINES (+20% Speed)</button>
        <button onclick="purchaseShieldRegen()">NANO REPAIR BOTS (+2% Shield Regen/sec)</button>
    </div>

    <div id="powerupConfirmation">
        <h2 id="powerupText"></h2>
    </div>

    <div id="errorMessage">
        <p id="errorMessageText"></p>
    </div>

    <div id="hintMessage">
        <h2 id="hintText"></h2>
    </div>
    
    <div id="mobileKeyboard">
        <div class="keyboard-row">
            <button onclick="typeNumber('7')">7</button>
            <button onclick="typeNumber('8')">8</button>
            <button onclick="typeNumber('9')">9</button>
        </div>
        <div class="keyboard-row">
            <button onclick="typeNumber('4')">4</button>
            <button onclick="typeNumber('5')">5</button>
            <button onclick="typeNumber('6')">6</button>
        </div>
        <div class="keyboard-row">
            <button onclick="typeNumber('1')">1</button>
            <button onclick="typeNumber('2')">2</button>
            <button onclick="typeNumber('3')">3</button>
        </div>
        <div class="keyboard-row">
            <button onclick="typeNumber('0')">0</button>
            <button class="backspace-btn" onclick="backspaceAnswer()">⌫</button>
            <button class="enter-btn" onclick="submitAnswer()">✓</button>
        </div>
    </div>

    <script>
        // --- VOCABULARY DATA ---
        const vocabulary = {
            nouns: [{"es":"vez","en":"time (occurrence)"},{"es":"año","en":"year"},{"es":"tiempo","en":"time (concept)"},{"es":"día","en":"day"},{"es":"cosa","en":"thing"},{"es":"hombre","en":"man"},{"es":"vida","en":"life"},{"es":"país","en":"country"},{"es":"casa","en":"house"},{"es":"mundo","en":"world"},{"es":"mujer","en":"woman"},{"es":"caso","en":"case"},{"es":"forma","en":"form"},{"es":"gente","en":"people"},{"es":"parte","en":"part"},{"es":"lugar","en":"place"},{"es":"trabajo","en":"work"},{"es":"mano","en":"hand"},{"es":"persona","en":"person"},{"es":"agua","en":"water"},{"es":"madre","en":"mother"},{"es":"padre","en":"father"},{"es":"gobierno","en":"government"},{"es":"punto","en":"point"},{"es":"noche","en":"night"},{"es":"grupo","en":"group"},{"es":"problema","en":"problem"},{"es":"hijo","en":"son"},{"es":"número","en":"number"},{"es":"hecho","en":"fact"},{"es":"historia","en":"history"},{"es":"cuerpo","en":"body"},{"es":"dinero","en":"money"},{"es":"empresa","en":"company"},{"es":"familia","en":"family"},{"es":"nombre","en":"name"},{"es":"orden","en":"order"},{"es":"guerra","en":"war"},{"es":"presidente","en":"president"},{"es":"ley","en":"law"},{"es":"ojo","en":"eye"},{"es":"fuerza","en":"force"},{"es":"amor","en":"love"},{"es":"calle","en":"street"},{"es":"puerta","en":"door"},{"es":"razón","en":"reason"},{"es":"mañana","en":"morning"},{"es":"ciudad","en":"city"},{"es":"pie","en":"foot"},{"es":"tipo","en":"type"},{"es":"pueblo","en":"town"},{"es":"siglo","en":"century"},{"es":"mes","en":"month"},{"es":"luz","en":"light"},{"es":"voz","en":"voice"},{"es":"cabeza","en":"head"},{"es":"minuto","en":"minute"},{"es":"amigo","en":"friend"},{"es":"cambio","en":"change"},{"es":"fin","en":"end"},{"es":"muerte","en":"death"},{"es":"resultado","en":"result"},{"es":"servicio","en":"service"},{"es":"aire","en":"air"},{"es":"libro","en":"book"},{"es":"poder","en":"power"},{"es":"efecto","en":"effect"},{"es":"semana","en":"week"},{"es":"sistema","en":"system"},{"es":"palabra","en":"word"},{"es":"política","en":"policy"},{"es":"obra","en":"work"},{"es":"nivel","en":"level"},{"es":"padre","en":"father"},{"es":"seguridad","en":"security"},{"es":"imagen","en":"image"},{"es":"interés","en":"interest"},{"es":"momento","en":"moment"},{"es":"paso","en":"step"},{"es":"tierra","en":"land"},{"es":"relación","en":"relationship"},{"es":"acción","en":"action"},{"es":"acuerdo","en":"agreement"},{"es":"situación","en":"situation"},{"es":"derecho","en":"right"},{"es":"proceso","en":"process"},{"es":"mercado","en":"market"},{"es":"salud","en":"health"},{"es":"sociedad","en":"society"},{"es":"educación","en":"education"},{"es":"programa","en":"program"},{"es":"valor","en":"value"},{"es":"juego","en":"game"},{"es":"coche","en":"car"},{"es":"medida","en":"measure"},{"es":"necesidad","en":"need"}],
            verbs: [{"es":"ser","en":"to be (permanent)"},{"es":"haber","en":"to have (auxiliary)"},{"es":"estar","en":"to be (temporary)"},{"es":"tener","en":"to have (possession)"},{"es":"hacer","en":"to do"},{"es":"poder","en":"to be able"},{"es":"decir","en":"to say"},{"es":"ir","en":"to go"},{"es":"ver","en":"to see"},{"es":"dar","en":"to give"},{"es":"saber","en":"to know"},{"es":"querer","en":"to want"},{"es":"llegar","en":"to arrive"},{"es":"pasar","en":"to pass"},{"es":"deber","en":"to owe"},{"es":"poner","en":"to put"},{"es":"parecer","en":"to seem"},{"es":"quedar","en":"to stay"},{"es":"creer","en":"to believe"},{"es":"hablar","en":"to speak"},{"es":"llevar","en":"to carry"},{"es":"dejar","en":"to leave"},{"es":"seguir","en":"to follow"},{"es":"encontrar","en":"to find"},{"es":"llamar","en":"to call"},{"es":"venir","en":"to come"},{"es":"pensar","en":"to think"},{"es":"salir","en":"to leave"},{"es":"volver","en":"to return"},{"es":"tomar","en":"to take"},{"es":"conocer","en":"to know"},{"es":"vivir","en":"to live"},{"es":"sentir","en":"to feel"},{"es":"tratar","en":"to treat"},{"es":"mirar","en":"to look"},{"es":"contar","en":"to count"},{"es":"empezar","en":"to start"},{"es":"esperar","en":"to wait"},{"es":"buscar","en":"to search"},{"es":"existir","en":"to exist"},{"es":"entrar","en":"to enter"},{"es":"trabajar","en":"to work"},{"es":"escribir","en":"to write"},{"es":"perder","en":"to lose"},{"es":"producir","en":"to produce"},{"es":"ocurrir","en":"to occur"},{"es":"entender","en":"to understand"},{"es":"pedir","en":"to ask for"},{"es":"recibir","en":"to receive"},{"es":"recordar","en":"to remember"},{"es":"terminar","en":"to finish"},{"es":"permitir","en":"to permit"},{"es":"aparecer","en":"to appear"},{"es":"conseguir","en":"to get"},{"es":"comenzar","en":"to begin"},{"es":"servir","en":"to serve"},{"es":"sacar","en":"to take out"},{"es":"necesitar","en":"to need"},{"es":"mantener","en":"to maintain"},{"es":"resultar","en":"to result"},{"es":"leer","en":"to read"},{"es":"caer","en":"to fall"},{"es":"cambiar","en":"to change"},{"es":"presentar","en":"to present"},{"es":"crear","en":"to create"},{"es":"abrir","en":"to open"},{"es":"considerar","en":"to consider"},{"es":"oír","en":"to hear"},{"es":"acabar","en":"to finish"},{"es":"convertir","en":"to convert"},{"es":"ganar","en":"to win"},{"es":"formar","en":"to form"},{"es":"traer","en":"to bring"},{"es":"partir","en":"to leave"},{"es":"morir","en":"to die"},{"es":"aceptar","en":"to accept"},{"es":"realizar","en":"to carry out"},{"es":"suponer","en":"to suppose"},{"es":"comprender","en":"to understand"},{"es":"lograr","en":"to achieve"},{"es":"explicar","en":"to explain"},{"es":"preguntar","en":"to ask"},{"es":"tocar","en":"to touch"},{"es":"reconocer","en":"to recognize"},{"es":"estudiar","en":"to study"},{"es":"alcanzar","en":"to reach"},{"es":"nacer","en":"to be born"},{"es":"dirigir","en":"to direct"},{"es":"correr","en":"to run"},{"es":"utilizar","en":"to use"},{"es":"pagar","en":"to pay"},{"es":"ayudar","en":"to help"},{"es":"jugar","en":"to play"},{"es":"escuchar","en":"to listen"},{"es":"cumplir","en":"to fulfill"},{"es":"ofrecer","en":"to offer"},{"es":"descubrir","en":"to discover"},{"es":"levantar","en":"to lift"},{"es":"intentar","en":"to try"}],
            adjectives: [{"es":"grande","en":"big"},{"es":"nuevo","en":"new"},{"es":"bueno","en":"good"},{"es":"primero","en":"first"},{"es":"mucho","en":"much"},{"es":"mismo","en":"same"},{"es":"último","en":"last"},{"es":"propio","en":"own"},{"es":"pequeño","en":"small"},{"es":"mayor","en":"older"},{"es":"único","en":"unique"},{"es":"político","en":"political"},{"es":"español","en":"Spanish"},{"es":"importante","en":"important"},{"es":"nacional","en":"national"},{"es":"diferente","en":"different"},{"es":"largo","en":"long"},{"es":"posible","en":"possible"},{"es":"claro","en":"clear"},{"es":"necesario","en":"necessary"},{"es":"humano","en":"human"},{"es":"general","en":"general"},{"es":"mejor","en":"better"},{"es":"blanco","en":"white"},{"es":"solo","en":"alone"},{"es":"negro","en":"black"},{"es":"alto","en":"high"},{"es":"bajo","en":"low"},{"es":"económico","en":"economic"},{"es":"principal","en":"main"},{"es":"joven","en":"young"},{"es":"difícil","en":"difficult"},{"es":"fácil","en":"easy"},{"es":"libre","en":"free"},{"es":"segundo","en":"second"},{"es":"cierto","en":"certain"},{"es":"especial","en":"special"},{"es":"fuerte","en":"strong"},{"es":"rojo","en":"red"},{"es":"serio","en":"serious"},{"es":"abierto","en":"open"},{"es":"pobre","en":"poor"},{"es":"feliz","en":"happy"},{"es":"capaz","en":"capable"},{"es":"duro","en":"hard"},{"es":"verde","en":"green"},{"es":"azul","en":"blue"},{"es":"común","en":"common"},{"es":"profundo","en":"deep"},{"es":"siguiente","en":"next"},{"es":"militar","en":"military"},{"es":"extraño","en":"strange"},{"es":"seguro","en":"sure"},{"es":"cultural","en":"cultural"},{"es":"antiguo","en":"ancient"},{"es":"lleno","en":"full"},{"es":"básico","en":"basic"},{"es":"reciente","en":"recent"},{"es":"superior","en":"superior"},{"es":"histórico","en":"historic"},{"es":"profesional","en":"professional"},{"es":"tradicional","en":"traditional"},{"es":"izquierdo","en":"left"},{"es":"contrario","en":"contrary"},{"es":"físico","en":"physical"},{"es":"muerto","en":"dead"},{"es":"tercero","en":"third"},{"es":"imposible","en":"impossible"},{"es":"privado","en":"private"},{"es":"rápido","en":"fast"},{"es":"perfecto","en":"perfect"},{"es":"inmediato","en":"immediate"},{"es":"enfermo","en":"sick"},{"es":"amplio","en":"wide"},{"es":"distinto","en":"distinct"},{"es":"limpio","en":"clean"},{"es":"oscuro","en":"dark"},{"es":"triste","en":"sad"},{"es":"caliente","en":"hot"},{"es":"frío","en":"cold"},{"es":"rico","en":"rich"},{"es":"moderno","en":"modern"},{"es":"corto","en":"short"}],
            adverbs: [{"es":"más","en":"more"},{"es":"muy","en":"very"},{"es":"ya","en":"already"},{"es":"también","en":"also"},{"es":"así","en":"so"},{"es":"bien","en":"well"},{"es":"siempre","en":"always"},{"es":"ahora","en":"now"},{"es":"sólo","en":"only"},{"es":"entonces","en":"then"},{"es":"después","en":"after"},{"es":"aquí","en":"here"},{"es":"hoy","en":"today"},{"es":"casi","en":"almost"},{"es":"nunca","en":"never"},{"es":"luego","en":"later"},{"es":"antes","en":"before"},{"es":"mal","en":"badly"},{"es":"ayer","en":"yesterday"},{"es":"pronto","en":"soon"},{"es":"tarde","en":"late"},{"es":"demasiado","en":"too much"},{"es":"quizás","en":"perhaps"},{"es":"abajo","en":"down"},{"es":"arriba","en":"up"},{"es":"lejos","en":"far"},{"es":"cerca","en":"near"},{"es":"adelante","en":"forward"},{"es":"atrás","en":"back"},{"es":"adentro","en":"inside"},{"es":"afuera","en":"outside"},{"es":"temprano","en":"early"},{"es":"despacio","en":"slowly"},{"es":"rápido","en":"quickly"},{"es":"mejor","en":"better"},{"es":"peor","en":"worse"},{"es":"además","en":"besides"},{"es":"tampoco","en":"neither"},{"es":"bastante","en":"enough"},{"es":"mientras","en":"while"},{"es":"jamás","en":"never"},{"es":"aún","en":"still"},{"es":"todavía","en":"yet"},{"es":"incluso","en":"even"},{"es":"solamente","en":"only"},{"es":"exactamente","en":"exactly"},{"es":"realmente","en":"really"},{"es":"generalmente","en":"generally"},{"es":"finalmente","en":"finally"},{"es":"especialmente","en":"especially"},{"es":"claramente","en":"clearly"},{"es":"seguramente","en":"surely"},{"es":"posiblemente","en":"possibly"},{"es":"ciertamente","en":"certainly"},{"es":"naturalmente","en":"naturally"},{"es":"obviamente","en":"obviously"},{"es":"directamente","en":"directly"},{"es":"fácilmente","en":"easily"},{"es":"rápidamente","en":"rapidly"},{"es":"lentamente","en":"slowly"},{"es":"fuertemente","en":"strongly"},{"es":"igualmente","en":"equally"},{"es":"completamente","en":"completely"},{"es":"perfectamente","en":"perfectly"},{"es":"principalmente","en":"mainly"},{"es":"últimamente","en":"lately"},{"es":"anteriormente","en":"previously"},{"es":"posteriormente","en":"subsequently"},{"es":"constantemente","en":"constantly"},{"es":"frecuentemente","en":"frequently"},{"es":"normalmente","en":"normally"},{"es":"usualmente","en":"usually"},{"es":"a menudo","en":"often"},{"es":"a veces","en":"sometimes"},{"es":"de vez en cuando","en":"from time to time"},{"es":"por supuesto","en":"of course"},{"es":"sin duda","en":"without a doubt"},{"es":"tal vez","en":"maybe"},{"es":"a lo mejor","en":"perhaps"},{"es":"de repente","en":"suddenly"},{"es":"de pronto","en":"suddenly"},{"es":"en seguida","en":"at once"},{"es":"por fin","en":"at last"},{"es":"por lo menos","en":"at least"},{"es":"a propósito","en":"on purpose"},{"es":"a tiempo","en":"on time"},{"es":"con cuidado","en":"carefully"},{"es":"en efecto","en":"indeed"},{"es":"en realidad","en":"actually"},{"es":"de verdad","en":"truly"},{"es":"por ejemplo","en":"for example"},{"es":"en general","en":"in general"},{"es":"a favor","en":"in favor"},{"es":"en contra","en":"against"}],
            pronouns: [{"es":"que","en":"that"},{"es":["lo","la"],"en":"it"},{"es":"se","en":"oneself"},{"es":"le","en":"him"},{"es":"yo","en":"I"},{"es":"te","en":"you"},{"es":"nos","en":"us"},{"es":"él","en":"he"},{"es":"ella","en":"she"},{"es":"eso","en":"that"},{"es":["los","las"],"en":"them"},{"es":"tú","en":"you"},{"es":"nosotros","en":"we"},{"es":["ellos","ellas"],"en":"they"},{"es":"algo","en":"something"},{"es":"nada","en":"nothing"},{"es":"alguien","en":"someone"},{"es":"nadie","en":"no one"},{"es":"mí","en":"me"}],
            prepositions: [{"es":"de","en":"of"},{"es":"a","en":"to"},{"es":"en","en":["in","on","at"]},{"es":"con","en":"with"},{"es":"por","en":["for","by","through"]},{"es":"para","en":"for"},{"es":"sin","en":"without"},{"es":"sobre","en":"on"},{"es":"entre","en":"between"},{"es":"desde","en":"from"},{"es":"hasta","en":"until"},{"es":"hacia","en":"toward"},{"es":"contra","en":"against"},{"es":"según","en":"according to"},{"es":"bajo","en":"under"},{"es":"ante","en":"before"},{"es":"tras","en":"after"},{"es":"durante","en":"during"},{"es":"mediante","en":"by means of"},{"es":"vía","en":"via"}],
            conjunctions: [{"es":["y","e"],"en":"and"},{"es":["o","u"],"en":"or"},{"es":"pero","en":"but"},{"es":"que","en":"that"},{"es":"si","en":"if"},{"es":"porque","en":"because"},{"es":"cuando","en":"when"},{"es":"como","en":"as"},{"es":"aunque","en":"although"},{"es":"sino","en":"but rather"},{"es":"mientras","en":"while"},{"es":"pues","en":"since"},{"es":"ni","en":"nor"},{"es":"donde","en":"where"},{"es":"luego","en":"then"},{"es":"para que","en":"so that"},{"es":"así que","en":"so"},{"es":"ya que","en":"since"}],
            interjections: [{"es":"hola","en":"hello"},{"es":"adiós","en":"goodbye"},{"es":"gracias","en":"thank you"},{"es":"por favor","en":"please"},{"es":"sí","en":"yes"},{"es":"bueno","en":"well"},{"es":"vale","en":"okay"},{"es":"venga","en":"come on"},{"es":"anda","en":"come on"},{"es":"cuidado","en":"be careful"},{"es":"ojo","en":"watch out"},{"es":"ay","en":"ouch"},{"es":"uy","en":"oops"},{"es":"eh","en":"huh"},{"es":"ah","en":"ah"},{"es":"oh","en":"oh"},{"es":"bravo","en":"bravo"},{"es":"ojalá","en":"I wish"},{"es":"salud","en":"cheers"}],
            determiners: [{"es":["el","la"],"en":"the"},{"es":["un","una"],"en":"a"},{"es":["los","las"],"en":"the"},{"es":["unos","unas"],"en":"some"},{"es":"su","en":"his"},{"es":["este","esta"],"en":"this"},{"es":["ese","esa"],"en":"that"},{"es":"mi","en":"my"},{"es":"todo","en":"all"},{"es":"tu","en":"your"},{"es":"otro","en":"other"},{"es":["estos","estas"],"en":"these"},{"es":["esos","esas"],"en":"those"},{"es":["aquel","aquella"],"en":"that"},{"es":"nuestro","en":"our"},{"es":"alguno","en":"some"},{"es":"ninguno","en":"none"},{"es":"mucho","en":"much"},{"es":"poco","en":"little"},{"es":"cada","en":"each"}]
        };
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        
        const game = {
            player: { x: 0, y: 0, vx: 0, vy: 0, angle: 0, speed: 0, shield: 100, maxShield: 100, speedMultiplier: 1, shieldRegenRate: 0, boosting: false, size: 12 },
            camera: { x: 0, y: 0, shake: 0 },
            cityscape: [],
            particles: [],
            enemies: [],
            turrets: [],
            lasers: [],
            enemyBullets: [],
            healthPowerups: [],
            healingAreas: [],
            mouse: { x: canvas.width / 2, y: canvas.height / 2 },
            time: 0, score: 0, enemySpawnTimer: 0, maxEnemies: 2,
            cityBounds: 3000,
            gameOver: false, paused: false, currentAnswer: '', isPressed: false, gameStarted: false,
            currentRound: 1, enemiesPerRound: 10, enemiesSpawnedThisRound: 0, roundInProgress: true,
            turretsToSpawnThisRound: 0,
            frameCount: 0, lastFPSCheck: 0, currentFPS: 60, fpsRatio: 1,
            emptyCityCells: [],
            nearestTurretAngle: null,
            roundRoster: { enemies: [] },
            touchOnUI: false,
            mode: 'math', // 'math' or 'spanish'
            practiceConfig: {}, // To store user's choices
            translationDirection: 'en-es' // 'en-es' or 'es-en'
        };
        
        function normalizeString(str) {
            if (typeof str !== 'string') str = String(str);
            return str.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        }

        function generateMathProblem(config) {
            const availableTypes = Object.keys(config).filter(key => config[key] && config[key].length > 0);
            if (availableTypes.length === 0) {
                return { question: "1 + 1 = ?", answer: 2 };
            }

            const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            const options = config[type];
            const choice = options[Math.floor(Math.random() * options.length)];

            let n1, n2, ans, question;

            switch (type) {
                case 'addition':
                    const maxAdd = Math.pow(10, choice) - 1;
                    const minAdd = choice > 1 ? Math.pow(10, choice - 1) : 1; // Min is 1
                    n1 = Math.floor(Math.random() * (maxAdd - minAdd + 1)) + minAdd;
                    n2 = Math.floor(Math.random() * (maxAdd - minAdd + 1)) + minAdd;
                    ans = n1 + n2;
                    question = `${n1} + ${n2} = ?`;
                    break;
                case 'subtraction':
                    const maxSub = Math.pow(10, choice) - 1;
                    const minSub = choice > 1 ? Math.pow(10, choice - 1) : 1; // Min is 1
                    do {
                        n1 = Math.floor(Math.random() * (maxSub - minSub + 1)) + minSub;
                        n2 = Math.floor(Math.random() * (maxSub - minSub + 1)) + minSub;
                    } while (n1 === n2); // Ensure result is not 0
                    if (n1 < n2) [n1, n2] = [n2, n1];
                    ans = n1 - n2;
                    question = `${n1} - ${n2} = ?`;
                    break;
                case 'multiplication':
                    n1 = choice;
                    n2 = Math.floor(Math.random() * 11) + 2; // 2-12
                    ans = n1 * n2;
                    question = `${n1} × ${n2} = ?`;
                    break;
                case 'division':
                    n2 = choice; // Divisor
                    const quotient = Math.floor(Math.random() * 11) + 2; // 2-12
                    n1 = n2 * quotient;
                    ans = quotient;
                    question = `${n1} ÷ ${n2} = ?`;
                    break;
            }
            return { question, answer: ans };
        }

        function generateSpanishProblem(config) {
            if (!config.wordList || config.wordList.length === 0) {
                return { question: "Hola", answer: "hello" }; // Fallback
            }
            const wordPair = config.wordList[Math.floor(Math.random() * config.wordList.length)];
            
            if (config.direction === 'en-es') {
                return { question: wordPair.en, answer: wordPair.es };
            } else {
                const questionText = Array.isArray(wordPair.es) ? wordPair.es.join('/') : wordPair.es;
                return { question: questionText, answer: wordPair.en };
            }
        }

        function generateProblem() {
            if (game.mode === 'math') {
                return generateMathProblem(game.practiceConfig);
            } else {
                return generateSpanishProblem(game.practiceConfig);
            }
        }
        
        function spawnEnemy() {
            if (game.enemies.length >= game.maxEnemies || game.enemiesSpawnedThisRound >= game.enemiesPerRound || !game.roundInProgress || game.roundRoster.enemies.length === 0) return;
            
            const archetype = game.roundRoster.enemies.pop();
            let x, y, attempts = 0;
            do {
                const angle = Math.random() * Math.PI * 2, dist = 200 + Math.random() * 400;
                x = game.player.x + Math.cos(angle) * dist;
                y = game.player.y + Math.sin(angle) * dist;
                attempts++;
            } while (checkCollision(x, y, 25) && attempts < 20);

            let chaseSpeed = 0;
            switch(archetype) {
                case 'chaser': chaseSpeed = 0.8 + Math.random() * 0.4; break;
                case 'orbiter': chaseSpeed = 0.6 + Math.random() * 0.3; break;
                case 'sniper': chaseSpeed = 0.4 + Math.random() * 0.2; break;
            }
            game.enemies.push({ x, y, vx: 0, vy: 0, size: 20, angle: 0, mathProblem: generateProblem(), chaseSpeed: chaseSpeed, shootTimer: Math.random() * 120, archetype: archetype });
            game.enemiesSpawnedThisRound++;
        }
        
        function enemyShoot(enemy) {
            const angle = Math.atan2(game.player.y - enemy.y, game.player.x - enemy.x);
            const damage = 10 + (game.currentRound - 1) * 10;
            game.enemyBullets.push({ x: enemy.x, y: enemy.y, vx: Math.cos(angle) * 3 * game.fpsRatio, vy: Math.sin(angle) * 3 * game.fpsRatio, size: 4, damage: damage });
            for (let i = 0; i < 3; i++) game.particles.push(createParticle(enemy.x, enemy.y, '#ff6600', 2));
        }
        
        function fireLaser(target) {
            const angle = Math.atan2(target.y - game.player.y, target.x - game.player.x);
            const laser = { x: game.player.x, y: game.player.y, vx: Math.cos(angle) * 15 * game.fpsRatio, vy: Math.sin(angle) * 15 * game.fpsRatio, life: 60, angle: angle, target: target };
            game.lasers.push(laser);
            return laser;
        }

        function addBuildingDetails(building) {
            building.windows = [];
            if (Math.random() > 0.7) {
                for (let s = 0; s < Math.floor(building.width / 50); s++) {
                    if (Math.random() > 0.3) {
                        const stripX = building.x + 20 + s * 50;
                        for (let y = building.y + 10; y < building.y + building.height - 10; y += 15) {
                            building.windows.push({ x: stripX, y: y, width: 5, height: 10, lit: true, color: '#00aaff' });
                        }
                    }
                }
            }
            for (let x = building.x + 10; x < building.x + building.width - 10; x += 25) {
                for (let y = building.y + 10; y < building.y + building.height - 10; y += 25) {
                    if (Math.random() < 0.5) {
                        building.windows.push({ x: x, y: y, width: 12, height: 12, lit: true, color: Math.random() > 0.9 ? '#ffff00' : '#00aaff' });
                    }
                }
            }
        }

        function generateCity() {
            const cityscape = [], healthPowerups = [], healingAreas = [];
            const mapSize = game.cityBounds;
            const gridSize = 30, cellSize = mapSize * 2 / gridSize;
            const grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill('solid'));

            let walkers = [{x: Math.floor(gridSize/2), y: Math.floor(gridSize/2)}];
            grid[walkers[0].y][walkers[0].x] = 'empty';
            let emptyCellCount = 1;
            const totalEmptyTarget = gridSize * gridSize * 0.40; // Reduced from 0.45 for a tighter city

            while(emptyCellCount < totalEmptyTarget) {
                walkers.forEach(walker => {
                    const dir = Math.floor(Math.random() * 4);
                    for(let j=0; j<Math.random() * 5; j++){
                        if (dir === 0 && walker.x > 1) walker.x--;
                        if (dir === 1 && walker.x < gridSize - 2) walker.x++;
                        if (dir === 2 && walker.y > 1) walker.y--;
                        if (dir === 3 && walker.y < gridSize - 2) walker.y++;
                        if(grid[walker.y][walker.x] === 'solid') {
                            grid[walker.y][walker.x] = 'empty';
                            emptyCellCount++;
                        }
                    }
                });
                if(Math.random() > 0.8 && walkers.length < 5) walkers.push({x: Math.floor(Math.random()*gridSize), y: Math.floor(Math.random()*gridSize)});
            }

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (grid[y][x] === 'solid') {
                        const worldX = -mapSize + x * cellSize, worldY = -mapSize + y * cellSize;
                        const structureType = Math.random();
                        if (structureType > 0.9) {
                            const building = { x: worldX, y: worldY, width: cellSize, height: cellSize, type: 'building', color: '#001a33' };
                            addBuildingDetails(building);
                            cityscape.push(building);
                        } else if (structureType > 0.3) {
                             for(let i=0; i<2; i++){
                                 for(let j=0; j<2; j++){
                                     if(Math.random() > 0.3){ 
                                         const padding = 15;
                                         const smallSize = cellSize/2 - padding;
                                         const building = { x: worldX + i * (smallSize+padding*2), y: worldY + j * (smallSize+padding*2), width: smallSize, height: smallSize, type: 'building', color: '#002244' };
                                         addBuildingDetails(building);
                                         cityscape.push(building);
                                     }
                                 }
                             }
                        } else {
                             for(let i=0; i<3; i++){
                                 for(let j=0; j<3; j++){
                                     if(Math.random() > 0.5){
                                         const obsSize = 15 + Math.random() * 10;
                                         cityscape.push({ x: worldX + i * cellSize/3 + 10, y: worldY + j * cellSize/3 + 10, width: obsSize, height: obsSize, type: 'obstacle', color: '#550000'});
                                     }
                                 }
                             }
                        }
                    }
                }
            }
            
            const wallThickness = 50;
            cityscape.push({ x: -mapSize - wallThickness, y: -mapSize - wallThickness, width: mapSize * 2 + wallThickness*2, height: wallThickness, type: 'building', color: '#001122', windows:[] });
            cityscape.push({ x: -mapSize - wallThickness, y: mapSize, width: mapSize * 2 + wallThickness*2, height: wallThickness, type: 'building', color: '#001122', windows:[] });
            cityscape.push({ x: -mapSize - wallThickness, y: -mapSize, width: wallThickness, height: mapSize * 2, type: 'building', color: '#001122', windows:[] });
            cityscape.push({ x: mapSize, y: -mapSize, width: wallThickness, height: mapSize * 2, type: 'building', color: '#001122', windows:[] });
            
            game.emptyCityCells = [];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (grid[y][x] === 'empty') {
                        game.emptyCityCells.push({x, y});
                    }
                }
            }

            for (let i = 0; i < 60; i++) {
                if (game.emptyCityCells.length === 0) break;
                const cell = game.emptyCityCells[Math.floor(Math.random() * game.emptyCityCells.length)];
                const x = -mapSize + cell.x * cellSize + Math.random() * cellSize;
                const y = -mapSize + cell.y * cellSize + Math.random() * cellSize;
                healthPowerups.push({ x, y, size: 10 });
            }
            
            for (let i = 0; i < 5; i++) {
                if (game.emptyCityCells.length === 0) break;
                const cellIndex = Math.floor(Math.random() * game.emptyCityCells.length);
                const cell = game.emptyCityCells[cellIndex];
                const x = -mapSize + cell.x * cellSize + cellSize / 2;
                const y = -mapSize + cell.y * cellSize + cellSize / 2;
                healingAreas.push({ x, y, radius: 120 });
            }

            const startX = -mapSize + (gridSize/2) * cellSize + cellSize/2;
            const startY = -mapSize + (gridSize/2) * cellSize + cellSize/2;
            
            return { cityscape, startPos: { x: startX, y: startY }, healthPowerups, healingAreas };
        }
        
        function spawnHealthPowerup() {
            if (game.emptyCityCells.length === 0) return;
            const mapSize = game.cityBounds, gridSize = 30, cellSize = mapSize * 2 / gridSize;
            const cell = game.emptyCityCells[Math.floor(Math.random() * game.emptyCityCells.length)];
            const x = -mapSize + cell.x * cellSize + Math.random() * cellSize;
            const y = -mapSize + cell.y * cellSize + Math.random() * cellSize;
            game.healthPowerups.push({ x, y, size: 10 });
        }

        function spawnTurret() {
             if (game.emptyCityCells.length === 0) return;
            const mapSize = game.cityBounds, gridSize = 30, cellSize = mapSize * 2 / gridSize;
            const cell = game.emptyCityCells[Math.floor(Math.random() * game.emptyCityCells.length)];
            const x = -mapSize + cell.x * cellSize + cellSize / 2;
            const y = -mapSize + cell.y * cellSize + cellSize / 2;
            const health = 1;
            const problems = [generateProblem()];
            game.turrets.push({ x, y, size: 25, angle: 0, health: health, maxHealth: health, mathProblems: problems, laser: null, color: 'blue' });
        }
        
        function checkCollision(x, y, size) {
            return game.cityscape.some(obj => x + size > obj.x && x - size < obj.x + obj.width && y + size > obj.y && y - size < obj.y + obj.height);
        }
        
        function createParticle(x, y, color = '#00ffff', speed = 2) {
            return { x, y, vx: (Math.random() - 0.5) * speed, vy: (Math.random() - 0.5) * speed, life: 1, decay: 0.02, color, size: Math.random() * 3 + 1 };
        }
        
        window.addEventListener('mousedown', (e) => { game.isPressed = true; game.mouse.x = e.clientX; game.mouse.y = e.clientY; });
        window.addEventListener('mouseup', (e) => { game.isPressed = false; });
        window.addEventListener('mousemove', (e) => { game.mouse.x = e.clientX; game.mouse.y = e.clientY; });
        
        window.addEventListener('touchstart', (e) => {
            const touchTarget = e.target;
            const isUI = touchTarget.closest('#mobileKeyboard, #pauseButton, #gameOverScreen, #pauseMenu, #startMenu, #tutorialScreen, #shopMenu, #mathPracticeMenu, #spanishPracticeMenu');
            
            if (isUI) {
                game.touchOnUI = true;
                return;
            }

            if (game.gameStarted && !game.gameOver && !game.paused) {
                e.preventDefault();
                game.isPressed = true;
                const touch = e.touches[0];
                game.mouse.x = touch.clientX;
                game.mouse.y = touch.clientY;
                game.touchOnUI = false;
            }
        }, { passive: false });

        window.addEventListener('touchmove', (e) => {
            if (game.touchOnUI) return;

            if (game.gameStarted && !game.gameOver && !game.paused && game.isPressed) {
                e.preventDefault();
                const touch = e.touches[0];
                game.mouse.x = touch.clientX;
                game.mouse.y = touch.clientY;
            }
        }, { passive: false });

        window.addEventListener('touchend', (e) => {
            game.isPressed = false;
            game.touchOnUI = false;
        }, { passive: false });
        
        window.addEventListener('keydown', (e) => {
            if (game.gameOver || !game.gameStarted) return;
            if (e.key === 'Escape') { if (game.paused) resumeGame(); else pauseGame(); return; }
            if (game.paused) return;

            if (e.key === 'Enter') {
                checkAnswer();
            } else if (e.key === 'Backspace') {
                game.currentAnswer = game.currentAnswer.slice(0, -1);
            } else if (e.key.length === 1 || e.key === ' ') { // Allow letters and spaces
                game.currentAnswer += e.key;
            }
            updateAnswerDisplay();
        });
        
        function pauseGame() { game.paused = true; document.getElementById('pauseMenu').style.display = 'block'; }
        function resumeGame() { game.paused = false; document.getElementById('pauseMenu').style.display = 'none'; }
        
        function restartFromPause() {
            game.paused = false;
            document.getElementById('pauseMenu').style.display = 'none';
            game.gameStarted = false;
            backToPracticeMenu();
        }
        
        function startGame(startRound = 1) {
            // Reset core game state for a new run
            const cityData = generateCity();
            game.cityscape = cityData.cityscape;
            game.healthPowerups = cityData.healthPowerups;
            game.healingAreas = cityData.healingAreas;
            game.player.x = cityData.startPos.x;
            game.player.y = cityData.startPos.y;
            game.player.vx = 0; game.player.vy = 0;
            game.player.shield = 100;
            game.player.maxShield = 100;
            game.player.speedMultiplier = 1;
            game.player.shieldRegenRate = 0;
            
            Object.assign(game, { turrets: [], enemies: [], lasers: [], enemyBullets: [], particles: [], score: 0, currentAnswer: '', gameOver: false, paused: false, enemySpawnTimer: 0, currentRound: startRound, enemiesSpawnedThisRound: 0, roundInProgress: true });
            
            document.getElementById('gameOverScreen').style.display = 'none';
            game.gameStarted = true;
            updateAnswerDisplay();
            
            setupRound(game.currentRound);
            
            // Start the round logic
            if (game.currentRound >= 11) {
                // Spawn all at once
                for (let i = 0; i < game.enemiesPerRound; i++) spawnEnemy();
            } else {
                // Staggered spawn
                for (let i = 0; i < game.maxEnemies; i++) setTimeout(() => spawnEnemy(), i * 500);
            }
            for (let i = 0; i < game.turretsToSpawnThisRound; i++) spawnTurret();
        }

        function startPracticeGame(mode) {
            game.mode = mode;
            if (mode === 'math') {
                const addOptions = Array.from(document.querySelectorAll('#add-options input:checked')).map(el => parseInt(el.value));
                const subOptions = Array.from(document.querySelectorAll('#sub-options input:checked')).map(el => parseInt(el.value));
                const mulOptions = Array.from(document.querySelectorAll('#mul-options input:checked')).map(el => parseInt(el.value));
                const divOptions = Array.from(document.querySelectorAll('#div-options input:checked')).map(el => parseInt(el.value));

                game.practiceConfig = {
                    addition: document.getElementById('add-check').checked ? addOptions : [],
                    subtraction: document.getElementById('sub-check').checked ? subOptions : [],
                    multiplication: document.getElementById('mul-check').checked ? mulOptions : [],
                    division: document.getElementById('div-check').checked ? divOptions : [],
                };

                const hasSelection = Object.values(game.practiceConfig).some(arr => arr.length > 0);
                if (!hasSelection) {
                    showError("Please select at least one math option to practice.");
                    return;
                }
                const startingRound = parseInt(document.getElementById('math-start-round').value);
                document.getElementById('mathPracticeMenu').style.display = 'none';
                startGame(startingRound);

            } else if (mode === 'spanish') {
                const wordList = [];
                const categories = Object.keys(vocabulary);
                categories.forEach(cat => {
                    const mainCheckbox = document.getElementById(`spanish-${cat}-check`);
                    if (mainCheckbox && mainCheckbox.checked) {
                        const subOptions = document.querySelectorAll(`#spanish-${cat}-options input:checked`);
                        subOptions.forEach(opt => {
                            const [start, end] = opt.value.split('-').map(Number);
                            wordList.push(...vocabulary[cat].slice(start - 1, end));
                        });
                    }
                });

                if (wordList.length === 0) {
                    showError("Please select at least one word category to practice.");
                    return;
                }
                
                game.practiceConfig = {
                    wordList: wordList,
                    direction: game.translationDirection
                };

                const startingRound = parseInt(document.getElementById('spanish-start-round').value);
                document.getElementById('spanishPracticeMenu').style.display = 'none';
                startGame(startingRound);
            }
        }
        
        function showTutorial() {
            const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            const content = document.getElementById('tutorialContent');
            content.innerHTML = `
                <h3>OBJECTIVE</h3><p>Pilot your ship, solve math or vocabulary problems to destroy enemies and turrets. Survive as long as possible.</p>
                <h3>COMBAT</h3><p>To shoot a specific enemy or turret, <span class="highlight">type the answer</span> to its problem, then <span class="highlight">${isMobile ? 'tap the checkmark (✓)' : 'press Enter'}</span> to fire. In Spanish mode, if you don't know the translation of a word, type in the original word for a hint.</p>
                <h3>ENEMIES</h3>
                <p><span class="highlight">White Ships (Snipers):</span> Keep their distance and avoid buildings.</p>
                <p><span class="highlight">Purple Ships (Orbiters):</span> Circle you and must avoid buildings.</p>
                <p><span class="highlight">Blue Ships (Phasers):</span> Phase through buildings.</p>
                <p><span class="highlight">Turrets:</span> Stationary foes with powerful lasers. Destroy them by solving all their math problems.</p>
                <h3>HEALTH & UPGRADES</h3>
                <p>Your shield does not regenerate on its own. Pick up <span class="highlight">green crosses</span> for a 25 shield boost, or rest in <span class="highlight">green healing zones</span> for rapid repairs.</p>
                <p>Between rounds, you can purchase one of three permanent, stacking upgrades for your ship.</p>
                <h3>CONTROLS</h3>
                ${isMobile ? `<p><span class="highlight">Move/Boost:</span> Touch & drag.</p>` : `<p><span class="highlight">Move/Boost:</span> Mouse & left-click.</p>`}`;
            document.getElementById('tutorialScreen').style.display = 'block';
            document.getElementById('startMenu').style.display = 'none';
        }
        
        function hideTutorial() { 
            document.getElementById('tutorialScreen').style.display = 'none';
            document.getElementById('startMenu').style.display = 'block';
        }

        function showMathPractice() {
            document.getElementById('mathPracticeMenu').style.display = 'block';
            document.getElementById('startMenu').style.display = 'none';
        }

        function hideMathPractice() {
            document.getElementById('mathPracticeMenu').style.display = 'none';
            document.getElementById('startMenu').style.display = 'block';
        }

        function showSpanishPractice() {
            document.getElementById('spanishPracticeMenu').style.display = 'block';
            document.getElementById('startMenu').style.display = 'none';
        }

        function hideSpanishPractice() {
            document.getElementById('spanishPracticeMenu').style.display = 'none';
            document.getElementById('startMenu').style.display = 'block';
        }

        function backToPracticeMenu() {
            document.getElementById('gameOverScreen').style.display = 'none';
            if (game.mode === 'math') {
                showMathPractice();
            } else {
                showSpanishPractice();
            }
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            const errorText = document.getElementById('errorMessageText');
            errorText.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 2500);
        }

        function showHint(text) {
            const hintDiv = document.getElementById('hintMessage');
            const hintText = document.getElementById('hintText');
            hintText.textContent = Array.isArray(text) ? text.join(' / ') : text;
            hintDiv.style.display = 'block';
            setTimeout(() => {
                hintDiv.style.display = 'none';
            }, 2000);
        }

        function toggleTranslationDirection() {
            const button = document.getElementById('translation-toggle');
            if (game.translationDirection === 'en-es') {
                game.translationDirection = 'es-en';
                button.textContent = 'ESP → ENG';
            } else {
                game.translationDirection = 'en-es';
                button.textContent = 'ENG → ESP';
            }
        }


        function toggleSubOptions(category, mode = 'math') {
            const prefix = mode === 'math' ? '' : 'spanish-';
            const checkbox = document.getElementById(`${prefix}${category}-check`);
            const optionsDiv = document.getElementById(`${prefix}${category}-options`);
            if (optionsDiv) {
                optionsDiv.style.display = checkbox.checked ? 'grid' : 'none';
            }
        }

        function checkAllInCategory(category, mode, isChecked) {
            const prefix = mode === 'math' ? '' : 'spanish-';
            const optionsDiv = document.getElementById(`${prefix}${category}-options`);
            if (optionsDiv) {
                const checkboxes = optionsDiv.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(cb => cb.checked = isChecked);
            }
        }

        function checkAllCategories(mode, isChecked) {
            const containerId = mode === 'math' ? 'mathPracticeMenu' : 'spanishPracticeMenu';
            const container = document.getElementById(containerId);
            const categoryCheckboxes = container.querySelectorAll('.category > h3 input[type="checkbox"]');
            
            categoryCheckboxes.forEach(cb => {
                cb.checked = isChecked;
                const category = cb.id.replace('-check', '').replace('spanish-', '');
                toggleSubOptions(category, mode);
                checkAllInCategory(category, mode, isChecked);
            });
        }

        function checkAllByRank(rank) {
            // Uncheck everything first for a clean slate
            checkAllCategories('spanish', false);

            Object.keys(vocabulary).forEach(cat => {
                const mainCheckbox = document.getElementById(`spanish-${cat}-check`);
                const rankCheckbox = document.querySelector(`#spanish-${cat}-options input[value="${rank}"]`);
                
                if (rankCheckbox) {
                    mainCheckbox.checked = true;
                    toggleSubOptions(cat, 'spanish');
                    rankCheckbox.checked = true;
                }
            });
        }

        function populateSetupMenus() {
            // Math Menu
            const mathRoundSelector = document.getElementById('math-start-round');
            const mulContainer = document.getElementById('mul-options');
            const divContainer = document.getElementById('div-options');
            mathRoundSelector.innerHTML = '';
            mulContainer.innerHTML = '';
            divContainer.innerHTML = '';
            for (let i = 1; i <= 10; i++) {
                mathRoundSelector.innerHTML += `<option value="${i}">Round ${i}</option>`;
            }
             for (let i = 2; i <= 12; i++) {
                mulContainer.innerHTML += `<label><input type="checkbox" value="${i}"> ×${i}</label>`;
                divContainer.innerHTML += `<label><input type="checkbox" value="${i}"> ÷${i}</label>`;
            }

            // Spanish Menu
            const spanishRoundSelector = document.getElementById('spanish-start-round');
            const spanishGrid = document.getElementById('spanish-options-grid');
            spanishRoundSelector.innerHTML = '';
            spanishGrid.innerHTML = '';
             for (let i = 1; i <= 10; i++) {
                spanishRoundSelector.innerHTML += `<option value="${i}">Round ${i}</option>`;
            }

            Object.keys(vocabulary).forEach(cat => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'category';
                
                const title = cat.charAt(0).toUpperCase() + cat.slice(1);
                categoryDiv.innerHTML = `
                    <h3><input type="checkbox" id="spanish-${cat}-check" onchange="toggleSubOptions('${cat}', 'spanish')"> ${title}</h3>
                    <div class="category-controls">
                        <button onclick="checkAllInCategory('${cat}', 'spanish', true)">All</button>
                        <button onclick="checkAllInCategory('${cat}', 'spanish', false)">None</button>
                    </div>`;
                
                const subOptionsDiv = document.createElement('div');
                subOptionsDiv.className = 'sub-options';
                subOptionsDiv.id = `spanish-${cat}-options`;
                subOptionsDiv.style.display = 'none';

                const wordCount = vocabulary[cat].length;
                for (let i = 0; i < wordCount; i += 10) {
                    const start = i + 1;
                    const end = Math.min(i + 10, wordCount);
                    subOptionsDiv.innerHTML += `<label><input type="checkbox" value="${start}-${end}"> ${start}-${end}</label>`;
                }

                categoryDiv.appendChild(subOptionsDiv);
                spanishGrid.appendChild(categoryDiv);
            });
        }
        
        function startNextRound() {
            game.roundInProgress = false; 
            game.currentRound++; 
            game.enemiesSpawnedThisRound = 0;
            document.getElementById('roundNumber').textContent = game.currentRound;
            document.getElementById('shopMenu').style.display = 'block';
        }

        function proceedToNextRound() {
            document.getElementById('shopMenu').style.display = 'none';
            document.getElementById('roundTransition').style.display = 'block';
            setupRound(game.currentRound);
            setTimeout(() => {
                document.getElementById('roundTransition').style.display = 'none';
                game.roundInProgress = true;
                 if (game.currentRound >= 11) {
                    for (let i = 0; i < game.enemiesPerRound; i++) spawnEnemy();
                } else {
                    for (let i = 0; i < game.maxEnemies; i++) setTimeout(() => spawnEnemy(), i * 500);
                }
                for (let i = 0; i < game.turretsToSpawnThisRound; i++) spawnTurret();
            }, 2000);
        }

        function purchaseShield() {
            game.player.maxShield *= 1.2;
            game.player.shield = game.player.maxShield;
            showPowerupConfirmation("SHIELD UPGRADED!");
        }

        function purchaseSpeed() {
            game.player.speedMultiplier += 0.2;
            showPowerupConfirmation("ENGINES TUNED!");
        }

        function purchaseShieldRegen() {
            game.player.shieldRegenRate += 0.02;
            showPowerupConfirmation("REPAIR BOTS ACTIVATED!");
        }

        function showPowerupConfirmation(text) {
            document.getElementById('shopMenu').style.display = 'none';
            document.getElementById('powerupText').textContent = text;
            document.getElementById('powerupConfirmation').style.display = 'block';
            setTimeout(() => {
                document.getElementById('powerupConfirmation').style.display = 'none';
                proceedToNextRound();
            }, 1500);
        }
        
        function typeNumber(num) { if (!game.gameOver && !game.paused) { event.stopPropagation(); game.currentAnswer += num; updateAnswerDisplay(); } }
        function backspaceAnswer() { if (!game.gameOver && !game.paused) { event.stopPropagation(); game.currentAnswer = game.currentAnswer.slice(0, -1); updateAnswerDisplay(); } }
        function submitAnswer() { if (!game.gameOver && !game.paused) { event.stopPropagation(); checkAnswer(); } }
        
        function updateAnswerDisplay() {
            const d = document.getElementById('currentAnswer');
            d.textContent = 'Answer: ' + game.currentAnswer;
            d.style.color = game.currentAnswer === '' ? '#00ffff' : '#ffff00';
            d.style.textShadow = game.currentAnswer === '' ? 'none' : '0 0 10px #ffff00';
        }
        
        function checkAnswer() {
            if (game.currentAnswer === '') return;

            const rawAnswer = game.currentAnswer.trim();
            
            if (game.mode === 'spanish') {
                const normalizedAnswer = normalizeString(rawAnswer);

                // Hint System: Check if user typed the question
                let hintFound = false;
                const allTargets = [...game.enemies, ...game.turrets];
                for (const target of allTargets) {
                    const problems = target.mathProblems || [target.mathProblem];
                    for (const problem of problems) {
                        if (typeof problem.question !== 'string') continue;
                        const baseQuestion = problem.question.split(' (')[0];
                        if (normalizeString(baseQuestion) === normalizedAnswer) {
                            showHint(problem.answer);
                            hintFound = true;
                            break;
                        }
                    }
                    if(hintFound) break;
                }

                if (hintFound) {
                    game.currentAnswer = '';
                    updateAnswerDisplay();
                    return;
                }
            }

            // Correct Answer Check
            const userAnswer = game.mode === 'math' ? parseInt(rawAnswer) : normalizeString(rawAnswer);

            const matchingEnemies = game.enemies.filter(e => {
                if (game.mode === 'math') {
                    return e.mathProblem.answer === userAnswer;
                } else {
                    const answer = e.mathProblem.answer;
                    const possibleAnswers = Array.isArray(answer) ? answer.map(normalizeString) : [normalizeString(answer)];
                    const baseAnswer = normalizeString(answer.toString().split(' (')[0]);
                    if (!possibleAnswers.includes(baseAnswer)) possibleAnswers.push(baseAnswer);
                    if (baseAnswer.startsWith('to ')) {
                        possibleAnswers.push(baseAnswer.substring(3));
                    }
                    return possibleAnswers.includes(userAnswer);
                }
            });

            const matchingTurrets = game.turrets.filter(t => 
                t.mathProblems.some(p => {
                    if (game.mode === 'math') {
                        return p.answer === userAnswer;
                    } else {
                        const answer = p.answer;
                        const possibleAnswers = Array.isArray(answer) ? answer.map(normalizeString) : [normalizeString(answer)];
                        const baseAnswer = normalizeString(answer.toString().split(' (')[0]);
                        if (!possibleAnswers.includes(baseAnswer)) possibleAnswers.push(baseAnswer);
                        if (baseAnswer.startsWith('to ')) {
                            possibleAnswers.push(baseAnswer.substring(3));
                        }
                        return possibleAnswers.includes(userAnswer);
                    }
                })
            );

            const allMatches = [...matchingEnemies, ...matchingTurrets];

            if (allMatches.length > 0) {
                // Find the closest target
                let closestTarget = allMatches[0];
                let minDistance = Math.hypot(game.player.x - closestTarget.x, game.player.y - closestTarget.y);

                for (let i = 1; i < allMatches.length; i++) {
                    const dist = Math.hypot(game.player.x - allMatches[i].x, game.player.y - allMatches[i].y);
                    if (dist < minDistance) {
                        minDistance = dist;
                        closestTarget = allMatches[i];
                    }
                }

                // Fire at the closest target
                const laser = fireLaser(closestTarget);
                if (closestTarget.mathProblems) { // It's a turret
                    const problem = closestTarget.mathProblems.find(p => {
                        if (game.mode === 'math') {
                           return p.answer === userAnswer;
                        }
                        const answer = p.answer;
                        const possibleAnswers = Array.isArray(answer) ? answer.map(normalizeString) : [normalizeString(answer)];
                        return possibleAnswers.includes(userAnswer);
                    });
                     laser.solvedProblem = problem;
                    game.score += 25;
                } else { // It's an enemy
                    game.score += 10;
                }
            }

            game.currentAnswer = '';
            updateAnswerDisplay();
        }

        function setupRound(round) {
            game.roundRoster.enemies = [];
            let counts = { sniper: 0, chaser: 0, orbiter: 0 };
            let turrets = 0;

            if (round === 1) {
                game.enemiesPerRound = 10;
                game.maxEnemies = 1;
                turrets = 0;
                counts.sniper = 10;
            } else if (round === 2) {
                game.enemiesPerRound = 10;
                game.maxEnemies = 2;
                turrets = 1;
                counts.sniper = 10;
            } else if (round === 3) {
                game.enemiesPerRound = 10;
                game.maxEnemies = 3;
                turrets = 1;
                counts.sniper = 8;
                counts.chaser = 2;
            } else if (round === 4) {
                game.enemiesPerRound = 10;
                game.maxEnemies = 4;
                turrets = 2;
                counts.sniper = 6;
                counts.chaser = 2;
                counts.orbiter = 2;
            } else if (round === 5) {
                game.enemiesPerRound = 10;
                game.maxEnemies = 5;
                turrets = 2;
                counts.sniper = 4;
                counts.chaser = 3;
                counts.orbiter = 3;
            } else if (round === 6) {
                game.enemiesPerRound = 10;
                game.maxEnemies = 6;
                turrets = 3;
                counts.sniper = 2;
                counts.chaser = 4;
                counts.orbiter = 4;
            } else if (round === 7) {
                game.enemiesPerRound = 10;
                game.maxEnemies = 7;
                turrets = 3;
                counts.sniper = 2;
                counts.chaser = 4;
                counts.orbiter = 4;
            } else if (round <= 10) {
                game.enemiesPerRound = 10;
                game.maxEnemies = round;
                turrets = 3;
                counts.sniper = 2;
                counts.chaser = 4;
                counts.orbiter = 4;
            } else { // Round 11+
                game.enemiesPerRound = round;
                game.maxEnemies = round;
                turrets = 3;
                const half = Math.floor(round / 2);
                counts.chaser = half;
                counts.orbiter = round - half;
            }

            game.turretsToSpawnThisRound = turrets;

            for (let i = 0; i < counts.sniper; i++) game.roundRoster.enemies.push('sniper');
            for (let i = 0; i < counts.chaser; i++) game.roundRoster.enemies.push('chaser');
            for (let i = 0; i < counts.orbiter; i++) game.roundRoster.enemies.push('orbiter');
            
            // Shuffle the roster for random spawning
            game.roundRoster.enemies.sort(() => Math.random() - 0.5);
        }
        
        function restartGame() {
            // This function is now deprecated in favor of starting fresh from the menu.
            // The button now calls backToPracticeMenu()
            // Kept here in case it's needed for other restart logic later.
            showMathPractice();
        }
        
        function update() {
            if (game.gameOver || game.paused || !game.gameStarted) return;
            const player = game.player;
            const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            const playerScreenX = canvas.width / 2;
            const playerScreenY = isMobile ? canvas.height / 3 : canvas.height / 2;
            player.angle = Math.atan2(game.mouse.y - playerScreenY, game.mouse.x - playerScreenX);
            const cursorDist = Math.hypot(game.mouse.x - playerScreenX, game.mouse.y - playerScreenY);
            let speedMult = Math.min(1, Math.max(0, (cursorDist - 20) / 130));
            const currentSpeed = (game.isPressed ? 5 : 2.5) * speedMult * game.fpsRatio * player.speedMultiplier;
            player.boosting = game.isPressed;
            const newVx = Math.cos(player.angle) * currentSpeed;
            const newVy = Math.sin(player.angle) * currentSpeed;
            if (!checkCollision(player.x + newVx, player.y, player.size)) { player.x += newVx; player.vx = newVx; } else { player.vx = 0; game.camera.shake = 2; }
            if (!checkCollision(player.x, player.y + newVy, player.size)) { player.y += newVy; player.vy = newVy; } else { player.vy = 0; game.camera.shake = 2; }
            
            player.shield = Math.min(player.maxShield, player.shield + (player.maxShield * game.player.shieldRegenRate / 60) * game.fpsRatio);
            game.healingAreas.forEach(area => {
                if (Math.hypot(player.x - area.x, player.y - area.y) < area.radius) {
                    player.shield = Math.min(player.maxShield, player.shield + (player.maxShield * 0.1 / 60) * game.fpsRatio);
                }
            });
            game.healthPowerups = game.healthPowerups.filter(p => {
                if (Math.hypot(player.x - p.x, player.y - p.y) < player.size + p.size) {
                    player.shield = Math.min(player.maxShield, player.shield + 25);
                    spawnHealthPowerup();
                    return false;
                }
                return true;
            });

            if (player.shield <= 0) { game.gameOver = true; document.getElementById('gameOverScreen').style.display = 'block'; document.getElementById('finalScore').textContent = 'Final Score: ' + game.score; document.getElementById('finalRound').textContent = 'Round: ' + game.currentRound; return; }
            game.camera.x = player.x - playerScreenX; game.camera.y = player.y - playerScreenY;
            if (game.camera.shake > 0) { game.camera.shake *= 0.85; game.camera.x += (Math.random() - 0.5) * game.camera.shake; game.camera.y += (Math.random() - 0.5) * game.camera.shake; }
            game.particles = game.particles.filter(p => { p.x += p.vx; p.y += p.vy; p.life -= p.decay; p.vx *= 0.95; p.vy *= 0.95; return p.life > 0; });
            
            game.enemies.forEach(e => {
                const dx = player.x - e.x, dy = player.y - e.y;
                const dist = Math.hypot(dx, dy);

                if(dist > 1500) {
                    let newX, newY, attempts = 0;
                    do {
                        const angle = Math.random() * Math.PI * 2, respawnDist = (canvas.width / 2) + Math.random() * 200;
                        newX = game.player.x + Math.cos(angle) * respawnDist;
                        newY = game.player.y + Math.sin(angle) * respawnDist;
                        attempts++;
                    } while (checkCollision(newX, newY, e.size) && attempts < 10);
                    if (attempts < 10) { e.x = newX; e.y = newY; }
                }

                e.shootTimer++; 
                let targetVx = 0, targetVy = 0;
                if (dist > 0) {
                    const chaseAngle = Math.atan2(dy, dx);
                    switch(e.archetype) {
                        case 'chaser': targetVx = Math.cos(chaseAngle) * e.chaseSpeed; targetVy = Math.sin(chaseAngle) * e.chaseSpeed; break;
                        case 'orbiter': const orbitDist = 300, tangentAngle = chaseAngle + Math.PI / 2; let moveAngle = dist > orbitDist + 50 ? chaseAngle : dist < orbitDist - 50 ? chaseAngle + Math.PI : tangentAngle; targetVx = Math.cos(moveAngle) * e.chaseSpeed; targetVy = Math.sin(moveAngle) * e.chaseSpeed; break;
                        case 'sniper': if (dist > 400) { targetVx = Math.cos(chaseAngle) * e.chaseSpeed; targetVy = Math.sin(chaseAngle) * e.chaseSpeed; } break;
                    }
                }
                
                e.vx += targetVx * 0.1; e.vy += targetVy * 0.1;
                if (e.archetype === 'sniper' || e.archetype === 'orbiter') {
                    if (checkCollision(e.x + e.vx, e.y, e.size)) e.vx = 0;
                    if (checkCollision(e.x, e.y + e.vy, e.size)) e.vy = 0;
                }
                
                e.x += e.vx; e.y += e.vy;
                e.vx *= 0.9; e.vy *= 0.9; e.angle += 0.03; 
                if (e.shootTimer > 90) { enemyShoot(e); e.shootTimer = 0; } 
            });

            let nearestTurret = null, minTurretDist = Infinity;
            game.turrets.forEach(t => {
                const dist = Math.hypot(player.x - t.x, player.y - t.y);
                if(dist < minTurretDist) { minTurretDist = dist; nearestTurret = t; }

                const targetAngle = Math.atan2(player.y - t.y, player.x - t.x);
                let angleDiff = targetAngle - t.angle;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                
                const baseTurnDistance = 150;
                const baseTurnSpeedRadPerSec = (60 * Math.PI / 180);
                const minTurnSpeedRadPerSec = (2 * Math.PI / 180);
                let turnSpeedRadPerSec = baseTurnSpeedRadPerSec * (baseTurnDistance / Math.max(dist, baseTurnDistance));
                turnSpeedRadPerSec = Math.max(turnSpeedRadPerSec, minTurnSpeedRadPerSec);
                const turnAmount = turnSpeedRadPerSec * (1/60) * game.fpsRatio;
                const maxTurn = Math.min(Math.abs(angleDiff), turnAmount);
                t.angle += Math.sign(angleDiff) * maxTurn;

                const laserLength = 4000;
                let endX = t.x + Math.cos(t.angle) * laserLength, endY = t.y + Math.sin(t.angle) * laserLength;
                const turretDamagePerSecond = 10 + (game.currentRound - 1) * 10;
                
                for(let i=0; i<laserLength; i+=25){
                    const checkX = t.x + Math.cos(t.angle) * i, checkY = t.y + Math.sin(t.angle) * i;
                    if(checkCollision(checkX, checkY, 2)){ endX = checkX; endY = checkY; break; }
                    if(Math.hypot(player.x - checkX, player.y - checkY) < player.size){ 
                        player.shield -= (turretDamagePerSecond / 60) * game.fpsRatio; 
                        endX = player.x; endY = player.y; 
                        break; 
                    }
                }
                t.laser = {x1: t.x, y1: t.y, x2: endX, y2: endY};
            });
            game.turrets = game.turrets.filter(t => t.health > 0);
            game.nearestTurretAngle = nearestTurret ? Math.atan2(nearestTurret.y - player.y, nearestTurret.x - player.x) : null;

            game.enemyBullets = game.enemyBullets.filter(b => { b.x += b.vx; b.y += b.vy; if (Math.hypot(b.x - player.x, b.y - player.y) < player.size + b.size) { player.shield -= b.damage; game.camera.shake = 6; for (let i = 0; i < 6; i++) game.particles.push(createParticle(b.x, b.y, '#ff0000', 4)); document.body.classList.add('damage-flash'); setTimeout(() => document.body.classList.remove('damage-flash'), 300); return false; } if (checkCollision(b.x, b.y, b.size)) { for (let i = 0; i < 3; i++) game.particles.push(createParticle(b.x, b.y, '#666666', 2)); return false; } return true; });
            game.enemySpawnTimer++; if (game.enemySpawnTimer > 120 && game.enemies.length < game.maxEnemies && game.enemiesSpawnedThisRound < game.enemiesPerRound) { spawnEnemy(); game.enemySpawnTimer = 0; }
            if (game.roundInProgress && game.enemiesSpawnedThisRound >= game.enemiesPerRound && game.enemies.length === 0 && game.turrets.length === 0) startNextRound();
            
            const enemiesToRemove = new Set();
            game.lasers = game.lasers.filter(l => {
                l.x += l.vx;
                l.y += l.vy;
                l.life--;

                if (checkCollision(l.x, l.y, 2)) {
                    for (let i = 0; i < 5; i++) game.particles.push(createParticle(l.x, l.y, '#00ffff', 3));
                    return false; // Laser is gone
                }

                if (l.target) {
                    if (Math.hypot(l.x - l.target.x, l.y - l.target.y) < l.target.size) {
                        // HIT!
                        l.life = 0; // Laser is gone
                        
                        if (l.target.mathProblems) { // It's a turret
                            const turret = l.target;
                            if (l.solvedProblem) {
                                const index = turret.mathProblems.indexOf(l.solvedProblem);
                                if (index > -1) {
                                    turret.mathProblems.splice(index, 1);
                                    turret.health--;
                                    if (turret.health <= 0) {
                                        for (let i = 0; i < 15; i++) game.particles.push(createParticle(turret.x, turret.y, '#ffffff', 8));
                                    }
                                }
                            }
                        } else { // It's an enemy
                            enemiesToRemove.add(l.target);
                            for (let i = 0; i < 15; i++) game.particles.push(createParticle(l.target.x, l.target.y, '#ffffff', 8));
                        }
                        return false; // Laser is gone
                    }
                }
                
                return l.life > 0;
            });

            if (enemiesToRemove.size > 0) {
                game.enemies = game.enemies.filter(e => !enemiesToRemove.has(e));
            }

            if (Math.hypot(player.vx, player.vy) > 0.1) { game.particles.push(createParticle(player.x - Math.cos(player.angle) * 15, player.y - Math.sin(player.angle) * 15, player.boosting ? '#ff6600' : '#0088ff', player.boosting ? 4 : 2)); }
            
            document.getElementById('round').textContent = game.currentRound; 
            document.getElementById('shield').textContent = `${Math.round(player.shield)} / ${Math.round(player.maxShield)}`; 
            document.getElementById('enemiesLeft').textContent = (game.enemiesPerRound - game.enemiesSpawnedThisRound) + game.enemies.length + game.turrets.length;
            document.getElementById('score').textContent = game.score;
            document.getElementById('playerSpeed').textContent = (Math.hypot(player.vx, player.vy) * 10).toFixed(1);
            document.getElementById('enemyDamage').textContent = 10 + (game.currentRound - 1) * 10;
        }
        
        function render() {
            ctx.fillStyle = '#000511'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save(); ctx.translate(-game.camera.x, -game.camera.y);
            
            game.healingAreas.forEach(area => {
                const gradient = ctx.createRadialGradient(area.x, area.y, 10, area.x, area.y, area.radius);
                gradient.addColorStop(0, 'rgba(0, 255, 100, 0.5)');
                gradient.addColorStop(1, 'rgba(0, 255, 100, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(area.x - area.radius, area.y - area.radius, area.radius * 2, area.radius * 2);
                ctx.fillStyle = '#00ff64'; ctx.shadowColor = '#00ff64'; ctx.shadowBlur = 15;
                ctx.beginPath(); ctx.arc(area.x, area.y, 10, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
            });

            game.cityscape.forEach(obj => {
                ctx.fillStyle = '#000'; ctx.fillRect(obj.x + 3, obj.y + 3, obj.width, obj.height);
                ctx.fillStyle = obj.color; ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                ctx.strokeStyle = obj.type === 'obstacle' ? '#ff3333' : '#003366'; ctx.lineWidth = 2; ctx.strokeRect(obj.x, obj.y, obj.width, obj.height);
                if (obj.type === 'building' && obj.windows) {
                    obj.windows.forEach(w => { if (w.lit) { ctx.fillStyle = w.color; ctx.shadowColor = w.color; ctx.shadowBlur = 8; ctx.fillRect(w.x, w.y, w.width, w.height); ctx.shadowBlur = 0; } });
                }
            });

            game.healthPowerups.forEach(p => {
                ctx.save(); ctx.fillStyle = '#00ff00'; ctx.shadowColor = '#00ff00'; ctx.shadowBlur = 10;
                ctx.fillRect(p.x - p.size, p.y - p.size / 4, p.size * 2, p.size / 2);
                ctx.fillRect(p.x - p.size / 4, p.y - p.size, p.size / 2, p.size * 2);
                ctx.restore();
            });

            game.particles.forEach(p => { ctx.save(); ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.shadowColor = p.color; ctx.shadowBlur = 8; ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size); ctx.restore(); });
            game.enemyBullets.forEach(b => { ctx.save(); ctx.fillStyle = '#ff6600'; ctx.shadowColor = '#ff6600'; ctx.shadowBlur = 8; ctx.beginPath(); ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2); ctx.fill(); ctx.restore(); });
            game.enemies.forEach(e => { 
                ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.angle); 
                let enemyColor = '#3399ff'; // Chaser (blue)
                if (e.archetype === 'sniper') enemyColor = '#ffffff'; // Sniper (white)
                if (e.archetype === 'orbiter') enemyColor = '#cc33ff'; // Orbiter (purple)
                ctx.fillStyle = enemyColor;
                ctx.shadowColor = ctx.fillStyle;
                ctx.shadowBlur = 15; 
                ctx.beginPath(); ctx.moveTo(e.size, 0); ctx.lineTo(0, -e.size); ctx.lineTo(-e.size, 0); ctx.lineTo(0, e.size); ctx.closePath(); ctx.fill(); 
                ctx.fillStyle = '#ff0000'; ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 10; ctx.beginPath(); ctx.arc(0, 0, e.size/3, 0, Math.PI * 2); ctx.fill(); 
                ctx.restore(); 
                ctx.save(); const text = e.mathProblem.question; ctx.font = 'bold 16px Courier New'; const textWidth = ctx.measureText(text).width; const padding = 12; ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.fillRect(e.x - textWidth/2 - padding/2, e.y - e.size - 22, textWidth + padding, 20); ctx.fillStyle = '#000000'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(text, e.x, e.y - e.size - 12); ctx.restore(); 
            });
            game.turrets.forEach(t => {
                ctx.save(); ctx.translate(t.x, t.y);
                let turretColor = '#0055aa';
                ctx.fillStyle = turretColor;
                ctx.beginPath(); ctx.arc(0, 0, t.size, 0, Math.PI * 2); ctx.fill();
                ctx.rotate(t.angle);
                ctx.fillStyle = '#888'; ctx.fillRect(0, -5, t.size + 10, 10);
                ctx.restore();
                if(t.laser) { ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 4; ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 15; ctx.beginPath(); ctx.moveTo(t.laser.x1, t.laser.y1); ctx.lineTo(t.laser.x2, t.laser.y2); ctx.stroke(); ctx.shadowBlur = 0; }
                const barWidth = 50;
                ctx.fillStyle = '#500'; ctx.fillRect(t.x - barWidth/2, t.y - t.size - 30, barWidth, 5);
                ctx.fillStyle = '#0f0'; ctx.fillRect(t.x - barWidth/2, t.y - t.size - 30, barWidth * (t.health / t.maxHealth), 5);
                t.mathProblems.forEach((p, i) => { const text = p.question; ctx.font = 'bold 12px Courier New'; const textWidth = ctx.measureText(text).width; ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.fillRect(t.x - textWidth/2 - 4, t.y - t.size - 50 - i * 15, textWidth + 8, 14); ctx.fillStyle = '#000'; ctx.textAlign = 'center'; ctx.fillText(text, t.x, t.y - t.size - 43 - i * 15); });
            });
            game.lasers.forEach(l => { ctx.save(); ctx.translate(l.x, l.y); ctx.rotate(l.angle); ctx.fillStyle = '#00ffff'; ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 15; ctx.fillRect(-15, -2, 30, 4); ctx.fillStyle = '#ffffff'; ctx.fillRect(10, -1, 10, 2); ctx.restore(); });
            const p = game.player; ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.angle); ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 15; ctx.fillStyle = '#0088ff'; ctx.beginPath(); ctx.moveTo(p.size, 0); ctx.lineTo(-p.size/2, -p.size/2); ctx.lineTo(-p.size/3, 0); ctx.lineTo(-p.size/2, p.size/2); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#00ffff'; ctx.shadowBlur = 20; ctx.beginPath(); ctx.arc(0, 0, p.size/3, 0, Math.PI * 2); ctx.fill(); if (p.boosting) { ctx.fillStyle = '#ff6600'; ctx.shadowColor = '#ff6600'; ctx.shadowBlur = 20; ctx.beginPath(); ctx.arc(-p.size, 0, p.size/2, 0, Math.PI * 2); ctx.fill(); } ctx.restore();
            
            if (game.nearestTurretAngle !== null) {
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(game.nearestTurretAngle);
                ctx.fillStyle = 'rgba(255, 50, 50, 0.7)';
                ctx.shadowColor = 'red';
                ctx.shadowBlur = 5;
                const arrowDist = p.size + 15;
                ctx.beginPath();
                ctx.moveTo(arrowDist, 0);
                ctx.lineTo(arrowDist - 8, -5);
                ctx.lineTo(arrowDist - 8, 5);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            ctx.restore();
            ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 2; ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 10; ctx.beginPath(); ctx.moveTo(game.mouse.x - 15, game.mouse.y); ctx.lineTo(game.mouse.x + 15, game.mouse.y); ctx.moveTo(game.mouse.x, game.mouse.y - 15); ctx.lineTo(game.mouse.x, game.mouse.y + 15); ctx.stroke(); ctx.fillStyle = '#00ffff'; ctx.beginPath(); ctx.arc(game.mouse.x, game.mouse.y, 3, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
        }
        
        function gameLoop(currentTime) {
            game.frameCount++; if (currentTime - game.lastFPSCheck >= 1000) { game.currentFPS = game.frameCount; game.fpsRatio = 60 / Math.max(game.currentFPS, 20); game.frameCount = 0; game.lastFPSCheck = currentTime; }
            update(); render(); requestAnimationFrame(gameLoop);
        }
        
        // --- INITIALIZATION ---
        const cityData = generateCity();
        game.cityscape = cityData.cityscape;
        game.healthPowerups = cityData.healthPowerups;
        game.healingAreas = cityData.healingAreas;
        game.player.x = cityData.startPos.x;
        game.player.y = cityData.startPos.y;
        game.lastFPSCheck = performance.now();
        
        populateSetupMenus();
        
        gameLoop();
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 100));
    </script>
</body>
</html>
