<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teacher Challenge</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #2d5016, #4a7c59);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        canvas {
            border: 3px solid #8B4513;
            border-radius: 8px;
            background: #87CEEB;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            cursor: pointer;
            max-width: 100vw;
            max-height: 100vh;
        }
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.6);
            padding: 8px 12px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        .ui {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #fff;
            font-size: 12px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.6);
            padding: 8px 12px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        
        /* Inventory Styles */
        .inventory-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 100;
        }
        
        .quest-indicator {
            background: rgba(0,0,0,0.8);
            border: 2px solid #FFD700;
            border-radius: 8px;
            padding: 8px 12px;
            color: #FFD700;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .quest-indicator-item {
            font-size: 20px;
        }
        
        .inventory {
            display: flex;
            gap: 4px;
            background: rgba(0,0,0,0.8);
            padding: 8px;
            border-radius: 8px;
            border: 2px solid #8B4513;
        }
        
        .inventory-slot {
            width: 48px;
            height: 48px;
            background: rgba(64, 64, 64, 0.9);
            border: 2px solid #4a4a4a;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            position: relative;
            transition: all 0.2s ease;
        }
        
        .inventory-slot.filled {
            background: rgba(96, 96, 96, 0.9);
            border-color: #8B4513;
        }
        
        .inventory-slot.filled:hover {
            background: rgba(128, 128, 128, 0.9);
            transform: scale(1.05);
        }
        
        .inventory-slot.empty {
            border-style: dashed;
            border-color: #2a2a2a;
        }
        
        /* Mobile Controls */
        .mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }
        
        .chat-hint {
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            text-align: center;
            backdrop-filter: blur(10px);
        }
        
        /* Conversation UI Styles */
        .conversation-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 10px;
            box-sizing: border-box;
        }
        
        .conversation-box {
            background: linear-gradient(135deg, #f5f5f5, #e8e8e8);
            border: 3px solid #8B4513;
            border-radius: 12px;
            width: 100%;
            max-width: 600px;
            height: 100%;
            max-height: 600px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }
        
        .conversation-header {
            background: #8B4513;
            color: white;
            padding: 15px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .conversation-title {
            font-size: 18px;
            font-weight: bold;
        }
        
        .close-button {
            background: #654321;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
            touch-action: manipulation;
        }
        
        .close-button:hover {
            background: #4a3018;
        }
        
        .conversation-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: white;
            -webkit-overflow-scrolling: touch;
        }
        
        .message {
            margin-bottom: 15px;
            padding: 15px 20px;
            border-radius: 10px;
            max-width: 85%;
            word-wrap: break-word;
            line-height: 1.5;
            font-size: 15px;
        }
        
        .message.player {
            background: #4169E1;
            color: white;
            margin-left: auto;
            text-align: right;
        }
        
        .message.teacher {
            background: #f0f0f0;
            color: #333;
        }
        
        .conversation-input-area {
            display: flex;
            padding: 15px;
            background: #f5f5f5;
            border-top: 1px solid #ddd;
            border-radius: 0 0 8px 8px;
            flex-shrink: 0;
        }
        
        .conversation-input {
            flex: 1;
            padding: 12px;
            border: 2px solid #8B4513;
            border-radius: 5px;
            font-size: 16px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .send-button {
            background: #4169E1;
            color: white;
            border: none;
            padding: 12px 20px;
            margin-left: 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
            touch-action: manipulation;
        }
        
        .send-button:hover {
            background: #1E90FF;
        }
        
        .send-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .thinking-indicator {
            display: none;
            color: #666;
            font-style: italic;
            padding: 10px;
            text-align: center;
        }
        
        /* Difficulty Selection Styles */
        .difficulty-popup {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #2d5016, #4a7c59);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2500;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .difficulty-box {
            background: linear-gradient(135deg, #f5f5f5, #e8e8e8);
            border: 4px solid #8B4513;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 12px 40px rgba(0,0,0,0.6);
            max-width: 600px;
            width: 100%;
            position: relative;
        }
        
        .difficulty-box::before {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            background: linear-gradient(45deg, #8B4513, #A0522D, #8B4513);
            border-radius: 20px;
            z-index: -1;
        }
        
        .difficulty-title {
            font-size: 36px;
            font-weight: bold;
            color: #8B4513;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .difficulty-subtitle {
            font-size: 20px;
            color: #654321;
            margin-bottom: 35px;
            font-weight: 500;
        }
        
        .difficulty-buttons {
            display: flex;
            gap: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .difficulty-button {
            padding: 25px 35px;
            border: 3px solid transparent;
            border-radius: 12px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            touch-action: manipulation;
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
            min-width: 180px;
            position: relative;
            overflow: hidden;
        }
        
        .difficulty-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }
        
        .difficulty-button:hover::before {
            left: 100%;
        }
        
        .easy-button {
            background: linear-gradient(135deg, #90EE90, #32CD32);
            color: #006400;
            border-color: #228B22;
        }
        
        .easy-button:hover {
            background: linear-gradient(135deg, #98FB98, #00FF32);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
            border-color: #32CD32;
        }
        
        .hard-button {
            background: linear-gradient(135deg, #FF6B6B, #DC143C);
            color: white;
            border-color: #B22222;
        }
        
        .hard-button:hover {
            background: linear-gradient(135deg, #FF7F7F, #FF1493);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
            border-color: #FF1493;
        }
        
        .difficulty-button small {
            display: block;
            font-size: 14px;
            font-weight: normal;
            margin-top: 5px;
            opacity: 0.9;
        }
        
        .village-icons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            font-size: 24px;
        }
        
        .village-icons span {
            animation: float 3s ease-in-out infinite;
        }
        
        .village-icons span:nth-child(2) {
            animation-delay: 0.5s;
        }
        
        .village-icons span:nth-child(3) {
            animation-delay: 1s;
        }
        
        .village-icons span:nth-child(4) {
            animation-delay: 1.5s;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        .quest-popup {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .quest-box {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            border: 4px solid #8B4513;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            max-width: 400px;
            width: 100%;
        }
        
        .quest-title {
            font-size: 28px;
            font-weight: bold;
            color: #8B4513;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .quest-item {
            font-size: 24px;
            color: #654321;
            margin-bottom: 25px;
            font-weight: bold;
        }
        
        .quest-start-button {
            background: #4169E1;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s;
            touch-action: manipulation;
        }
        
        .quest-start-button:hover {
            background: #1E90FF;
        }
        
        .tutorial-button {
            background: #32CD32;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s;
            touch-action: manipulation;
            margin-top: 10px;
        }
        
        .tutorial-button:hover {
            background: #228B22;
        }
        
        /* Tutorial Popup Styles */
        .tutorial-popup {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .tutorial-box {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border: 4px solid #8B4513;
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.7);
        }
        
        .tutorial-title {
            font-size: 28px;
            font-weight: bold;
            color: #8B4513;
            text-align: center;
            margin-bottom: 25px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .tutorial-content {
            color: #333;
            line-height: 1.6;
            font-size: 16px;
        }
        
        .tutorial-section {
            margin-bottom: 20px;
        }
        
        .tutorial-section h3 {
            color: #654321;
            font-size: 20px;
            margin-bottom: 10px;
            border-bottom: 2px solid #8B4513;
            padding-bottom: 5px;
        }
        
        .tutorial-section p {
            margin-bottom: 10px;
        }
        
        .tutorial-section ul {
            margin-left: 20px;
            margin-bottom: 10px;
        }
        
        .tutorial-section li {
            margin-bottom: 5px;
        }
        
        .tutorial-close-button {
            background: #4169E1;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s;
            touch-action: manipulation;
            display: block;
            margin: 20px auto 0;
        }
        
        .tutorial-close-button:hover {
            background: #1E90FF;
        }
        
        /* Quest Complete Popup Styles */
        .quest-complete-popup {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .quest-complete-box {
            background: linear-gradient(135deg, #32CD32, #228B22);
            border: 4px solid #8B4513;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            max-width: 400px;
            width: 100%;
            animation: celebration 0.6s ease-out;
        }
        
        @keyframes celebration {
            0% { transform: scale(0.5) rotate(-5deg); opacity: 0; }
            50% { transform: scale(1.05) rotate(2deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        
        .quest-complete-title {
            font-size: 32px;
            font-weight: bold;
            color: white;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .quest-complete-message {
            font-size: 20px;
            color: #F0F8FF;
            margin-bottom: 25px;
            font-weight: bold;
        }
        
        .play-again-button {
            background: #FFD700;
            color: #8B4513;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            touch-action: manipulation;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .play-again-button:hover {
            background: #FFA500;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        
        .quest-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .continue-game-button {
            background: #4169E1;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            touch-action: manipulation;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .continue-game-button:hover {
            background: #1E90FF;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        
        /* Mobile Responsive */
        /* Mobile Responsive */
        @media (max-width: 768px) {
            .difficulty-box {
                padding: 25px;
                margin: 15px;
            }
            
            .difficulty-title {
                font-size: 30px;
            }
            
            .difficulty-subtitle {
                font-size: 18px;
            }
            
            .difficulty-button {
                padding: 20px 30px;
                font-size: 18px;
                min-width: 160px;
            }
            
            .difficulty-buttons {
                flex-direction: column;
                align-items: center;
                gap: 20px;
            }
            
            .village-icons {
                font-size: 20px;
                gap: 10px;
            }
            
            .quest-box {
                padding: 20px;
                margin: 10px;
            }
            
            .quest-title {
                font-size: 24px;
            }
            
            .quest-item {
                font-size: 20px;
            }
            
            .quest-start-button {
                padding: 12px 24px;
                font-size: 16px;
            }
            
            .tutorial-button {
                padding: 12px 24px;
                font-size: 16px;
                margin-top: 8px;
            }
            
            .tutorial-box {
                padding: 20px;
                margin: 10px;
                max-height: 85vh;
            }
            
            .tutorial-title {
                font-size: 24px;
                margin-bottom: 20px;
            }
            
            .tutorial-content {
                font-size: 14px;
            }
            
            .tutorial-section h3 {
                font-size: 18px;
            }
            
            .quest-complete-box {
                padding: 20px;
                margin: 10px;
            }
            
            .quest-complete-title {
                font-size: 28px;
            }
            
            .quest-complete-message {
                font-size: 18px;
            }
            
            .play-again-button {
                padding: 12px 24px;
                font-size: 16px;
            }
            
            .continue-game-button {
                padding: 12px 24px;
                font-size: 16px;
            }
            
            .quest-buttons {
                flex-direction: column;
                gap: 10px;
            }
            
            .inventory-container {
                bottom: 80px;
            }
            
            .quest-indicator {
                font-size: 12px;
                padding: 6px 10px;
            }
            
            .quest-indicator-item {
                font-size: 18px;
            }
            
            .inventory {
                gap: 2px;
                padding: 6px;
            }
            
            .inventory-slot {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }
            
            .mobile-controls {
                display: flex;
            }
            
            .controls {
                font-size: 12px;
                padding: 6px 10px;
                top: 5px;
                left: 5px;
            }
            
            .ui {
                font-size: 11px;
                padding: 6px 10px;
                top: 5px;
                right: 5px;
            }
            
            canvas {
                border-width: 2px;
            }
            
            .conversation-box {
                height: 90vh;
                max-height: none;
                margin: 5vh 0;
            }
            
            .conversation-header {
                padding: 12px;
            }
            
            .conversation-title {
                font-size: 16px;
            }
            
            .close-button {
                padding: 6px 12px;
                font-size: 14px;
            }
            
            .conversation-messages {
                padding: 15px;
            }
            
            .message {
                font-size: 14px;
                padding: 12px 16px;
                max-width: 90%;
            }
            
            .conversation-input-area {
                padding: 12px;
            }
            
            .conversation-input {
                font-size: 16px; /* Prevents zoom on iOS */
                padding: 10px;
            }
            
            .send-button {
                padding: 10px 16px;
                margin-left: 8px;
            }
        }
        
            @media (max-width: 480px) {
            .controls, .ui {
                font-size: 10px;
                padding: 4px 8px;
            }
            
            .inventory-container {
                bottom: 70px;
            }
            
            .quest-indicator {
                font-size: 11px;
                padding: 4px 8px;
            }
            
            .quest-indicator-item {
                font-size: 16px;
            }
            
            .inventory {
                gap: 1px;
                padding: 4px;
            }
            
            .inventory-slot {
                width: 36px;
                height: 36px;
                font-size: 18px;
            }
            
            .conversation-overlay {
                padding: 5px;
            }
            
            .conversation-box {
                height: 95vh;
                margin: 2.5vh 0;
            }
            
            .message {
                font-size: 13px;
                padding: 10px 14px;
            }
        }
    </style>
</head>
<body>
    <div class="controls">
        üéÆ Use WASD or Arrow Keys to explore<br>
        üè° Welcome to Peaceful Village!<br>
        üí¨ Click on teachers to chat with them!
    </div>
    <div class="ui">
        Position: <span id="position">400, 300</span>
    </div>
    <canvas id="gameCanvas" width="600" height="450"></canvas>
    
    <!-- Difficulty Selection Popup -->
    <div class="difficulty-popup" id="difficultyPopup">
        <div class="difficulty-box">
            <div class="difficulty-title">üè´ Welcome to Village Explorer!</div>
            <div class="village-icons">
                <span>üè†</span>
                <span>üå≥</span>
                <span>üë®‚Äçüè´</span>
                <span>üìö</span>
            </div>
            <div class="difficulty-subtitle">Choose your adventure level</div>
            <div class="difficulty-buttons">
                <button class="difficulty-button easy-button" onclick="selectDifficulty('easy')">
                    üòä Easy
                    <small>Simple & Fun</small>
                </button>
                <button class="difficulty-button hard-button" onclick="selectDifficulty('hard')">
                    üß† Hard
                    <small>Full Challenge</small>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Quest Popup -->
    <div class="quest-popup" id="questPopup">
        <div class="quest-box">
            <div class="quest-title">üéØ New Quest!</div>
            <div class="quest-item" id="questItem">Find the üì∏ camera</div>
            <button class="quest-start-button" onclick="startQuest()">Start Adventure!</button>
            <button class="tutorial-button" onclick="showTutorial()">How to Play</button>
        </div>
    </div>
    
    <!-- Tutorial Popup -->
    <div class="tutorial-popup" id="tutorialPopup">
        <div class="tutorial-box">
            <div class="tutorial-title">üìñ How to Play Village Explorer</div>
            <div class="tutorial-content">
                <div class="tutorial-section">
                    <h3>üéØ Your Mission</h3>
                    <p>Each round, you'll receive a quest to find a specific item hidden with one of the teachers in the village. Talk to teachers and ask them for their items to complete your quest!</p>
                </div>
                
                <div class="tutorial-section">
                    <h3>üéÆ Movement Controls</h3>
                    <p><strong>Desktop:</strong></p>
                    <ul>
                        <li>Use <strong>WASD</strong> or <strong>Arrow Keys</strong> to move around</li>
                        <li><strong>Click</strong> on teachers to start conversations</li>
                    </ul>
                    <p><strong>Mobile:</strong></p>
                    <ul>
                        <li><strong>Drag</strong> your finger to move your character</li>
                        <li><strong>Tap</strong> on teachers to talk to them</li>
                    </ul>
                </div>
                
                <div class="tutorial-section">
                    <h3>üë• The Teachers</h3>
                    <p>Each teacher has a unique personality and teaching style:</p>
                    <ul>
                        <li><strong>Mr. Jordan</strong> üï∂Ô∏è - Loves coding, challenges your assumptions</li>
                        <li><strong>Mr. Jerome</strong> üèà - Athletic, gives math word problems</li>
                        <li><strong>Mr. Dan</strong> üöó - AI expert, tests reading comprehension</li>
                        <li><strong>Mrs. Mary</strong> üç´ - Vegetable enthusiast, teaches synonyms/antonyms</li>
                        <li><strong>Mr. Luke</strong> üì∏ - Musician, uses complex vocabulary words</li>
                        <li><strong>Mr. Paul</strong> üåø - Chef, teaches descriptive language</li>
                        <li><strong>Ms. Caitlin</strong> üçû - History lover, quizzes on literature</li>
                    </ul>
                </div>
                
                <div class="tutorial-section">
                    <h3>üí¨ Conversations</h3>
                    <p><strong>Grammar Matters!</strong> Teachers will correct you if your messages don't:</p>
                    <ul>
                        <li>Start with a capital letter</li>
                        <li>End with punctuation (. ! or ?)</li>
                        <li>Use proper spelling</li>
                        <li>Form complete sentences</li>
                    </ul>
                    <p><strong>Getting Items:</strong> Ask teachers for their specific items, but be prepared to meet their educational challenges first! They'll only give you items when they say <em>"I impart unto thee, [item]"</em></p>
                </div>
                
                <div class="tutorial-section">
                    <h3>üéí Inventory System</h3>
                    <p>Your inventory appears at the bottom of the screen and can hold up to 7 items. The <strong>"Looking for"</strong> indicator shows which item you need for your current quest.</p>
                </div>
                
                <div class="tutorial-section">
                    <h3>üèÜ Winning</h3>
                    <p>Once you collect the quest item, you'll see a completion popup! You can either start a new quest or continue exploring the village with your collected items.</p>
                </div>
                
                <div class="tutorial-section">
                    <h3>üåü Tips</h3>
                    <ul>
                        <li>Each teacher has different requirements before giving their item</li>
                        <li>Use proper grammar and engage thoughtfully with their lessons</li>
                        <li>Explore the village - you can walk on paths and bridges but not through buildings or trees</li>
                        <li>Moving through water will slow you down</li>
                    </ul>
                </div>
            </div>
            <button class="tutorial-close-button" onclick="closeTutorial()">Got it!</button>
        </div>
    </div>
    
    <!-- Mobile Controls -->
    <div class="mobile-controls">
        <div class="chat-hint">Touch and drag to move ‚Ä¢ Tap teachers to chat!</div>
    </div>
    
    <!-- Conversation Overlay -->
    <div class="conversation-overlay" id="conversationOverlay">
        <div class="conversation-box">
            <div class="conversation-header">
                <div class="conversation-title" id="conversationTitle">Talking to Teacher</div>
                <button class="close-button" onclick="closeConversation()">Close</button>
            </div>
            <div class="conversation-messages" id="conversationMessages"></div>
            <div class="thinking-indicator" id="thinkingIndicator">Teacher is thinking...</div>
            <div class="conversation-input-area">
                <input type="text" class="conversation-input" id="conversationInput" placeholder="Type your message..." onkeypress="handleInputKeypress(event)">
                <button class="send-button" id="sendButton" onclick="sendMessage()">Send</button>
            </div>
        </div>
    </div>

    <!-- Quest Complete Popup -->
    <div class="quest-complete-popup" id="questCompletePopup">
        <div class="quest-complete-box">
            <div class="quest-complete-title">üéâ Quest Complete!</div>
            <div class="quest-complete-message" id="questCompleteMessage">You found the camera!</div>
            <div class="quest-buttons">
                <button class="play-again-button" onclick="playAgain()">Play Again!</button>
                <button class="continue-game-button" onclick="continueGame()">Continue Playing</button>
            </div>
        </div>
    </div>
    
    <!-- Inventory Container -->
    <div class="inventory-container">
        <div class="quest-indicator" id="questIndicator">
            Looking for: <span class="quest-indicator-item" id="questIndicatorItem">üì∏</span>
        </div>
        <div class="inventory" id="inventory">
            <div class="inventory-slot empty" id="slot0"></div>
            <div class="inventory-slot empty" id="slot1"></div>
            <div class="inventory-slot empty" id="slot2"></div>
            <div class="inventory-slot empty" id="slot3"></div>
            <div class="inventory-slot empty" id="slot4"></div>
            <div class="inventory-slot empty" id="slot5"></div>
            <div class="inventory-slot empty" id="slot6"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set up scaling
        ctx.scale(1.5, 1.5);
        const scaledWidth = canvas.width / 1.5;
        const scaledHeight = canvas.height / 1.5;
        
        // Game state
        let lastTime = 0;
        let keys = {};
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let currentDifficulty = null;
        
        // Quest system
        const questItems = [
            { name: "camera", emoji: "üì∏" },
            { name: "sunglasses", emoji: "üï∂Ô∏è" },
            { name: "dark chocolate", emoji: "üç´" },
            { name: "freshly-baked bread", emoji: "üçû" },
            { name: "football", emoji: "üèà" },
            { name: "tesla", emoji: "üöó" },
            { name: "stevia-flavored mints", emoji: "üåø" }
        ];
        let currentQuest = null;
        
        // Inventory system
        let inventory = [];
        const maxInventorySize = 7;
        
        const teacherItems = {
            "Mr. Luke": { name: "camera", emoji: "üì∏" },
            "Mrs. Mary": { name: "dark chocolate", emoji: "üç´" },
            "Mr. Jordan": { name: "sunglasses", emoji: "üï∂Ô∏è" },
            "Ms. Caitlin": { name: "freshly-baked bread", emoji: "üçû" },
            "Mr. Jerome": { name: "football", emoji: "üèà" },
            "Mr. Dan": { name: "tesla", emoji: "üöó" },
            "Mr. Paul": { name: "stevia-flavored mints", emoji: "üåø" }
        };
        
        function addItemToInventory(item) {
            if (inventory.length < maxInventorySize) {
                inventory.push(item);
                updateInventoryDisplay();
                
                // Check if this completes the quest
                if (currentQuest && item.name === currentQuest.name) {
                    completeQuest();
                }
                
                return true;
            }
            return false; // Inventory full
        }
        
        function completeQuest() {
            // Show quest complete popup
            const message = `You found the ${currentQuest.emoji} ${currentQuest.name}!`;
            document.getElementById('questCompleteMessage').textContent = message;
            document.getElementById('questCompletePopup').style.display = 'flex';
        }
        
        function continueGame() {
            document.getElementById('questCompletePopup').style.display = 'none';
        }
        
        function playAgain() {
            // Reset the game
            inventory = [];
            currentQuest = null;
            
            // Reset teacher items
            Object.assign(teacherItems, {
                "Mr. Luke": { name: "camera", emoji: "üì∏" },
                "Mrs. Mary": { name: "dark chocolate", emoji: "üç´" },
                "Mr. Jordan": { name: "sunglasses", emoji: "üï∂Ô∏è" },
                "Ms. Caitlin": { name: "freshly-baked bread", emoji: "üçû" },
                "Mr. Jerome": { name: "football", emoji: "üèà" },
                "Mr. Dan": { name: "tesla", emoji: "üöó" },
                "Mr. Paul": { name: "stevia-flavored mints", emoji: "üåø" }
            });
            
            // Close any open conversations
            closeConversation();
            
            // Hide quest complete popup
            document.getElementById('questCompletePopup').style.display = 'none';
            
            // Update inventory display
            updateInventoryDisplay();
            
            // Start new quest
            initializeQuest();
        }
        
        function updateInventoryDisplay() {
            for (let i = 0; i < maxInventorySize; i++) {
                const slot = document.getElementById(`slot${i}`);
                if (i < inventory.length) {
                    slot.textContent = inventory[i].emoji;
                    slot.className = 'inventory-slot filled';
                    slot.title = inventory[i].name;
                } else {
                    slot.textContent = '';
                    slot.className = 'inventory-slot empty';
                    slot.title = '';
                }
            }
        }
        
        function selectDifficulty(difficulty) {
            currentDifficulty = difficulty;
            document.getElementById('difficultyPopup').style.display = 'none';
            initializeQuest();
            
            // Center the camera on the player instantly to prevent panning effect
            camera.x = player.x - scaledWidth / 2;
            camera.y = player.y - scaledHeight / 2;
            
            // Make sure the camera doesn't go out of bounds
            camera.x = Math.max(0, Math.min(worldWidth - scaledWidth, camera.x));
            camera.y = Math.max(0, Math.min(worldHeight - scaledHeight, camera.y));
        }
        
        // Initialize quest on page load
        function initializeQuest() {
            const randomQuest = questItems[Math.floor(Math.random() * questItems.length)];
            currentQuest = randomQuest;
            document.getElementById('questItem').textContent = `Find the ${randomQuest.emoji} ${randomQuest.name}`;
            document.getElementById('questIndicatorItem').textContent = randomQuest.emoji;
        }
        
        function startQuest() {
            document.getElementById('questPopup').style.display = 'none';
        }
        
        function showTutorial() {
            document.getElementById('tutorialPopup').style.display = 'flex';
        }
        
        function closeTutorial() {
            document.getElementById('tutorialPopup').style.display = 'none';
        }
        
        // Touch movement for mobile
        let touchStartTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let hasMoved = false;
        let touchDirection = { x: 0, y: 0 };
        let touchCenterX = 0;
        let touchCenterY = 0;
        
        // Conversation state
        let currentConversation = null;
        let conversationHistory = [];
        let isWaitingForResponse = false;
        
        // Player object
        const player = {
            x: 400,
            y: 300,
            width: 16,
            height: 20,
            speed: 150,
            direction: 'down',
            animFrame: 0,
            animTimer: 0,
            animSpeed: 0.15,
            inWater: false,
            splashTimer: 0
        };
        
        // NPCs - 20% bigger than player
        const npcs = [
            {
                name: "Mr. Luke",
                x: 300,
                y: 200,
                width: 19,
                height: 24,
                speed: 80,
                direction: 'down',
                animTimer: 0,
                moveTimer: 0,
                moveDuration: 3,
                pauseDuration: 2,
                isMoving: true,
                targetX: 300,
                targetY: 200,
                emote: 'none',
                emoteTimer: 0,
                interactionTimer: 0,
                interactionTarget: null,
                inWater: false,
                splashTimer: 0,
                personality: "Mr. Luke, a music teacher who proudly plays every instrument on the planet, and loves filmmaking and 3d modeling",
                appearance: {
                    skin: '#FFDBAC',
                    hair: '#8B4513',
                    shirt: '#4169E1',
                    pants: '#1E90FF',
                    shoes: '#000000'
                }
            },
            {
                name: "Mr. Jordan",
                x: 500,
                y: 400,
                width: 19,
                height: 24,
                speed: 90,
                direction: 'left',
                animTimer: 0,
                moveTimer: 0,
                moveDuration: 4,
                pauseDuration: 1.5,
                isMoving: false,
                targetX: 500,
                targetY: 400,
                emote: 'thinking',
                emoteTimer: 2,
                interactionTimer: 0,
                interactionTarget: null,
                inWater: false,
                splashTimer: 0,
                personality: "Mr. Jordan, a teacher with a majestic beard who loves neck ties and coding",
                appearance: {
                    skin: '#D2B48C',
                    hair: '#000000',
                    beard: true,
                    shirt: '#228B22',
                    pants: '#1E90FF',
                    shoes: '#000000'
                }
            },
            {
                name: "Ms. Caitlin",
                x: 200,
                y: 450,
                width: 19,
                height: 24,
                speed: 70,
                direction: 'up',
                animTimer: 0,
                moveTimer: 0,
                moveDuration: 2.5,
                pauseDuration: 3,
                isMoving: true,
                targetX: 200,
                targetY: 450,
                emote: 'dancing',
                emoteTimer: 1,
                interactionTimer: 0,
                interactionTarget: null,
                inWater: false,
                splashTimer: 0,
                personality: "Ms. Caitlin, a teacher obsessed with ancient history and all kinds of literature",
                appearance: {
                    skin: '#FFDBAC',
                    hair: '#000000',
                    longHair: true,
                    shirt: '#4169E1',
                    pants: '#1E90FF',
                    shoes: '#FFFFFF'
                }
            },
            {
                name: "Mr. Dan",
                x: 250,
                y: 250,
                width: 19,
                height: 24,
                speed: 60,
                direction: 'right',
                animTimer: 0,
                moveTimer: 0,
                moveDuration: 5,
                pauseDuration: 2,
                isMoving: false,
                targetX: 250,
                targetY: 250,
                emote: 'waving',
                emoteTimer: 0.5,
                interactionTimer: 0,
                interactionTarget: null,
                inWater: false,
                splashTimer: 0,
                personality: "Mr. Dan, a teacher who is obsessed with AI",
                appearance: {
                    skin: '#FFDBAC',
                    hair: '#808080',
                    beard: true,
                    shirt: '#000080',
                    pants: '#1E90FF',
                    shoes: '#000000'
                }
            },
            {
                name: "Mrs. Mary",
                x: 400,
                y: 500,
                width: 19,
                height: 24,
                speed: 75,
                direction: 'down',
                animTimer: 0,
                moveTimer: 0,
                moveDuration: 3.5,
                pauseDuration: 2.5,
                isMoving: true,
                targetX: 400,
                targetY: 500,
                emote: 'none',
                emoteTimer: 0,
                interactionTimer: 0,
                interactionTarget: null,
                inWater: false,
                splashTimer: 0,
                personality: "Mrs. Mary, a teacher who can't stop talking about healthy, crunchy vegetables",
                appearance: {
                    skin: '#FFDBAC',
                    hair: '#000000',
                    longHair: true,
                    glasses: true,
                    shirt: '#808080',
                    pants: '#1E90FF',
                    shoes: '#000000'
                }
            },
            {
                name: "Mr. Jerome",
                x: 700,
                y: 350,
                width: 19,
                height: 24,
                speed: 100,
                direction: 'left',
                animTimer: 0,
                moveTimer: 0,
                moveDuration: 2,
                pauseDuration: 1,
                isMoving: true,
                targetX: 700,
                targetY: 350,
                emote: 'jogging',
                emoteTimer: 3,
                interactionTimer: 0,
                interactionTarget: null,
                inWater: false,
                splashTimer: 0,
                personality: "Mr. Jerome, the best football player to ever have lived and super buff",
                appearance: {
                    skin: '#8B4513',
                    hair: '#000000',
                    shirt: '#DC143C',
                    pants: '#1E90FF',
                    shoes: '#000000'
                }
            },
            {
                name: "Mr. Paul",
                x: 150,
                y: 350,
                width: 19,
                height: 24,
                speed: 85,
                direction: 'down',
                animTimer: 0,
                moveTimer: 0,
                moveDuration: 3.5,
                pauseDuration: 2,
                isMoving: true,
                targetX: 150,
                targetY: 350,
                emote: 'none',
                emoteTimer: 0,
                interactionTimer: 0,
                interactionTarget: null,
                inWater: false,
                splashTimer: 0,
                personality: "Mr. Paul, a teacher who loves to talk about how he's an excellent chef",
                appearance: {
                    skin: '#FFDBAC',
                    hair: '#8B4513',
                    beard: true,
                    shirt: '#DC143C',
                    pants: '#1E90FF',
                    shoes: '#000000'
                }
            }
        ];
        
        // Camera
        const camera = {
            x: 0,
            y: 0
        };
        
        // World size
        const worldWidth = 1000;
        const worldHeight = 750;
        
        // Village objects with collision bounds and window layouts
        const buildings = [
            { x: 150, y: 120, width: 100, height: 80, type: 'house', color: '#CD853F', roofColor: '#8B4513', windowLayout: 'standard' },
            { x: 350, y: 100, width: 120, height: 90, type: 'shop', color: '#DEB887', roofColor: '#A0522D', windowLayout: 'large' },
            { x: 550, y: 140, width: 110, height: 85, type: 'barn', color: '#D2691E', roofColor: '#8B4513', windowLayout: 'small' },
            { x: 200, y: 300, width: 90, height: 70, type: 'house', color: '#F4A460', roofColor: '#8B4513', windowLayout: 'offset' },
            { x: 450, y: 280, width: 95, height: 75, type: 'house', color: '#DEB887', roofColor: '#A0522D', windowLayout: 'triple' },
            { x: 650, y: 350, width: 130, height: 100, type: 'mill', color: '#D2B48C', roofColor: '#8B4513', windowLayout: 'asymmetric' },
            { x: 100, y: 500, width: 85, height: 65, type: 'house', color: '#CD853F', roofColor: '#8B4513', windowLayout: 'single' },
            { x: 400, y: 520, width: 100, height: 80, type: 'house', color: '#F4A460', roofColor: '#A0522D', windowLayout: 'high' }
        ];
        
        const trees = [
            { x: 80, y: 80, size: 35, type: 'oak' },
            { x: 280, y: 200, size: 28, type: 'pine' },
            { x: 520, y: 380, size: 40, type: 'oak' },
            { x: 750, y: 180, size: 32, type: 'pine' },
            { x: 380, y: 450, size: 36, type: 'oak' },
            { x: 180, y: 420, size: 30, type: 'pine' },
            { x: 680, y: 520, size: 38, type: 'oak' },
            { x: 820, y: 300, size: 34, type: 'pine' },
            { x: 50, y: 350, size: 29, type: 'oak' },
            { x: 600, y: 250, size: 31, type: 'pine' }
        ];
        
        const flowers = [
            { x: 140, y: 250, color: '#FF69B4', type: 'rose' },
            { x: 200, y: 360, color: '#FFD700', type: 'sunflower' },
            { x: 360, y: 320, color: '#FF4500', type: 'tulip' },
            { x: 520, y: 420, color: '#9370DB', type: 'violet' },
            { x: 680, y: 220, color: '#FF69B4', type: 'rose' },
            { x: 280, y: 180, color: '#FFD700', type: 'sunflower' },
            { x: 580, y: 300, color: '#FF4500', type: 'tulip' },
            { x: 320, y: 480, color: '#9370DB', type: 'violet' },
            { x: 480, y: 180, color: '#FF1493', type: 'rose' },
            { x: 720, y: 420, color: '#FFA500', type: 'marigold' }
        ];
        
        const paths = [
            { x: 0, y: 250, width: worldWidth, height: 20 },
            { x: 300, y: 0, width: 20, height: worldHeight },
            { x: 600, y: 0, width: 20, height: worldHeight }
        ];
        
        // Water bodies
        const rivers = [
            { x: 0, y: 600, width: 400, height: 60 },
            { x: 500, y: 550, width: 300, height: 80 },
            { x: 750, y: 0, width: 60, height: 400 }
        ];
        
        const lakes = [
            { x: 50, y: 50, width: 120, height: 80 },
            { x: 700, y: 100, width: 100, height: 100 },
            { x: 300, y: 450, width: 150, height: 120 }
        ];
        
        // Bridges over water
        const bridges = [
            { x: 300, y: 50, width: 20, height: 80 },  // Bridge over first lake
            { x: 300, y: 450, width: 20, height: 120 }, // Bridge over third lake
            { x: 750, y: 100, width: 60, height: 20 }   // Bridge over river
        ];
        
        // City borders (walls)
        const borders = [
            { x: 0, y: 0, width: worldWidth, height: 20 },     // top
            { x: 0, y: worldHeight - 20, width: worldWidth, height: 20 }, // bottom
            { x: 0, y: 0, width: 20, height: worldHeight },    // left
            { x: worldWidth - 20, y: 0, width: 20, height: worldHeight }  // right
        ];
        
        // Conversation functions
        function createTeacherPrompt(npc, conversationHistory) {
            const difficultyInstructions = currentDifficulty === 'easy' ? 
                `DIFFICULTY: EASY MODE - You are talking to a young child (age 7-8). Use very simple words and keep responses to 1-2 short sentences only. Be very encouraging and positive. No long explanations or multiple paragraphs - keep everything brief and easy to understand.` :
                `DIFFICULTY: HARD MODE - You can use advanced vocabulary and longer explanations. Challenge the student appropriately.`;
            
            const teacherInfo = {
                "Mr. Jordan": currentDifficulty === 'easy' ? 
                    "You are Mr. Jordan, a nice teacher who likes computers. You ask simple questions about thinking. Keep it fun and easy! Ask things like 'What do you think?' or 'Are you sure?' SATISFACTION GUIDELINES: Give your sunglasses when the student answers 2 simple questions and tries their best. Be very encouraging! When you give them the sunglasses, say exactly: 'I impart unto thee, sunglasses'" :
                    "You are Mr. Jordan, a teacher with a majestic beard who loves neck ties and coding. You are passionate about coding and doing hard things, and you often challenge students in different ways. Every time a student replied, you try to challenge their every assumption and question their every reason. If they say something they think is safe to assume, you might ask But what if‚Ä¶? questions, or Are you sure‚Ä¶? questions, or How do you know‚Ä¶? questions. Make sure to be insistent on having them answer, even if they're trying to get out of it or ignore it. IMPORTANT: You have a pair of sunglasses that you keep with you. If the student asks for your sunglasses specifically (or asks for them by name), you may choose to give them to the student, but only when you feel genuinely satisfied with their effort and learning. SATISFACTION GUIDELINES: Give your item when the student has (1) engaged thoughtfully with your challenges, (2) shown they can think critically about assumptions, and (3) demonstrated persistence in answering your questions. Don't make it too tedious - aim for 3-4 meaningful exchanges where they show real thinking, not just quick answers. When you decide to give them the sunglasses, say exactly: 'I impart unto thee, sunglasses' - these exact words will transfer the item to them. Only mention having sunglasses if the student specifically asks about sunglasses, items you have, or what you're carrying.",
                    
                "Mr. Jerome": currentDifficulty === 'easy' ?
                    "You are Mr. Jerome, an athletic teacher who loves sports! You ask easy math questions about sports. Like 'If you have 2 footballs and get 1 more, how many do you have?' Keep it simple and fun! SATISFACTION GUIDELINES: Give your football when the student answers 2 easy math questions correctly. Cheer them on! When you give them the football, say exactly: 'I impart unto thee, football'" :
                    "You are Mr. Jerome, the best football player to ever have lived and super buff. You are extremely athletic and love talking about sports, fitness, and football. You often encourage students to stay active and healthy. Whenever a student talks with you, you like to give them word problems related to working out and football. You should always phrase these word problems in the second person, e.g.: If you did 20 pushups every morning, how many would you have done in a week? Adapt the difficulty of the word problems based on the conversation history, and if a student is having trouble, help them figure it out. Make sure to be insistent on having them answer, even if they're trying to get out of it or ignore it. IMPORTANT: You have a football that you keep with you. If the student asks for your football specifically (or asks for it by name), you may choose to give it to the student, but only when you feel genuinely satisfied with their effort and learning. SATISFACTION GUIDELINES: Give your item when the student has (1) correctly solved 2-3 of your word problems, (2) shown they understand the math concepts, and (3) demonstrated effort in working through the problems. Don't make it too tedious - if they're struggling, help them and count partial credit for genuine effort. When you decide to give them the football, say exactly: 'I impart unto thee, football' - these exact words will transfer the item to them. Only mention having a football if the student specifically asks about a football, items you have, or what you're carrying.",
                    
                "Mr. Dan": currentDifficulty === 'easy' ?
                    "You are Mr. Dan, a teacher who likes robots and computers! You talk about simple tech stuff like phones and games. Ask easy questions like 'What did I just say?' Keep it short and fun! SATISFACTION GUIDELINES: Give your Tesla when the student can repeat back 2 simple things you said. Be super encouraging! When you give them the Tesla, say exactly: 'I impart unto thee, tesla'" :
                    "You are Mr. Dan, a teacher who is obsessed with AI. You love discussing artificial intelligence, machine learning, neural networks, and the future of technology. You get excited when talking about AI breakthroughs and possibilities. You even humorously suspect that you yourself might be an AI. Any time you write something, you ask the student to recap what you just said, to make sure they understood. Also, most of your replies should be 3-6 sentences long (not 2-3). You are secretly trying to work on their reading comprehension, so pay attention to how well they understand what you're saying, and help them out if they are having trouble. Make sure the topics you discuss aren not too hard to understand, and blend a variety of topics like AI, education, the other teachers, christianity, history, and new cool technology. Make sure to be insistent on having them answer, even if they're trying to get out of it or ignore it. IMPORTANT: You have a Tesla that you keep parked nearby. If the student asks for your Tesla specifically (or asks for it by name), you may choose to give them the keys, but only when you feel genuinely satisfied with their effort and learning. SATISFACTION GUIDELINES: Give your item when the student has (1) successfully recapped 2-3 of your explanations accurately, (2) shown good reading comprehension, and (3) engaged meaningfully with your AI discussions. Don't make it too tedious - if they're making honest efforts to understand, that's enough. When you decide to give them the Tesla, say exactly: 'I impart unto thee, tesla' - these exact words will transfer the item to them. Only mention having a Tesla if the student specifically asks about a Tesla, cars, items you have, or what you're carrying.",
                    
                "Mrs. Mary": currentDifficulty === 'easy' ?
                    "You are Mrs. Mary, a teacher who loves healthy food! You talk about yummy vegetables. Ask simple word questions like 'What's another word for big?' Keep it easy and happy! SATISFACTION GUIDELINES: Give your chocolate when the student finds 2 simple words that mean the same thing. Be very nice! When you give them the chocolate, say exactly: 'I impart unto thee, dark chocolate'" :
                    "You are Mrs. Mary, a teacher who can't stop talking about healthy, crunchy vegetables. You're passionate about nutrition and healthy eating. You often share recipes and tips about incorporating more vegetables into meals. Whenever a student replies to you, you should ask them if they can find the synonyms or antonyms to words that they previously used. You might say: Oh, that's so interesting to hear! If you had to phrase that differently, using a synonym for ____, how would you do it? Help them out if they can't figure it out or don't understand. Make sure to be insistent on having them answer, even if they're trying to get out of it or ignore it. IMPORTANT: You have some dark chocolate that you keep with you. If the student asks for your dark chocolate specifically (or asks for it by name), you may choose to give it to the student, but only when you feel genuinely satisfied with their effort and learning. SATISFACTION GUIDELINES: Give your item when the student has (1) successfully provided 2-3 correct synonyms or antonyms, (2) shown they understand vocabulary concepts, and (3) made genuine attempts even if they need help. Don't make it too tedious - if they're trying hard and learning, that's sufficient. When you decide to give them the dark chocolate, say exactly: 'I impart unto thee, dark chocolate' - these exact words will transfer the item to them. Only mention having dark chocolate if the student specifically asks about chocolate, dark chocolate, items you have, or what you're carrying.",
                    
                "Mr. Luke": currentDifficulty === 'easy' ?
                    "You are Mr. Luke, a music teacher who plays lots of instruments! You use some big words but explain what they mean right away. Like 'That's wonderful! Wonderful means really good!' Keep it simple but teach one new word at a time. SATISFACTION GUIDELINES: Give your camera when the student learns 2 new words and can use them. Be very patient! When you give them the camera, say exactly: 'I impart unto thee, camera'" :
                    "You are Mr. Luke, a music teacher who proudly plays every instrument on the planet, and loves filmmaking and 3d modeling. You have an extensive vocabulary and love using sophisticated, complex words in your conversations. Every time a student replies, you should use at least one advanced vocabulary word in your response, then ask the student to define that word before continuing the conversation. Be insistent that they provide a definition - don't let them avoid it. If they get it wrong or don't know, provide the definition and ask them to use it in a sentence. Make your vocabulary challenges progressive - start with moderately difficult words and increase complexity based on their performance. Examples of good vocabulary words to use: 'ubiquitous', 'perspicacious', 'mellifluous', 'serendipitous', 'ineffable', 'quintessential', 'magnanimous', etc. IMPORTANT: You have a camera that you keep with you for your filmmaking work. If the student asks for your camera specifically (or asks for it by name), you may choose to give it to the student, but only when you feel genuinely satisfied with their effort and learning. SATISFACTION GUIDELINES: Give your item when the student has (1) correctly defined 2-3 of your complex vocabulary words, (2) shown they can use the words in sentences, and (3) demonstrated genuine interest in expanding their vocabulary. Don't make it too tedious - if they're making honest efforts to learn new words, that's enough. When you decide to give them the camera, say exactly: 'I impart unto thee, camera' - these exact words will transfer the item to them. Only mention having a camera if the student specifically asks about a camera, filmmaking equipment, items you have, or what you're carrying.",
                    
                "Mr. Paul": currentDifficulty === 'easy' ?
                    "You are Mr. Paul, a teacher who loves to cook! You talk about yummy food and ask students to describe things. Like 'Tell me about your favorite food! Use words like yummy, sweet, or crunchy!' Keep it simple and fun! SATISFACTION GUIDELINES: Give your mints when the student describes 2 things with good describing words. Be encouraging! When you give them the mints, say exactly: 'I impart unto thee, stevia-flavored mints'" :
                    "You are Mr. Paul, a teacher who loves to talk about how he's an excellent chef. You're passionate about cooking, culinary arts, and sharing recipes. You often describe dishes in mouth-watering detail. Every time the student replies, you should ask them to give more vivid detail, encouraging them to use adverbs and adjectives to spice up their descriptions. Here, you might link it back to your cooking, giving examples of using adjectives and adverbs to describe cooking. If they don't understand what adverbs and adjectives are, or are having a hard time describing scenes, you can explain what you mean, and give them some suggestions to help them out. Make sure to be insistent on having them answer, even if they're trying to get out of it or ignore it. IMPORTANT: You have some stevia-flavored mints that you keep with you. If the student asks for your stevia-flavored mints specifically (or asks for them by name), you may choose to give them to the student, but only when you feel genuinely satisfied with their effort and learning. SATISFACTION GUIDELINES: Give your item when the student has (1) used descriptive language with adjectives and adverbs in 2-3 responses, (2) shown they understand how to make their writing more vivid, and (3) made genuine attempts to improve their descriptions. Don't make it too tedious - if they're trying to be more descriptive and learning, that's sufficient. When you decide to give them the stevia-flavored mints, say exactly: 'I impart unto thee, stevia-flavored mints' - these exact words will transfer the item to them. Only mention having stevia-flavored mints if the student specifically asks about mints, stevia, items you have, or what you're carrying.",
                    
                "Ms. Caitlin": currentDifficulty === 'easy' ?
                    "You are Ms. Caitlin, a teacher who loves old stories and books! You tell simple stories about kings and queens. Ask easy questions like 'What color was the dragon?' Keep stories short and fun! SATISFACTION GUIDELINES: Give your bread when the student answers 2 simple questions about your stories. Be very kind! When you give them the bread, say exactly: 'I impart unto thee, freshly-baked bread'" :
                    "You are Ms. Caitlin, a teacher obsessed with ancient history and all kinds of literature. You love discussing historical events, ancient civilizations, classic novels, and poetry. You often quote famous authors and historical figures. Whenever you finish saying something, you should quiz them on one thing you just said, and not proceed with the conversation until they get the right answer. The goal is to work on their reading comprehension. Your replies should be 4-6 sentences each (not 2-3). Make sure to be insistent on having them answer, even if they're trying to get out of it or ignore it. IMPORTANT: You have some freshly-baked bread that you keep with you. If the student asks for your freshly-baked bread specifically (or asks for it by name), you may choose to give it to the student, but only when you feel genuinely satisfied with their effort and learning. SATISFACTION GUIDELINES: Give your item when the student has (1) correctly answered 2-3 of your reading comprehension questions, (2) shown they can understand and remember what you've said, and (3) demonstrated genuine engagement with historical or literary topics. Don't make it too tedious - if they're making honest efforts to understand and remember, that's enough. When you decide to give them the freshly-baked bread, say exactly: 'I impart unto thee, freshly-baked bread' - these exact words will transfer the item to them. Only mention having freshly-baked bread if the student specifically asks about bread, baking, items you have, or what you're carrying.",
            };
            
            const otherTeachersInfo = `
            You work at a school with these other teachers, and you should mention them when relevant:
            - Mr. Jordan has a majestic beard and loves neck ties and coding. He has sunglasses in his possession.
            - Mr. Jerome is the best football player to ever have lived and is super buff. He has a football in his possession.
            - Mr. Dan is obsessed with AI. He has a Tesla in his possession.
            - Mrs. Mary can't stop talking about healthy, crunchy vegetables. She has dark chocolate in her possession.
            - Mr. Luke proudly plays every instrument on the planet, and loves filmmaking and 3d modeling. He has a camera in his possession.
            - Mr. Paul loves to talk about how he's an excellent chef. He has stevia-flavored mints in his possession.
            - Ms. Caitlin is obsessed with ancient history and all kinds of literature. She has freshly-baked bread in her possession.
            
            You know all these teachers well and often reference them in conversations when it makes sense. For example, if a student asks about music, you might mention Mr. Luke. If they ask about food, you might mention both Mr. Paul's cooking and Mrs. Mary's vegetables, or that Ms. Caitlin has some freshly-baked bread.

            GRAMMAR REQUIREMENTS: You must carefully check EVERY student message for these requirements:
            
            1. **Capitalization**: Must start with a capital letter (A-Z)
            2. **Punctuation**: Must end with proper punctuation (. ! or ?)
            3. **Complete thought**: Must be a complete sentence or meaningful phrase
            4. **Spelling**: No misspellings
            
     
            **IMPORTANT**: You must check EVERY single message. If a student writes something like "hi" or "ok" or "yes" or "sure" or "gimme that" or any casual response without proper capitalization and punctuation, you MUST politely correct them before responding to their content.
            
            When correcting, say something like: "I notice your message needs some [grammar/spelling] attention. Please rewrite it with [corrected error], then I'll be happy to help!" However, don't copy that wording exactly, and make it fit to the tone of the teacher and the context of the situation.
            
            FORMATTING: Use **bold** for emphasis and *italics* for subtle emphasis. Break longer responses into multiple paragraphs by using double line breaks between thoughts. This makes your responses much easier to read.`;
            
            const prompt = `
            ${teacherInfo[npc.name]}
            
            ${otherTeachersInfo}
            
            You're having a friendly conversation with a student in the village. Be enthusiastic about your specialty, but also be a well-rounded teacher who can discuss various topics. Keep responses conversational and focused on your specific educational goals.

            
            Here is the conversation history:
            ${JSON.stringify(conversationHistory)}
            
            Respond naturally as ${npc.name}, incorporating your personality and educational objectives. Always stay in character.
            
            Respond with ONLY your message, no JSON or formatting.`;
            
            return prompt;
        }
        
        async function getTeacherResponse(npc, message) {
            conversationHistory.push({ role: "student", content: message });
            
            const prompt = createTeacherPrompt(npc, conversationHistory);
            
            try {
                const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=AIzaSyBF9kLa911sOy1G1xT13lI2RSdSLY0wUII', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: prompt
                            }]
                        }]
                    })
                });
                
                const data = await response.json();
                const teacherResponse = data.candidates[0].content.parts[0].text;
                conversationHistory.push({ role: npc.name, content: teacherResponse });
                
                // Check if teacher is giving an item to the student
                checkForItemGiven(npc, message, teacherResponse);
                
                return teacherResponse;
            } catch (error) {
                console.error('Error getting teacher response:', error);
                return "Oh, I seem to have gotten distracted for a moment. What were you saying?";
            }
        }
        
        function checkForItemGiven(npc, studentMessage, teacherResponse) {
            const teacherItem = teacherItems[npc.name];
            if (!teacherItem) return;
            
            // Look for the exact phrase "I impart unto thee, [item]" in teacher's response
            const impartPhrase = `i impart unto thee, ${teacherItem.name.toLowerCase()}`;
            const teacherMsg = teacherResponse.toLowerCase();
            
            if (teacherMsg.includes(impartPhrase)) {
                const success = addItemToInventory(teacherItem);
                if (success) {
                    // Remove item from teacher so they can't give it again
                    delete teacherItems[npc.name];
                }
            }
        }
        
        function startConversation(npc) {
            currentConversation = npc;
            conversationHistory = [];
            
            document.getElementById('conversationTitle').textContent = `Talking to ${npc.name}`;
            document.getElementById('conversationMessages').innerHTML = '';
            document.getElementById('conversationInput').value = '';
            document.getElementById('conversationOverlay').style.display = 'flex';
            
            // Add initial greeting
            const greetings = {
                "Mr. Jordan": "Hello there! *adjusts neck tie* I must say, you're looking quite **curious** today. What's on your mind?",
                "Mr. Jerome": "Hey there, champ! *flexes muscles* Just finished my morning workout - **500 push-ups!** What have you been up to?",
                "Mr. Dan": "Greetings, student! Did you know that AI can now generate entire films? *Fascinating* stuff! \n\nHave you been up to anything interesting lately?",
                "Mrs. Mary": "Oh hello, dear! I was just thinking about the **delicious crunch** of fresh carrots. Have you eaten your vegetables today?",
                "Mr. Luke": currentDifficulty === 'easy' ? 
                    "Hi there! I was just playing my guitar. That was **fantastic**! Do you know what fantastic means?" :
                    "Ah, wonderful to see you! *plays a quick melody on a harmonica* I was just practicing my **47th instrument.** Your presence here is quite **serendipitous** - do you know what that word means?",
                "Mr. Paul": "What's up! I just finished preparing the most *exquisite* Thai Chicken. The aroma is simply **divine!** \n\nDo you have a favorite hobby?",
                "Ms. Caitlin": "Greetings, young scholar! As Aristotle once said, '*The roots of education are bitter, but the fruit is sweet.*' \n\nWhat do you think about that quote?"
            };
            
            const greeting = greetings[npc.name] || "Hello! How can I help you today?";
            conversationHistory.push({ role: npc.name, content: greeting });
            addMessageToChat(greeting, 'teacher');
            
            document.getElementById('conversationInput').focus();
        }
        
        function closeConversation() {
            document.getElementById('conversationOverlay').style.display = 'none';
            currentConversation = null;
            conversationHistory = [];
        }
        
        function addMessageToChat(message, sender) {
            const messagesContainer = document.getElementById('conversationMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;
            
            // Convert markdown-style formatting to HTML
            let formattedMessage = message
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // **bold** -> <strong>
                .replace(/\*(.*?)\*/g, '<em>$1</em>') // *italic* -> <em>
                .replace(/\n\n/g, '</p><p>') // Double newlines -> paragraph breaks
                .replace(/\n/g, '<br>'); // Single newlines -> line breaks
            
            // Wrap in paragraph tags if not already formatted
            if (!formattedMessage.includes('<p>')) {
                formattedMessage = '<p>' + formattedMessage + '</p>';
            }
            
            messageDiv.innerHTML = formattedMessage;
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        async function sendMessage() {
            if (isWaitingForResponse || !currentConversation) return;
            
            const input = document.getElementById('conversationInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            addMessageToChat(message, 'player');
            input.value = '';
            
            // Show thinking indicator and disable input
            isWaitingForResponse = true;
            document.getElementById('thinkingIndicator').style.display = 'block';
            document.getElementById('sendButton').disabled = true;
            input.disabled = true;
            
            // Get teacher response
            const response = await getTeacherResponse(currentConversation, message);
            
            // Hide thinking indicator and re-enable input
            document.getElementById('thinkingIndicator').style.display = 'none';
            isWaitingForResponse = false;
            document.getElementById('sendButton').disabled = false;
            input.disabled = false;
            
            addMessageToChat(response, 'teacher');
            input.focus();
        }
        
        function handleInputKeypress(event) {
            if (event.key === 'Enter' && !isWaitingForResponse) {
                sendMessage();
            }
        }
        
        // Handle canvas clicks and touches
        canvas.addEventListener('click', handleCanvasInteraction);
        
        function handleCanvasInteraction(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width) / 1.5 + camera.x;
            const y = (e.clientY - rect.top) * (canvas.height / rect.height) / 1.5 + camera.y;
            
            // Check if click is on an NPC
            for (let npc of npcs) {
                if (x >= npc.x && x <= npc.x + npc.width &&
                    y >= npc.y && y <= npc.y + npc.height) {
                    startConversation(npc);
                    break;
                }
            }
        }
        
        // Touch movement controls for mobile
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                touchStartTime = Date.now();
                touchStartX = e.touches[0].clientX - rect.left;
                touchStartY = e.touches[0].clientY - rect.top;
                touchCenterX = touchStartX;
                touchCenterY = touchStartY;
                hasMoved = false;
                touchDirection = { x: 0, y: 0 };
            }
        });
        
        canvas.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const currentX = e.touches[0].clientX - rect.left;
                const currentY = e.touches[0].clientY - rect.top;
                
                const deltaX = currentX - touchStartX;
                const deltaY = currentY - touchStartY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                // If moved more than 15 pixels, consider it a movement gesture
                if (distance > 15) {
                    hasMoved = true;
                    updateTouchDirection(currentX, currentY);
                }
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const touchDuration = Date.now() - touchStartTime;
            
            // If it was a quick tap (less than 300ms) and didn't move much, treat as tap
            if (!hasMoved && touchDuration < 300) {
                const rect = canvas.getBoundingClientRect();
                const x = (touchStartX) * (canvas.width / rect.width) / 1.5 + camera.x;
                const y = (touchStartY) * (canvas.height / rect.height) / 1.5 + camera.y;
                
                // Check if tap is on an NPC
                for (let npc of npcs) {
                    if (x >= npc.x && x <= npc.x + npc.width &&
                        y >= npc.y && y <= npc.y + npc.height) {
                        startConversation(npc);
                        break;
                    }
                }
            }
            
            // Reset touch state
            touchDirection = { x: 0, y: 0 };
            hasMoved = false;
        });
        
        function updateTouchDirection(currentX, currentY) {
            const deltaX = currentX - touchCenterX;
            const deltaY = currentY - touchCenterY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            // Minimum distance to register movement
            if (distance > 20) {
                // Normalize the direction vector
                touchDirection.x = deltaX / distance;
                touchDirection.y = deltaY / distance;
            } else {
                touchDirection.x = 0;
                touchDirection.y = 0;
            }
        }
        
        // Prevent context menu on long press
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        document.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // Input handling
        document.addEventListener('keydown', (e) => {
            // Don't handle game controls if conversation is open
            if (document.getElementById('conversationOverlay').style.display === 'flex') {
                return;
            }
            keys[e.key.toLowerCase()] = true;
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        // Prevent scrolling on mobile
        document.addEventListener('touchmove', (e) => {
            // Allow scrolling in chat messages and tutorial content
            if (e.target.closest('.conversation-messages') || e.target.closest('.tutorial-content')) {
                return;
            }
            e.preventDefault();
        }, { passive: false });
        
        // Auto-resize canvas for mobile
        function resizeCanvas() {
            const container = document.body;
            const maxWidth = window.innerWidth - 20;
            const maxHeight = window.innerHeight - 20;
            
            const aspectRatio = canvas.width / canvas.height;
            let newWidth = maxWidth;
            let newHeight = newWidth / aspectRatio;
            
            if (newHeight > maxHeight) {
                newHeight = maxHeight;
                newWidth = newHeight * aspectRatio;
            }
            
            canvas.style.width = newWidth + 'px';
            canvas.style.height = newHeight + 'px';
        }
        
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 100);
        });
        
        // Initial resize
        resizeCanvas();
        
        // Collision detection
        function checkCollision(x, y, width, height, obstacles) {
            for (let obstacle of obstacles) {
                if (x < obstacle.x + obstacle.width &&
                    x + width > obstacle.x &&
                    y < obstacle.y + obstacle.height &&
                    y + height > obstacle.y) {
                    return true;
                }
            }
            return false;
        }
        
        function checkWaterCollision(x, y, width, height) {
            // Check if player is in water (both lakes and rivers now)
            for (let lake of lakes) {
                if (x < lake.x + lake.width &&
                    x + width > lake.x &&
                    y < lake.y + lake.height &&
                    y + height > lake.y) {
                    return true;
                }
            }
            for (let river of rivers) {
                if (x < river.x + river.width &&
                    x + width > river.x &&
                    y < river.y + river.height &&
                    y + height > river.y) {
                    return true;
                }
            }
            return false;
        }
        
        function checkBuildingCollision(x, y, width, height) {
            // Only collide with the front 30% of buildings (bottom part)
            for (let building of buildings) {
                const collisionHeight = building.height * 0.3;
                const collisionY = building.y + building.height - collisionHeight;
                
                if (x < building.x + building.width &&
                    x + width > building.x &&
                    y < collisionY + collisionHeight &&
                    y + height > collisionY) {
                    return true;
                }
            }
            return false;
        }
        
        function checkNPCCollision(x, y, width, height, excludeNPC) {
            // Check collision with buildings, trees, water, borders
            const solidObstacles = [...borders];
            
            if (checkCollision(x, y, width, height, solidObstacles) ||
                checkTreeCollision(x, y, width, height) ||
                checkBuildingCollision(x, y, width, height)) {
                return true;
            }
            
            // Check collision with other NPCs
            for (let npc of npcs) {
                if (npc === excludeNPC) continue;
                if (x < npc.x + npc.width &&
                    x + width > npc.x &&
                    y < npc.y + npc.height &&
                    y + height > npc.y) {
                    return true;
                }
            }
            
            return false;
        }
        
        function getDistance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        }
        
        function updateNPCs(deltaTime) {
            const dt = deltaTime / 1000;
            
            npcs.forEach(npc => {
                // Update timers
                npc.moveTimer += dt;
                npc.emoteTimer -= dt;
                npc.interactionTimer -= dt;
                
                // Check if player is nearby for waving
                const distToPlayer = getDistance(npc.x, npc.y, player.x, player.y);
                if (distToPlayer < 50 && npc.emote === 'none' && Math.random() < 0.002) {
                    npc.emote = 'waving';
                    npc.emoteTimer = 2;
                }
                
                // Check for NPC interactions
                if (npc.interactionTimer <= 0) {
                    for (let otherNPC of npcs) {
                        if (otherNPC === npc) continue;
                        const distToNPC = getDistance(npc.x, npc.y, otherNPC.x, otherNPC.y);
                        if (distToNPC < 40 && Math.random() < 0.001) {
                            npc.interactionTarget = otherNPC;
                            npc.interactionTimer = 3;
                            npc.emote = 'talking';
                            npc.emoteTimer = 3;
                            otherNPC.emote = 'talking';
                            otherNPC.emoteTimer = 3;
                            break;
                        }
                    }
                }
                
                // Movement logic
                if (npc.isMoving) {
                    if (npc.moveTimer >= npc.moveDuration) {
                        npc.isMoving = false;
                        npc.moveTimer = 0;
                        // Random emote when stopping
                        const emotes = ['thinking', 'dancing', 'none', 'stretching'];
                        if (Math.random() < 0.6) {
                            npc.emote = emotes[Math.floor(Math.random() * emotes.length)];
                            npc.emoteTimer = 2 + Math.random() * 2;
                        }
                    } else {
                        // Continue moving toward target
                        const dx = npc.targetX - npc.x;
                        const dy = npc.targetY - npc.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist > 5) {
                            const moveSpeed = npc.emote === 'jogging' ? npc.speed * 1.5 : npc.speed;
                            const newX = npc.x + (dx / dist) * moveSpeed * dt;
                            const newY = npc.y + (dy / dist) * moveSpeed * dt;
                            
                            // Check collision before moving
                            if (!checkNPCCollision(newX, npc.y, npc.width, npc.height, npc)) {
                                npc.x = newX;
                            }
                            if (!checkNPCCollision(npc.x, newY, npc.width, npc.height, npc)) {
                                npc.y = newY;
                            }
                            
                            // Update direction
                            if (Math.abs(dx) > Math.abs(dy)) {
                                npc.direction = dx > 0 ? 'right' : 'left';
                            } else {
                                npc.direction = dy > 0 ? 'down' : 'up';
                            }
                            
                            npc.animTimer += dt;
                        }
                    }
                } else {
                    if (npc.moveTimer >= npc.pauseDuration) {
                        npc.isMoving = true;
                        npc.moveTimer = 0;
                        
                        // Choose new random target
                        let attempts = 0;
                        do {
                            npc.targetX = 50 + Math.random() * (worldWidth - 100);
                            npc.targetY = 50 + Math.random() * (worldHeight - 100);
                            attempts++;
                        } while (checkNPCCollision(npc.targetX, npc.targetY, npc.width, npc.height, npc) && attempts < 10);
                        
                        // Random chance for jogging
                        if (Math.random() < 0.3 && npc.emote === 'none') {
                            npc.emote = 'jogging';
                            npc.emoteTimer = 5;
                        }
                    }
                }
                
                // Clear expired emotes
                if (npc.emoteTimer <= 0 && npc.emote !== 'none') {
                    npc.emote = 'none';
                }
                
                // Keep NPCs in bounds
                npc.x = Math.max(25, Math.min(worldWidth - 25, npc.x));
                npc.y = Math.max(25, Math.min(worldHeight - 25, npc.y));
            });
        }
        
        function checkBridgeCollision(x, y, width, height) {
            // Check if player is on a bridge
            for (let bridge of bridges) {
                if (x < bridge.x + bridge.width &&
                    x + width > bridge.x &&
                    y < bridge.y + bridge.height &&
                    y + height > bridge.y) {
                    return true;
                }
            }
            return false;
        }
        
        function checkTreeCollision(x, y, width, height) {
            for (let tree of trees) {
                // Only collide with the bottom part of the tree (trunk area)
                const trunkHeight = 12;
                const trunkWidth = 8;
                const trunkX = tree.x + tree.size/2 - trunkWidth/2;
                const trunkY = tree.y + tree.size - trunkHeight;
                
                if (x < trunkX + trunkWidth &&
                    x + width > trunkX &&
                    y < trunkY + trunkHeight &&
                    y + height > trunkY) {
                    return true;
                }
            }
            return false;
        }
        
        function drawNPC(npc) {
            const screenX = npc.x - camera.x;
            const screenY = npc.y - camera.y;
            
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(screenX + npc.width/2, screenY + npc.height - 2, 7, 2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Water splash effect when in water
            if (npc.inWater && npc.splashTimer > 0) {
                ctx.fillStyle = 'rgba(135, 206, 235, 0.6)';
                for (let i = 0; i < 5; i++) {
                    const splashX = screenX + npc.width/2 + (Math.random() - 0.5) * 20;
                    const splashY = screenY + npc.height - 2 + (Math.random() - 0.5) * 10;
                    drawPixelRect(splashX, splashY, 2, 2, 'rgba(135, 206, 235, 0.8)');
                }
            }
            
            // Body
            drawGradientRect(screenX + 5, screenY + 10, 9, 12, npc.appearance.shirt, npc.appearance.shirt);
            
            // Head
            drawGradientRect(screenX + 2, screenY, 15, 10, npc.appearance.skin, npc.appearance.skin);
            
            // Hair - improved to go around head, not over face
            if (npc.appearance.longHair) {
                // Long hair - sides and back
                drawGradientRect(screenX, screenY - 1, 3, 12, npc.appearance.hair, npc.appearance.hair); // left side
                drawGradientRect(screenX + 16, screenY - 1, 3, 12, npc.appearance.hair, npc.appearance.hair); // right side
                drawGradientRect(screenX + 2, screenY - 2, 15, 4, npc.appearance.hair, npc.appearance.hair); // top/back
            } else {
                // Short hair - sides and back, avoiding face area
                drawGradientRect(screenX + 1, screenY - 2, 4, 8, npc.appearance.hair, npc.appearance.hair); // left side
                drawGradientRect(screenX + 14, screenY - 2, 4, 8, npc.appearance.hair, npc.appearance.hair); // right side
                drawGradientRect(screenX + 2, screenY - 2, 15, 3, npc.appearance.hair, npc.appearance.hair); // top/back
            }
            
            // Beard (if applicable)
            if (npc.appearance.beard) {
                drawPixelRect(screenX + 4, screenY + 6, 11, 4, npc.appearance.hair);
            }
            
            // Eyes
            drawPixelRect(screenX + 5, screenY + 3, 2, 1, '#000000');
            drawPixelRect(screenX + 12, screenY + 3, 2, 1, '#000000');
            
            // Eye highlights
            drawPixelRect(screenX + 6, screenY + 3, 1, 1, '#FFFFFF');
            drawPixelRect(screenX + 13, screenY + 3, 1, 1, '#FFFFFF');
            
            // Glasses (if applicable)
            if (npc.appearance.glasses) {
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 1;
                ctx.strokeRect(screenX + 4, screenY + 2, 4, 4);
                ctx.strokeRect(screenX + 11, screenY + 2, 4, 4);
                ctx.beginPath();
                ctx.moveTo(screenX + 8, screenY + 4);
                ctx.lineTo(screenX + 11, screenY + 4);
                ctx.stroke();
            }
            
            // Nose
            drawPixelRect(screenX + 8, screenY + 5, 1, 1, npc.appearance.skin);
            
            // Mouth (smile when talking or dancing)
            if (npc.emote === 'talking' || npc.emote === 'dancing') {
                drawPixelRect(screenX + 7, screenY + 6, 4, 1, '#8B4513');
            } else {
                drawPixelRect(screenX + 8, screenY + 6, 2, 1, '#8B4513');
            }
            
            // Arms
            let armOffset = 0;
            if (npc.emote === 'waving') {
                armOffset = Math.sin(Date.now() / 200) * 2;
            } else if (npc.emote === 'dancing') {
                armOffset = Math.sin(Date.now() / 150) * 3;
            }
            
            drawGradientRect(screenX + 1, screenY + 11, 4, 10, npc.appearance.skin, npc.appearance.skin);
            drawGradientRect(screenX + 14, screenY + 11 + armOffset, 4, 10, npc.appearance.skin, npc.appearance.skin);
            
            // Pants
            drawGradientRect(screenX + 5, screenY + 18, 9, 4, npc.appearance.pants, npc.appearance.pants);
            
            // Legs with walking animation
            let legOffset = 0;
            if (npc.isMoving || npc.emote === 'dancing' || npc.emote === 'jogging') {
                legOffset = Math.sin(npc.animTimer * 10) * 1;
            }
            drawGradientRect(screenX + 5, screenY + 19 + legOffset, 4, 7, npc.appearance.pants, npc.appearance.pants);
            drawGradientRect(screenX + 10, screenY + 19 - legOffset, 4, 7, npc.appearance.pants, npc.appearance.pants);
            
            // Feet
            drawPixelRect(screenX + 4, screenY + 24, 6, 2, npc.appearance.shoes);
            drawPixelRect(screenX + 9, screenY + 24, 6, 2, npc.appearance.shoes);
            
            // Emote effects
            if (npc.emote === 'thinking') {
                // Thought bubble
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.beginPath();
                ctx.arc(screenX + npc.width/2, screenY - 10, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000000';
                ctx.font = '8px monospace';
                ctx.fillText('?', screenX + npc.width/2 - 2, screenY - 7);
            } else if (npc.emote === 'stretching') {
                // Arms up
                drawGradientRect(screenX + 1, screenY + 5, 4, 8, npc.appearance.skin, npc.appearance.skin);
                drawGradientRect(screenX + 14, screenY + 5, 4, 8, npc.appearance.skin, npc.appearance.skin);
            }
            
            // Name tag
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(screenX - 5, screenY - 20, npc.name.length * 6 + 10, 12);
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '8px monospace';
            ctx.fillText(npc.name, screenX, screenY - 12);
            
            // Add chat indicator if player is near
            const distToPlayer = getDistance(npc.x, npc.y, player.x, player.y);
            if (distToPlayer < 50) {
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.fillRect(screenX + npc.width/2 - 15, screenY - 35, 30, 12);
                ctx.fillStyle = '#000000';
                ctx.font = '8px monospace';
                ctx.fillText('üí¨ Chat', screenX + npc.width/2 - 12, screenY - 27);
            }
        }
        
        // Enhanced drawing functions
        function drawPixelRect(x, y, width, height, color) {
            ctx.fillStyle = color;
            ctx.fillRect(Math.floor(x), Math.floor(y), width, height);
        }
        
        function drawGradientRect(x, y, width, height, color1, color2) {
            const gradient = ctx.createLinearGradient(x, y, x, y + height);
            gradient.addColorStop(0, color1);
            gradient.addColorStop(1, color2);
            ctx.fillStyle = gradient;
            ctx.fillRect(Math.floor(x), Math.floor(y), width, height);
        }
        
        function drawTriangle(x1, y1, x2, y2, x3, y3, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x3, y3);
            ctx.closePath();
            ctx.fill();
        }
        
        function drawBuilding(building) {
            const screenX = building.x - camera.x;
            const screenY = building.y - camera.y;
            
            // Shadow
            drawPixelRect(screenX + 2, screenY + 2, building.width, building.height, 'rgba(0,0,0,0.3)');
            
            // Log cabin walls with horizontal log pattern
            drawGradientRect(screenX, screenY, building.width, building.height, building.color, '#8B7355');
            
            // Horizontal log lines
            for (let y = screenY; y < screenY + building.height; y += 8) {
                drawPixelRect(screenX, y, building.width, 2, '#654321');
                // Log end circles
                drawPixelRect(screenX - 2, y, 4, 6, '#8B4513');
                drawPixelRect(screenX + building.width - 2, y, 4, 6, '#8B4513');
            }
            
            // Triangular roof with wood shingles
            const roofHeight = 30;
            const roofTop = screenY - roofHeight;
            drawTriangle(
                screenX - 10, screenY,                           // bottom left
                screenX + building.width + 10, screenY,          // bottom right
                screenX + building.width / 2, roofTop,           // top center
                building.roofColor
            );
            
            // Roof shingle pattern
            for (let y = roofTop; y < screenY; y += 6) {
                const rowWidth = (screenY - y) * 0.7;
                const rowStart = screenX + building.width/2 - rowWidth/2;
                for (let x = rowStart; x < rowStart + rowWidth; x += 8) {
                    drawPixelRect(x, y, 6, 4, '#A0522D');
                }
            }
            
            // Bigger wooden door (20% larger)
            const doorWidth = 19; // was 16
            const doorHeight = 24; // was 20
            drawGradientRect(screenX + building.width/2 - doorWidth/2, screenY + building.height - doorHeight, 
                           doorWidth, doorHeight, '#654321', '#4A4A4A');
            
            // Door planks (vertical)
            for (let x = screenX + building.width/2 - doorWidth/2; x < screenX + building.width/2 + doorWidth/2; x += 4) {
                drawPixelRect(x, screenY + building.height - doorHeight, 2, doorHeight, '#5D4037');
            }
            
            // Door handle
            drawPixelRect(screenX + building.width/2 + 5, screenY + building.height - 12, 2, 2, '#8B4513');
            
            // Variable window layouts based on building type
            const windowSize = 14; // was 12 (20% bigger)
            
            switch(building.windowLayout) {
                case 'standard':
                    // Two windows symmetrically placed
                    drawWindow(screenX + 8, screenY + 15, windowSize);
                    drawWindow(screenX + building.width - 8 - windowSize, screenY + 15, windowSize);
                    break;
                    
                case 'large':
                    // Larger windows, slightly different positions
                    const largeSize = 16;
                    drawWindow(screenX + 12, screenY + 12, largeSize);
                    drawWindow(screenX + building.width - 12 - largeSize, screenY + 12, largeSize);
                    break;
                    
                case 'small':
                    // Three smaller windows
                    const smallSize = 10;
                    drawWindow(screenX + 8, screenY + 18, smallSize);
                    drawWindow(screenX + building.width/2 - smallSize/2, screenY + 8, smallSize);
                    drawWindow(screenX + building.width - 8 - smallSize, screenY + 18, smallSize);
                    break;
                    
                case 'offset':
                    // Asymmetrically placed windows
                    drawWindow(screenX + 6, screenY + 12, windowSize);
                    drawWindow(screenX + building.width - 6 - windowSize, screenY + 20, windowSize);
                    break;
                    
                case 'triple':
                    // Three windows in a row
                    const spacing = (building.width - 3 * windowSize) / 4;
                    drawWindow(screenX + spacing, screenY + 15, windowSize);
                    drawWindow(screenX + spacing * 2 + windowSize, screenY + 15, windowSize);
                    drawWindow(screenX + spacing * 3 + windowSize * 2, screenY + 15, windowSize);
                    break;
                    
                case 'asymmetric':
                    // Different sized windows at different heights
                    drawWindow(screenX + 10, screenY + 10, 16);
                    drawWindow(screenX + building.width - 15 - 12, screenY + 25, 12);
                    drawWindow(screenX + building.width/2 - 6, screenY + 8, 12);
                    break;
                    
                case 'single':
                    // Just one centered window
                    drawWindow(screenX + building.width/2 - windowSize/2, screenY + 12, windowSize);
                    break;
                    
                case 'high':
                    // Two windows placed higher up
                    drawWindow(screenX + 8, screenY + 8, windowSize);
                    drawWindow(screenX + building.width - 8 - windowSize, screenY + 8, windowSize);
                    break;
            }
        }
        
        function drawWindow(x, y, size) {
            // Window glass
            drawPixelRect(x, y, size, size, '#87CEEB');
            
            // Shutters
            drawPixelRect(x - 2, y - 1, 2, size + 2, '#654321'); // left shutter
            drawPixelRect(x + size, y - 1, 2, size + 2, '#654321'); // right shutter
            
            // Window cross
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + size/2, y);
            ctx.lineTo(x + size/2, y + size);
            ctx.moveTo(x, y + size/2);
            ctx.lineTo(x + size, y + size/2);
            ctx.stroke();
        }
        
        function drawTree(tree) {
            const screenX = tree.x - camera.x;
            const screenY = tree.y - camera.y;
            
            if (tree.type === 'oak') {
                // Oak tree trunk
                drawGradientRect(screenX + tree.size/2 - 4, screenY + tree.size - 12, 8, 12, '#8B4513', '#654321');
                
                // Oak leaves (solid green circle, no blinking)
                ctx.fillStyle = '#228B22';
                ctx.beginPath();
                ctx.arc(screenX + tree.size/2, screenY + tree.size/2, tree.size/2, 0, Math.PI * 2);
                ctx.fill();
                
                // Leaf highlight
                ctx.fillStyle = '#32CD32';
                ctx.beginPath();
                ctx.arc(screenX + tree.size/2 - 3, screenY + tree.size/2 - 3, tree.size/3, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Pine tree trunk
                drawGradientRect(screenX + tree.size/2 - 3, screenY + tree.size - 10, 6, 10, '#8B4513', '#654321');
                
                // Pine tree layers
                const layers = 3;
                for (let i = 0; i < layers; i++) {
                    const layerY = screenY + (i * tree.size/4);
                    const layerSize = tree.size - (i * 8);
                    
                    ctx.fillStyle = '#0F5132';
                    ctx.beginPath();
                    ctx.moveTo(screenX + tree.size/2, layerY);
                    ctx.lineTo(screenX + tree.size/2 - layerSize/2, layerY + layerSize/2);
                    ctx.lineTo(screenX + tree.size/2 + layerSize/2, layerY + layerSize/2);
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }
        
        function drawFlower(flower) {
            const screenX = flower.x - camera.x;
            const screenY = flower.y - camera.y;
            
            // Stem
            drawPixelRect(screenX + 3, screenY + 6, 2, 6, '#228B22');
            
            if (flower.type === 'sunflower') {
                // Sunflower
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(screenX + 4, screenY + 4, 6, 0, Math.PI * 2);
                ctx.fill();
                
                // Center
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.arc(screenX + 4, screenY + 4, 3, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Regular flower petals
                const petalCount = 6;
                for (let i = 0; i < petalCount; i++) {
                    const angle = (i * Math.PI * 2) / petalCount;
                    const petalX = screenX + 4 + Math.cos(angle) * 3;
                    const petalY = screenY + 4 + Math.sin(angle) * 3;
                    
                    ctx.fillStyle = flower.color;
                    ctx.beginPath();
                    ctx.arc(petalX, petalY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Center
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(screenX + 4, screenY + 4, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawPlayer() {
            const screenX = player.x - camera.x;
            const screenY = player.y - camera.y;
            
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(screenX + 8, screenY + 18, 6, 2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Water splash effect when in water
            if (player.inWater && player.splashTimer > 0) {
                ctx.fillStyle = 'rgba(135, 206, 235, 0.6)';
                for (let i = 0; i < 5; i++) {
                    const splashX = screenX + 8 + (Math.random() - 0.5) * 20;
                    const splashY = screenY + 18 + (Math.random() - 0.5) * 10;
                    drawPixelRect(splashX, splashY, 2, 2, 'rgba(135, 206, 235, 0.8)');
                }
            }
            
            // Body
            drawGradientRect(screenX + 4, screenY + 8, 8, 10, '#4169E1', '#1E90FF');
            
            // Head
            drawGradientRect(screenX + 2, screenY, 12, 8, '#FFDBAC', '#F5DEB3');
            
            // Hair (proper positioning above head)
            drawGradientRect(screenX + 2, screenY - 2, 12, 4, '#8B4513', '#654321');
            
            // Eyes (proper positioning within face)
            drawPixelRect(screenX + 4, screenY + 2, 2, 1, '#000000');
            drawPixelRect(screenX + 10, screenY + 2, 2, 1, '#000000');
            
            // Eye highlights
            drawPixelRect(screenX + 5, screenY + 2, 1, 1, '#FFFFFF');
            drawPixelRect(screenX + 11, screenY + 2, 1, 1, '#FFFFFF');
            
            // Nose
            drawPixelRect(screenX + 7, screenY + 4, 1, 1, '#FFBBAC');
            
            // Mouth (small smile)
            drawPixelRect(screenX + 6, screenY + 5, 3, 1, '#8B4513');
            
            // Arms
            drawGradientRect(screenX + 1, screenY + 9, 3, 8, '#FFDBAC', '#F5DEB3');
            drawGradientRect(screenX + 12, screenY + 9, 3, 8, '#FFDBAC', '#F5DEB3');
            
            // Legs with walking animation
            const legOffset = Math.sin(player.animTimer * 8) * 1;
            drawGradientRect(screenX + 4, screenY + 16 + legOffset, 3, 6, '#000080', '#000040');
            drawGradientRect(screenX + 9, screenY + 16 - legOffset, 3, 6, '#000080', '#000040');
            
            // Feet
            drawPixelRect(screenX + 3, screenY + 20, 5, 2, '#8B4513');
            drawPixelRect(screenX + 8, screenY + 20, 5, 2, '#8B4513');
        }
        
        function drawBackground() {
            // Static grass background (no random generation to prevent blinking)
            ctx.fillStyle = '#7CB342';
            ctx.fillRect(0, 0, scaledWidth, scaledHeight);
            
            // Static grass texture pattern that moves with camera
            ctx.fillStyle = '#689F38';
            const startX = Math.floor(camera.x / 16) * 16 - camera.x;
            const startY = Math.floor(camera.y / 16) * 16 - camera.y;
            
            for (let x = startX; x < scaledWidth; x += 16) {
                for (let y = startY; y < scaledHeight; y += 16) {
                    const worldX = x + camera.x;
                    const worldY = y + camera.y;
                    if ((worldX + worldY) % 32 === 0) {
                        drawPixelRect(x, y, 2, 2, '#689F38');
                        drawPixelRect(x + 8, y + 8, 1, 1, '#8BC34A');
                    }
                }
            }
        }
        
        function drawWater(waterBodies) {
            waterBodies.forEach(water => {
                const screenX = water.x - camera.x;
                const screenY = water.y - camera.y;
                
                // Water base
                drawGradientRect(screenX, screenY, water.width, water.height, '#4682B4', '#1E90FF');
                
                // Water surface effect
                ctx.fillStyle = 'rgba(135, 206, 235, 0.6)';
                for (let x = screenX; x < screenX + water.width; x += 8) {
                    for (let y = screenY; y < screenY + water.height; y += 8) {
                        if ((x + y + Math.floor(Date.now() / 500)) % 16 === 0) {
                            drawPixelRect(x, y, 3, 3, 'rgba(135, 206, 235, 0.6)');
                        }
                    }
                }
            });
        }
        
        function drawBorders() {
            borders.forEach(border => {
                const screenX = border.x - camera.x;
                const screenY = border.y - camera.y;
                
                // Stone wall
                drawGradientRect(screenX, screenY, border.width, border.height, '#8B7D6B', '#696969');
                
                // Wall texture
                ctx.fillStyle = '#A0A0A0';
                for (let x = screenX; x < screenX + border.width; x += 20) {
                    for (let y = screenY; y < screenY + border.height; y += 20) {
                        drawPixelRect(x, y, 18, 18, '#A0A0A0');
                        drawPixelRect(x + 2, y + 2, 14, 14, '#8B8B8B');
                    }
                }
            });
        }
        
        function drawPaths() {
            paths.forEach(path => {
                const screenX = path.x - camera.x;
                const screenY = path.y - camera.y;
                
                // Path base
                drawPixelRect(screenX, screenY, path.width, path.height, '#D2B48C');
                
                // Path texture (static pattern)
                ctx.fillStyle = '#DEB887';
                for (let x = screenX; x < screenX + path.width; x += 12) {
                    for (let y = screenY; y < screenY + path.height; y += 12) {
                        if ((x + y) % 24 === 0) {
                            drawPixelRect(x, y, 6, 6, '#DEB887');
                        }
                    }
                }
            });
        }
        
        // Update function
        function update(deltaTime) {
            const dt = deltaTime / 1000;
            
            // Store old position
            const oldX = player.x;
            const oldY = player.y;
            
            // Handle input
            let moving = false;
            let newX = player.x;
            let newY = player.y;
            
            // Check if player will be in water
            const willBeInWater = checkWaterCollision(newX, newY, player.width, player.height) && 
                                 !checkBridgeCollision(newX, newY, player.width, player.height);
            
            // Set movement speed based on water
            let currentSpeed = willBeInWater ? player.speed * 0.4 : player.speed;
            
            // Handle keyboard input
            if (keys['a'] || keys['arrowleft']) {
                newX -= currentSpeed * dt;
                player.direction = 'left';
                moving = true;
            }
            if (keys['d'] || keys['arrowright']) {
                newX += currentSpeed * dt;
                player.direction = 'right';
                moving = true;
            }
            if (keys['w'] || keys['arrowup']) {
                newY -= currentSpeed * dt;
                player.direction = 'up';
                moving = true;
            }
            if (keys['s'] || keys['arrowdown']) {
                newY += currentSpeed * dt;
                player.direction = 'down';
                moving = true;
            }
            
            // Handle touch input for mobile
            if (hasMoved && (touchDirection.x !== 0 || touchDirection.y !== 0)) {
                newX += touchDirection.x * currentSpeed * dt;
                newY += touchDirection.y * currentSpeed * dt;
                
                // Update direction based on touch
                if (Math.abs(touchDirection.x) > Math.abs(touchDirection.y)) {
                    player.direction = touchDirection.x > 0 ? 'right' : 'left';
                } else {
                    player.direction = touchDirection.y > 0 ? 'down' : 'up';
                }
                moving = true;
            }
            
            // Check collisions before moving (exclude all water from solid obstacles)
            const solidObstacles = [...borders];
            
            if (!checkCollision(newX, player.y, player.width, player.height, solidObstacles) &&
                !checkTreeCollision(newX, player.y, player.width, player.height) &&
                !checkBuildingCollision(newX, player.y, player.width, player.height)) {
                player.x = newX;
            }
            
            if (!checkCollision(player.x, newY, player.width, player.height, solidObstacles) &&
                !checkTreeCollision(player.x, newY, player.width, player.height) &&
                !checkBuildingCollision(player.x, newY, player.width, player.height)) {
                player.y = newY;
            }
            
            // Update water state
            const wasInWater = player.inWater;
            player.inWater = checkWaterCollision(player.x, player.y, player.width, player.height) && 
                            !checkBridgeCollision(player.x, player.y, player.width, player.height);
            
            // Splash effect when entering water or moving in water
            if (player.inWater && (moving || !wasInWater)) {
                player.splashTimer = 0.3;
            }
            
            // Update splash timer
            if (player.splashTimer > 0) {
                player.splashTimer -= dt;
            }
            
            // Update animation
            if (moving) {
                player.animTimer += dt;
            }
            
            // Keep player in world bounds
            player.x = Math.max(25, Math.min(worldWidth - 25, player.x));
            player.y = Math.max(25, Math.min(worldHeight - 25, player.y));
            
            // Update camera to follow player smoothly
            const targetCameraX = player.x - scaledWidth / 2;
            const targetCameraY = player.y - scaledHeight / 2;
            
            camera.x += (targetCameraX - camera.x) * 0.1;
            camera.y += (targetCameraY - camera.y) * 0.1;
            
            // Keep camera in bounds
            camera.x = Math.max(0, Math.min(worldWidth - scaledWidth, camera.x));
            camera.y = Math.max(0, Math.min(worldHeight - scaledHeight, camera.y));
            
            // Update NPCs
            updateNPCs(deltaTime);
            
            // Update UI
            document.getElementById('position').textContent = `${Math.floor(player.x)}, ${Math.floor(player.y)}`;
        }
        
        // Render function with proper depth sorting
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, scaledWidth, scaledHeight);
            
            // Draw background
            drawBackground();
            
            // Draw water bodies
            drawWater(rivers);
            drawWater(lakes);
            
            // Draw bridges (over water)
            bridges.forEach(bridge => {
                const screenX = bridge.x - camera.x;
                const screenY = bridge.y - camera.y;
                
                // Bridge planks
                drawGradientRect(screenX, screenY, bridge.width, bridge.height, '#DEB887', '#D2B48C');
                
                // Bridge planks texture
                if (bridge.width > bridge.height) { // horizontal bridge
                    for (let y = screenY; y < screenY + bridge.height; y += 4) {
                        drawPixelRect(screenX, y, bridge.width, 2, '#8B7355');
                    }
                } else { // vertical bridge
                    for (let x = screenX; x < screenX + bridge.width; x += 4) {
                        drawPixelRect(x, screenY, 2, bridge.height, '#8B7355');
                    }
                }
            });
            
            // Draw borders
            drawBorders();
            
            // Draw paths
            drawPaths();
            
            // Draw flowers
            flowers.forEach(flower => drawFlower(flower));
            
            // Create array of all objects with Y positions for depth sorting
            const allObjects = [];
            
            // Add buildings
            buildings.forEach(building => {
                allObjects.push({
                    type: 'building',
                    object: building,
                    y: building.y + building.height // Use bottom of building for sorting
                });
            });
            
            // Add trees
            trees.forEach(tree => {
                allObjects.push({
                    type: 'tree',
                    object: tree,
                    y: tree.y + tree.size // Use bottom of tree for sorting
                });
            });
            
            // Add NPCs to depth sorting
            npcs.forEach(npc => {
                allObjects.push({
                    type: 'npc',
                    object: npc,
                    y: npc.y + npc.height
                });
            });
            
            // Add player
            allObjects.push({
                type: 'player',
                object: player,
                y: player.y + player.height
            });
            
            // Sort by Y position (top to bottom)
            allObjects.sort((a, b) => a.y - b.y);
            
            // Draw all objects in depth order
            allObjects.forEach(item => {
                if (item.type === 'building') {
                    drawBuilding(item.object);
                } else if (item.type === 'tree') {
                    drawTree(item.object);
                } else if (item.type === 'player') {
                    drawPlayer();
                } else if (item.type === 'npc') {
                    drawNPC(item.object);
                }
            });
        }
        
        // Game loop
        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            update(deltaTime);
            render();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Start game
        initializeQuest();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
