<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Wasteland Adventure - Tactical Combat</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #0f0;
            padding: 10px;
            min-height: 100vh;
            min-height: 100dvh;
        }
        body.fullscreen-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            overflow-y: auto;
            padding-top: max(10px, env(safe-area-inset-top, 10px));
            padding-bottom: max(10px, env(safe-area-inset-bottom, 10px));
        }
        
        #game-container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #0f0;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.3em;
            color: #0f0;
            text-shadow: 0 0 10px #0f0;
        }
        
        .screen { display: none; }
        .screen.active { display: block; }
        
        .story-text {
            background: rgba(0, 255, 0, 0.05);
            border: 1px solid #0f0;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            line-height: 1.6;
            font-size: 0.95em;
        }
        
        .progress-bar {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #0f0;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            text-align: center;
        }
        
        .inventory-box {
            background: rgba(255, 255, 0, 0.05);
            border: 1px solid #ff0;
            padding: 12px;
            margin: 10px 0;
            border-radius: 5px;
        }
        
        .inv-item {
            margin: 5px 0;
            font-size: 0.9em;
        }
        
        /* Combat Grid Styles */
        .combat-layout {
            display: grid;
            grid-template-columns: 1fr 280px;
            gap: 15px;
            margin: 15px 0;
        }
        
        @media (max-width: 700px) {
            .combat-layout {
                grid-template-columns: 1fr;
            }
        }
        
        .grid-container {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0f0;
            padding: 10px;
            border-radius: 5px;
        }
        
        .grid-title {
            text-align: center;
            margin-bottom: 10px;
            font-size: 0.9em;
            color: #ff0;
        }
        
        .combat-grid {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 2px;
            aspect-ratio: 12/10;
            position: relative;
        }
        
        .grid-cell {
            aspect-ratio: 1;
            background: rgba(0, 50, 0, 0.3);
            border: 1px solid rgba(0, 255, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75em;
            cursor: pointer;
            position: relative;
            transition: all 0.15s;
        }
        
        .grid-cell:hover {
            background: rgba(0, 100, 0, 0.5);
        }
        
        .grid-cell.player {
            background: rgba(0, 255, 0, 0.4);
            border-color: #0f0;
        }
        
        .grid-cell.enemy {
            background: rgba(255, 0, 0, 0.4);
            border-color: #f00;
        }

        .grid-cell.enemy-targeted {
            background: rgba(255, 50, 50, 0.7);
            border-color: #ff0;
            box-shadow: 0 0 10px #ff0, inset 0 0 5px rgba(255, 255, 0, 0.3);
            animation: target-pulse 1s infinite;
        }

        @keyframes target-pulse {
            0%, 100% { box-shadow: 0 0 10px #ff0, inset 0 0 5px rgba(255, 255, 0, 0.3); }
            50% { box-shadow: 0 0 20px #ff0, inset 0 0 10px rgba(255, 255, 0, 0.5); }
        }

        .enemy-number {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 0.7em;
            background: #f00;
            color: #fff;
            border-radius: 50%;
            width: 14px;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .los-line-secondary {
            stroke: rgba(100, 100, 100, 0.3);
            stroke-width: 1;
            stroke-dasharray: 4, 4;
        }

        /* Cover types */
        .grid-cell.cover-small {
            background: rgba(100, 100, 100, 0.4);
            border-color: #888;
        }
        
        .grid-cell.cover-small::after {
            content: '░';
            color: #aaa;
            font-size: 1.1em;
        }
        
        .grid-cell.cover-medium {
            background: rgba(120, 100, 60, 0.6);
            border-color: #a86;
        }
        
        .grid-cell.cover-medium::after {
            content: '▒';
            color: #ca8;
            font-size: 1.1em;
        }
        
        .grid-cell.cover-wall {
            background: rgba(80, 80, 80, 0.9);
            border-color: #666;
        }
        
        .grid-cell.cover-wall::after {
            content: '█';
            color: #555;
            font-size: 1.1em;
        }
        
        .grid-cell.hazard {
            background: rgba(255, 165, 0, 0.4);
            border-color: #ffa500;
        }
        
        .grid-cell.hazard::after {
            content: '☢';
            color: #ffa500;
            font-size: 0.9em;
        }
        
        .grid-cell.move-range {
            background: rgba(0, 150, 255, 0.3);
            border-color: #0af;
        }
        
        .grid-cell.attack-range {
            background: rgba(255, 100, 100, 0.2);
            border-color: rgba(255, 0, 0, 0.5);
        }
        
        .grid-cell.selected {
            box-shadow: 0 0 8px #fff;
            border-color: #fff;
        }

        /* Path visualization */
        .grid-cell.path {
            background: rgba(0, 200, 255, 0.4);
            border-color: #0cf;
        }

        .grid-cell.path-start {
            background: rgba(0, 255, 100, 0.5);
            border-color: #0f6;
        }

        .grid-cell.path-end {
            background: rgba(255, 200, 0, 0.5);
            border-color: #fc0;
        }

        .grid-cell.path-drawing {
            background: rgba(150, 100, 255, 0.5);
            border-color: #a6f;
        }

        .grid-cell.path-invalid {
            background: rgba(255, 50, 50, 0.5);
            border-color: #f33;
        }

        .path-mode-toggle {
            display: flex;
            gap: 5px;
            margin-bottom: 8px;
        }

        .path-mode-toggle button {
            flex: 1;
            padding: 5px 8px;
            font-size: 0.8em;
            background: rgba(0, 100, 0, 0.3);
            border: 1px solid #0f0;
            color: #0f0;
            cursor: pointer;
            border-radius: 3px;
        }

        .path-mode-toggle button.active {
            background: rgba(0, 255, 0, 0.3);
            border-color: #0f0;
            box-shadow: 0 0 5px #0f0;
        }

        .path-mode-toggle button:hover {
            background: rgba(0, 150, 0, 0.4);
        }

        /* ============================================
           SKILL-BASED SOLUTION OPTIONS (Fallout-style)
           ============================================ */
        .solution-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .solution-options {
            background: #1a1a1a;
            border: 3px solid #0f0;
            border-radius: 10px;
            padding: 20px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .solution-title {
            color: #0f0;
            text-align: center;
            margin-bottom: 10px;
            font-size: 1.3em;
            text-shadow: 0 0 10px #0f0;
        }

        .solution-description {
            color: #aaa;
            text-align: center;
            margin-bottom: 20px;
            font-size: 0.9em;
        }

        .solution-option {
            background: rgba(0, 50, 0, 0.3);
            border: 2px solid #0f0;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .solution-option:hover:not(.locked) {
            background: rgba(0, 100, 0, 0.5);
            transform: translateX(5px);
        }

        .solution-option.locked {
            background: rgba(50, 0, 0, 0.3);
            border-color: #600;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .solution-option.mastered {
            background: rgba(50, 50, 0, 0.3);
            border-color: #fc0;
        }

        .solution-option.mastered:hover {
            background: rgba(80, 80, 0, 0.5);
        }

        .option-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
        }

        .option-icon {
            font-size: 1.2em;
        }

        .option-label {
            font-size: 1.1em;
            font-weight: bold;
            color: #0f0;
        }

        .locked .option-label {
            color: #f44;
        }

        .mastered .option-label {
            color: #fc0;
        }

        .option-skill {
            font-size: 0.85em;
            color: #888;
            margin-left: 30px;
        }

        .skill-locked {
            color: #f44;
        }

        .skill-mastered {
            color: #fc0;
        }

        .option-preview {
            font-size: 0.8em;
            color: #0a0;
            margin-left: 30px;
            margin-top: 5px;
            font-style: italic;
        }

        /* Skill indicator in UI */
        .skill-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            margin-left: 5px;
        }

        .skill-indicator.available {
            background: rgba(0, 100, 0, 0.3);
            border: 1px solid #0f0;
            color: #0f0;
        }

        .skill-indicator.locked {
            background: rgba(100, 0, 0, 0.3);
            border: 1px solid #f44;
            color: #f44;
        }

        .skill-indicator.mastered {
            background: rgba(100, 100, 0, 0.3);
            border: 1px solid #fc0;
            color: #fc0;
        }

        /* ============================================
           VISUAL MATH SYSTEM (K-2 Support)
           ============================================ */

        .visual-math-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }

        .visual-math-container {
            background: #1a1a1a;
            border: 3px solid #0f0;
            border-radius: 10px;
            padding: 20px;
            max-width: 600px;
            width: 95%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .visual-math-title {
            color: #0f0;
            text-align: center;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .visual-math-instruction {
            color: #aaa;
            text-align: center;
            margin-bottom: 15px;
            font-size: 1em;
        }

        /* Counting Objects Area */
        .counting-area {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            padding: 15px;
            background: rgba(0, 50, 0, 0.2);
            border: 2px dashed #0f0;
            border-radius: 8px;
            min-height: 100px;
            margin-bottom: 15px;
        }

        .count-object {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8em;
            cursor: pointer;
            transition: transform 0.2s;
            user-select: none;
        }

        .count-object:hover {
            transform: scale(1.2);
        }

        .count-object.selected {
            background: rgba(0, 255, 0, 0.3);
            border-radius: 50%;
            animation: pulse 0.5s ease-in-out;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        /* Coin System */
        .coin-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 15px;
        }

        .coin-tray {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            padding: 10px;
            background: rgba(139, 90, 43, 0.3);
            border: 2px solid #8b5a2b;
            border-radius: 8px;
            min-height: 60px;
        }

        .coin {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: grab;
            user-select: none;
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
        }

        .coin:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .coin.dragging {
            cursor: grabbing;
            opacity: 0.8;
            z-index: 100;
        }

        .coin.penny {
            background: linear-gradient(145deg, #b87333, #8b4513);
            border: 2px solid #cd7f32;
            color: #2a1a0a;
            font-size: 0.7em;
        }

        .coin.nickel {
            background: linear-gradient(145deg, #a8a8a8, #808080);
            border: 2px solid #c0c0c0;
            color: #333;
            font-size: 0.7em;
        }

        .coin.dime {
            background: linear-gradient(145deg, #c0c0c0, #a0a0a0);
            border: 2px solid #d3d3d3;
            color: #333;
            font-size: 0.6em;
            width: 35px;
            height: 35px;
        }

        .coin.quarter {
            background: linear-gradient(145deg, #d4d4d4, #b0b0b0);
            border: 2px solid #e0e0e0;
            color: #333;
            font-size: 0.65em;
            width: 50px;
            height: 50px;
        }

        .coin-drop-zone {
            min-height: 80px;
            background: rgba(0, 100, 0, 0.2);
            border: 3px dashed #0f0;
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }

        .coin-drop-zone.drag-over {
            background: rgba(0, 150, 0, 0.3);
            border-color: #0f0;
        }

        .coin-total {
            text-align: center;
            font-size: 1.5em;
            color: #0f0;
            margin-top: 10px;
        }

        /* Number Line */
        .number-line-container {
            margin: 20px 0;
            padding: 10px;
        }

        .number-line {
            position: relative;
            height: 60px;
            background: linear-gradient(to right, #333, #333);
            margin: 20px 10px;
        }

        .number-line-track {
            position: absolute;
            top: 25px;
            left: 0;
            right: 0;
            height: 4px;
            background: #0f0;
        }

        .number-line-tick {
            position: absolute;
            top: 15px;
            width: 2px;
            height: 24px;
            background: #0f0;
            transform: translateX(-50%);
        }

        .number-line-label {
            position: absolute;
            top: 42px;
            transform: translateX(-50%);
            color: #0f0;
            font-size: 0.9em;
        }

        .number-line-marker {
            position: absolute;
            top: 5px;
            width: 20px;
            height: 20px;
            background: #ff0;
            border-radius: 50%;
            transform: translateX(-50%);
            cursor: grab;
            transition: left 0.3s;
            z-index: 10;
        }

        .number-line-marker.dragging {
            cursor: grabbing;
            transition: none;
        }

        .number-line-result {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: #0f0;
            color: #000;
            padding: 3px 10px;
            border-radius: 4px;
            font-weight: bold;
        }

        /* Shape Recognition */
        .shape-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 15px 0;
        }

        .shape-option {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 50, 0, 0.3);
            border: 2px solid #0f0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            padding: 10px;
        }

        .shape-option:hover {
            background: rgba(0, 100, 0, 0.4);
            transform: scale(1.05);
        }

        .shape-option.selected {
            background: rgba(0, 150, 0, 0.5);
            border-color: #0f0;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
        }

        .shape-option.correct {
            background: rgba(0, 200, 0, 0.5);
            border-color: #0f0;
        }

        .shape-option.incorrect {
            background: rgba(200, 0, 0, 0.5);
            border-color: #f00;
        }

        .shape-svg {
            width: 60px;
            height: 60px;
        }

        .shape-svg path, .shape-svg polygon, .shape-svg circle, .shape-svg rect {
            fill: none;
            stroke: #0f0;
            stroke-width: 3;
        }

        /* Ten Frame */
        .ten-frame {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            max-width: 300px;
            margin: 15px auto;
            padding: 10px;
            background: rgba(0, 50, 0, 0.2);
            border: 2px solid #0f0;
            border-radius: 8px;
        }

        .ten-frame-cell {
            aspect-ratio: 1;
            border: 2px solid #0f0;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            cursor: pointer;
            transition: background 0.2s;
        }

        .ten-frame-cell.filled {
            background: rgba(0, 255, 0, 0.3);
        }

        .ten-frame-cell:hover:not(.filled) {
            background: rgba(0, 100, 0, 0.2);
        }

        /* Base-10 Blocks */
        .base10-area {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .base10-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .base10-label {
            color: #0f0;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .base10-blocks {
            display: flex;
            flex-direction: column;
            gap: 3px;
            min-height: 100px;
            padding: 5px;
            background: rgba(0, 50, 0, 0.2);
            border: 1px solid #0f0;
            border-radius: 4px;
        }

        .base10-hundred {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #4a9, #296);
            border: 2px solid #0f0;
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(10, 1fr);
        }

        .base10-ten {
            width: 50px;
            height: 8px;
            background: linear-gradient(90deg, #4a9, #296);
            border: 1px solid #0f0;
        }

        .base10-one {
            width: 10px;
            height: 10px;
            background: #0f0;
            border: 1px solid #0a0;
        }

        .base10-ones-group {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            max-width: 55px;
        }

        /* Visual answer display */
        .visual-answer-display {
            text-align: center;
            padding: 15px;
            background: rgba(0, 50, 0, 0.3);
            border: 2px solid #0f0;
            border-radius: 8px;
            margin: 15px 0;
        }

        .visual-answer-label {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .visual-answer-value {
            color: #0f0;
            font-size: 2em;
            font-weight: bold;
        }

        .visual-submit-btn {
            display: block;
            width: 100%;
            padding: 15px;
            margin-top: 15px;
            background: rgba(0, 100, 0, 0.5);
            border: 2px solid #0f0;
            border-radius: 8px;
            color: #0f0;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .visual-submit-btn:hover {
            background: rgba(0, 150, 0, 0.6);
        }

        .visual-submit-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Comparison symbols */
        .comparison-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }

        .comparison-number {
            font-size: 2.5em;
            color: #0f0;
            padding: 10px 20px;
            background: rgba(0, 50, 0, 0.3);
            border: 2px solid #0f0;
            border-radius: 8px;
        }

        .comparison-symbols {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .comparison-symbol {
            font-size: 2em;
            padding: 10px 25px;
            background: rgba(0, 50, 0, 0.3);
            border: 2px solid #0f0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .comparison-symbol:hover {
            background: rgba(0, 100, 0, 0.4);
            transform: scale(1.1);
        }

        .comparison-symbol.selected {
            background: rgba(0, 150, 0, 0.5);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        .cell-content {
            font-size: 1.2em;
            z-index: 2;
        }
        
        .cell-coord {
            position: absolute;
            bottom: 0px;
            right: 1px;
            font-size: 0.4em;
            color: rgba(0, 255, 0, 0.3);
        }
        
        /* Line of Sight overlay */
        .los-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .los-line {
            stroke-width: 3;
            stroke-linecap: round;
        }
        
        .los-line.clear {
            stroke: rgba(0, 255, 0, 0.7);
        }
        
        .los-line.partial {
            stroke: rgba(255, 255, 0, 0.7);
            stroke-dasharray: 5, 3;
        }
        
        .los-line.blocked {
            stroke: rgba(255, 0, 0, 0.7);
            stroke-dasharray: 3, 3;
        }
        
        .los-indicator {
            position: absolute;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.75em;
            font-weight: bold;
            z-index: 11;
            white-space: nowrap;
        }
        
        .los-indicator.clear {
            background: rgba(0, 100, 0, 0.9);
            border: 1px solid #0f0;
            color: #0f0;
        }
        
        .los-indicator.partial {
            background: rgba(100, 100, 0, 0.9);
            border: 1px solid #ff0;
            color: #ff0;
        }
        
        .los-indicator.blocked {
            background: rgba(100, 0, 0, 0.9);
            border: 1px solid #f44;
            color: #f44;
        }
        
        /* Side Panel */
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .stat-box {
            background: rgba(0, 255, 0, 0.08);
            border: 2px solid #0f0;
            padding: 10px;
            border-radius: 5px;
        }
        
        .stat-box h3 {
            text-align: center;
            margin-bottom: 8px;
            font-size: 0.95em;
            color: #ff0;
        }
        
        .stat-line {
            margin: 4px 0;
            font-size: 0.85em;
        }
        
        .hp-bar, .ap-bar {
            width: 100%;
            height: 18px;
            background: #222;
            border: 1px solid #0f0;
            border-radius: 3px;
            overflow: hidden;
            margin: 4px 0;
        }
        
        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff4444);
            transition: width 0.5s;
            text-align: center;
            line-height: 18px;
            font-size: 0.75em;
            font-weight: bold;
            color: #fff;
        }
        
        .ap-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #44ff44);
            transition: width 0.5s;
            text-align: center;
            line-height: 18px;
            font-size: 0.75em;
            font-weight: bold;
            color: #000;
        }
        
        .coord-display {
            background: rgba(0, 100, 255, 0.1);
            border: 1px solid #0af;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
            font-size: 0.85em;
        }
        
        .distance-calc {
            background: rgba(255, 255, 0, 0.1);
            border: 1px solid #ff0;
            padding: 8px;
            border-radius: 4px;
            font-size: 0.8em;
        }
        
        .distance-calc .formula {
            color: #ff0;
            text-align: center;
            margin-top: 5px;
        }
        
        /* Action Buttons */
        .btn {
            background: #0f0;
            color: #000;
            border: none;
            padding: 10px 12px;
            font-size: 0.9em;
            font-weight: bold;
            cursor: pointer;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 4px;
            width: calc(100% - 8px);
            text-align: left;
            transition: all 0.2s;
        }
        
        .btn:active { opacity: 0.7; transform: scale(0.98); }
        .btn:disabled { background: #333; color: #666; cursor: not-allowed; }
        
        .btn.combat { background: #ff4444; color: #fff; }
        .btn.tactical { background: #4444ff; color: #fff; }
        .btn.support { background: #ffaa00; color: #000; }
        .btn.move { background: #00aaff; color: #fff; }
        .btn.environment { background: #ff8800; color: #000; }
        .btn.small { padding: 6px 8px; font-size: 0.8em; }
        
        .action-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
        }
        
        /* Math Section */
        .math-section {
            background: rgba(255, 255, 0, 0.1);
            border: 2px solid #ff0;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
        
        .math-problem {
            font-size: 1em;
            margin: 10px 0;
            text-align: center;
            color: #ff0;
            line-height: 1.5;
        }
        
        .answer-input {
            width: 100%;
            padding: 12px;
            font-size: 1.1em;
            background: #000;
            border: 2px solid #ff0;
            color: #ff0;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            text-align: center;
            margin: 10px 0;
        }
        
        /* Messages */
        .message {
            padding: 10px;
            margin: 8px 0;
            border-radius: 5px;
            font-weight: bold;
            text-align: center;
            font-size: 0.9em;
        }
        
        .message.success { background: rgba(0, 255, 0, 0.2); border: 1px solid #0f0; }
        .message.error { background: rgba(255, 0, 0, 0.2); border: 1px solid #f00; color: #f00; }
        .message.info { background: rgba(255, 255, 0, 0.2); border: 1px solid #ff0; color: #ff0; }
        
        .combat-log {
            background: rgba(255, 0, 0, 0.08);
            border: 1px solid #f00;
            padding: 10px;
            margin: 8px 0;
            border-radius: 5px;
            color: #f00;
            font-size: 0.85em;
        }
        
        /* Legend */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            font-size: 0.75em;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .legend-icon {
            width: 16px;
            height: 16px;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
        }
        
        .mode-indicator {
            background: rgba(0, 150, 255, 0.2);
            border: 2px solid #0af;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            margin: 10px 0;
            font-weight: bold;
            color: #0af;
        }
        
        .mode-indicator.attack-mode {
            background: rgba(255, 0, 0, 0.2);
            border-color: #f44;
            color: #f44;
        }
        
        /* Popup Modal */
        .popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .popup-overlay.active {
            display: flex;
        }
        
        .popup-box {
            background: #111;
            border: 3px solid #0f0;
            border-radius: 10px;
            padding: 25px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
        }
        
        .popup-box.success {
            border-color: #0f0;
        }
        
        .popup-box.error {
            border-color: #f44;
        }
        
        .popup-box.info {
            border-color: #ff0;
        }
        
        .popup-title {
            font-size: 1.4em;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .popup-box.success .popup-title { color: #0f0; }
        .popup-box.error .popup-title { color: #f44; }
        .popup-box.info .popup-title { color: #ff0; }
        
        .popup-content {
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 20px;
        }
        
        .popup-btn {
            background: #0f0;
            color: #000;
            border: none;
            padding: 12px 40px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        }
        
        .popup-box.error .popup-btn {
            background: #f44;
            color: #fff;
        }
        
        .popup-box.info .popup-btn {
            background: #ff0;
            color: #000;
        }
        
        /* Trap styling - different from hazard */
        .grid-cell.trap {
            background: rgba(150, 50, 200, 0.4);
            border-color: #a855f7;
        }
        
        .grid-cell.trap::after {
            content: '⚙';
            color: #a855f7;
            font-size: 1.2em;
        }
        
        .ap-cost-tag {
            display: inline-block;
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #0f0;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.85em;
            margin-left: 5px;
        }
        
        /* Weapon slot styles */
        .weapon-slot {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #555;
            border-radius: 4px;
            padding: 6px;
            margin: 4px 0;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .weapon-slot:hover {
            border-color: #888;
            background: rgba(50, 50, 50, 0.6);
        }
        
        .weapon-slot.active {
            border-color: #0f0;
            background: rgba(0, 100, 0, 0.3);
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
        }
        
        .weapon-slot .weapon-name {
            display: block;
            font-weight: bold;
            font-size: 0.85em;
            color: #fff;
        }
        
        .weapon-slot .weapon-stats {
            display: block;
            font-size: 0.7em;
            color: #aaa;
        }
        
        .weapon-slot .weapon-range {
            display: block;
            font-size: 0.65em;
            color: #ff0;
        }
        
        .weapon-slot.active .weapon-name {
            color: #0f0;
        }
        
        .weapon-slot.out-of-range .weapon-range {
            color: #f44;
        }
        
        .weapon-slot.in-range .weapon-range {
            color: #0f0;
        }
        
        .cover-legend {
            display: flex;
            gap: 10px;
            margin-top: 8px;
            padding: 8px;
            background: rgba(0,0,0,0.5);
            border-radius: 4px;
            font-size: 0.7em;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .cover-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* Skill Progress */
        .skill-progress-container {
            background: rgba(100, 0, 200, 0.1);
            border: 2px solid #a855f7;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        
        .skill-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .skill-bar {
            width: 100%;
            height: 16px;
            background: #222;
            border: 1px solid #a855f7;
            border-radius: 3px;
            overflow: hidden;
        }

        .skill-fill {
            height: 100%;
            background: linear-gradient(90deg, #7c3aed, #a855f7);
            transition: width 0.3s;
        }

        .skill-fill.mastered {
            background: linear-gradient(90deg, #ffd700, #ffaa00);
        }

        .skill-progress-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 30, 0.98);
            border: 3px solid #a855f7;
            border-radius: 10px;
            padding: 20px;
            z-index: 10000;
            min-width: 300px;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 0 30px rgba(168, 85, 247, 0.5);
        }

        .skill-progress-popup.correct {
            border-color: #0f0;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
        }

        .skill-progress-popup.incorrect {
            border-color: #f44;
            box-shadow: 0 0 30px rgba(255, 68, 68, 0.5);
        }

        .skill-mastery-badge {
            display: inline-block;
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.8em;
            font-weight: bold;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Vitals System */
        .vitals-container {
            background: rgba(139, 69, 19, 0.15);
            border: 2px solid #8b4513;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }

        .vitals-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #daa520;
        }

        .vital-row {
            display: flex;
            align-items: center;
            margin: 4px 0;
            font-size: 0.85em;
        }

        .vital-icon {
            width: 20px;
            text-align: center;
            margin-right: 6px;
        }

        .vital-label {
            width: 60px;
            color: #ccc;
        }

        .vital-bar {
            flex: 1;
            height: 12px;
            background: #222;
            border: 1px solid #555;
            border-radius: 3px;
            overflow: hidden;
            margin: 0 8px;
        }

        .vital-fill {
            height: 100%;
            transition: width 0.3s, background 0.3s;
        }

        .vital-fill.hunger { background: linear-gradient(90deg, #8b4513, #cd853f); }
        .vital-fill.thirst { background: linear-gradient(90deg, #1e90ff, #00bfff); }
        .vital-fill.energy { background: linear-gradient(90deg, #9932cc, #da70d6); }
        .vital-fill.warmth { background: linear-gradient(90deg, #ff4500, #ffa500); }

        .vital-fill.critical { background: linear-gradient(90deg, #8b0000, #ff0000) !important; animation: vital-flash 0.5s infinite; }
        .vital-fill.warning { background: linear-gradient(90deg, #b8860b, #ffd700) !important; }

        @keyframes vital-flash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .vital-value {
            width: 35px;
            text-align: right;
            font-size: 0.85em;
        }

        .vital-status {
            font-size: 0.75em;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 5px;
        }

        .vital-status.critical { background: #8b0000; color: #fff; }
        .vital-status.warning { background: #b8860b; color: #fff; }
        .vital-status.good { background: #228b22; color: #fff; }

        .vitals-actions {
            display: flex;
            gap: 5px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .vitals-actions button {
            flex: 1;
            min-width: 60px;
            padding: 5px 8px;
            font-size: 0.8em;
        }

        /* Trading Post */
        .shop-container {
            background: rgba(255, 215, 0, 0.08);
            border: 2px solid #ffd700;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        .shop-header {
            text-align: center;
            color: #ffd700;
            font-size: 1.2em;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        .shop-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #555;
            padding: 10px;
            margin: 8px 0;
            border-radius: 5px;
            transition: all 0.2s;
        }
        
        .shop-item:hover {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
        }
        
        .shop-item .item-info {
            flex: 1;
        }
        
        .shop-item .item-name {
            font-weight: bold;
            color: #fff;
            display: block;
        }
        
        .shop-item .item-desc {
            font-size: 0.8em;
            color: #aaa;
        }
        
        .shop-item .item-price {
            color: #ffd700;
            font-weight: bold;
            margin-left: 15px;
        }
        
        .shop-item .btn {
            margin-left: 10px;
            width: auto;
            padding: 8px 15px;
        }
        
        .caps-display {
            text-align: center;
            font-size: 1.1em;
            color: #ffd700;
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
        }
        
        /* Math Streak Bonus */
        .streak-display {
            background: linear-gradient(135deg, rgba(255, 100, 0, 0.2), rgba(255, 50, 0, 0.1));
            border: 1px solid #ff6600;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.85em;
            color: #ff6600;
            display: inline-block;
            margin-top: 5px;
        }
        
        .streak-display.hot {
            animation: fire 0.5s infinite alternate;
        }
        
        @keyframes fire {
            from { text-shadow: 0 0 5px #ff6600; }
            to { text-shadow: 0 0 15px #ff0000, 0 0 25px #ff6600; }
        }
        
        /* Crafting System */
        .crafting-container {
            background: rgba(139, 69, 19, 0.15);
            border: 2px solid #cd853f;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        .crafting-header {
            text-align: center;
            color: #cd853f;
            font-size: 1.2em;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(205, 133, 63, 0.5);
        }
        
        .recipe-card {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #8b4513;
            padding: 12px;
            margin: 10px 0;
            border-radius: 5px;
        }
        
        .recipe-name {
            font-weight: bold;
            color: #daa520;
            font-size: 1.1em;
            margin-bottom: 8px;
        }
        
        .recipe-ingredients {
            font-size: 0.9em;
            color: #bbb;
            margin-bottom: 10px;
            padding-left: 10px;
            border-left: 2px solid #8b4513;
        }
        
        .recipe-result {
            color: #0f0;
            font-size: 0.85em;
        }
        
        .materials-display {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #666;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 0.9em;
        }
        
        /* Hacking Terminal */
        .terminal-container {
            background: #000;
            border: 3px solid #0f0;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3), inset 0 0 50px rgba(0, 255, 0, 0.05);
        }
        
        .terminal-header {
            color: #0f0;
            text-align: center;
            font-size: 1.1em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #0f0;
        }
        
        .terminal-screen {
            background: rgba(0, 50, 0, 0.3);
            border: 1px solid #0a0;
            padding: 15px;
            margin: 10px 0;
            border-radius: 3px;
            min-height: 100px;
        }
        
        .terminal-prompt {
            color: #0f0;
            margin-bottom: 10px;
        }
        
        .terminal-sequence {
            font-size: 1.3em;
            letter-spacing: 8px;
            text-align: center;
            color: #0f0;
            padding: 15px;
            background: rgba(0, 100, 0, 0.2);
            border-radius: 3px;
            margin: 10px 0;
        }
        
        .terminal-input {
            width: 100%;
            padding: 10px;
            font-size: 1.1em;
            background: #001100;
            border: 2px solid #0f0;
            color: #0f0;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            text-align: center;
        }
        
        .terminal-input::placeholder {
            color: #050;
        }
        
        .hack-progress {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin: 10px 0;
        }
        
        .hack-pip {
            width: 20px;
            height: 20px;
            border: 2px solid #0f0;
            border-radius: 50%;
            background: transparent;
        }
        
        .hack-pip.complete {
            background: #0f0;
            box-shadow: 0 0 10px #0f0;
        }
        
        .hack-pip.failed {
            background: #f00;
            border-color: #f00;
        }
        
        /* Lockpicking */
        .lockpick-container {
            background: rgba(50, 50, 70, 0.3);
            border: 2px solid #778;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        .lockpick-header {
            text-align: center;
            color: #aab;
            font-size: 1.2em;
            margin-bottom: 15px;
        }
        
        .lock-display {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }
        
        .lock-tumbler {
            width: 50px;
            height: 70px;
            background: linear-gradient(180deg, #333, #222);
            border: 2px solid #555;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            color: #888;
            font-weight: bold;
        }
        
        .lock-tumbler.solved {
            border-color: #0f0;
            color: #0f0;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        
        .lock-tumbler.current {
            border-color: #ff0;
            color: #ff0;
            animation: pulse 1s infinite;
        }
        
        .lockpick-hint {
            text-align: center;
            color: #aaa;
            font-size: 0.9em;
            margin: 10px 0;
            font-style: italic;
        }
        
        /* Inventory System */
        .inventory-panel {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #888;
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .inventory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #555;
        }
        
        .weight-bar {
            width: 150px;
            height: 12px;
            background: #222;
            border: 1px solid #666;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .weight-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a4, #6c6);
            transition: width 0.3s;
        }
        
        .weight-fill.warning {
            background: linear-gradient(90deg, #c84, #ea6);
        }
        
        .weight-fill.critical {
            background: linear-gradient(90deg, #a44, #c66);
        }
        
        .inv-item-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            margin: 4px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            font-size: 0.85em;
        }
        
        .inv-item-row:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .inv-item-name {
            flex: 1;
            color: #ddd;
        }
        
        .inv-item-weight {
            color: #888;
            margin: 0 10px;
            font-size: 0.9em;
        }
        
        .inv-item-value {
            color: #ffd700;
            margin-right: 10px;
        }
        
        .inv-item-actions button {
            padding: 3px 8px;
            font-size: 0.8em;
            margin-left: 4px;
        }
        
        /* Shop Tabs */
        .shop-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        
        .shop-tab {
            flex: 1;
            padding: 10px;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #555;
            color: #aaa;
            cursor: pointer;
            text-align: center;
            border-radius: 5px 5px 0 0;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        .shop-tab:hover {
            background: rgba(255, 215, 0, 0.1);
            border-color: #888;
        }
        
        .shop-tab.active {
            background: rgba(255, 215, 0, 0.2);
            border-color: #ffd700;
            color: #ffd700;
        }
        
        .shop-section {
            display: none;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .shop-section.active {
            display: block;
        }
        
        .empty-inventory {
            text-align: center;
            color: #666;
            padding: 20px;
            font-style: italic;
        }

        /* Base Building Screen Styles */
        .base-header {
            text-align: center;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 100, 50, 0.3);
            border: 1px solid #0a5;
            border-radius: 5px;
        }
        .base-header h2 {
            margin: 0 0 10px 0;
            color: #0f0;
        }
        .base-resources {
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 1.1em;
        }
        .resource-item {
            padding: 5px 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
        }
        .base-grid-container {
            display: flex;
            justify-content: center;
            margin: 15px 0;
        }
        .base-grid {
            display: grid;
            grid-template-columns: repeat(6, 60px);
            grid-template-rows: repeat(4, 60px);
            gap: 3px;
            background: rgba(0, 50, 0, 0.3);
            padding: 10px;
            border: 2px solid #0a5;
            border-radius: 5px;
        }
        .base-cell {
            width: 60px;
            height: 60px;
            background: rgba(30, 30, 30, 0.8);
            border: 1px solid #333;
            border-radius: 3px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1.5em;
        }
        .base-cell:hover {
            border-color: #0f0;
            background: rgba(0, 80, 0, 0.3);
        }
        .base-cell.occupied {
            background: rgba(0, 100, 50, 0.4);
            border-color: #0a5;
            cursor: default;
        }
        .base-cell.selected {
            border-color: #ff0;
            box-shadow: 0 0 10px #ff0;
        }
        .base-cell.preview {
            background: rgba(100, 100, 0, 0.3);
            border-color: #aa0;
        }
        .base-cell.preview.invalid {
            background: rgba(100, 0, 0, 0.3);
            border-color: #a00;
        }
        .base-cell .building-name {
            font-size: 0.5em;
            color: #8f8;
            margin-top: 2px;
        }
        .base-info-panel {
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 50, 50, 0.3);
            border: 1px solid #088;
            border-radius: 5px;
        }
        .base-benefits {
            font-size: 0.9em;
        }
        #benefits-list {
            margin-top: 8px;
            color: #8f8;
        }
        .benefit-item {
            display: inline-block;
            padding: 3px 8px;
            margin: 2px;
            background: rgba(0, 100, 0, 0.3);
            border-radius: 3px;
            font-size: 0.85em;
        }
        .base-build-panel {
            margin: 15px 0;
            padding: 10px;
            background: rgba(50, 50, 0, 0.3);
            border: 1px solid #880;
            border-radius: 5px;
        }
        .base-build-panel h3 {
            margin: 0 0 10px 0;
            color: #ff0;
        }
        .build-options {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
        }
        .build-option {
            padding: 8px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .build-option:hover {
            border-color: #0f0;
            background: rgba(0, 50, 0, 0.4);
        }
        .build-option.selected {
            border-color: #ff0;
            background: rgba(80, 80, 0, 0.4);
        }
        .build-option.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .build-option.locked:hover {
            border-color: #555;
            background: rgba(0, 0, 0, 0.4);
        }
        .build-option .build-icon {
            font-size: 1.5em;
            margin-right: 8px;
        }
        .build-option .build-name {
            font-weight: bold;
            color: #fff;
        }
        .build-option .build-desc {
            font-size: 0.8em;
            color: #aaa;
            margin-top: 3px;
        }
        .build-option .build-cost {
            font-size: 0.85em;
            color: #ff0;
            margin-top: 5px;
        }
        .build-option .build-size {
            font-size: 0.75em;
            color: #888;
        }
        .build-option .build-requires {
            font-size: 0.75em;
            color: #f88;
            margin-top: 3px;
        }
        .base-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
        }
        .base-actions .btn {
            min-width: 120px;
        }

        /* Tutorial tip styles - subtle bottom toast */
        .tutorial-tip {
            position: fixed;
            bottom: -120px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid #4fc3f7;
            border-radius: 10px;
            padding: 15px 20px;
            max-width: 500px;
            width: 90%;
            z-index: 999;
            box-shadow: 0 -5px 30px rgba(79, 195, 247, 0.3);
            transition: bottom 0.4s ease-out;
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }
        .tutorial-tip.active {
            bottom: 20px;
        }
        .tutorial-tip-icon {
            font-size: 1.5em;
            flex-shrink: 0;
        }
        .tutorial-tip-content {
            flex: 1;
        }
        .tutorial-tip-title {
            color: #4fc3f7;
            font-weight: bold;
            font-size: 1em;
            margin-bottom: 5px;
        }
        .tutorial-tip-text {
            color: #e0e0e0;
            font-size: 0.9em;
            line-height: 1.4;
        }
        .tutorial-tip-dismiss {
            background: transparent;
            border: 1px solid #4fc3f7;
            color: #4fc3f7;
            padding: 5px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            flex-shrink: 0;
            transition: all 0.2s;
        }
        .tutorial-tip-dismiss:hover {
            background: #4fc3f7;
            color: #000;
        }
        .tutorial-disable {
            color: #888;
            font-size: 0.75em;
            cursor: pointer;
            text-decoration: underline;
            margin-top: 8px;
            display: inline-block;
        }
        .tutorial-disable:hover {
            color: #aaa;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1>☢ WASTELAND ADVENTURE ☢</h1>
        
        <!-- Start Screen -->
        <div id="start-screen" class="screen active">
            <div class="story-text">
                <p style="margin-bottom: 15px;">You are a wasteland wanderer scavenging through the ruins of the Capital Wasteland.</p>
                <p style="margin-bottom: 15px;"><strong>TACTICAL GRID COMBAT (12×10):</strong></p>
                <p style="margin-left: 15px; font-size: 0.9em; margin-bottom: 15px;">
                • Each square = 5 feet<br>
                • Melee range = 1 square (5 ft, must be adjacent)<br>
                • Calculate distances using √[(Δx)² + (Δy)²]
                </p>
                <p style="margin-bottom: 10px;"><strong>FEATURES:</strong></p>
                <p style="margin-left: 15px; font-size: 0.9em;">
                ⚔️ Tactical grid combat with distance calculations<br>
                🏪 Trading posts with money math<br>
                ⭐ XP & leveling system<br>
                🔥 Math streak bonuses
                </p>
            </div>
            
            <div id="save-buttons" style="margin-top: 20px;">
                <button class="btn" onclick="startNewGame()" style="font-size: 1.1em; padding: 15px;">🎮 NEW GAME</button>
                <button class="btn" id="continue-btn" onclick="continueGame()" style="font-size: 1.1em; padding: 15px; margin-left: 10px; display: none;">📂 CONTINUE</button>
            </div>
            <div id="save-info" style="margin-top: 10px; font-size: 0.85em; color: #888;"></div>
        </div>
        
        <!-- Exploration Screen -->
        <div id="exploration-screen" class="screen">
            <div class="progress-bar">
                <strong>Distance: <span id="distance">0</span> km</strong> | 
                <strong>Encounters: <span id="encounters">0</span></strong>
            </div>
            
            <!-- Skill Progress Display -->
            <div class="skill-progress-container">
                <div class="skill-header">
                    <span>📊 Math Skills</span>
                    <span id="skills-mastered-count">0 Mastered</span>
                </div>
                <div id="recent-skill-progress" style="font-size: 0.85em; color: #8f8; min-height: 20px;">
                    <!-- Shows most recent skill practiced -->
                </div>
                <div style="text-align: center; margin-top: 5px; font-size: 0.8em;">
                    <span id="streak-display" class="streak-display" style="display: none;">🔥 Streak: <span id="streak-count">0</span></span>
                </div>
            </div>
            
            <div class="inventory-box">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <strong>INVENTORY & STATS:</strong>
                    <button class="btn small" onclick="openInventoryManager()" style="padding: 4px 8px; width: auto;">📦 Manage</button>
                </div>
                <div class="inv-item">HP: <span id="inv-hp">100</span>/<span id="inv-max-hp">100</span></div>
                <div class="inv-item">
                    Weight: <span id="inv-weight-display"><span id="inv-weight-unknown" onclick="calculateWeightCheck()" style="color: #ff0; cursor: pointer; text-decoration: underline;">?</span></span><span id="inv-weight-known" style="display: none;"><span id="inv-weight">0</span>/<span id="inv-max-weight">100</span> lbs
                    <div class="weight-bar" style="display: inline-block; vertical-align: middle; margin-left: 8px;">
                        <div class="weight-fill" id="weight-fill" style="width: 0%;"></div>
                    </div></span>
                </div>
                <div class="inv-item" style="margin-top: 8px;"><strong>WEAPONS:</strong></div>
                <div class="inv-item">Slot 1: <span id="inv-weapon1">Glock 17</span> <span id="inv-weapon1-durability" onclick="calculateDurabilityCheck(1)" style="color: #ff0; cursor: pointer; text-decoration: underline;">[?%]</span> <span id="inv-weapon1-ammo" style="color: #ff0;"></span> <span id="inv-weapon1-active" style="color: #0f0;">[ACTIVE]</span></div>
                <div class="inv-item">Slot 2: <span id="inv-weapon2">Hunting Knife</span> <span id="inv-weapon2-durability" onclick="calculateDurabilityCheck(2)" style="color: #ff0; cursor: pointer; text-decoration: underline;">[?%]</span> <span id="inv-weapon2-ammo" style="color: #ff0;"></span> <span id="inv-weapon2-active" style="color: #0f0; display: none;">[ACTIVE]</span></div>
                <div class="inv-item" style="margin-top: 8px;"><strong>AMMUNITION:</strong></div>
                <div class="inv-item" id="inv-ammo-display" style="font-size: 0.9em;">
                    🔫 9mm: 24
                </div>
                <div class="inv-item" style="margin-top: 8px;">Med Kits: <span id="inv-medkits">2</span> | Items: <span id="inv-item-count">0</span></div>
                <div class="inv-item">Cash: <span id="inv-money">$50.00</span> 💵</div>
            </div>

            <!-- Vitals Display -->
            <div class="vitals-container">
                <div class="vitals-header">
                    <span>🏕️ SURVIVAL STATUS</span>
                    <span id="vitals-warning" style="color: #ff6b6b; display: none;">⚠️ CRITICAL</span>
                </div>
                <!-- Distance Tier Indicator -->
                <div id="distance-tier-indicator" class="distance-tier-display" style="display: none; text-align: center; padding: 8px; margin-bottom: 8px; border: 1px solid #444; border-radius: 5px; background: rgba(0,0,0,0.3);">
                    <div style="font-size: 0.8em; color: #888;">📍 CURRENT ZONE</div>
                    <div id="tier-name" style="font-size: 1.1em; font-weight: bold; color: #0f0;">Safe Zone</div>
                    <div style="font-size: 0.75em; margin-top: 3px;">
                        <span id="tier-distance" style="color: #aaa;">0 km from base</span> |
                        <span style="color: #f88;">⚔️ <span id="tier-enemy-mult">×1.0</span></span> |
                        <span style="color: #8f8;">💎 <span id="tier-loot-mult">×1.0</span></span>
                    </div>
                </div>
                <div class="vital-row">
                    <span class="vital-icon">🍖</span>
                    <span class="vital-label">Hunger</span>
                    <div class="vital-bar">
                        <div class="vital-fill hunger" id="hunger-fill" style="width: 100%;"></div>
                    </div>
                    <span class="vital-value" id="hunger-value">100</span>
                </div>
                <div class="vital-row">
                    <span class="vital-icon">💧</span>
                    <span class="vital-label">Thirst</span>
                    <div class="vital-bar">
                        <div class="vital-fill thirst" id="thirst-fill" style="width: 100%;"></div>
                    </div>
                    <span class="vital-value" id="thirst-value">100</span>
                </div>
                <div class="vital-row">
                    <span class="vital-icon">💤</span>
                    <span class="vital-label">Energy</span>
                    <div class="vital-bar">
                        <div class="vital-fill energy" id="energy-fill" style="width: 100%;"></div>
                    </div>
                    <span class="vital-value" id="energy-value">100</span>
                </div>
                <div class="vital-row">
                    <span class="vital-icon">🌡️</span>
                    <span class="vital-label">Warmth</span>
                    <div class="vital-bar">
                        <div class="vital-fill warmth" id="warmth-fill" style="width: 75%;"></div>
                    </div>
                    <span class="vital-value" id="warmth-value">75</span>
                </div>
                <div class="vitals-actions">
                    <button class="btn small" onclick="openEatMenu()">🍖 Eat</button>
                    <button class="btn small" onclick="openDrinkMenu()">💧 Drink</button>
                    <button class="btn small" onclick="openFieldCamp()">⛺ Camp</button>
                    <button class="btn small" onclick="startReturnToBase()" style="background: #4a6741;" id="return-base-btn">🏕️ Return (<span id="return-distance">0</span> km)</button>
                </div>
            </div>

            <!-- Inventory Manager Popup -->
            <div id="inventory-manager" class="inventory-panel" style="display: none;">
                <div class="inventory-header">
                    <strong>📦 INVENTORY</strong>
                    <span>Weight: <span id="mgr-weight">0</span>/<span id="mgr-max-weight">100</span> lbs</span>
                </div>
                <div id="inventory-list"></div>
                <div style="margin-top: 15px; display: flex; gap: 10px;">
                    <button class="btn" onclick="closeInventoryManager()" style="flex: 1;">CLOSE</button>
                </div>
            </div>
            
            <div id="exploration-narrative" class="story-text"></div>
            <div id="exploration-choices"></div>

            <!-- Save/Menu Button -->
            <div style="position: fixed; bottom: 10px; right: 10px; z-index: 100;">
                <button id="save-btn" class="btn" onclick="manualSave()" style="padding: 8px 12px; font-size: 0.85em;" title="Save Game">💾 Save</button>
                <button class="btn" onclick="showMainMenu()" style="padding: 8px 12px; font-size: 0.85em; margin-left: 5px;" title="Main Menu">🏠 Menu</button>
            </div>
            
            <div id="exploration-math" class="math-section" style="display: none;">
                <div class="math-problem" id="explore-problem"></div>
                <input type="number" class="answer-input" id="explore-answer" placeholder="Enter answer">
                <button class="btn" onclick="submitExplorationAnswer()">CONFIRM</button>
                <button class="btn" onclick="cancelExploration()">CANCEL</button>
            </div>
            
            <!-- Trading Post -->
            <div id="trading-post" class="shop-container" style="display: none;">
                <div class="shop-header">🏪 TRADING POST 🏪</div>
                <div class="caps-display">
                    Your Cash: <span id="shop-money">$50.00</span> 💵 |
                    Weight: <span id="shop-weight">0</span>/<span id="shop-max-weight">100</span> lbs
                </div>
                
                <div class="shop-tabs">
                    <div class="shop-tab active" id="tab-buy" onclick="switchShopTab('buy')">🛒 BUY</div>
                    <div class="shop-tab" id="tab-sell" onclick="switchShopTab('sell')">💰 SELL</div>
                    <div class="shop-tab" id="tab-invest" onclick="switchShopTab('invest')">📈 INVEST</div>
                </div>
                
                <div id="shop-buy-section" class="shop-section active">
                    <div id="shop-items"></div>
                </div>
                
                <div id="shop-sell-section" class="shop-section">
                    <div id="sell-items"></div>
                </div>
                
                <div id="shop-invest-section" class="shop-section">
                    <div style="background: rgba(100,200,100,0.1); border: 1px solid #4a4; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                        <h3 style="color: #4f4; margin-bottom: 10px;">📈 WASTELAND INVESTMENT FUND</h3>
                        <p style="font-size: 0.9em; color: #aaa;">The trader offers investment opportunities. Calculate compound interest to earn returns!</p>
                    </div>
                    <div id="invest-options"></div>
                </div>
                
                <div id="shop-math" class="math-section" style="display: none; margin-top: 15px;">
                    <div class="math-problem" id="shop-problem"></div>
                    <input type="number" class="answer-input" id="shop-answer" placeholder="Enter answer">
                    <button class="btn support" onclick="submitShopAnswer()">CONFIRM</button>
                    <button class="btn" onclick="cancelShopPurchase()">CANCEL</button>
                </div>
                <button class="btn" onclick="leaveShop()" id="leave-shop-btn" style="margin-top: 15px;">LEAVE SHOP</button>
            </div>
            
            <!-- Crafting Workbench -->
            <div id="crafting-bench" class="crafting-container" style="display: none;">
                <div class="crafting-header">🔧 WORKBENCH 🔧</div>
                <div class="materials-display" id="materials-display">
                    <strong>Your Materials:</strong><br>
                    <span id="materials-list">None</span>
                </div>
                <div id="recipe-list"></div>
                <div id="crafting-math" class="math-section" style="display: none; margin-top: 15px;">
                    <div class="math-problem" id="craft-problem"></div>
                    <input type="number" class="answer-input" id="craft-answer" placeholder="Enter answer">
                    <button class="btn support" onclick="submitCraftAnswer()">CRAFT</button>
                    <button class="btn" onclick="cancelCraft()">CANCEL</button>
                </div>
                <button class="btn" onclick="leaveCrafting()" id="leave-craft-btn" style="margin-top: 15px;">LEAVE WORKBENCH</button>
            </div>
            
            <!-- Hacking Terminal -->
            <div id="hacking-terminal" class="terminal-container" style="display: none;">
                <div class="terminal-header">◈ ROBCO INDUSTRIES TERMINAL ◈</div>
                <div class="hack-progress" id="hack-progress"></div>
                <div class="terminal-screen">
                    <div class="terminal-prompt" id="hack-prompt"></div>
                    <div class="terminal-sequence" id="hack-sequence"></div>
                </div>
                <div id="hack-input-area">
                    <input type="text" class="terminal-input" id="hack-answer" placeholder="ENTER SOLUTION">
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button class="btn" onclick="submitHackAnswer()" style="flex: 1; background: #0f0; color: #000;">SUBMIT</button>
                        <button class="btn" onclick="exitHacking()" style="flex: 1;">EXIT</button>
                    </div>
                </div>
            </div>
            
            <!-- Lockpicking -->
            <div id="lockpick-screen" class="lockpick-container" style="display: none;">
                <div class="lockpick-header">🔐 LOCKED CONTAINER 🔐</div>
                <div class="lock-display" id="lock-display"></div>
                <div class="lockpick-hint" id="lock-hint"></div>
                <div id="lock-input-area">
                    <input type="number" class="answer-input" id="lock-answer" placeholder="Enter number">
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button class="btn support" onclick="submitLockAnswer()">TRY</button>
                        <button class="btn" onclick="exitLockpick()">GIVE UP</button>
                    </div>
                </div>
            </div>
            
            <div id="exploration-messages"></div>
        </div>
        
        <!-- Combat Screen -->
        <div id="combat-screen" class="screen">
            <div id="narrative-text" class="story-text" style="margin-bottom: 10px; padding: 10px;"></div>
            
            <div class="combat-layout">
                <div class="grid-container">
                    <div class="grid-title">TACTICAL MAP <span id="grid-mode-text">(Select action below)</span></div>
                    <div class="combat-grid" id="combat-grid"></div>
                    <div class="legend">
                        <div class="legend-item"><div class="legend-icon" style="background: rgba(0,255,0,0.4);">☺</div> You</div>
                        <div class="legend-item"><div class="legend-icon" style="background: rgba(255,0,0,0.4);">☠</div> Enemy</div>
                        <div class="legend-item"><div class="legend-icon" style="background: rgba(255,165,0,0.4);">☢</div> Explosive</div>
                        <div class="legend-item"><div class="legend-icon" style="background: rgba(150,50,200,0.4);">⚙</div> Trap</div>
                    </div>
                    <div class="cover-legend">
                        <strong>COVER:</strong>
                        <div class="cover-legend-item"><div class="legend-icon" style="background: rgba(100,100,100,0.4);">░</div> Small (-15% dmg)</div>
                        <div class="cover-legend-item"><div class="legend-icon" style="background: rgba(120,100,60,0.6);">▒</div> Medium (-30% dmg)</div>
                        <div class="cover-legend-item"><div class="legend-icon" style="background: rgba(80,80,80,0.9);">█</div> Wall (Blocks LOS)</div>
                    </div>
                </div>
                
                <div class="side-panel">
                    <div class="stat-box">
                        <h3>WANDERER</h3>
                        <div class="stat-line">HP: <span id="player-hp">100</span>/<span id="player-max-hp">100</span></div>
                        <div class="hp-bar"><div class="hp-fill" id="player-hp-bar" style="width: 100%">100</div></div>
                        <div class="stat-line">AP: <span id="player-ap">100</span>/<span id="player-max-ap">100</span></div>
                        <div class="ap-bar"><div class="ap-fill" id="player-ap-bar" style="width: 100%">100</div></div>
                        <div class="stat-line">Pos: (<span id="player-x">1</span>, <span id="player-y">5</span>)</div>
                    </div>
                    
                    <div class="stat-box" style="border-color: #ff0;">
                        <h3 style="color: #ff0;">WEAPONS</h3>
                        <div id="weapon-slot-1" class="weapon-slot active" onclick="switchWeapon(1)">
                            <span class="weapon-name" id="weapon1-name">Glock 17</span>
                            <span class="weapon-stats" id="weapon1-stats">Dmg: 22 | Acc: 52%</span>
                            <span class="weapon-range" id="weapon1-range">Range: 1-8 sq</span>
                        </div>
                        <div id="weapon-slot-2" class="weapon-slot" onclick="switchWeapon(2)">
                            <span class="weapon-name" id="weapon2-name">Hunting Knife</span>
                            <span class="weapon-stats" id="weapon2-stats">Dmg: 18 | Acc: 68%</span>
                            <span class="weapon-range" id="weapon2-range">Range: 0-1 sq</span>
                        </div>
                        <div style="font-size: 0.7em; color: #888; margin-top: 5px; text-align: center;">Click to switch weapon</div>
                    </div>
                    
                    <div class="stat-box" style="border-color: #f00;">
                        <h3 style="color: #f44;">ENEMIES <span id="enemies-alive-count"></span></h3>
                        <div id="enemy-list-container">
                            <!-- Enemy list populated dynamically -->
                        </div>
                        <div id="target-controls" style="display: none; margin-top: 8px; text-align: center;">
                            <button onclick="cycleTarget(-1)" class="btn" style="padding: 2px 8px; font-size: 0.8em;">◄ Prev</button>
                            <span style="margin: 0 8px; color: #ff0;">TARGET</span>
                            <button onclick="cycleTarget(1)" class="btn" style="padding: 2px 8px; font-size: 0.8em;">Next ►</button>
                        </div>
                        <div id="targeted-enemy-details" style="margin-top: 8px; border-top: 1px solid #444; padding-top: 8px;">
                            <div class="stat-line"><strong id="enemy-name">ENEMY</strong></div>
                            <div class="stat-line">HP: <span id="enemy-hp">80</span>/<span id="enemy-max-hp">80</span></div>
                            <div class="hp-bar"><div class="hp-fill" id="enemy-hp-bar" style="width: 100%">80</div></div>
                            <div class="stat-line">Pos: (<span id="enemy-x">10</span>, <span id="enemy-y">5</span>)</div>
                            <div class="stat-line">Type: <span id="enemy-type">Ranged</span></div>
                        </div>
                    </div>
                    
                    <div class="distance-calc">
                        <strong>Distance (5 ft/square):</strong>
                        <div id="distance-display" style="margin-top: 5px;">
                            <span id="current-distance">9</span> squares (<span id="current-feet">45</span> ft)
                        </div>
                        <div id="los-status" style="margin-top: 5px; font-weight: bold;">
                            LOS: <span id="los-text">Checking...</span>
                        </div>
                        <div id="range-status" style="margin-top: 5px; font-size: 0.85em;">
                            Range: <span id="range-text">Checking...</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="mode-indicator" class="mode-indicator" style="display: none;"></div>
            
            <div id="choice-phase">
                <div style="background: rgba(0,255,0,0.1); border: 1px solid #0f0; padding: 8px; margin-bottom: 10px; border-radius: 5px; text-align: center; font-size: 0.9em;">
                    <strong>AP COSTS:</strong> Move = 5/sq | Attack = Weapon AP | Med Kit = 30 | Flee = 50 | Hazard/Trap = 15<br>
                    <span style="color: #888; font-size: 0.85em;">Each square = 5 feet | Click weapon slots to switch</span>
                </div>
                <div class="action-grid">
                    <button class="btn move" onclick="enterMoveMode()">🚶 MOVE <span class="ap-cost-tag">5 AP/sq</span><br><span style="font-size:0.8em">Click grid to move</span></button>
                    <button class="btn combat" onclick="enterAttackMode()" id="attack-btn">🎯 ATTACK <span class="ap-cost-tag" id="attack-ap-cost">13 AP</span><br><span style="font-size:0.8em" id="attack-weapon-info">Glock 17</span></button>
                    <button class="btn support" onclick="useMedKit()" id="stimpak-btn">💉 MED KIT <span class="ap-cost-tag">30 AP</span><br><span style="font-size:0.8em">Heals 40% max HP</span></button>
                    <button class="btn move" onclick="attemptFlee()" id="flee-btn">🏃 FLEE <span class="ap-cost-tag">50 AP</span><br><span style="font-size:0.8em">Math challenge to escape</span></button>
                    <button class="btn" onclick="takeCover()" id="cover-btn" style="background: #456;">🛡️ TAKE COVER <span class="ap-cost-tag">15 AP</span><br><span style="font-size:0.8em" id="cover-status">+15% accuracy</span></button>
                    <button class="btn" onclick="steadyAim()" id="steady-btn" style="background: #654;">🎯 STEADY AIM <span class="ap-cost-tag">20 AP</span><br><span style="font-size:0.8em" id="steady-status">+10% next attack</span></button>
                    <button class="btn" onclick="endTurn()" style="grid-column: span 2;">⏭ END TURN<br><span style="font-size:0.8em">Enemy acts, AP resets</span></button>
                </div>
                <div id="env-actions"></div>
            </div>
            
            <div id="math-phase" class="math-section" style="display: none;">
                <div class="math-problem" id="math-problem"></div>
                <input type="number" class="answer-input" id="answer-input" placeholder="Enter answer">
                <div style="display: flex; gap: 10px;">
                    <button class="btn" onclick="submitAnswer()" style="flex: 1;">CONFIRM</button>
                    <button class="btn" onclick="cancelAction()" style="flex: 1;">CANCEL</button>
                </div>
            </div>
            
            <div id="message-area"></div>
        </div>

        <!-- Tutorial Tip Toast -->
        <div id="tutorial-tip" class="tutorial-tip">
            <div class="tutorial-tip-icon">💡</div>
            <div class="tutorial-tip-content">
                <div class="tutorial-tip-title" id="tutorial-tip-title">Tip</div>
                <div class="tutorial-tip-text" id="tutorial-tip-text"></div>
                <span class="tutorial-disable" onclick="disableTutorial()">Don't show tips</span>
            </div>
            <button class="tutorial-tip-dismiss" onclick="dismissTutorialTip()">Got it</button>
        </div>

        <!-- Popup Modal -->
        <div id="popup-overlay" class="popup-overlay">
            <div id="popup-box" class="popup-box">
                <div id="popup-title" class="popup-title">RESULT</div>
                <div id="popup-content" class="popup-content"></div>
                <button class="popup-btn" onclick="closePopup()">OK</button>
            </div>
        </div>
        
        <!-- Game Over Screen -->
        <div id="gameover-screen" class="screen">
            <div class="story-text">
                <h2 style="text-align: center; margin-bottom: 15px;" id="gameover-title">JOURNEY ENDED</h2>
                <p style="text-align: center; font-size: 1.2em; margin: 20px 0;" id="gameover-text"></p>
                <div style="text-align: center; margin: 10px 0;">
                    <strong>📊 FINAL STATS</strong><br><br>
                    <strong>Distance:</strong> <span id="final-distance">0</span> km<br>
                    <strong>Encounters:</strong> <span id="final-encounters">0</span><br>
                    <strong>Cash:</strong> <span id="final-money">$0.00</span><br><br>
                    <strong>🧮 MATH PERFORMANCE</strong><br>
                    <strong>Correct:</strong> <span id="final-correct">0</span> / <span id="final-attempted">0</span><br>
                    <strong>Accuracy:</strong> <span id="final-accuracy">0</span>%<br>
                    <strong>Best Streak:</strong> <span id="final-streak">0</span> 🔥
                </div>
            </div>
            <button class="btn" onclick="restartGame()">🎮 NEW JOURNEY</button>
        </div>

        <!-- Base Building Screen -->
        <div id="base-screen" class="screen">
            <div class="base-header">
                <h2>🏕️ <span id="base-name">Camp</span> - Home Base</h2>
                <div class="base-resources">
                    <span class="resource-item">🪵 Wood: <span id="base-wood">20</span></span>
                    <span class="resource-item">🔩 Steel: <span id="base-steel">10</span></span>
                </div>
            </div>

            <!-- Player Stats at Base -->
            <div class="base-player-stats" style="background: rgba(0,255,0,0.05); border: 1px solid #0f0; padding: 10px; margin: 10px 0; border-radius: 5px;">
                <div style="display: flex; justify-content: space-between; flex-wrap: wrap; gap: 10px;">
                    <span>❤️ HP: <span id="base-hp">100</span>/<span id="base-max-hp">100</span></span>
                    <span>🍖 Hunger: <span id="base-hunger">100</span></span>
                    <span>💧 Thirst: <span id="base-thirst">100</span></span>
                    <span>💤 Energy: <span id="base-energy">100</span></span>
                    <span>💵 Cash: <span id="base-money">$50.00</span></span>
                </div>
            </div>

            <div class="base-grid-container">
                <div class="base-grid" id="base-grid">
                    <!-- 6x4 grid generated by JS -->
                </div>
            </div>

            <div class="base-info-panel">
                <div class="base-benefits" id="base-benefits">
                    <strong>🏠 Base Benefits:</strong>
                    <div id="benefits-list">No buildings yet. Build a Shelter to get started!</div>
                </div>
            </div>

            <div class="base-build-panel" id="build-panel">
                <h3>🔨 Build Structure</h3>
                <div class="build-options" id="build-options">
                    <!-- Building options generated by JS -->
                </div>
            </div>

            <div class="base-actions">
                <button class="btn" onclick="startExploration()" style="background: #2a5a2a;">🗺️ Go Explore</button>
                <button class="btn" onclick="restAtBase()" id="base-rest-btn" style="display: none;">😴 Rest Here</button>
                <button class="btn" onclick="openBaseCooking()" id="base-cook-btn" style="display: none;">🍳 Cook Food</button>
                <button class="btn" onclick="openBaseEatMenu()" id="base-eat-btn">🍖 Eat</button>
                <button class="btn" onclick="openBaseDrinkMenu()" id="base-drink-btn">💧 Drink</button>
                <button class="btn" onclick="openWeaponStash()" style="background: #4a4a6a;">⚔️ Manage Weapons</button>
                <button class="btn" onclick="openRepairMenu()" id="base-repair-btn" style="background: #8b4513;">🔧 Repair Gear</button>
                <button class="btn" onclick="openHomeStash()" style="background: #5a3a1a;">📦 Storage Stash</button>
            </div>
        </div>
    </div>

    <!-- Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <script>
        // ============================================
        // SUPABASE & SKILL SYSTEM INTEGRATION
        // ============================================

        const SUPABASE_URL = 'https://joxvhzxkrcigknsdrusr.supabase.co';
        const SUPABASE_KEY = 'sb_publishable_xgvdFBaHCJKl9p-Lu61aZw_3oLkeTtc';

        // Skill system state
        var skillSystem = {
            supabase: null,
            currentUser: null,
            playerSkills: {},      // { skillName: { available: bool, mastery: number } }
            isConnected: false,
            isGuestMode: false,
            sessionStartTime: null,
            problemsAttempted: 0,
            problemsCorrect: 0
        };

        // Map portal skill names to game skill categories
        const SKILL_MAPPING = {
            // Elementary - Basic Arithmetic (K-2)
            'Counting and Number Recognition': { category: 'counting', minGrade: 'K' },
            'Place Value Understanding': { category: 'place_value', minGrade: 'K' },
            'Comparing Numbers': { category: 'comparing', minGrade: 'K' },
            'Skip Counting': { category: 'skip_counting', minGrade: '1' },
            'Time Telling': { category: 'time', minGrade: '1' },
            'Money and Coins': { category: 'money', minGrade: '1' },
            'Patterns and Sequences': { category: 'patterns', minGrade: '1' },
            'Basic Addition': { category: 'addition', minGrade: '1' },
            'Basic Subtraction': { category: 'subtraction', minGrade: '1' },

            // Elementary - Intermediate (3-5)
            'Multiplication': { category: 'multiplication', minGrade: '3' },
            'Division': { category: 'division', minGrade: '3' },
            'Basic Fractions': { category: 'fractions', minGrade: '3' },
            'Rounding and Estimation': { category: 'rounding', minGrade: '3' },
            'Basic Measurement': { category: 'measurement', minGrade: '2' },
            'Unit Conversion': { category: 'unit_conversion', minGrade: '4' },

            // Elementary - Advanced
            'Decimals': { category: 'decimals', minGrade: '4' },
            'Percentages': { category: 'percentages', minGrade: '5' },
            'Negatives': { category: 'negatives', minGrade: '6' },

            // Middle School
            'Ratio and Proportion': { category: 'ratios', minGrade: '6' },
            'Basic Algebraic Expressions': { category: 'algebra_basic', minGrade: '6' },
            'Solving Simple Equations': { category: 'equations_simple', minGrade: '6' },
            'Basic Graphing': { category: 'graphing', minGrade: '6' },
            'Data Collection': { category: 'data_collection', minGrade: '3' },
            'Mean Median Mode': { category: 'mean_median_mode', minGrade: '6' },

            // Geometry
            'Basic Geometry Concepts': { category: 'geometry_basic', minGrade: '3' },
            'Area and Perimeter': { category: 'area_perimeter', minGrade: '3' },
            'Angles and Lines': { category: 'angles', minGrade: '4' },
            'Volume': { category: 'volume', minGrade: '5' },
            'Triangles and Pythagorean Theorem': { category: 'pythagorean', minGrade: '8' },
            'Transformations': { category: 'transformations', minGrade: '8' },
            'Circles': { category: 'circles', minGrade: '7' },

            // Algebra
            'Linear Equations': { category: 'linear_equations', minGrade: '8' },
            'Quadratic Equations': { category: 'quadratics', minGrade: '9' },
            'Polynomials': { category: 'polynomials', minGrade: '9' },
            'Inequalities': { category: 'inequalities', minGrade: '7' },
            'Basic Functions': { category: 'functions', minGrade: '8' },

            // Advanced
            'Exponential and Logarithmic Functions': { category: 'exponential', minGrade: '10' },
            'Trigonometry': { category: 'trigonometry', minGrade: '10' },
            'Probability and Statistics': { category: 'probability', minGrade: '7' },
            'Sequence and Series': { category: 'sequences', minGrade: '11' },
            'Limits': { category: 'limits', minGrade: '12' },
            'Derivatives': { category: 'derivatives', minGrade: '12' },
            'Integrals': { category: 'integrals', minGrade: '12' }
        };

        // Initialize Supabase connection
        async function initializeSkillSystem() {
            try {
                // Create Supabase client
                skillSystem.supabase = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

                // Check for existing session
                const { data: { session }, error } = await skillSystem.supabase.auth.getSession();

                if (session && session.user) {
                    skillSystem.currentUser = session.user;
                    skillSystem.isConnected = true;
                    skillSystem.isGuestMode = false;
                    console.log('🎮 Skill System: Connected as', session.user.email);

                    // Load player's skills
                    await loadPlayerSkills();
                } else {
                    // Guest mode - all skills available for demo
                    console.log('🎮 Skill System: Guest mode (all skills available)');
                    skillSystem.isGuestMode = true;
                    enableAllSkillsForGuest();
                }

                skillSystem.sessionStartTime = new Date();

            } catch (err) {
                console.error('🎮 Skill System: Init error', err);
                skillSystem.isGuestMode = true;
                enableAllSkillsForGuest();
            }
        }

        // Load skills from Supabase
        async function loadPlayerSkills() {
            if (!skillSystem.supabase || !skillSystem.currentUser) return;

            try {
                const { data, error } = await skillSystem.supabase
                    .from('skill_progress')
                    .select('skill_name, state, mastery_score')
                    .eq('user_id', skillSystem.currentUser.id)
                    .eq('subject', 'Math')
                    .in('state', ['available', 'in_progress', 'mastered', 'activated']);

                if (error) throw error;

                // Build skills map
                skillSystem.playerSkills = {};
                if (data) {
                    data.forEach(skill => {
                        skillSystem.playerSkills[skill.skill_name] = {
                            available: true,
                            mastery: skill.mastery_score || 0,
                            state: skill.state
                        };
                    });
                }

                console.log('🎮 Loaded', Object.keys(skillSystem.playerSkills).length, 'skills');

            } catch (err) {
                console.error('🎮 Error loading skills:', err);
                enableAllSkillsForGuest();
            }
        }

        // Enable all skills for guest/demo mode
        function enableAllSkillsForGuest() {
            skillSystem.playerSkills = {};
            Object.keys(SKILL_MAPPING).forEach(skillName => {
                skillSystem.playerSkills[skillName] = {
                    available: true,
                    mastery: 100,
                    state: 'mastered'
                };
            });
        }

        // Check if player has a specific skill
        function hasSkill(skillName) {
            if (skillSystem.isGuestMode) return true;
            return skillSystem.playerSkills[skillName]?.available === true;
        }

        // Get skill mastery level (0-100)
        function getSkillMastery(skillName) {
            if (skillSystem.isGuestMode) return 100;
            return skillSystem.playerSkills[skillName]?.mastery || 0;
        }

        // Check if player has any skill in a category
        function hasSkillCategory(category) {
            if (skillSystem.isGuestMode) return true;

            for (const [skillName, mapping] of Object.entries(SKILL_MAPPING)) {
                if (mapping.category === category && hasSkill(skillName)) {
                    return true;
                }
            }
            return false;
        }

        // Get the skill name for a category
        function getSkillForCategory(category) {
            for (const [skillName, mapping] of Object.entries(SKILL_MAPPING)) {
                if (mapping.category === category) {
                    return skillName;
                }
            }
            return null;
        }

        // Grade level order for comparison
        const GRADE_ORDER = ['K', 'K-1', '1', '2', '3', '4', '5', '5-6', '6', '7', '7-8', '8', '9', '9-12', '10', '11', '12'];

        // Determine player's effective grade level based on their highest unlocked skill
        function getPlayerGradeLevel() {
            // Guest mode = max difficulty
            if (skillSystem.isGuestMode) return '9-12';

            // No skills = easiest
            if (Object.keys(skillSystem.playerSkills).length === 0) return 'K-1';

            // Find the highest grade skill the player has
            var highestGradeIndex = 0;
            for (const [skillName, mapping] of Object.entries(SKILL_MAPPING)) {
                if (hasSkill(skillName)) {
                    var gradeIndex = GRADE_ORDER.indexOf(mapping.minGrade);
                    if (gradeIndex > highestGradeIndex) {
                        highestGradeIndex = gradeIndex;
                    }
                }
            }

            // Map the grade back to our grade level categories
            var grade = GRADE_ORDER[highestGradeIndex];
            if (grade === 'K' || grade === '1') return 'K-1';
            if (grade === '2') return '2';
            if (grade === '3') return '3';
            if (grade === '4') return '4';
            if (grade === '5' || grade === '6') return '5-6';
            if (grade === '7' || grade === '8') return '7-8';
            return '9-12';
        }

        // Log a practice session to Supabase
        async function logPracticeSession(skillName, correct, problemData) {
            skillSystem.problemsAttempted++;
            if (correct) skillSystem.problemsCorrect++;

            if (!skillSystem.supabase || !skillSystem.currentUser || skillSystem.isGuestMode) {
                return; // Don't log for guests
            }

            try {
                const sessionData = {
                    user_id: skillSystem.currentUser.id,
                    subject: 'Math',
                    skill_name: skillName,
                    source_type: 'game',
                    game_id: 'wasteland_adventure',
                    score: correct ? 100 : 0,
                    correct_count: correct ? 1 : 0,
                    total_count: 1,
                    started_at: new Date().toISOString()
                };

                const { error } = await skillSystem.supabase
                    .from('skill_practice_sessions')
                    .insert(sessionData);

                if (error) {
                    console.error('🎮 Error logging practice:', error);
                }

            } catch (err) {
                console.error('🎮 Practice logging failed:', err);
            }
        }

        // Show skill progress notification after solving a problem
        function showSkillProgress(skillName, correct) {
            var mastery = getSkillMastery(skillName);
            var masteryDelta = correct ? 5 : 0; // Gain 5% mastery on correct answer

            // Update local mastery tracking (actual update happens in Supabase)
            if (skillSystem.playerSkills[skillName] && correct) {
                skillSystem.playerSkills[skillName].mastery = Math.min(100, mastery + masteryDelta);
            }

            // Update the recent skill progress display
            var recentEl = document.getElementById('recent-skill-progress');
            if (recentEl) {
                var newMastery = Math.min(100, mastery + masteryDelta);
                var icon = correct ? '✓' : '✗';
                var color = correct ? '#8f8' : '#f88';
                var progressHtml = '<span style="color: ' + color + ';">' + icon + '</span> ' + skillName;
                if (correct && masteryDelta > 0) {
                    progressHtml += ' <span style="color: #a855f7;">(+' + masteryDelta + '% → ' + newMastery + '%)</span>';
                }
                recentEl.innerHTML = progressHtml;

                // Show skill bar for the current skill
                var skillBarHtml = '<div class="skill-bar" style="margin-top: 5px;">';
                var barClass = newMastery >= 100 ? 'mastered' : '';
                skillBarHtml += '<div class="skill-fill ' + barClass + '" style="width: ' + newMastery + '%;"></div>';
                skillBarHtml += '</div>';
                recentEl.innerHTML += skillBarHtml;

                // Celebration for mastery
                if (newMastery >= 100 && mastery < 100) {
                    recentEl.innerHTML += '<div style="color: #ffd700; margin-top: 5px;">🎉 SKILL MASTERED!</div>';
                }
            }

            // Update mastered count
            updateXPDisplay();
        }

        // Get available solution options for a challenge
        function getSolutionOptions(challenge) {
            // challenge = {
            //   title: "Locked Door",
            //   options: [
            //     { id: 'force', label: 'Force it open', skill: 'Basic Subtraction', problem: {...} },
            //     { id: 'pick', label: 'Pick the lock', skill: 'Multiplication', problem: {...} },
            //     ...
            //   ]
            // }

            return challenge.options.map(option => {
                const available = hasSkill(option.skill);
                const mastery = getSkillMastery(option.skill);

                return {
                    ...option,
                    available: available,
                    mastery: mastery,
                    locked: !available,
                    masteryBonus: mastery >= 80 // Mastered skills might get bonuses
                };
            });
        }

        // Display solution options UI (Fallout-style)
        function showSolutionOptions(challenge, onSelect) {
            const options = getSolutionOptions(challenge);

            let html = '<div class="solution-options">';
            html += '<h3 class="solution-title">' + challenge.title + '</h3>';
            html += '<p class="solution-description">' + (challenge.description || 'Choose your approach:') + '</p>';

            options.forEach((opt, index) => {
                const statusClass = opt.locked ? 'locked' : (opt.masteryBonus ? 'mastered' : 'available');
                const statusIcon = opt.locked ? '🔒' : (opt.masteryBonus ? '⭐' : '✓');

                html += '<div class="solution-option ' + statusClass + '" data-index="' + index + '">';
                html += '<div class="option-header">';
                html += '<span class="option-icon">' + statusIcon + '</span>';
                html += '<span class="option-label">' + opt.label + '</span>';
                html += '</div>';
                html += '<div class="option-skill">';
                html += 'Requires: <strong>' + opt.skill + '</strong>';
                if (opt.locked) {
                    html += ' <span class="skill-locked">(Not Unlocked)</span>';
                } else if (opt.masteryBonus) {
                    html += ' <span class="skill-mastered">(Mastered - Bonus!)</span>';
                }
                html += '</div>';
                if (!opt.locked && opt.preview) {
                    html += '<div class="option-preview">' + opt.preview + '</div>';
                }
                html += '</div>';
            });

            html += '</div>';

            // Show in a modal/popup
            const overlay = document.createElement('div');
            overlay.className = 'solution-overlay';
            overlay.innerHTML = html;
            document.body.appendChild(overlay);

            // Add click handlers
            overlay.querySelectorAll('.solution-option:not(.locked)').forEach(el => {
                el.addEventListener('click', function() {
                    const index = parseInt(this.dataset.index);
                    document.body.removeChild(overlay);
                    onSelect(options[index]);
                });
            });
        }

        // ============================================
        // VISUAL MATH SYSTEM (K-2 Support)
        // ============================================

        // Visual math state
        var visualMathState = {
            currentType: null,
            currentAnswer: 0,
            correctAnswer: 0,
            onComplete: null,
            skillName: null,
            problemData: null
        };

        // Object icons for counting (themed to wasteland)
        const COUNT_OBJECTS = {
            bullets: '🔫',
            money: '💵',
            food: '🥫',
            water: '💧',
            meds: '💊',
            scrap: '⚙️',
            ammo: '🎯',
            meat: '🍖'
        };

        // Format money as $X.XX from cents
        function formatMoney(cents) {
            if (cents === undefined || cents === null) cents = 0;
            var dollars = Math.floor(cents / 100);
            var remainingCents = Math.abs(cents % 100);
            return '$' + dollars + '.' + (remainingCents < 10 ? '0' : '') + remainingCents;
        }

        // Parse money string like "$5.25" or "5.25" to cents
        function parseMoney(str) {
            if (typeof str === 'number') return Math.round(str * 100);
            str = str.replace('$', '').trim();
            var parts = str.split('.');
            var dollars = parseInt(parts[0]) || 0;
            var cents = parseInt(parts[1]) || 0;
            if (parts[1] && parts[1].length === 1) cents *= 10; // Handle "5.5" as $5.50
            return dollars * 100 + cents;
        }

        // Create a visual math problem overlay
        function showVisualMathProblem(options) {
            // options = {
            //   type: 'counting' | 'coins' | 'shapes' | 'comparison' | 'tenFrame' | 'base10' | 'numberLine',
            //   question: "How many bullets?",
            //   data: {...}, // type-specific data
            //   correctAnswer: number or string,
            //   skillName: "Counting and Number Recognition",
            //   onComplete: function(correct, answer) {...}
            // }

            visualMathState = {
                currentType: options.type,
                currentAnswer: null,
                correctAnswer: options.correctAnswer,
                onComplete: options.onComplete,
                skillName: options.skillName,
                problemData: options
            };

            const overlay = document.createElement('div');
            overlay.className = 'visual-math-overlay';
            overlay.id = 'visual-math-overlay';

            let contentHTML = '<div class="visual-math-container">';
            contentHTML += '<h3 class="visual-math-title">' + options.question + '</h3>';

            if (options.instruction) {
                contentHTML += '<p class="visual-math-instruction">' + options.instruction + '</p>';
            }

            // Generate content based on type
            switch (options.type) {
                case 'counting':
                    contentHTML += generateCountingUI(options.data);
                    break;
                case 'coins':
                    contentHTML += generateCoinUI(options.data);
                    break;
                case 'shapes':
                    contentHTML += generateShapeUI(options.data);
                    break;
                case 'comparison':
                    contentHTML += generateComparisonUI(options.data);
                    break;
                case 'tenFrame':
                    contentHTML += generateTenFrameUI(options.data);
                    break;
                case 'base10':
                    contentHTML += generateBase10UI(options.data);
                    break;
                case 'numberLine':
                    contentHTML += generateNumberLineUI(options.data);
                    break;
            }

            // Add answer display for types that need it
            if (['counting', 'coins', 'tenFrame'].includes(options.type)) {
                contentHTML += '<div class="visual-answer-display">';
                contentHTML += '<div class="visual-answer-label">Your answer:</div>';
                contentHTML += '<div class="visual-answer-value" id="visual-answer">0</div>';
                contentHTML += '</div>';
            }

            contentHTML += '<button class="visual-submit-btn" id="visual-submit-btn" onclick="submitVisualAnswer()">Submit Answer</button>';
            contentHTML += '</div>';

            overlay.innerHTML = contentHTML;
            document.body.appendChild(overlay);

            // Initialize interactivity based on type
            setTimeout(() => {
                switch (options.type) {
                    case 'counting':
                        initCountingInteraction();
                        break;
                    case 'coins':
                        initCoinInteraction();
                        break;
                    case 'shapes':
                        initShapeInteraction();
                        break;
                    case 'comparison':
                        initComparisonInteraction();
                        break;
                    case 'tenFrame':
                        initTenFrameInteraction();
                        break;
                    case 'numberLine':
                        initNumberLineInteraction();
                        break;
                }
            }, 100);
        }

        // === COUNTING OBJECTS ===
        function generateCountingUI(data) {
            // data = { objectType: 'bullets', count: 7 }
            const icon = COUNT_OBJECTS[data.objectType] || '⭐';
            let html = '<div class="counting-area" id="counting-area">';

            // Create objects in random-ish positions
            for (let i = 0; i < data.count; i++) {
                html += '<div class="count-object" data-index="' + i + '">' + icon + '</div>';
            }

            html += '</div>';
            html += '<p style="text-align: center; color: #888; margin-top: 10px;">Click each item to count it!</p>';
            return html;
        }

        function initCountingInteraction() {
            const objects = document.querySelectorAll('.count-object');
            let counted = 0;

            objects.forEach(obj => {
                obj.addEventListener('click', function() {
                    if (!this.classList.contains('selected')) {
                        this.classList.add('selected');
                        counted++;
                        document.getElementById('visual-answer').textContent = counted;
                        visualMathState.currentAnswer = counted;
                    }
                });
            });
        }

        // === COIN SYSTEM ===
        function generateCoinUI(data) {
            // data = { coins: [{type: 'quarter', count: 2}, {type: 'dime', count: 3}], targetCents: 75 }
            let html = '<div class="coin-area">';

            // Coin tray (available coins)
            html += '<p style="text-align: center; color: #0f0;">Available Coins:</p>';
            html += '<div class="coin-tray" id="coin-tray">';

            data.coins.forEach((coinGroup, groupIndex) => {
                for (let i = 0; i < coinGroup.count; i++) {
                    const coinValue = getCoinValue(coinGroup.type);
                    html += '<div class="coin ' + coinGroup.type + '" draggable="true" data-value="' + coinValue + '" data-id="' + groupIndex + '-' + i + '">';
                    html += getCoinLabel(coinGroup.type);
                    html += '</div>';
                }
            });

            html += '</div>';

            // Drop zone
            html += '<p style="text-align: center; color: #0f0; margin-top: 15px;">Drag coins here to make ' + data.targetCents + '¢:</p>';
            html += '<div class="coin-drop-zone" id="coin-drop-zone"></div>';
            html += '<div class="coin-total" id="coin-total">Total: 0¢</div>';

            html += '</div>';
            return html;
        }

        function getCoinValue(type) {
            const values = { penny: 1, nickel: 5, dime: 10, quarter: 25 };
            return values[type] || 0;
        }

        function getCoinLabel(type) {
            const labels = { penny: '1¢', nickel: '5¢', dime: '10¢', quarter: '25¢' };
            return labels[type] || '';
        }

        function initCoinInteraction() {
            const tray = document.getElementById('coin-tray');
            const dropZone = document.getElementById('coin-drop-zone');
            let totalCents = 0;

            function updateTotal() {
                const droppedCoins = dropZone.querySelectorAll('.coin');
                totalCents = 0;
                droppedCoins.forEach(coin => {
                    totalCents += parseInt(coin.dataset.value);
                });
                document.getElementById('coin-total').textContent = 'Total: ' + totalCents + '¢';
                document.getElementById('visual-answer').textContent = totalCents + '¢';
                visualMathState.currentAnswer = totalCents;
            }

            // Drag events for coins
            const coins = document.querySelectorAll('.coin');
            coins.forEach(coin => {
                coin.addEventListener('dragstart', function(e) {
                    e.dataTransfer.setData('text/plain', this.dataset.id);
                    this.classList.add('dragging');
                });

                coin.addEventListener('dragend', function() {
                    this.classList.remove('dragging');
                });

                // Touch support
                coin.addEventListener('touchstart', handleTouchStart, { passive: false });
                coin.addEventListener('touchmove', handleTouchMove, { passive: false });
                coin.addEventListener('touchend', handleTouchEnd);
            });

            // Drop zone events
            dropZone.addEventListener('dragover', function(e) {
                e.preventDefault();
                this.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', function() {
                this.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', function(e) {
                e.preventDefault();
                this.classList.remove('drag-over');
                const coinId = e.dataTransfer.getData('text/plain');
                const coin = document.querySelector('.coin[data-id="' + coinId + '"]');
                if (coin && coin.parentElement === tray) {
                    this.appendChild(coin);
                    updateTotal();
                }
            });

            // Click on coin in drop zone to return it
            dropZone.addEventListener('click', function(e) {
                if (e.target.classList.contains('coin')) {
                    tray.appendChild(e.target);
                    updateTotal();
                }
            });

            // Touch handling for mobile
            let touchCoin = null;
            let touchClone = null;

            function handleTouchStart(e) {
                e.preventDefault();
                touchCoin = e.target;
                touchClone = touchCoin.cloneNode(true);
                touchClone.style.position = 'fixed';
                touchClone.style.zIndex = '1000';
                touchClone.style.pointerEvents = 'none';
                document.body.appendChild(touchClone);
            }

            function handleTouchMove(e) {
                if (!touchClone) return;
                e.preventDefault();
                const touch = e.touches[0];
                touchClone.style.left = (touch.clientX - 25) + 'px';
                touchClone.style.top = (touch.clientY - 25) + 'px';
            }

            function handleTouchEnd(e) {
                if (!touchClone || !touchCoin) return;

                const touch = e.changedTouches[0];
                const dropRect = dropZone.getBoundingClientRect();
                const trayRect = tray.getBoundingClientRect();

                if (touch.clientX >= dropRect.left && touch.clientX <= dropRect.right &&
                    touch.clientY >= dropRect.top && touch.clientY <= dropRect.bottom) {
                    if (touchCoin.parentElement === tray) {
                        dropZone.appendChild(touchCoin);
                        updateTotal();
                    }
                } else if (touch.clientX >= trayRect.left && touch.clientX <= trayRect.right &&
                           touch.clientY >= trayRect.top && touch.clientY <= trayRect.bottom) {
                    if (touchCoin.parentElement === dropZone) {
                        tray.appendChild(touchCoin);
                        updateTotal();
                    }
                }

                document.body.removeChild(touchClone);
                touchClone = null;
                touchCoin = null;
            }
        }

        // === SHAPE RECOGNITION ===
        function generateShapeUI(data) {
            // data = { targetShape: 'triangle', shapes: ['circle', 'triangle', 'square', 'rectangle', 'pentagon', 'hexagon'] }
            let html = '<div class="shape-grid" id="shape-grid">';

            data.shapes.forEach((shape, index) => {
                html += '<div class="shape-option" data-shape="' + shape + '">';
                html += getShapeSVG(shape);
                html += '<div style="margin-top: 5px; font-size: 0.9em; color: #aaa;">' + shape + '</div>';
                html += '</div>';
            });

            html += '</div>';
            return html;
        }

        function getShapeSVG(shape) {
            const svgs = {
                circle: '<svg class="shape-svg" viewBox="0 0 60 60"><circle cx="30" cy="30" r="25"/></svg>',
                triangle: '<svg class="shape-svg" viewBox="0 0 60 60"><polygon points="30,5 55,55 5,55"/></svg>',
                square: '<svg class="shape-svg" viewBox="0 0 60 60"><rect x="5" y="5" width="50" height="50"/></svg>',
                rectangle: '<svg class="shape-svg" viewBox="0 0 60 60"><rect x="5" y="15" width="50" height="30"/></svg>',
                pentagon: '<svg class="shape-svg" viewBox="0 0 60 60"><polygon points="30,5 55,22 47,55 13,55 5,22"/></svg>',
                hexagon: '<svg class="shape-svg" viewBox="0 0 60 60"><polygon points="15,8 45,8 58,30 45,52 15,52 2,30"/></svg>',
                oval: '<svg class="shape-svg" viewBox="0 0 60 60"><ellipse cx="30" cy="30" rx="28" ry="18"/></svg>',
                diamond: '<svg class="shape-svg" viewBox="0 0 60 60"><polygon points="30,5 55,30 30,55 5,30"/></svg>',
                star: '<svg class="shape-svg" viewBox="0 0 60 60"><polygon points="30,5 35,22 55,22 40,35 45,55 30,42 15,55 20,35 5,22 25,22"/></svg>'
            };
            return svgs[shape] || svgs.circle;
        }

        function initShapeInteraction() {
            const options = document.querySelectorAll('.shape-option');

            options.forEach(opt => {
                opt.addEventListener('click', function() {
                    // Clear previous selection
                    options.forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                    visualMathState.currentAnswer = this.dataset.shape;
                });
            });
        }

        // === COMPARISON (>, <, =) ===
        function generateComparisonUI(data) {
            // data = { leftNumber: 5, rightNumber: 8 }
            let html = '<div class="comparison-container">';
            html += '<div class="comparison-number">' + data.leftNumber + '</div>';
            html += '<div class="comparison-symbols" id="comparison-symbols">';
            html += '<div class="comparison-symbol" data-symbol="<">&lt;</div>';
            html += '<div class="comparison-symbol" data-symbol="=">=</div>';
            html += '<div class="comparison-symbol" data-symbol=">">&gt;</div>';
            html += '</div>';
            html += '<div class="comparison-number">' + data.rightNumber + '</div>';
            html += '</div>';
            return html;
        }

        function initComparisonInteraction() {
            const symbols = document.querySelectorAll('.comparison-symbol');

            symbols.forEach(sym => {
                sym.addEventListener('click', function() {
                    symbols.forEach(s => s.classList.remove('selected'));
                    this.classList.add('selected');
                    visualMathState.currentAnswer = this.dataset.symbol;
                });
            });
        }

        // === TEN FRAME ===
        function generateTenFrameUI(data) {
            // data = { targetNumber: 7, mode: 'fill' | 'count' }
            let html = '<div class="ten-frame" id="ten-frame">';

            for (let i = 0; i < 10; i++) {
                const filled = data.mode === 'count' && i < data.prefilled;
                html += '<div class="ten-frame-cell' + (filled ? ' filled' : '') + '" data-index="' + i + '">';
                if (filled) html += '●';
                html += '</div>';
            }

            html += '</div>';

            if (data.mode === 'fill') {
                html += '<p style="text-align: center; color: #888;">Click cells to fill in ' + data.targetNumber + '</p>';
            } else {
                html += '<p style="text-align: center; color: #888;">How many dots are filled in?</p>';
            }

            return html;
        }

        function initTenFrameInteraction() {
            const cells = document.querySelectorAll('.ten-frame-cell');
            let filledCount = document.querySelectorAll('.ten-frame-cell.filled').length;

            // Update initial count
            document.getElementById('visual-answer').textContent = filledCount;
            visualMathState.currentAnswer = filledCount;

            cells.forEach(cell => {
                cell.addEventListener('click', function() {
                    if (this.classList.contains('filled')) {
                        this.classList.remove('filled');
                        this.textContent = '';
                        filledCount--;
                    } else {
                        this.classList.add('filled');
                        this.textContent = '●';
                        filledCount++;
                    }
                    document.getElementById('visual-answer').textContent = filledCount;
                    visualMathState.currentAnswer = filledCount;
                });
            });
        }

        // === BASE-10 BLOCKS ===
        function generateBase10UI(data) {
            // data = { number: 347 } - show hundreds, tens, ones
            const hundreds = Math.floor(data.number / 100);
            const tens = Math.floor((data.number % 100) / 10);
            const ones = data.number % 10;

            let html = '<div class="base10-area">';

            // Hundreds
            html += '<div class="base10-column">';
            html += '<div class="base10-label">Hundreds</div>';
            html += '<div class="base10-blocks">';
            for (let i = 0; i < hundreds; i++) {
                html += '<div class="base10-hundred"></div>';
            }
            html += '</div>';
            html += '</div>';

            // Tens
            html += '<div class="base10-column">';
            html += '<div class="base10-label">Tens</div>';
            html += '<div class="base10-blocks">';
            for (let i = 0; i < tens; i++) {
                html += '<div class="base10-ten"></div>';
            }
            html += '</div>';
            html += '</div>';

            // Ones
            html += '<div class="base10-column">';
            html += '<div class="base10-label">Ones</div>';
            html += '<div class="base10-blocks">';
            html += '<div class="base10-ones-group">';
            for (let i = 0; i < ones; i++) {
                html += '<div class="base10-one"></div>';
            }
            html += '</div>';
            html += '</div>';
            html += '</div>';

            html += '</div>';

            // Input for answer
            html += '<div style="text-align: center; margin-top: 20px;">';
            html += '<input type="number" id="base10-answer" class="terminal-input" style="width: 150px;" placeholder="Enter number" oninput="visualMathState.currentAnswer = parseInt(this.value) || 0;">';
            html += '</div>';

            return html;
        }

        // === NUMBER LINE ===
        function generateNumberLineUI(data) {
            // data = { min: 0, max: 20, targetNumber: 15, showTarget: false }
            let html = '<div class="number-line-container">';
            html += '<div class="number-line" id="number-line">';
            html += '<div class="number-line-track"></div>';

            // Create tick marks and labels
            const range = data.max - data.min;
            const tickInterval = range <= 10 ? 1 : Math.ceil(range / 10);

            for (let i = data.min; i <= data.max; i += tickInterval) {
                const pct = ((i - data.min) / range) * 100;
                html += '<div class="number-line-tick" style="left: ' + pct + '%;"></div>';
                html += '<div class="number-line-label" style="left: ' + pct + '%;">' + i + '</div>';
            }

            // Draggable marker
            html += '<div class="number-line-marker" id="number-line-marker" style="left: 50%;">';
            html += '<div class="number-line-result" id="marker-value">' + Math.round((data.max + data.min) / 2) + '</div>';
            html += '</div>';

            html += '</div>';

            if (data.showTarget) {
                html += '<p style="text-align: center; color: #0f0;">Move the marker to: ' + data.targetNumber + '</p>';
            }

            html += '</div>';
            return html;
        }

        function initNumberLineInteraction() {
            const marker = document.getElementById('number-line-marker');
            const line = document.getElementById('number-line');
            const valueDisplay = document.getElementById('marker-value');

            const data = visualMathState.problemData.data;
            const range = data.max - data.min;

            let isDragging = false;

            function updateMarkerPosition(clientX) {
                const rect = line.getBoundingClientRect();
                let pct = ((clientX - rect.left) / rect.width) * 100;
                pct = Math.max(0, Math.min(100, pct));

                const value = Math.round(data.min + (pct / 100) * range);

                marker.style.left = pct + '%';
                valueDisplay.textContent = value;
                visualMathState.currentAnswer = value;
            }

            marker.addEventListener('mousedown', function(e) {
                isDragging = true;
                marker.classList.add('dragging');
                e.preventDefault();
            });

            document.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    updateMarkerPosition(e.clientX);
                }
            });

            document.addEventListener('mouseup', function() {
                isDragging = false;
                marker.classList.remove('dragging');
            });

            // Touch support
            marker.addEventListener('touchstart', function(e) {
                isDragging = true;
                marker.classList.add('dragging');
                e.preventDefault();
            });

            document.addEventListener('touchmove', function(e) {
                if (isDragging && e.touches.length > 0) {
                    updateMarkerPosition(e.touches[0].clientX);
                }
            });

            document.addEventListener('touchend', function() {
                isDragging = false;
                marker.classList.remove('dragging');
            });

            // Click anywhere on line to move marker
            line.addEventListener('click', function(e) {
                if (e.target !== marker) {
                    updateMarkerPosition(e.clientX);
                }
            });

            // Set initial answer
            visualMathState.currentAnswer = Math.round((data.max + data.min) / 2);
        }

        // Submit the visual answer
        function submitVisualAnswer() {
            const overlay = document.getElementById('visual-math-overlay');
            const answer = visualMathState.currentAnswer;
            const correct = visualMathState.correctAnswer;

            // Check if answer matches
            let isCorrect = false;
            if (typeof correct === 'number') {
                isCorrect = answer === correct;
            } else if (typeof correct === 'string') {
                isCorrect = answer === correct;
            }

            // Log practice session
            if (visualMathState.skillName) {
                logPracticeSession(visualMathState.skillName, isCorrect, {
                    type: visualMathState.currentType,
                    answer: answer,
                    correctAnswer: correct
                });
            }

            // Show feedback briefly
            const btn = document.getElementById('visual-submit-btn');
            if (isCorrect) {
                btn.style.background = 'rgba(0, 200, 0, 0.8)';
                btn.textContent = '✓ Correct!';
            } else {
                btn.style.background = 'rgba(200, 0, 0, 0.8)';
                btn.textContent = '✗ The answer was ' + correct;
            }

            btn.disabled = true;

            // Close after delay
            setTimeout(() => {
                if (overlay && overlay.parentElement) {
                    document.body.removeChild(overlay);
                }

                if (visualMathState.onComplete) {
                    visualMathState.onComplete(isCorrect, answer);
                }
            }, 1500);
        }

        // Close visual math without submitting
        function closeVisualMath() {
            const overlay = document.getElementById('visual-math-overlay');
            if (overlay && overlay.parentElement) {
                document.body.removeChild(overlay);
            }
        }

        // Helper: Generate a K-2 appropriate math problem
        function generateVisualMathProblem(category, difficulty) {
            // difficulty: 'K', '1', '2'
            const problems = {
                counting: function() {
                    const objects = Object.keys(COUNT_OBJECTS);
                    const objectType = objects[Math.floor(Math.random() * objects.length)];
                    const maxCount = difficulty === 'K' ? 10 : (difficulty === '1' ? 20 : 30);
                    const count = Math.floor(Math.random() * maxCount) + 1;

                    return {
                        type: 'counting',
                        question: 'How many ' + objectType + ' can you count?',
                        instruction: 'Click each item to count it',
                        data: { objectType: objectType, count: count },
                        correctAnswer: count,
                        skillName: 'Counting and Number Recognition'
                    };
                },

                coins: function() {
                    const maxCents = difficulty === 'K' ? 25 : (difficulty === '1' ? 50 : 100);
                    const targetCents = Math.floor(Math.random() * (maxCents - 5)) + 5;

                    // Generate coins that can make the target
                    const coins = [
                        { type: 'quarter', count: Math.floor(targetCents / 25) + 1 },
                        { type: 'dime', count: Math.floor(targetCents / 10) + 2 },
                        { type: 'nickel', count: Math.floor(targetCents / 5) + 2 },
                        { type: 'penny', count: Math.min(10, targetCents) }
                    ];

                    return {
                        type: 'coins',
                        question: 'Make ' + targetCents + ' cents',
                        instruction: 'Drag coins to the box to make the exact amount',
                        data: { coins: coins, targetCents: targetCents },
                        correctAnswer: targetCents,
                        skillName: 'Counting and Number Recognition'
                    };
                },

                shapes: function() {
                    const allShapes = ['circle', 'triangle', 'square', 'rectangle'];
                    if (difficulty !== 'K') {
                        allShapes.push('pentagon', 'hexagon', 'oval', 'diamond');
                    }

                    const targetShape = allShapes[Math.floor(Math.random() * allShapes.length)];
                    const shapes = [...new Set([targetShape, ...allShapes.slice(0, 5)])].slice(0, 6);

                    // Shuffle
                    for (let i = shapes.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [shapes[i], shapes[j]] = [shapes[j], shapes[i]];
                    }

                    return {
                        type: 'shapes',
                        question: 'Find the ' + targetShape,
                        instruction: 'Click on the shape that matches',
                        data: { targetShape: targetShape, shapes: shapes },
                        correctAnswer: targetShape,
                        skillName: 'Counting and Number Recognition'
                    };
                },

                comparison: function() {
                    const max = difficulty === 'K' ? 10 : (difficulty === '1' ? 20 : 100);
                    const a = Math.floor(Math.random() * max) + 1;
                    let b;

                    // Sometimes make them equal
                    if (Math.random() < 0.2) {
                        b = a;
                    } else {
                        b = Math.floor(Math.random() * max) + 1;
                    }

                    const correctAnswer = a < b ? '<' : (a > b ? '>' : '=');

                    return {
                        type: 'comparison',
                        question: 'Which symbol makes this true?',
                        instruction: 'Click <, =, or > to compare the numbers',
                        data: { leftNumber: a, rightNumber: b },
                        correctAnswer: correctAnswer,
                        skillName: 'Counting and Number Recognition'
                    };
                },

                tenFrame: function() {
                    const targetNumber = Math.floor(Math.random() * 10) + 1;
                    const mode = Math.random() < 0.5 ? 'fill' : 'count';

                    return {
                        type: 'tenFrame',
                        question: mode === 'fill' ?
                            'Fill in ' + targetNumber + ' dots' :
                            'How many dots are there?',
                        instruction: mode === 'fill' ?
                            'Click cells to add or remove dots' :
                            'Count the filled circles',
                        data: {
                            targetNumber: targetNumber,
                            mode: mode,
                            prefilled: mode === 'count' ? targetNumber : 0
                        },
                        correctAnswer: targetNumber,
                        skillName: 'Counting and Number Recognition'
                    };
                },

                base10: function() {
                    const max = difficulty === 'K' ? 20 : (difficulty === '1' ? 100 : 999);
                    const number = Math.floor(Math.random() * max) + 1;

                    return {
                        type: 'base10',
                        question: 'What number do these blocks show?',
                        instruction: 'Count the hundreds, tens, and ones',
                        data: { number: number },
                        correctAnswer: number,
                        skillName: 'Place Value Understanding'
                    };
                },

                numberLine: function() {
                    const max = difficulty === 'K' ? 10 : (difficulty === '1' ? 20 : 100);
                    const target = Math.floor(Math.random() * (max - 1)) + 1;

                    return {
                        type: 'numberLine',
                        question: 'Find ' + target + ' on the number line',
                        instruction: 'Drag the marker to the correct position',
                        data: { min: 0, max: max, targetNumber: target, showTarget: true },
                        correctAnswer: target,
                        skillName: 'Counting and Number Recognition'
                    };
                }
            };

            if (problems[category]) {
                return problems[category]();
            }

            // Random category if not specified
            const categories = Object.keys(problems);
            return problems[categories[Math.floor(Math.random() * categories.length)]]();
        }

        // Integration: Show visual math for young grades
        function showVisualMathForGrade(category, onComplete) {
            const gradeLevel = selectedGrade || 'advanced';

            // Only use visual math for K-2
            if (['K-1', '2'].includes(gradeLevel)) {
                const difficulty = gradeLevel === 'K-1' ? 'K' : '2';
                const problem = generateVisualMathProblem(category, difficulty);
                problem.onComplete = onComplete;
                showVisualMathProblem(problem);
                return true;
            }

            return false; // Not a visual math grade
        }

        // ============================================
        // PHASE 1: FOUNDATION SYSTEMS
        // ============================================

        // === BASE BUILDING SYSTEM ===
        // Teaches: Area, Perimeter, Volume, Resource Management, Ratios

        const BASE_BUILDING = {
            // Grid is 6x4 = 24 slots for buildings
            gridWidth: 6,
            gridHeight: 4,
            rooms: {
                shelter: {
                    name: 'Shelter',
                    icon: '🏠',
                    width: 1, height: 1,
                    description: 'Basic shelter. Allows resting.',
                    costs: { wood: 10, steel: 0 },
                    benefits: { restBonus: 10 },
                    unlocked: true
                },
                storage: {
                    name: 'Storage Shed',
                    icon: '📦',
                    width: 1, height: 1,
                    description: '+25 carry capacity.',
                    costs: { wood: 15, steel: 5 },
                    benefits: { carryCapacity: 25 },
                    unlocked: true
                },
                workshop: {
                    name: 'Workshop',
                    icon: '🔧',
                    width: 2, height: 1,
                    description: 'Craft items. Requires area calculation.',
                    costs: { wood: 20, steel: 15 },
                    benefits: { craftingStation: true },
                    unlocked: true
                },
                kitchen: {
                    name: 'Kitchen',
                    icon: '🍳',
                    width: 1, height: 1,
                    description: 'Cook food. +20% food effectiveness.',
                    costs: { wood: 15, steel: 10 },
                    benefits: { cookingBonus: 20 },
                    unlocked: true
                },
                medbay: {
                    name: 'Medical Bay',
                    icon: '🏥',
                    width: 2, height: 1,
                    description: 'Heal wounds. Med kits heal +25% more.',
                    costs: { wood: 10, steel: 25 },
                    benefits: { healingBonus: 25 },
                    requires: ['shelter']
                },
                armory: {
                    name: 'Armory',
                    icon: '🔫',
                    width: 1, height: 1,
                    description: 'Store weapons. +10% weapon accuracy.',
                    costs: { wood: 10, steel: 30 },
                    benefits: { accuracyBonus: 10 },
                    requires: ['workshop']
                },
                watchtower: {
                    name: 'Watchtower',
                    icon: '🗼',
                    width: 1, height: 2,
                    description: 'Spot danger early. -15% ambush chance.',
                    costs: { wood: 25, steel: 15 },
                    benefits: { ambushReduction: 15 },
                    requires: ['shelter']
                },
                greenhouse: {
                    name: 'Greenhouse',
                    icon: '🌱',
                    width: 2, height: 2,
                    description: 'Grow food. Slow hunger decay by 25%.',
                    costs: { wood: 30, steel: 10 },
                    benefits: { hungerDecayReduction: 25 },
                    requires: ['kitchen']
                },
                generator: {
                    name: 'Generator',
                    icon: '⚡',
                    width: 1, height: 1,
                    description: 'Powers advanced buildings. Required for upgrades.',
                    costs: { wood: 5, steel: 40 },
                    benefits: { power: true },
                    requires: ['workshop']
                },
                tradingPost: {
                    name: 'Trading Post',
                    icon: '🏪',
                    width: 2, height: 1,
                    description: 'Better shop prices. -10% buy, +10% sell.',
                    costs: { wood: 25, steel: 20 },
                    benefits: { shopDiscount: 10 },
                    requires: ['storage']
                }
            },
            // Building materials available in the world
            materials: {
                wood: { name: 'Wood', icon: '🪵', sources: ['forest', 'ruins'] },
                steel: { name: 'Steel', icon: '🔩', sources: ['ruins', 'factory'] }
            }
        };

        // Base state - will be saved/loaded with gameState
        var baseState = {
            established: false,       // Has player built their first structure?
            name: 'Camp',             // Player can name their base
            buildings: [],            // Array of { type, gridX, gridY }
            grid: null,               // 2D array tracking occupied cells
            resources: {
                wood: 20,             // Starting resources
                steel: 10
            },
            totalBenefits: {          // Computed from all buildings
                carryCapacity: 0,
                restBonus: 0,
                cookingBonus: 0,
                healingBonus: 0,
                accuracyBonus: 0,
                ambushReduction: 0,
                hungerDecayReduction: 0,
                shopDiscount: 0,
                hasCraftingStation: false,
                hasPower: false
            },
            // Home stash - unlimited storage at base
            stash: {
                items: [],            // Array of item names (strings) or weapon objects
                materials: {          // Stored materials
                    metal: 0,
                    chem: 0,
                    elec: 0,
                    cloth: 0
                },
                ammo: {},             // Stored ammo by type
                money: 0              // Stored money in cents
            }
        };

        // Initialize base grid
        function initBaseGrid() {
            baseState.grid = [];
            for (var y = 0; y < BASE_BUILDING.gridHeight; y++) {
                baseState.grid[y] = [];
                for (var x = 0; x < BASE_BUILDING.gridWidth; x++) {
                    baseState.grid[y][x] = null; // null = empty
                }
            }
        }
        initBaseGrid();

        // Currently selected building type for placement
        var selectedBuildingType = null;

        // Travel state - tracks if player is at base or exploring
        var travelState = {
            atBase: true,           // Player starts at base
            distanceFromBase: 0,    // How far from base (in km)
            isReturning: false      // Currently traveling back?
        };

        // Open the base screen
        function openBaseScreen() {
            travelState.atBase = true;
            travelState.distanceFromBase = 0;
            showScreen('base-screen');
            renderBaseGrid();
            renderBuildOptions();
            updateBaseUI();
            updateBasePlayerStats();

            // Tutorial: first time at base
            showTutorialTip('first_base', 1000);
        }

        // Update player stats display on base screen
        function updateBasePlayerStats() {
            document.getElementById('base-hp').textContent = gameState.player.hp;
            document.getElementById('base-max-hp').textContent = gameState.player.maxHp;
            document.getElementById('base-hunger').textContent = Math.round(gameState.player.vitals.hunger);
            document.getElementById('base-thirst').textContent = Math.round(gameState.player.vitals.thirst);
            document.getElementById('base-energy').textContent = Math.round(gameState.player.vitals.energy);
            document.getElementById('base-money').textContent = formatMoney(gameState.player.money);
        }

        // Start exploration from base
        function startExploration() {
            travelState.atBase = false;
            travelState.distanceFromBase = 0;
            travelState.isReturning = false;
            showScreen('exploration-screen');
            updateInventoryDisplay();
            updateReturnButton();
            updateDistanceTierIndicator();

            // Show initial exploration narrative
            document.getElementById('exploration-narrative').innerHTML =
                '<strong>🗺️ SETTING OUT</strong><br><br>' +
                'You leave your camp behind and head into the wasteland. ' +
                'The further you travel, the longer the journey back.<br><br>' +
                '<span style="color: #888;">Distance from base: 0 km</span>';

            var html = '<button class="btn" onclick="nextExplorationEvent()">🚶 CONTINUE EXPLORING</button>';
            document.getElementById('exploration-choices').innerHTML = html;

            // Tutorial: first time exploring
            showTutorialTip('first_explore', 1200);
        }

        // Update the return to base button with current distance
        function updateReturnButton() {
            var distEl = document.getElementById('return-distance');
            if (distEl) {
                distEl.textContent = travelState.distanceFromBase;
            }
        }

        // Start the return journey to base
        function startReturnToBase() {
            if (travelState.distanceFromBase <= 0) {
                // Already at base
                openBaseScreen();
                return;
            }

            travelState.isReturning = true;

            document.getElementById('exploration-narrative').innerHTML =
                '<strong>🏕️ RETURNING TO BASE</strong><br><br>' +
                'You turn back toward your camp. The journey home is ' + travelState.distanceFromBase + ' km.<br><br>' +
                '<div style="background: rgba(255,200,0,0.1); border: 1px solid #fa0; padding: 10px; border-radius: 5px;">' +
                '⚠️ <strong>Warning:</strong> Travel will consume vitals!<br>' +
                'Hunger/Thirst/Energy will drain based on distance.' +
                '</div>';

            var html = '<button class="btn" style="background: #4a6741;" onclick="travelToBase()">🚶 BEGIN JOURNEY HOME (' + travelState.distanceFromBase + ' km)</button>';
            html += '<button class="btn" onclick="cancelReturn()">❌ STAY & EXPLORE</button>';
            document.getElementById('exploration-choices').innerHTML = html;

            // Tutorial: first return
            showTutorialTip('first_return', 1000);
        }

        // Actually travel back to base
        function travelToBase() {
            var distance = travelState.distanceFromBase;
            var grade = getPlayerGradeLevel();
            var problem, answer, hint;

            // Generate travel math problem based on grade
            if (['K-1', '2'].includes(grade)) {
                // Simple: how far total traveled?
                problem = 'You traveled ' + distance + ' km away from base.<br>Now you must travel ' + distance + ' km back.<br><br>How many km total for the round trip?';
                answer = distance * 2;
                hint = distance + ' + ' + distance + ' = ?';
            } else if (['3', '4'].includes(grade)) {
                // Speed calculation
                var speed = 3; // km per hour
                var hours = Math.ceil(distance / speed);
                problem = 'Your walking speed is ' + speed + ' km per hour.<br>Base is ' + distance + ' km away.<br><br>How many hours to get home? (Round up)';
                answer = hours;
                hint = distance + ' ÷ ' + speed + ' = ? (round up)';
            } else {
                // Vitals consumption
                var hungerRate = 2;
                var hungerLoss = distance * hungerRate;
                problem = 'Traveling uses ' + hungerRate + ' hunger per km.<br>Base is ' + distance + ' km away.<br><br>How much hunger will you lose?';
                answer = hungerLoss;
                hint = distance + ' × ' + hungerRate + ' = ?';
            }

            requireCalculation({
                title: '🏕️ TRAVEL HOME',
                description: problem,
                formula: hint,
                answer: answer,
                xpReward: 0,
                context: 'travel',
                onSuccess: function() {
                    completeReturnToBase();
                },
                onFailure: function() {
                    // Got lost - extra vitals drain
                    var extraDrain = Math.floor(distance * 0.5);
                    decayVitals(extraDrain);
                    showPopup(
                        '<strong>Wrong Turn!</strong><br><br>' +
                        'You got a bit lost on the way back.<br>' +
                        'Extra vitals drained from the detour.<br><br>' +
                        '<span style="color: #888;">Still arriving at base...</span>',
                        'info',
                        'NAVIGATION ERROR'
                    );
                    var originalClose = closePopup;
                    closePopup = function() {
                        document.getElementById('popup-overlay').classList.remove('active');
                        closePopup = originalClose;
                        completeReturnToBase();
                    };
                }
            });
        }

        // Complete the return journey
        function completeReturnToBase() {
            // Drain vitals based on distance traveled
            decayVitals(travelState.distanceFromBase);

            // Reset travel state
            travelState.atBase = true;
            travelState.distanceFromBase = 0;
            travelState.isReturning = false;
            updateDistanceTierIndicator();

            // Check if player survived the journey
            if (gameState.player.hp <= 0) {
                showScreen('gameover-screen');
                return;
            }

            showPopup(
                '<strong>🏕️ HOME SWEET HOME</strong><br><br>' +
                'You made it back to your camp safely!<br><br>' +
                'Rest up, manage your supplies, and prepare for the next expedition.',
                'success',
                'ARRIVED AT BASE'
            );

            var originalClose = closePopup;
            closePopup = function() {
                document.getElementById('popup-overlay').classList.remove('active');
                closePopup = originalClose;
                openBaseScreen();
            };
        }

        // Cancel return and continue exploring
        function cancelReturn() {
            travelState.isReturning = false;
            nextExplorationEvent();
        }

        // Open eat menu at base (uses same system)
        function openBaseEatMenu() {
            openEatMenu();
        }

        // Open drink menu at base
        function openBaseDrinkMenu() {
            openDrinkMenu();
        }

        // Legacy function - now redirects to startExploration
        function leaveBase() {
            startExploration();
        }

        // ============ FIELD CAMPING SYSTEM ============
        // Allows players to set up camp in the field using camping equipment

        function openFieldCamp() {
            if (!hasCampingGear()) {
                showPopup(
                    '<strong>No Camping Gear!</strong><br><br>' +
                    'You need a Camping Set to set up camp in the field.<br><br>' +
                    'Buy one from a trader or find one while exploring.',
                    'error',
                    'CANNOT CAMP'
                );
                return;
            }

            var tier = getDistanceTier();

            // Get equipment durability for display
            var campDur = getEquipmentDurability('Camping Set');
            var sleepDur = hasSleepingBag() ? getEquipmentDurability('Sleeping Bag') : 0;
            var stoveDur = hasPortableStove() ? getEquipmentDurability('Portable Stove') : 0;
            var purifyDur = hasWaterPurifier() ? getEquipmentDurability('Water Purifier') : 0;

            document.getElementById('exploration-narrative').innerHTML =
                '<strong>🏕️ FIELD CAMP</strong><br><br>' +
                'You set up your camping gear and take a break from traveling.<br><br>' +
                '<div style="background: rgba(74,103,65,0.2); border: 1px solid #4a6741; padding: 10px; border-radius: 5px;">' +
                '<strong>Location:</strong> <span style="color: ' + tier.color + ';">' + tier.name + '</span> (' + Math.floor(travelState.distanceFromBase) + ' km from base)<br>' +
                '<strong>Your Gear:</strong><br>' +
                '• Camping Set: <span style="color:' + getDurabilityColor(campDur) + ';">' + campDur + '%</span><br>' +
                '• Sleeping Bag: ' + (hasSleepingBag() ? '<span style="color:' + getDurabilityColor(sleepDur) + ';">' + sleepDur + '%</span> (+20% rest)' : '✗') + '<br>' +
                '• Portable Stove: ' + (hasPortableStove() ? '<span style="color:' + getDurabilityColor(stoveDur) + ';">' + stoveDur + '%</span>' : '✗') + '<br>' +
                '• Water Purifier: ' + (hasWaterPurifier() ? '<span style="color:' + getDurabilityColor(purifyDur) + ';">' + purifyDur + '%</span>' : '✗') +
                '</div>';

            var html = '<button class="btn" onclick="restAtFieldCamp()">😴 REST<br><span style="font-size:0.85em">Restore energy' + (hasSleepingBag() ? ' (+20% bonus)' : '') + '</span></button>';

            if (hasPortableStove()) {
                html += '<button class="btn" onclick="cookAtFieldCamp()">🍳 COOK<br><span style="font-size:0.85em">Prepare food</span></button>';
            }

            html += '<button class="btn" onclick="openEatMenu()">🍖 EAT<br><span style="font-size:0.85em">Consume food</span></button>';
            html += '<button class="btn" onclick="openDrinkMenu()">💧 DRINK<br><span style="font-size:0.85em">Consume drinks</span></button>';

            if (hasWaterPurifier()) {
                html += '<button class="btn" onclick="purifyWater()">💧 PURIFY<br><span style="font-size:0.85em">Clean stream water</span></button>';
            }

            // Show weapon management option
            var invWeaponCount = getInventoryWeapons().length;
            html += '<button class="btn" onclick="openWeaponStash()" style="background: #4a4a6a;">⚔️ WEAPONS<br><span style="font-size:0.85em">' + invWeaponCount + ' in inventory</span></button>';

            // Show repair option with durability status
            var dur1 = gameState.player.weaponDurability ? gameState.player.weaponDurability.slot1 : 100;
            var dur2 = gameState.player.weaponDurability ? gameState.player.weaponDurability.slot2 : 100;
            var needsRepair = dur1 < 100 || dur2 < 100;
            html += '<button class="btn" onclick="openRepairMenu()" style="background: #8b4513;">🔧 REPAIR<br><span style="font-size:0.85em">' +
                    (needsRepair ? '<span style="color:' + getDurabilityColor(Math.min(dur1, dur2)) + ';">Weapons: ' + Math.min(dur1, dur2) + '%</span>' : 'All gear OK') +
                    '</span></button>';

            html += '<button class="btn" onclick="packUpCamp()">📦 PACK UP<br><span style="font-size:0.85em">Continue exploring</span></button>';

            document.getElementById('exploration-choices').innerHTML = html;
        }

        function restAtFieldCamp() {
            var baseRest = 30; // Base energy restoration
            var sleepingBagBonus = hasSleepingBag() ? 0.2 : 0;
            var totalRest = Math.floor(baseRest * (1 + sleepingBagBonus));

            var grade = getPlayerGradeLevel();
            var problem, answer, hint;

            if (['K-1', '2'].includes(grade)) {
                problem = 'Resting restores ' + baseRest + ' energy.<br>' +
                          (sleepingBagBonus > 0 ? 'Sleeping bag adds ' + Math.floor(baseRest * sleepingBagBonus) + ' more.<br><br>' : '<br>') +
                          'How much energy will you gain?';
                answer = totalRest;
                hint = sleepingBagBonus > 0 ? baseRest + ' + ' + Math.floor(baseRest * sleepingBagBonus) + ' = ?' : baseRest + ' = ?';
            } else {
                problem = 'Base rest: ' + baseRest + ' energy<br>' +
                          'Sleeping bag bonus: ' + (sleepingBagBonus * 100) + '%<br><br>' +
                          'Total energy restored?';
                answer = totalRest;
                hint = baseRest + ' × ' + (1 + sleepingBagBonus).toFixed(1) + ' = ?';
            }

            requireCalculation({
                title: '😴 FIELD REST',
                description: problem,
                formula: hint,
                answer: answer,
                xpReward: 0,
                context: 'camping',
                onSuccess: function() {
                    gameState.player.vitals.energy = Math.min(100, gameState.player.vitals.energy + totalRest);
                    // Small hunger/thirst drain from time passing
                    gameState.player.vitals.hunger = Math.max(0, gameState.player.vitals.hunger - 5);
                    gameState.player.vitals.thirst = Math.max(0, gameState.player.vitals.thirst - 8);

                    // Degrade camping equipment
                    degradeCampingEquipment('Camping Set', 5);
                    if (hasSleepingBag()) degradeCampingEquipment('Sleeping Bag', 3);

                    showPopup(
                        '<strong>😴 RESTED!</strong><br><br>' +
                        'Energy +' + totalRest + '<br>' +
                        'Hunger -5 (time passed)<br>' +
                        'Thirst -8 (time passed)<br>' +
                        '<span style="color: #888;">Equipment wear: Camping Set -5%, Sleeping Bag -3%</span>',
                        'success',
                        'WELL RESTED'
                    );
                    updateVitalsDisplay();

                    var originalClose = closePopup;
                    closePopup = function() {
                        document.getElementById('popup-overlay').classList.remove('active');
                        closePopup = originalClose;
                        openFieldCamp();
                    };
                },
                onFailure: function() {
                    var partialRest = Math.floor(totalRest / 2);
                    gameState.player.vitals.energy = Math.min(100, gameState.player.vitals.energy + partialRest);
                    gameState.player.vitals.hunger = Math.max(0, gameState.player.vitals.hunger - 5);
                    gameState.player.vitals.thirst = Math.max(0, gameState.player.vitals.thirst - 8);

                    showPopup(
                        '<strong>Restless Sleep</strong><br><br>' +
                        'You couldn\'t get comfortable.<br>' +
                        'Energy +' + partialRest + ' (half)',
                        'info',
                        'POOR REST'
                    );
                    updateVitalsDisplay();

                    var originalClose = closePopup;
                    closePopup = function() {
                        document.getElementById('popup-overlay').classList.remove('active');
                        closePopup = originalClose;
                        openFieldCamp();
                    };
                }
            });
        }

        function cookAtFieldCamp() {
            // Use the same cooking system but return to field camp after
            openCookingMenu();
        }

        function purifyWater() {
            // Check if player has stream water to purify
            var streamWaterCount = gameState.player.inventory.filter(function(item) {
                return item === 'Stream Water';
            }).length;

            if (streamWaterCount === 0) {
                showPopup(
                    '<strong>No Water to Purify!</strong><br><br>' +
                    'You don\'t have any Stream Water.<br>' +
                    'Find some while exploring to purify it.',
                    'info',
                    'NO STREAM WATER'
                );
                return;
            }

            var grade = getPlayerGradeLevel();
            var problem, answer;

            if (['K-1', '2'].includes(grade)) {
                problem = 'You have ' + streamWaterCount + ' Stream Water.<br>' +
                          'If you purify 1, how many will you have left?';
                answer = streamWaterCount - 1;
            } else {
                var ratio = 2; // 2 stream water = 1 purified
                var canMake = Math.floor(streamWaterCount / ratio);
                problem = 'It takes ' + ratio + ' Stream Water to make 1 Water Bottle.<br>' +
                          'You have ' + streamWaterCount + ' Stream Water.<br><br>' +
                          'How many Water Bottles can you make?';
                answer = canMake;
            }

            requireCalculation({
                title: '💧 WATER PURIFICATION',
                description: problem,
                formula: '',
                answer: answer,
                xpReward: 0,
                context: 'camping',
                onSuccess: function() {
                    // Remove stream water and add water bottle
                    if (['K-1', '2'].includes(grade)) {
                        removeFromInventory('Stream Water');
                        gameState.player.inventory.push('Water Bottle');
                    } else {
                        var made = Math.floor(streamWaterCount / 2);
                        for (var i = 0; i < made * 2; i++) {
                            removeFromInventory('Stream Water');
                        }
                        for (var j = 0; j < made; j++) {
                            gameState.player.inventory.push('Water Bottle');
                        }
                    }

                    // Degrade water purifier
                    degradeCampingEquipment('Water Purifier', 8);

                    calculateCarryWeight();
                    showPopup(
                        '<strong>💧 WATER PURIFIED!</strong><br><br>' +
                        'Clean drinking water obtained!<br>' +
                        '<span style="color: #888;">Water Purifier wear: -8%</span>',
                        'success',
                        'PURIFICATION COMPLETE'
                    );

                    var originalClose = closePopup;
                    closePopup = function() {
                        document.getElementById('popup-overlay').classList.remove('active');
                        closePopup = originalClose;
                        openFieldCamp();
                    };
                },
                onFailure: function() {
                    showPopup(
                        '<strong>Purification Failed!</strong><br><br>' +
                        'The water was contaminated. Try again.',
                        'error',
                        'FAILED'
                    );
                    var originalClose = closePopup;
                    closePopup = function() {
                        document.getElementById('popup-overlay').classList.remove('active');
                        closePopup = originalClose;
                        openFieldCamp();
                    };
                }
            });
        }

        function packUpCamp() {
            nextExplorationEvent();
        }

        // Render the base grid with buildings
        function renderBaseGrid() {
            var gridEl = document.getElementById('base-grid');
            var html = '';

            for (var y = 0; y < BASE_BUILDING.gridHeight; y++) {
                for (var x = 0; x < BASE_BUILDING.gridWidth; x++) {
                    var cellContent = '';
                    var cellClass = 'base-cell';
                    var buildingAtCell = getBuildingAt(x, y);

                    if (buildingAtCell) {
                        var roomDef = BASE_BUILDING.rooms[buildingAtCell.type];
                        // Only show icon on the top-left cell of multi-cell buildings
                        if (buildingAtCell.gridX === x && buildingAtCell.gridY === y) {
                            cellContent = '<span>' + roomDef.icon + '</span><span class="building-name">' + roomDef.name + '</span>';
                        }
                        cellClass += ' occupied';
                    }

                    html += '<div class="' + cellClass + '" data-x="' + x + '" data-y="' + y + '" onclick="handleBaseCellClick(' + x + ',' + y + ')">' + cellContent + '</div>';
                }
            }

            gridEl.innerHTML = html;
        }

        // Get building at a specific cell (handles multi-cell buildings)
        function getBuildingAt(x, y) {
            for (var i = 0; i < baseState.buildings.length; i++) {
                var b = baseState.buildings[i];
                var roomDef = BASE_BUILDING.rooms[b.type];
                if (x >= b.gridX && x < b.gridX + roomDef.width &&
                    y >= b.gridY && y < b.gridY + roomDef.height) {
                    return b;
                }
            }
            return null;
        }

        // Check if a building can be placed at position
        function canPlaceBuilding(type, x, y) {
            var roomDef = BASE_BUILDING.rooms[type];
            if (!roomDef) return { valid: false, reason: 'Unknown building type' };

            // Check bounds
            if (x + roomDef.width > BASE_BUILDING.gridWidth || y + roomDef.height > BASE_BUILDING.gridHeight) {
                return { valid: false, reason: 'Building doesn\'t fit here' };
            }

            // Check all cells are empty
            for (var dy = 0; dy < roomDef.height; dy++) {
                for (var dx = 0; dx < roomDef.width; dx++) {
                    if (getBuildingAt(x + dx, y + dy)) {
                        return { valid: false, reason: 'Space is occupied' };
                    }
                }
            }

            // Check resource costs
            if (baseState.resources.wood < roomDef.costs.wood) {
                return { valid: false, reason: 'Need ' + roomDef.costs.wood + ' wood (have ' + baseState.resources.wood + ')' };
            }
            if (baseState.resources.steel < roomDef.costs.steel) {
                return { valid: false, reason: 'Need ' + roomDef.costs.steel + ' steel (have ' + baseState.resources.steel + ')' };
            }

            // Check requirements
            if (roomDef.requires) {
                for (var i = 0; i < roomDef.requires.length; i++) {
                    var reqType = roomDef.requires[i];
                    var hasReq = baseState.buildings.some(function(b) { return b.type === reqType; });
                    if (!hasReq) {
                        var reqName = BASE_BUILDING.rooms[reqType].name;
                        return { valid: false, reason: 'Requires ' + reqName + ' first' };
                    }
                }
            }

            return { valid: true };
        }

        // Handle click on base grid cell
        function handleBaseCellClick(x, y) {
            if (!selectedBuildingType) {
                // No building selected - show info about existing building
                var building = getBuildingAt(x, y);
                if (building) {
                    var roomDef = BASE_BUILDING.rooms[building.type];
                    showPopup(
                        '<strong>' + roomDef.icon + ' ' + roomDef.name + '</strong><br><br>' +
                        roomDef.description + '<br><br>' +
                        '<span style="color: #888;">Size: ' + roomDef.width + '×' + roomDef.height + '</span>',
                        'info',
                        'BUILDING INFO'
                    );
                }
                return;
            }

            // Try to place selected building
            var canPlace = canPlaceBuilding(selectedBuildingType, x, y);
            if (!canPlace.valid) {
                showPopup('<strong>Cannot Build Here</strong><br><br>' + canPlace.reason, 'error', 'PLACEMENT ERROR');
                return;
            }

            // Start building process with math problem
            startBuildingConstruction(selectedBuildingType, x, y);
        }

        // Start construction with math problem
        function startBuildingConstruction(type, x, y) {
            var roomDef = BASE_BUILDING.rooms[type];
            var woodCost = roomDef.costs.wood;
            var steelCost = roomDef.costs.steel;
            var area = roomDef.width * roomDef.height;

            // Tutorial: first building
            showTutorialTip('first_building', 500);

            // Generate math problem based on grade level
            var gradeLevel = getPlayerGradeLevel();
            var problem, answer, hint;

            if (['K-1', '2'].includes(gradeLevel)) {
                // Simple addition for costs
                problem = 'Building ' + roomDef.name + ' needs ' + woodCost + ' wood and ' + steelCost + ' steel.<br><br>How many total materials?';
                answer = woodCost + steelCost;
                hint = woodCost + ' + ' + steelCost + ' = ?';
            } else if (['3', '4'].includes(gradeLevel)) {
                // Area calculation
                problem = roomDef.name + ' is ' + roomDef.width + ' × ' + roomDef.height + ' squares.<br><br>What is the floor area?';
                answer = area;
                hint = 'Area = width × height';
            } else {
                // Material efficiency - materials per square
                var totalMats = woodCost + steelCost;
                problem = roomDef.name + ' uses ' + totalMats + ' materials for ' + area + ' square(s).<br><br>How many materials per square? (Round to nearest whole)';
                answer = Math.round(totalMats / area);
                hint = 'Materials per square = total ÷ area';
            }

            requireCalculation({
                title: '🔨 CONSTRUCTION: ' + roomDef.name,
                description: problem,
                formula: hint,
                answer: answer,
                xpReward: 0,
                context: 'building',
                onSuccess: function() {
                    completeConstruction(type, x, y);
                },
                onFailure: function() {
                    // Partial failure - waste some resources
                    var wastedWood = Math.ceil(woodCost * 0.25);
                    var wastedSteel = Math.ceil(steelCost * 0.25);
                    baseState.resources.wood = Math.max(0, baseState.resources.wood - wastedWood);
                    baseState.resources.steel = Math.max(0, baseState.resources.steel - wastedSteel);
                    updateBaseUI();
                    showPopup(
                        '<strong>Construction Failed!</strong><br><br>' +
                        'Miscalculation wasted materials:<br>' +
                        '🪵 -' + wastedWood + ' wood<br>' +
                        '🔩 -' + wastedSteel + ' steel<br><br>' +
                        'Try again!',
                        'error',
                        'BUILD FAILED'
                    );
                }
            });
        }

        // Complete building construction
        function completeConstruction(type, x, y) {
            var roomDef = BASE_BUILDING.rooms[type];

            // Deduct resources
            baseState.resources.wood -= roomDef.costs.wood;
            baseState.resources.steel -= roomDef.costs.steel;

            // Add building
            baseState.buildings.push({
                type: type,
                gridX: x,
                gridY: y
            });

            // Mark as established
            if (!baseState.established) {
                baseState.established = true;
            }

            // Recalculate benefits
            recalculateBaseBenefits();

            // Clear selection
            selectedBuildingType = null;

            // Update UI
            renderBaseGrid();
            renderBuildOptions();
            updateBaseUI();

            showPopup(
                '<strong>' + roomDef.icon + ' ' + roomDef.name + ' Built!</strong><br><br>' +
                roomDef.description,
                'success',
                'CONSTRUCTION COMPLETE'
            );
        }

        // Recalculate all benefits from buildings
        function recalculateBaseBenefits() {
            // Reset benefits
            baseState.totalBenefits = {
                carryCapacity: 0,
                restBonus: 0,
                cookingBonus: 0,
                healingBonus: 0,
                accuracyBonus: 0,
                ambushReduction: 0,
                hungerDecayReduction: 0,
                shopDiscount: 0,
                hasCraftingStation: false,
                hasPower: false
            };

            // Sum up benefits from all buildings
            for (var i = 0; i < baseState.buildings.length; i++) {
                var building = baseState.buildings[i];
                var roomDef = BASE_BUILDING.rooms[building.type];
                var benefits = roomDef.benefits;

                if (benefits.carryCapacity) baseState.totalBenefits.carryCapacity += benefits.carryCapacity;
                if (benefits.restBonus) baseState.totalBenefits.restBonus += benefits.restBonus;
                if (benefits.cookingBonus) baseState.totalBenefits.cookingBonus += benefits.cookingBonus;
                if (benefits.healingBonus) baseState.totalBenefits.healingBonus += benefits.healingBonus;
                if (benefits.accuracyBonus) baseState.totalBenefits.accuracyBonus += benefits.accuracyBonus;
                if (benefits.ambushReduction) baseState.totalBenefits.ambushReduction += benefits.ambushReduction;
                if (benefits.hungerDecayReduction) baseState.totalBenefits.hungerDecayReduction += benefits.hungerDecayReduction;
                if (benefits.shopDiscount) baseState.totalBenefits.shopDiscount += benefits.shopDiscount;
                if (benefits.craftingStation) baseState.totalBenefits.hasCraftingStation = true;
                if (benefits.power) baseState.totalBenefits.hasPower = true;
            }

            // Apply carry capacity bonus to player
            gameState.player.maxCarryWeight = 100 + baseState.totalBenefits.carryCapacity;
        }

        // Render building options panel
        function renderBuildOptions() {
            var optionsEl = document.getElementById('build-options');
            var html = '';

            for (var type in BASE_BUILDING.rooms) {
                var roomDef = BASE_BUILDING.rooms[type];
                var canBuild = canPlaceBuildingAnywhere(type);
                var isSelected = selectedBuildingType === type;
                var isLocked = !canBuild.valid && canBuild.reason.includes('Requires');

                var optionClass = 'build-option';
                if (isSelected) optionClass += ' selected';
                if (!canBuild.valid) optionClass += ' locked';

                html += '<div class="' + optionClass + '" onclick="selectBuildingType(\'' + type + '\')">';
                html += '<span class="build-icon">' + roomDef.icon + '</span>';
                html += '<span class="build-name">' + roomDef.name + '</span>';
                html += '<span class="build-size">(' + roomDef.width + '×' + roomDef.height + ')</span>';
                html += '<div class="build-desc">' + roomDef.description + '</div>';
                html += '<div class="build-cost">🪵 ' + roomDef.costs.wood + ' 🔩 ' + roomDef.costs.steel + '</div>';

                if (!canBuild.valid) {
                    html += '<div class="build-requires">⚠ ' + canBuild.reason + '</div>';
                }

                html += '</div>';
            }

            optionsEl.innerHTML = html;
        }

        // Check if building can be placed anywhere (for showing locked status)
        function canPlaceBuildingAnywhere(type) {
            var roomDef = BASE_BUILDING.rooms[type];

            // Check requirements first
            if (roomDef.requires) {
                for (var i = 0; i < roomDef.requires.length; i++) {
                    var reqType = roomDef.requires[i];
                    var hasReq = baseState.buildings.some(function(b) { return b.type === reqType; });
                    if (!hasReq) {
                        var reqName = BASE_BUILDING.rooms[reqType].name;
                        return { valid: false, reason: 'Requires ' + reqName };
                    }
                }
            }

            // Check resources
            if (baseState.resources.wood < roomDef.costs.wood) {
                return { valid: false, reason: 'Need more wood' };
            }
            if (baseState.resources.steel < roomDef.costs.steel) {
                return { valid: false, reason: 'Need more steel' };
            }

            // Check if there's any valid placement
            for (var y = 0; y < BASE_BUILDING.gridHeight; y++) {
                for (var x = 0; x < BASE_BUILDING.gridWidth; x++) {
                    var canPlace = canPlaceBuilding(type, x, y);
                    if (canPlace.valid) return { valid: true };
                }
            }

            return { valid: false, reason: 'No space available' };
        }

        // Select a building type for placement
        function selectBuildingType(type) {
            var canBuild = canPlaceBuildingAnywhere(type);
            if (!canBuild.valid) {
                showPopup('<strong>Cannot Build</strong><br><br>' + canBuild.reason, 'error', 'LOCKED');
                return;
            }

            if (selectedBuildingType === type) {
                selectedBuildingType = null; // Deselect
            } else {
                selectedBuildingType = type;
            }

            renderBuildOptions();
            highlightValidPlacements();
        }

        // Highlight valid placement cells
        function highlightValidPlacements() {
            var cells = document.querySelectorAll('.base-cell');
            cells.forEach(function(cell) {
                cell.classList.remove('preview', 'invalid');

                if (selectedBuildingType) {
                    var x = parseInt(cell.dataset.x);
                    var y = parseInt(cell.dataset.y);
                    var canPlace = canPlaceBuilding(selectedBuildingType, x, y);

                    if (!getBuildingAt(x, y)) {
                        cell.classList.add('preview');
                        if (!canPlace.valid) {
                            cell.classList.add('invalid');
                        }
                    }
                }
            });
        }

        // Update base UI elements
        function updateBaseUI() {
            document.getElementById('base-name').textContent = baseState.name;
            document.getElementById('base-wood').textContent = baseState.resources.wood;
            document.getElementById('base-steel').textContent = baseState.resources.steel;

            // Update benefits list
            var benefitsHtml = '';
            var b = baseState.totalBenefits;

            if (baseState.buildings.length === 0) {
                benefitsHtml = 'No buildings yet. Build a Shelter to get started!';
            } else {
                if (b.carryCapacity > 0) benefitsHtml += '<span class="benefit-item">📦 +' + b.carryCapacity + ' Carry</span>';
                if (b.restBonus > 0) benefitsHtml += '<span class="benefit-item">😴 +' + b.restBonus + '% Rest</span>';
                if (b.cookingBonus > 0) benefitsHtml += '<span class="benefit-item">🍳 +' + b.cookingBonus + '% Food</span>';
                if (b.healingBonus > 0) benefitsHtml += '<span class="benefit-item">🏥 +' + b.healingBonus + '% Heal</span>';
                if (b.accuracyBonus > 0) benefitsHtml += '<span class="benefit-item">🎯 +' + b.accuracyBonus + '% Accuracy</span>';
                if (b.ambushReduction > 0) benefitsHtml += '<span class="benefit-item">👁️ -' + b.ambushReduction + '% Ambush</span>';
                if (b.hungerDecayReduction > 0) benefitsHtml += '<span class="benefit-item">🌱 -' + b.hungerDecayReduction + '% Hunger</span>';
                if (b.shopDiscount > 0) benefitsHtml += '<span class="benefit-item">🏪 ' + b.shopDiscount + '% Discount</span>';
                if (b.hasCraftingStation) benefitsHtml += '<span class="benefit-item">🔧 Crafting</span>';
                if (b.hasPower) benefitsHtml += '<span class="benefit-item">⚡ Power</span>';
            }

            document.getElementById('benefits-list').innerHTML = benefitsHtml;

            // Show/hide action buttons based on buildings
            var hasShelter = baseState.buildings.some(function(b) { return b.type === 'shelter'; });
            var hasKitchen = baseState.buildings.some(function(b) { return b.type === 'kitchen'; });

            document.getElementById('base-rest-btn').style.display = hasShelter ? 'inline-block' : 'none';
            document.getElementById('base-cook-btn').style.display = hasKitchen ? 'inline-block' : 'none';
        }

        // Rest at base (improved rest with shelter bonus)
        function restAtBase() {
            var baseRestBonus = baseState.totalBenefits.restBonus;
            var restAmount = 40 + baseRestBonus;

            if (gameState.player.vitals.hunger < 30) {
                showPopup('Too hungry to rest well. Eat something first!', 'error', 'CANNOT REST');
                return;
            }

            var currentEnergy = gameState.player.vitals.energy;
            var newEnergy = Math.min(100, currentEnergy + restAmount);

            requireCalculation({
                title: '😴 REST AT BASE',
                description: 'Base rest bonus: +' + baseRestBonus + '%<br>Total rest: +' + restAmount + ' energy<br><br>Current: ' + Math.round(currentEnergy),
                formula: Math.round(currentEnergy) + ' + ' + restAmount + ' = ? (max 100)',
                answer: Math.min(100, Math.round(currentEnergy) + restAmount),
                xpReward: 0,
                context: 'base',
                onSuccess: function() {
                    gameState.player.vitals.energy = newEnergy;
                    // Small HP recovery at base
                    var hpRecovery = Math.min(10, gameState.player.maxHp - gameState.player.hp);
                    gameState.player.hp += hpRecovery;
                    updateBaseUI();
                    updateInventoryDisplay();
                    showPopup(
                        '<strong>Well Rested!</strong><br><br>' +
                        '😴 Energy: +' + restAmount + '<br>' +
                        '❤️ HP: +' + hpRecovery,
                        'success',
                        'RESTED'
                    );
                },
                onFailure: function() {
                    // Partial rest
                    gameState.player.vitals.energy = Math.min(100, currentEnergy + Math.floor(restAmount / 2));
                    updateBaseUI();
                    showPopup('Restless sleep... Only partial recovery.', 'info', 'POOR REST');
                }
            });
        }

        // Open cooking at base (uses existing cooking system with bonus)
        function openBaseCooking() {
            openCookingMenu();
        }

        // Show base building interface
        function showBaseBuildingChallenge(onComplete) {
            const roomTypes = Object.keys(BASE_BUILDING.rooms);
            const roomType = roomTypes[Math.floor(Math.random() * roomTypes.length)];
            const room = BASE_BUILDING.rooms[roomType];

            // Generate room dimensions based on grade
            const gradeLevel = selectedGrade || 'advanced';
            let width, length, height;

            if (['K-1', '2'].includes(gradeLevel)) {
                // Simple counting - small squares
                width = Math.floor(Math.random() * 3) + 2; // 2-4
                length = Math.floor(Math.random() * 3) + 2;
                height = 2;
            } else if (['3', '4'].includes(gradeLevel)) {
                // Area and perimeter
                width = Math.floor(Math.random() * 5) + 3; // 3-7
                length = Math.floor(Math.random() * 5) + 3;
                height = 2;
            } else {
                // Volume calculations
                width = Math.floor(Math.random() * 6) + 4; // 4-9
                length = Math.floor(Math.random() * 6) + 4;
                height = Math.floor(Math.random() * 3) + 2; // 2-4
            }

            // Determine which calculation to ask
            const calcTypes = [];
            if (hasSkillForCategory('multiplication') || ['K-1', '2'].includes(gradeLevel)) {
                calcTypes.push('area');
            }
            if (hasSkillForCategory('addition')) {
                calcTypes.push('perimeter');
            }
            if (hasSkillForCategory('multiplication') && !['K-1', '2', '3'].includes(gradeLevel)) {
                calcTypes.push('volume');
                calcTypes.push('materials');
            }

            const calcType = calcTypes[Math.floor(Math.random() * calcTypes.length)] || 'area';

            let question, correctAnswer, hint;

            switch (calcType) {
                case 'area':
                    question = 'You\'re building a ' + room.name + '. The floor is ' + width + ' ft × ' + length + ' ft. How many square feet of flooring do you need?';
                    correctAnswer = width * length;
                    hint = 'Area = length × width';
                    break;
                case 'perimeter':
                    question = 'You\'re fencing around a ' + room.name + ' that is ' + width + ' ft × ' + length + ' ft. How many feet of fencing do you need?';
                    correctAnswer = 2 * (width + length);
                    hint = 'Perimeter = 2 × (length + width)';
                    break;
                case 'volume':
                    question = 'Your ' + room.name + ' is ' + width + ' ft × ' + length + ' ft × ' + height + ' ft tall. What\'s the total volume in cubic feet?';
                    correctAnswer = width * length * height;
                    hint = 'Volume = length × width × height';
                    break;
                case 'materials':
                    const area = width * length;
                    const materialType = Math.random() < 0.5 ? 'wood' : 'steel';
                    const mat = BASE_BUILDING.materials[materialType];
                    question = 'Building a ' + width + ' ft × ' + length + ' ft floor requires ' + mat.perSquare + ' ' + mat.name + ' per square foot. How much ' + mat.name + ' total?';
                    correctAnswer = area * mat.perSquare;
                    hint = 'Total materials = area × materials per square';
                    break;
            }

            // Show visual grid for younger grades
            if (['K-1', '2'].includes(gradeLevel)) {
                showBuildingGridVisual(width, length, question, correctAnswer, onComplete);
            } else {
                // Standard calculation prompt
                showBuildingCalculation(question, correctAnswer, hint, calcType, onComplete);
            }
        }

        function showBuildingGridVisual(width, length, question, correctAnswer, onComplete) {
            const overlay = document.createElement('div');
            overlay.className = 'visual-math-overlay';
            overlay.id = 'building-overlay';

            let html = '<div class="visual-math-container">';
            html += '<h3 class="visual-math-title">🏗️ Base Building</h3>';
            html += '<p class="visual-math-instruction">' + question + '</p>';

            // Visual grid
            html += '<div style="display: grid; grid-template-columns: repeat(' + width + ', 40px); gap: 2px; justify-content: center; margin: 20px 0;">';
            for (let y = 0; y < length; y++) {
                for (let x = 0; x < width; x++) {
                    html += '<div class="count-object" data-counted="false" style="width: 40px; height: 40px; background: rgba(139, 90, 43, 0.3); border: 2px solid #8b5a2b; border-radius: 4px; display: flex; align-items: center; justify-content: center; cursor: pointer;">🧱</div>';
                }
            }
            html += '</div>';
            html += '<p style="text-align: center; color: #888;">Click each square to count it!</p>';

            html += '<div class="visual-answer-display">';
            html += '<div class="visual-answer-label">Your count:</div>';
            html += '<div class="visual-answer-value" id="building-count">0</div>';
            html += '</div>';

            html += '<button class="visual-submit-btn" id="building-submit" onclick="submitBuildingAnswer(' + correctAnswer + ')">Submit Answer</button>';
            html += '</div>';

            overlay.innerHTML = html;
            document.body.appendChild(overlay);

            // Initialize counting
            let counted = 0;
            overlay.querySelectorAll('.count-object').forEach(cell => {
                cell.addEventListener('click', function() {
                    if (this.dataset.counted === 'false') {
                        this.dataset.counted = 'true';
                        this.style.background = 'rgba(0, 255, 0, 0.3)';
                        this.style.borderColor = '#0f0';
                        counted++;
                        document.getElementById('building-count').textContent = counted;
                    }
                });
            });

            window.currentBuildingCallback = onComplete;
        }

        function showBuildingCalculation(question, correctAnswer, hint, calcType, onComplete) {
            const overlay = document.createElement('div');
            overlay.className = 'visual-math-overlay';
            overlay.id = 'building-overlay';

            let html = '<div class="visual-math-container">';
            html += '<h3 class="visual-math-title">🏗️ Base Building</h3>';
            html += '<p class="visual-math-instruction">' + question + '</p>';
            html += '<p style="color: #888; font-size: 0.9em; text-align: center; margin: 10px 0;"><em>Hint: ' + hint + '</em></p>';

            html += '<div style="text-align: center; margin: 20px 0;">';
            html += '<input type="number" id="building-answer" class="terminal-input" style="width: 150px; font-size: 1.3em;" placeholder="?">';
            html += '</div>';

            html += '<button class="visual-submit-btn" onclick="submitBuildingAnswer(' + correctAnswer + ')">Submit Answer</button>';
            html += '</div>';

            overlay.innerHTML = html;
            document.body.appendChild(overlay);

            window.currentBuildingCallback = onComplete;
        }

        function submitBuildingAnswer(correctAnswer) {
            const overlay = document.getElementById('building-overlay');
            const countDisplay = document.getElementById('building-count');
            const inputField = document.getElementById('building-answer');

            let playerAnswer;
            if (countDisplay) {
                playerAnswer = parseInt(countDisplay.textContent);
            } else if (inputField) {
                playerAnswer = parseInt(inputField.value);
            }

            const isCorrect = playerAnswer === correctAnswer;

            // Log practice
            logPracticeSession('Basic Multiplication', isCorrect, {
                type: 'base_building',
                answer: playerAnswer,
                correctAnswer: correctAnswer
            });

            // Show result
            const btn = overlay.querySelector('.visual-submit-btn');
            if (isCorrect) {
                btn.style.background = 'rgba(0, 200, 0, 0.8)';
                btn.textContent = '✓ Correct! Building complete!';
            } else {
                btn.style.background = 'rgba(200, 0, 0, 0.8)';
                btn.textContent = '✗ The answer was ' + correctAnswer;
            }
            btn.disabled = true;

            setTimeout(() => {
                if (overlay.parentElement) {
                    document.body.removeChild(overlay);
                }
                if (window.currentBuildingCallback) {
                    window.currentBuildingCallback(isCorrect, playerAnswer);
                }
            }, 1500);
        }

        // === TIME & SCHEDULING SYSTEM ===
        // Teaches: Time-telling, elapsed time, rates

        const TIME_SYSTEM = {
            currentHour: 8, // Game starts at 8 AM
            currentMinute: 0,
            dayNumber: 1,
            events: []
        };

        function formatTime(hour, minute) {
            const h = hour % 12 || 12;
            const ampm = hour < 12 ? 'AM' : 'PM';
            const m = minute.toString().padStart(2, '0');
            return h + ':' + m + ' ' + ampm;
        }

        function showTimeChallenge(onComplete) {
            const gradeLevel = selectedGrade || 'advanced';
            const challengeTypes = [];

            // Grade-appropriate challenges
            if (['K-1'].includes(gradeLevel)) {
                challengeTypes.push('read_hour', 'read_half');
            } else if (['2'].includes(gradeLevel)) {
                challengeTypes.push('read_5min', 'elapsed_simple');
            } else if (['3', '4'].includes(gradeLevel)) {
                challengeTypes.push('elapsed_minutes', 'arrival_time');
            } else {
                challengeTypes.push('elapsed_complex', 'rate_time');
            }

            const challengeType = challengeTypes[Math.floor(Math.random() * challengeTypes.length)];

            let question, correctAnswer, options = [], showClock = true;
            let hour = Math.floor(Math.random() * 12) + 1;
            let minute = 0;

            switch (challengeType) {
                case 'read_hour':
                    minute = 0;
                    question = 'What time does the clock show?';
                    correctAnswer = hour + ':00';
                    options = [hour + ':00', ((hour % 12) + 1) + ':00', ((hour + 10) % 12 + 1) + ':00', '12:00'];
                    break;

                case 'read_half':
                    minute = Math.random() < 0.5 ? 0 : 30;
                    question = 'What time does the clock show?';
                    correctAnswer = hour + ':' + (minute === 0 ? '00' : '30');
                    options = [hour + ':00', hour + ':30', ((hour % 12) + 1) + ':00', ((hour % 12) + 1) + ':30'];
                    break;

                case 'read_5min':
                    minute = Math.floor(Math.random() * 12) * 5;
                    question = 'What time does the clock show?';
                    correctAnswer = hour + ':' + minute.toString().padStart(2, '0');
                    options = generateTimeOptions(hour, minute);
                    break;

                case 'elapsed_simple':
                    minute = 0;
                    const hoursElapsed = Math.floor(Math.random() * 3) + 1;
                    question = 'It\'s ' + hour + ':00. What time will it be in ' + hoursElapsed + ' hour' + (hoursElapsed > 1 ? 's' : '') + '?';
                    const newHour = (hour + hoursElapsed - 1) % 12 + 1;
                    correctAnswer = newHour + ':00';
                    options = generateTimeOptions(newHour, 0);
                    showClock = false;
                    break;

                case 'elapsed_minutes':
                    minute = Math.floor(Math.random() * 4) * 15;
                    const minsElapsed = [15, 30, 45][Math.floor(Math.random() * 3)];
                    question = 'It\'s ' + hour + ':' + minute.toString().padStart(2, '0') + '. What time will it be in ' + minsElapsed + ' minutes?';
                    const totalMins = hour * 60 + minute + minsElapsed;
                    const endHour = Math.floor(totalMins / 60) % 12 || 12;
                    const endMin = totalMins % 60;
                    correctAnswer = endHour + ':' + endMin.toString().padStart(2, '0');
                    options = generateTimeOptions(endHour, endMin);
                    showClock = false;
                    break;

                case 'arrival_time':
                    const startHour = Math.floor(Math.random() * 8) + 6; // 6 AM - 2 PM
                    const travelTime = [20, 30, 45, 60][Math.floor(Math.random() * 4)];
                    question = 'You leave at ' + startHour + ':00. Travel takes ' + travelTime + ' minutes. When do you arrive?';
                    const arrivalMins = startHour * 60 + travelTime;
                    const arrHour = Math.floor(arrivalMins / 60) % 12 || 12;
                    const arrMin = arrivalMins % 60;
                    correctAnswer = arrHour + ':' + arrMin.toString().padStart(2, '0');
                    options = generateTimeOptions(arrHour, arrMin);
                    showClock = false;
                    break;

                case 'rate_time':
                    const distance = [10, 15, 20, 25, 30][Math.floor(Math.random() * 5)];
                    const speed = [5, 10][Math.floor(Math.random() * 2)];
                    question = 'You need to travel ' + distance + ' miles at ' + speed + ' mph. How many hours will it take?';
                    correctAnswer = (distance / speed).toString();
                    showClock = false;
                    break;
            }

            showTimeUI(question, correctAnswer, options, showClock ? { hour, minute } : null, challengeType, onComplete);
        }

        function generateTimeOptions(hour, minute) {
            const correct = hour + ':' + minute.toString().padStart(2, '0');
            const options = [correct];

            while (options.length < 4) {
                const randHour = Math.floor(Math.random() * 12) + 1;
                const randMin = Math.floor(Math.random() * 12) * 5;
                const opt = randHour + ':' + randMin.toString().padStart(2, '0');
                if (!options.includes(opt)) {
                    options.push(opt);
                }
            }

            // Shuffle
            for (let i = options.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [options[i], options[j]] = [options[j], options[i]];
            }

            return options;
        }

        function showTimeUI(question, correctAnswer, options, clockData, challengeType, onComplete) {
            const overlay = document.createElement('div');
            overlay.className = 'visual-math-overlay';
            overlay.id = 'time-overlay';

            let html = '<div class="visual-math-container">';
            html += '<h3 class="visual-math-title">⏰ Time Challenge</h3>';
            html += '<p class="visual-math-instruction">' + question + '</p>';

            // Draw clock if needed
            if (clockData) {
                html += generateClockSVG(clockData.hour, clockData.minute);
            }

            // Options or input
            if (options && options.length > 0) {
                html += '<div class="shape-grid" style="grid-template-columns: repeat(2, 1fr);">';
                options.forEach(opt => {
                    html += '<div class="shape-option" data-answer="' + opt + '" style="font-size: 1.3em; padding: 15px;">' + opt + '</div>';
                });
                html += '</div>';
            } else {
                html += '<div style="text-align: center; margin: 20px 0;">';
                html += '<input type="text" id="time-answer" class="terminal-input" style="width: 100px; font-size: 1.3em;" placeholder="?">';
                html += '</div>';
            }

            html += '<button class="visual-submit-btn" id="time-submit" disabled>Select an answer</button>';
            html += '</div>';

            overlay.innerHTML = html;
            document.body.appendChild(overlay);

            let selectedAnswer = null;

            // Option selection
            overlay.querySelectorAll('.shape-option').forEach(opt => {
                opt.addEventListener('click', function() {
                    overlay.querySelectorAll('.shape-option').forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedAnswer = this.dataset.answer;
                    document.getElementById('time-submit').disabled = false;
                    document.getElementById('time-submit').textContent = 'Submit Answer';
                });
            });

            // Input field change
            const inputField = document.getElementById('time-answer');
            if (inputField) {
                inputField.addEventListener('input', function() {
                    selectedAnswer = this.value;
                    document.getElementById('time-submit').disabled = this.value.length === 0;
                    document.getElementById('time-submit').textContent = 'Submit Answer';
                });
            }

            // Submit handler
            document.getElementById('time-submit').onclick = function() {
                const isCorrect = selectedAnswer === correctAnswer || selectedAnswer === correctAnswer.toString();

                logPracticeSession('Counting and Number Recognition', isCorrect, {
                    type: 'time_' + challengeType,
                    answer: selectedAnswer,
                    correctAnswer: correctAnswer
                });

                if (isCorrect) {
                    this.style.background = 'rgba(0, 200, 0, 0.8)';
                    this.textContent = '✓ Correct!';
                } else {
                    this.style.background = 'rgba(200, 0, 0, 0.8)';
                    this.textContent = '✗ Answer: ' + correctAnswer;
                }
                this.disabled = true;

                setTimeout(() => {
                    if (overlay.parentElement) {
                        document.body.removeChild(overlay);
                    }
                    if (onComplete) onComplete(isCorrect, selectedAnswer);
                }, 1500);
            };
        }

        function generateClockSVG(hour, minute) {
            const hourAngle = (hour % 12 + minute / 60) * 30 - 90;
            const minuteAngle = minute * 6 - 90;

            const hourX = 50 + 25 * Math.cos(hourAngle * Math.PI / 180);
            const hourY = 50 + 25 * Math.sin(hourAngle * Math.PI / 180);
            const minX = 50 + 35 * Math.cos(minuteAngle * Math.PI / 180);
            const minY = 50 + 35 * Math.sin(minuteAngle * Math.PI / 180);

            let svg = '<div style="text-align: center; margin: 20px 0;">';
            svg += '<svg width="150" height="150" viewBox="0 0 100 100" style="background: #111; border: 3px solid #0f0; border-radius: 50%;">';

            // Hour markers
            for (let i = 1; i <= 12; i++) {
                const angle = i * 30 - 90;
                const x = 50 + 40 * Math.cos(angle * Math.PI / 180);
                const y = 50 + 40 * Math.sin(angle * Math.PI / 180);
                svg += '<text x="' + x + '" y="' + (y + 3) + '" fill="#0f0" font-size="8" text-anchor="middle">' + i + '</text>';
            }

            // Hour hand (short, thick)
            svg += '<line x1="50" y1="50" x2="' + hourX + '" y2="' + hourY + '" stroke="#0f0" stroke-width="4" stroke-linecap="round"/>';

            // Minute hand (long, thin)
            svg += '<line x1="50" y1="50" x2="' + minX + '" y2="' + minY + '" stroke="#0a0" stroke-width="2" stroke-linecap="round"/>';

            // Center dot
            svg += '<circle cx="50" cy="50" r="3" fill="#0f0"/>';

            svg += '</svg>';
            svg += '</div>';

            return svg;
        }

        // === ENHANCED CURRENCY SYSTEM ===
        // Teaches: Money counting, decimals, percentages

        // Currency system for math challenges - prices in cents for realism
        const CURRENCY_SYSTEM = {
            playerMoney: 10000, // $100.00
            items: [
                { name: 'Med Kit', price: 2500, icon: '💉' },      // $25.00
                { name: 'Antitoxin', price: 1500, icon: '💊' },    // $15.00
                { name: 'Water Bottle', price: 200, icon: '💧' },   // $2.00
                { name: 'Canned Food', price: 250, icon: '🥫' },    // $2.50
                { name: '9mm Ammo (10)', price: 500, icon: '🔫' },  // $5.00
                { name: 'Frag Grenade', price: 4500, icon: '💣' },  // $45.00
                { name: 'Hunting Knife', price: 3500, icon: '🔪' }, // $35.00
                { name: 'Body Armor', price: 12000, icon: '🦺' }    // $120.00
            ]
        };

        function showCurrencyChallenge(onComplete) {
            const gradeLevel = selectedGrade || 'advanced';
            const challengeTypes = [];

            if (['K-1', '2'].includes(gradeLevel)) {
                challengeTypes.push('count_coins', 'make_change_simple');
            } else if (['3', '4'].includes(gradeLevel)) {
                challengeTypes.push('make_change', 'total_cost');
            } else if (['5-6'].includes(gradeLevel)) {
                challengeTypes.push('discount', 'tax');
            } else {
                challengeTypes.push('compound', 'comparison');
            }

            const challengeType = challengeTypes[Math.floor(Math.random() * challengeTypes.length)];

            let question, correctAnswer, hint = '';
            const item = CURRENCY_SYSTEM.items[Math.floor(Math.random() * CURRENCY_SYSTEM.items.length)];

            switch (challengeType) {
                case 'count_coins':
                    // Use visual coin system
                    const targetCents = Math.floor(Math.random() * 50) + 10;
                    showVisualMathProblem({
                        type: 'coins',
                        question: 'Make ' + targetCents + ' cents to buy supplies',
                        instruction: 'Drag coins to make the exact amount',
                        data: {
                            coins: [
                                { type: 'quarter', count: 4 },
                                { type: 'dime', count: 5 },
                                { type: 'nickel', count: 5 },
                                { type: 'penny', count: 10 }
                            ],
                            targetCents: targetCents
                        },
                        correctAnswer: targetCents,
                        skillName: 'Counting and Number Recognition',
                        onComplete: onComplete
                    });
                    return;

                case 'make_change_simple':
                    // Use simpler dollar amounts for young grades
                    const simplePrice = Math.round(item.price / 100); // Convert to dollars
                    const paid = Math.ceil(simplePrice / 5) * 5; // Round up to nearest $5
                    const change = paid - simplePrice;
                    question = 'You buy a ' + item.name + ' ' + item.icon + ' for $' + simplePrice + '. You pay $' + paid + '. How much change in dollars?';
                    correctAnswer = change;
                    hint = 'Change = paid - price';
                    break;

                case 'make_change':
                    const priceInDollars = (item.price / 100).toFixed(2);
                    const paidAmount = [20, 50, 100][Math.floor(Math.random() * 3)];
                    const changeAmount = (paidAmount - item.price / 100).toFixed(2);
                    question = 'A ' + item.name + ' ' + item.icon + ' costs $' + priceInDollars + '. You pay with $' + paidAmount + '. What\'s your change?';
                    correctAnswer = parseFloat(changeAmount);
                    hint = 'Change = amount paid - price';
                    break;

                case 'total_cost':
                    const qty = Math.floor(Math.random() * 4) + 2;
                    const unitPrice = (item.price / 100).toFixed(2);
                    const totalCost = ((item.price * qty) / 100).toFixed(2);
                    question = 'You want to buy ' + qty + ' ' + item.name + 's ' + item.icon + ' at $' + unitPrice + ' each. What\'s the total cost?';
                    correctAnswer = parseFloat(totalCost);
                    hint = 'Total = price × quantity';
                    break;

                case 'discount':
                    const discountPct = [10, 15, 20, 25][Math.floor(Math.random() * 4)];
                    const basePrice = Math.round(item.price / (1 - discountPct / 100));
                    const discountedPrice = basePrice - Math.round(basePrice * discountPct / 100);
                    question = 'A ' + item.name + ' ' + item.icon + ' normally costs $' + (basePrice / 100).toFixed(2) + ' but is ' + discountPct + '% off. What\'s the sale price?';
                    correctAnswer = parseFloat((discountedPrice / 100).toFixed(2));
                    hint = 'Sale price = original - (original × discount%)';
                    break;

                case 'tax':
                    const taxRate = [5, 8, 10][Math.floor(Math.random() * 3)];
                    const withTax = Math.round(item.price * (1 + taxRate / 100));
                    question = 'A ' + item.name + ' ' + item.icon + ' is $' + (item.price / 100).toFixed(2) + ' plus ' + taxRate + '% tax. What\'s the total with tax?';
                    correctAnswer = parseFloat((withTax / 100).toFixed(2));
                    hint = 'Total = price + (price × tax rate)';
                    break;

                case 'compound':
                    const principal = [100, 200, 500][Math.floor(Math.random() * 3)];
                    const rate = 10;
                    const years = 2;
                    const compound = Math.round(principal * Math.pow(1 + rate / 100, years));
                    question = 'You invest $' + principal + ' at 10% annual interest. After 2 years with compound interest, how much do you have?';
                    correctAnswer = compound;
                    hint = 'A = P(1 + r)^t';
                    break;

                case 'comparison':
                    const item2 = CURRENCY_SYSTEM.items[Math.floor(Math.random() * CURRENCY_SYSTEM.items.length)];
                    const buyQty1 = Math.floor(Math.random() * 3) + 1;
                    const buyQty2 = Math.floor(Math.random() * 3) + 1;
                    const total1 = buyQty1 * item.price;
                    const total2 = buyQty2 * item2.price;
                    question = 'Which costs more: ' + buyQty1 + ' ' + item.name + '(s) at $' + (item.price / 100).toFixed(2) + ' each, or ' + buyQty2 + ' ' + item2.name + '(s) at $' + (item2.price / 100).toFixed(2) + ' each?';
                    correctAnswer = total1 > total2 ? item.name : (total1 < total2 ? item2.name : 'Same');
                    break;
            }

            showCurrencyUI(question, correctAnswer, hint, challengeType, onComplete);
        }

        function showCurrencyUI(question, correctAnswer, hint, challengeType, onComplete) {
            const overlay = document.createElement('div');
            overlay.className = 'visual-math-overlay';
            overlay.id = 'currency-overlay';

            let html = '<div class="visual-math-container">';
            html += '<h3 class="visual-math-title">💵 Cash Exchange</h3>';
            html += '<p class="visual-math-instruction">' + question + '</p>';

            if (hint) {
                html += '<p style="color: #888; font-size: 0.9em; text-align: center;"><em>' + hint + '</em></p>';
            }

            // For comparison, show options
            if (challengeType === 'comparison') {
                html += '<div class="shape-grid" style="grid-template-columns: repeat(3, 1fr);">';
                const options = [correctAnswer];
                if (correctAnswer !== 'Same') {
                    options.push(correctAnswer === question.split(' or ')[0].split(': ')[1].split(' ')[1] ?
                        question.split(' or ')[1].split(' ')[0] : question.split(': ')[1].split(' ')[1]);
                    options.push('Same');
                }
                options.forEach(opt => {
                    html += '<div class="shape-option" data-answer="' + opt + '" style="padding: 15px;">' + opt + '</div>';
                });
                html += '</div>';
            } else {
                html += '<div style="text-align: center; margin: 20px 0;">';
                html += '<input type="number" id="currency-answer" class="terminal-input" style="width: 150px; font-size: 1.3em;" placeholder="dollars" step="0.01">';
                html += '</div>';
            }

            html += '<button class="visual-submit-btn" id="currency-submit">Submit Answer</button>';
            html += '</div>';

            overlay.innerHTML = html;
            document.body.appendChild(overlay);

            let selectedAnswer = null;

            // Option click handlers
            overlay.querySelectorAll('.shape-option').forEach(opt => {
                opt.addEventListener('click', function() {
                    overlay.querySelectorAll('.shape-option').forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedAnswer = this.dataset.answer;
                });
            });

            document.getElementById('currency-submit').onclick = function() {
                const inputField = document.getElementById('currency-answer');
                if (inputField) {
                    selectedAnswer = parseInt(inputField.value);
                }

                const isCorrect = selectedAnswer == correctAnswer;

                logPracticeSession('Basic Multiplication', isCorrect, {
                    type: 'currency_' + challengeType,
                    answer: selectedAnswer,
                    correctAnswer: correctAnswer
                });

                if (isCorrect) {
                    this.style.background = 'rgba(0, 200, 0, 0.8)';
                    this.textContent = '✓ Correct!';
                } else {
                    this.style.background = 'rgba(200, 0, 0, 0.8)';
                    this.textContent = '✗ Answer: ' + correctAnswer;
                }
                this.disabled = true;

                setTimeout(() => {
                    if (overlay.parentElement) {
                        document.body.removeChild(overlay);
                    }
                    if (onComplete) onComplete(isCorrect, selectedAnswer);
                }, 1500);
            };
        }

        // === SHAPE CHALLENGE SYSTEM ===
        // Teaches: Shape properties, angles, symmetry

        function showShapeChallenge(onComplete) {
            const gradeLevel = selectedGrade || 'advanced';

            if (['K-1', '2'].includes(gradeLevel)) {
                // Use visual shape recognition
                const problem = generateVisualMathProblem('shapes', gradeLevel === 'K-1' ? 'K' : '2');
                problem.onComplete = onComplete;
                showVisualMathProblem(problem);
                return;
            }

            const challenges = [];

            if (['3', '4'].includes(gradeLevel)) {
                challenges.push('sides_corners', 'right_angles', 'symmetry_lines');
            } else if (['5-6'].includes(gradeLevel)) {
                challenges.push('angle_sum', 'classify_triangle', 'quadrilateral_type');
            } else {
                challenges.push('polygon_angles', 'triangle_angles', 'similar_shapes');
            }

            const challengeType = challenges[Math.floor(Math.random() * challenges.length)];

            let question, correctAnswer, options = [];

            switch (challengeType) {
                case 'sides_corners':
                    const shapes = [
                        { name: 'triangle', sides: 3 },
                        { name: 'square', sides: 4 },
                        { name: 'pentagon', sides: 5 },
                        { name: 'hexagon', sides: 6 },
                        { name: 'octagon', sides: 8 }
                    ];
                    const shape = shapes[Math.floor(Math.random() * shapes.length)];
                    question = 'How many sides does a ' + shape.name + ' have?';
                    correctAnswer = shape.sides;
                    options = [3, 4, 5, 6, 8];
                    break;

                case 'right_angles':
                    const rightAngleShapes = [
                        { name: 'square', count: 4 },
                        { name: 'rectangle', count: 4 },
                        { name: 'right triangle', count: 1 },
                        { name: 'regular hexagon', count: 0 }
                    ];
                    const raShape = rightAngleShapes[Math.floor(Math.random() * rightAngleShapes.length)];
                    question = 'How many right angles (90°) does a ' + raShape.name + ' have?';
                    correctAnswer = raShape.count;
                    options = [0, 1, 2, 4];
                    break;

                case 'symmetry_lines':
                    const symShapes = [
                        { name: 'square', lines: 4 },
                        { name: 'rectangle', lines: 2 },
                        { name: 'equilateral triangle', lines: 3 },
                        { name: 'circle', lines: 'infinite' }
                    ];
                    const symShape = symShapes[Math.floor(Math.random() * (symShapes.length - 1))]; // Exclude circle for simplicity
                    question = 'How many lines of symmetry does a ' + symShape.name + ' have?';
                    correctAnswer = symShape.lines;
                    options = [1, 2, 3, 4];
                    break;

                case 'angle_sum':
                    const polygons = [
                        { name: 'triangle', sum: 180 },
                        { name: 'quadrilateral', sum: 360 },
                        { name: 'pentagon', sum: 540 },
                        { name: 'hexagon', sum: 720 }
                    ];
                    const poly = polygons[Math.floor(Math.random() * polygons.length)];
                    question = 'What is the sum of all interior angles in a ' + poly.name + '?';
                    correctAnswer = poly.sum;
                    options = [180, 360, 540, 720];
                    break;

                case 'classify_triangle':
                    const triangleTypes = ['equilateral', 'isosceles', 'scalene', 'right'];
                    const triType = triangleTypes[Math.floor(Math.random() * triangleTypes.length)];
                    const descriptions = {
                        equilateral: 'all sides equal',
                        isosceles: 'two sides equal',
                        scalene: 'no sides equal',
                        right: 'one 90° angle'
                    };
                    question = 'A triangle with ' + descriptions[triType] + ' is called?';
                    correctAnswer = triType;
                    options = triangleTypes;
                    break;

                case 'triangle_angles':
                    const angle1 = Math.floor(Math.random() * 60) + 30; // 30-90
                    const angle2 = Math.floor(Math.random() * (150 - angle1 - 10)) + 10;
                    const angle3 = 180 - angle1 - angle2;
                    question = 'A triangle has angles of ' + angle1 + '° and ' + angle2 + '°. What is the third angle?';
                    correctAnswer = angle3;
                    break;
            }

            showShapeChallengeUI(question, correctAnswer, options, challengeType, onComplete);
        }

        function showShapeChallengeUI(question, correctAnswer, options, challengeType, onComplete) {
            const overlay = document.createElement('div');
            overlay.className = 'visual-math-overlay';
            overlay.id = 'shape-challenge-overlay';

            let html = '<div class="visual-math-container">';
            html += '<h3 class="visual-math-title">🔷 Shape Challenge</h3>';
            html += '<p class="visual-math-instruction">' + question + '</p>';

            if (options.length > 0) {
                html += '<div class="shape-grid" style="grid-template-columns: repeat(2, 1fr);">';
                options.forEach(opt => {
                    html += '<div class="shape-option" data-answer="' + opt + '" style="padding: 15px; font-size: 1.1em;">' + opt + (typeof opt === 'number' && challengeType.includes('angle') ? '°' : '') + '</div>';
                });
                html += '</div>';
            } else {
                html += '<div style="text-align: center; margin: 20px 0;">';
                html += '<input type="number" id="shape-answer" class="terminal-input" style="width: 100px;" placeholder="?">';
                html += '<span style="margin-left: 5px; color: #0f0;">°</span>';
                html += '</div>';
            }

            html += '<button class="visual-submit-btn" id="shape-submit">Submit Answer</button>';
            html += '</div>';

            overlay.innerHTML = html;
            document.body.appendChild(overlay);

            let selectedAnswer = null;

            overlay.querySelectorAll('.shape-option').forEach(opt => {
                opt.addEventListener('click', function() {
                    overlay.querySelectorAll('.shape-option').forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedAnswer = this.dataset.answer;
                });
            });

            document.getElementById('shape-submit').onclick = function() {
                const inputField = document.getElementById('shape-answer');
                if (inputField) {
                    selectedAnswer = parseInt(inputField.value);
                }

                const isCorrect = selectedAnswer == correctAnswer;

                logPracticeSession('Basic Geometry Concepts', isCorrect, {
                    type: 'shape_' + challengeType,
                    answer: selectedAnswer,
                    correctAnswer: correctAnswer
                });

                if (isCorrect) {
                    this.style.background = 'rgba(0, 200, 0, 0.8)';
                    this.textContent = '✓ Correct!';
                } else {
                    this.style.background = 'rgba(200, 0, 0, 0.8)';
                    this.textContent = '✗ Answer: ' + correctAnswer + (typeof correctAnswer === 'number' && challengeType.includes('angle') ? '°' : '');
                }
                this.disabled = true;

                setTimeout(() => {
                    if (overlay.parentElement) {
                        document.body.removeChild(overlay);
                    }
                    if (onComplete) onComplete(isCorrect, selectedAnswer);
                }, 1500);
            };
        }

        // ============================================
        // PHASE 2: NAVIGATION SYSTEMS
        // ============================================

        // === MAP & COORDINATE SYSTEM ===
        // Teaches: Coordinates, directions, distance, transformations

        const MAP_SYSTEM = {
            gridSize: 10, // 10x10 coordinate grid
            locations: [
                { name: 'Base Camp', icon: '🏠', x: 5, y: 5 },
                { name: 'Trading Post', icon: '🏪', x: 2, y: 3 },
                { name: 'Old Bunker', icon: '🔒', x: 8, y: 2 },
                { name: 'Bandit Camp', icon: '💀', x: 7, y: 8 },
                { name: 'Water Source', icon: '💧', x: 1, y: 7 },
                { name: 'Scrap Yard', icon: '⚙️', x: 9, y: 6 },
                { name: 'Med Station', icon: '🏥', x: 3, y: 9 },
                { name: 'Radio Tower', icon: '📡', x: 6, y: 1 }
            ]
        };

        function showMapChallenge(onComplete) {
            const gradeLevel = selectedGrade || 'advanced';
            const challengeTypes = [];

            if (['K-1'].includes(gradeLevel)) {
                challengeTypes.push('directions', 'find_location');
            } else if (['2', '3'].includes(gradeLevel)) {
                challengeTypes.push('read_coords', 'count_steps');
            } else if (['4', '5-6'].includes(gradeLevel)) {
                challengeTypes.push('plot_point', 'distance_grid', 'scale_reading');
            } else {
                challengeTypes.push('pythagorean_distance', 'midpoint', 'bearing');
            }

            const challengeType = challengeTypes[Math.floor(Math.random() * challengeTypes.length)];

            let question, correctAnswer, mapData = {};
            const loc1 = MAP_SYSTEM.locations[Math.floor(Math.random() * MAP_SYSTEM.locations.length)];
            let loc2 = MAP_SYSTEM.locations[Math.floor(Math.random() * MAP_SYSTEM.locations.length)];
            while (loc2 === loc1) {
                loc2 = MAP_SYSTEM.locations[Math.floor(Math.random() * MAP_SYSTEM.locations.length)];
            }

            switch (challengeType) {
                case 'directions':
                    const dx = loc2.x - loc1.x;
                    const dy = loc2.y - loc1.y;
                    let direction = '';
                    if (dy < 0) direction = 'North';
                    else if (dy > 0) direction = 'South';
                    if (dx > 0) direction += direction ? 'east' : 'East';
                    else if (dx < 0) direction += direction ? 'west' : 'West';
                    question = 'From ' + loc1.name + ' ' + loc1.icon + ', which direction is ' + loc2.name + ' ' + loc2.icon + '?';
                    correctAnswer = direction || 'Same location';
                    mapData = { showLocations: [loc1, loc2], highlight: loc1 };
                    break;

                case 'find_location':
                    question = 'Find the ' + loc1.name + ' ' + loc1.icon + ' on the map. What is at position (' + loc1.x + ', ' + loc1.y + ')?';
                    correctAnswer = loc1.name;
                    mapData = { showGrid: true, showLocations: MAP_SYSTEM.locations };
                    break;

                case 'read_coords':
                    question = 'What are the coordinates of ' + loc1.name + ' ' + loc1.icon + '?';
                    correctAnswer = '(' + loc1.x + ', ' + loc1.y + ')';
                    mapData = { showGrid: true, showLocations: MAP_SYSTEM.locations, highlight: loc1 };
                    break;

                case 'count_steps':
                    const stepsX = Math.abs(loc2.x - loc1.x);
                    const stepsY = Math.abs(loc2.y - loc1.y);
                    question = 'How many grid squares do you travel going from ' + loc1.name + ' to ' + loc2.name + '? (Manhattan distance: only horizontal + vertical)';
                    correctAnswer = stepsX + stepsY;
                    mapData = { showGrid: true, showLocations: [loc1, loc2], drawPath: true };
                    break;

                case 'plot_point':
                    const newX = Math.floor(Math.random() * 9) + 1;
                    const newY = Math.floor(Math.random() * 9) + 1;
                    question = 'You discover a new location at (' + newX + ', ' + newY + '). Click to plot it on the map!';
                    correctAnswer = newX + ',' + newY;
                    mapData = { showGrid: true, showLocations: MAP_SYSTEM.locations, plotMode: true, targetX: newX, targetY: newY };
                    break;

                case 'distance_grid':
                    const gridDist = Math.abs(loc2.x - loc1.x) + Math.abs(loc2.y - loc1.y);
                    question = 'Each grid square is 10 miles. What\'s the total travel distance (Manhattan) from ' + loc1.name + ' to ' + loc2.name + '?';
                    correctAnswer = gridDist * 10;
                    mapData = { showGrid: true, showLocations: [loc1, loc2], scale: 10 };
                    break;

                case 'scale_reading':
                    const scale = [5, 10, 20][Math.floor(Math.random() * 3)];
                    const squares = Math.floor(Math.random() * 8) + 2;
                    question = 'If 1 square on the map = ' + scale + ' miles, how many miles is ' + squares + ' squares?';
                    correctAnswer = scale * squares;
                    mapData = { showScale: true, scale: scale };
                    break;

                case 'pythagorean_distance':
                    const pdx = loc2.x - loc1.x;
                    const pdy = loc2.y - loc1.y;
                    const straightLine = Math.sqrt(pdx * pdx + pdy * pdy);
                    question = 'What\'s the straight-line distance from ' + loc1.name + ' (' + loc1.x + ',' + loc1.y + ') to ' + loc2.name + ' (' + loc2.x + ',' + loc2.y + ')? Round to 1 decimal.';
                    correctAnswer = Math.round(straightLine * 10) / 10;
                    mapData = { showGrid: true, showLocations: [loc1, loc2], drawLine: true };
                    break;

                case 'midpoint':
                    const midX = (loc1.x + loc2.x) / 2;
                    const midY = (loc1.y + loc2.y) / 2;
                    question = 'What\'s the midpoint between ' + loc1.name + ' (' + loc1.x + ',' + loc1.y + ') and ' + loc2.name + ' (' + loc2.x + ',' + loc2.y + ')?';
                    correctAnswer = '(' + midX + ', ' + midY + ')';
                    mapData = { showGrid: true, showLocations: [loc1, loc2] };
                    break;

                case 'bearing':
                    const bdx = loc2.x - loc1.x;
                    const bdy = -(loc2.y - loc1.y); // Invert Y for compass
                    let bearing = Math.atan2(bdx, bdy) * 180 / Math.PI;
                    if (bearing < 0) bearing += 360;
                    bearing = Math.round(bearing);
                    question = 'What compass bearing (0-360°) points from ' + loc1.name + ' to ' + loc2.name + '? (0°=North, 90°=East)';
                    correctAnswer = bearing;
                    mapData = { showGrid: true, showLocations: [loc1, loc2], showCompass: true };
                    break;
            }

            showMapUI(question, correctAnswer, challengeType, mapData, onComplete);
        }

        function showMapUI(question, correctAnswer, challengeType, mapData, onComplete) {
            const overlay = document.createElement('div');
            overlay.className = 'visual-math-overlay';
            overlay.id = 'map-overlay';

            let html = '<div class="visual-math-container" style="max-width: 650px;">';
            html += '<h3 class="visual-math-title">🗺️ Navigation</h3>';
            html += '<p class="visual-math-instruction">' + question + '</p>';

            // Draw map grid
            if (mapData.showGrid) {
                html += '<div style="display: grid; grid-template-columns: 25px repeat(10, 30px); gap: 1px; margin: 15px auto; width: fit-content;">';

                // Top row with X labels
                html += '<div></div>';
                for (let x = 0; x < 10; x++) {
                    html += '<div style="text-align: center; color: #0f0; font-size: 0.8em;">' + x + '</div>';
                }

                // Grid rows
                for (let y = 0; y < 10; y++) {
                    // Y label
                    html += '<div style="text-align: center; color: #0f0; font-size: 0.8em; line-height: 30px;">' + y + '</div>';

                    for (let x = 0; x < 10; x++) {
                        const loc = mapData.showLocations ? mapData.showLocations.find(l => l.x === x && l.y === y) : null;
                        const isHighlight = mapData.highlight && mapData.highlight.x === x && mapData.highlight.y === y;
                        const cellStyle = 'width: 30px; height: 30px; background: ' + (isHighlight ? 'rgba(255, 255, 0, 0.3)' : 'rgba(0, 50, 0, 0.3)') + '; border: 1px solid #0a0; display: flex; align-items: center; justify-content: center; font-size: 1em; cursor: ' + (mapData.plotMode ? 'pointer' : 'default') + ';';

                        html += '<div class="map-cell" data-x="' + x + '" data-y="' + y + '" style="' + cellStyle + '">';
                        if (loc) {
                            html += loc.icon;
                        }
                        html += '</div>';
                    }
                }
                html += '</div>';
            }

            // Direction options
            if (challengeType === 'directions') {
                html += '<div class="shape-grid" style="grid-template-columns: repeat(3, 1fr);">';
                ['Northwest', 'North', 'Northeast', 'West', '', 'East', 'Southwest', 'South', 'Southeast'].forEach(dir => {
                    if (dir) {
                        html += '<div class="shape-option" data-answer="' + dir + '" style="padding: 10px;">' + dir + '</div>';
                    } else {
                        html += '<div style="background: rgba(0,0,0,0.5);"></div>';
                    }
                });
                html += '</div>';
            } else if (challengeType === 'find_location') {
                html += '<div class="shape-grid" style="grid-template-columns: repeat(2, 1fr);">';
                const shuffledLocs = [...MAP_SYSTEM.locations].sort(() => Math.random() - 0.5).slice(0, 4);
                if (!shuffledLocs.includes(correctAnswer)) shuffledLocs[0] = { name: correctAnswer };
                shuffledLocs.forEach(loc => {
                    html += '<div class="shape-option" data-answer="' + (loc.name || loc) + '" style="padding: 10px;">' + (loc.icon || '') + ' ' + (loc.name || loc) + '</div>';
                });
                html += '</div>';
            } else if (!mapData.plotMode) {
                html += '<div style="text-align: center; margin: 15px 0;">';
                html += '<input type="text" id="map-answer" class="terminal-input" style="width: 150px; font-size: 1.1em;" placeholder="Your answer">';
                html += '</div>';
            }

            html += '<button class="visual-submit-btn" id="map-submit">' + (mapData.plotMode ? 'Click on map to plot' : 'Submit Answer') + '</button>';
            html += '</div>';

            overlay.innerHTML = html;
            document.body.appendChild(overlay);

            let selectedAnswer = null;

            // Handle option clicks
            overlay.querySelectorAll('.shape-option').forEach(opt => {
                opt.addEventListener('click', function() {
                    overlay.querySelectorAll('.shape-option').forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedAnswer = this.dataset.answer;
                });
            });

            // Handle plot mode
            if (mapData.plotMode) {
                overlay.querySelectorAll('.map-cell').forEach(cell => {
                    cell.addEventListener('click', function() {
                        overlay.querySelectorAll('.map-cell').forEach(c => c.style.background = 'rgba(0, 50, 0, 0.3)');
                        this.style.background = 'rgba(0, 255, 0, 0.5)';
                        selectedAnswer = this.dataset.x + ',' + this.dataset.y;
                        document.getElementById('map-submit').textContent = 'Submit: (' + this.dataset.x + ', ' + this.dataset.y + ')';
                    });
                });
            }

            document.getElementById('map-submit').onclick = function() {
                const inputField = document.getElementById('map-answer');
                if (inputField) {
                    selectedAnswer = inputField.value;
                }

                let isCorrect = false;
                if (typeof correctAnswer === 'number') {
                    isCorrect = parseFloat(selectedAnswer) === correctAnswer;
                } else {
                    isCorrect = selectedAnswer === correctAnswer || selectedAnswer === correctAnswer.toString();
                }

                logPracticeSession('Counting and Number Recognition', isCorrect, {
                    type: 'map_' + challengeType,
                    answer: selectedAnswer,
                    correctAnswer: correctAnswer
                });

                if (isCorrect) {
                    this.style.background = 'rgba(0, 200, 0, 0.8)';
                    this.textContent = '✓ Correct!';
                } else {
                    this.style.background = 'rgba(200, 0, 0, 0.8)';
                    this.textContent = '✗ Answer: ' + correctAnswer;
                }
                this.disabled = true;

                setTimeout(() => {
                    if (overlay.parentElement) {
                        document.body.removeChild(overlay);
                    }
                    if (onComplete) onComplete(isCorrect, selectedAnswer);
                }, 1500);
            };
        }

        // === WEATHER & TEMPERATURE SYSTEM ===
        // Teaches: Temperature, negative numbers, patterns, prediction

        const WEATHER_SYSTEM = {
            conditions: ['Clear', 'Cloudy', 'Radiation Storm', 'Dust Storm', 'Rain'],
            baseTemp: 75 // Fahrenheit
        };

        function showWeatherChallenge(onComplete) {
            const gradeLevel = selectedGrade || 'advanced';
            const challengeTypes = [];

            if (['K-1', '2'].includes(gradeLevel)) {
                challengeTypes.push('compare_temp', 'thermometer_read');
            } else if (['3', '4'].includes(gradeLevel)) {
                challengeTypes.push('temp_change', 'pattern_predict');
            } else if (['5-6'].includes(gradeLevel)) {
                challengeTypes.push('negative_temps', 'temp_range');
            } else {
                challengeTypes.push('wind_chill', 'conversion');
            }

            const challengeType = challengeTypes[Math.floor(Math.random() * challengeTypes.length)];

            let question, correctAnswer, weatherData = {};

            switch (challengeType) {
                case 'compare_temp':
                    const temp1 = Math.floor(Math.random() * 60) + 20;
                    const temp2 = Math.floor(Math.random() * 60) + 20;
                    question = 'Which is warmer: ' + temp1 + '°F or ' + temp2 + '°F?';
                    correctAnswer = Math.max(temp1, temp2) + '°F';
                    weatherData = { temps: [temp1, temp2] };
                    break;

                case 'thermometer_read':
                    const readTemp = Math.floor(Math.random() * 80) + 10;
                    question = 'What temperature does the thermometer show?';
                    correctAnswer = readTemp;
                    weatherData = { showThermometer: true, temp: readTemp };
                    break;

                case 'temp_change':
                    const startTemp = Math.floor(Math.random() * 50) + 40;
                    const change = [5, 10, 12, 15, 20][Math.floor(Math.random() * 5)];
                    const rising = Math.random() < 0.5;
                    question = 'The temperature is ' + startTemp + '°F. It ' + (rising ? 'rises' : 'falls') + ' by ' + change + '°. What\'s the new temperature?';
                    correctAnswer = rising ? startTemp + change : startTemp - change;
                    weatherData = { start: startTemp, change: change, rising: rising };
                    break;

                case 'pattern_predict':
                    const temps = [];
                    let basePatternTemp = Math.floor(Math.random() * 30) + 50;
                    const patternChange = [2, 3, 5][Math.floor(Math.random() * 3)];
                    for (let i = 0; i < 4; i++) {
                        temps.push(basePatternTemp + i * patternChange);
                    }
                    question = 'Temperature pattern: ' + temps.join('°F, ') + '°F. What comes next?';
                    correctAnswer = temps[3] + patternChange;
                    weatherData = { pattern: temps };
                    break;

                case 'negative_temps':
                    const negStart = Math.floor(Math.random() * 20) + 5;
                    const negDrop = Math.floor(Math.random() * 30) + 15;
                    question = 'The temperature is ' + negStart + '°F. It drops ' + negDrop + ' degrees. What\'s the new temperature?';
                    correctAnswer = negStart - negDrop;
                    break;

                case 'temp_range':
                    const high = Math.floor(Math.random() * 30) + 70;
                    const low = Math.floor(Math.random() * 30) + 30;
                    question = 'High: ' + high + '°F, Low: ' + low + '°F. What\'s the temperature range?';
                    correctAnswer = high - low;
                    break;

                case 'wind_chill':
                    const actualTemp = Math.floor(Math.random() * 30) + 20;
                    const windSpeed = [10, 15, 20, 25][Math.floor(Math.random() * 4)];
                    // Simplified wind chill: feels like temp - (wind speed / 2)
                    const feelsLike = actualTemp - Math.round(windSpeed / 2);
                    question = 'Temperature: ' + actualTemp + '°F, Wind: ' + windSpeed + ' mph. "Feels like" = temp - (wind ÷ 2). What does it feel like?';
                    correctAnswer = feelsLike;
                    break;

                case 'conversion':
                    const tempF = [32, 50, 68, 86, 212][Math.floor(Math.random() * 5)];
                    const tempC = Math.round((tempF - 32) * 5 / 9);
                    question = 'Convert ' + tempF + '°F to Celsius. Use: C = (F - 32) × 5/9';
                    correctAnswer = tempC;
                    break;
            }

            showWeatherUI(question, correctAnswer, challengeType, weatherData, onComplete);
        }

        function showWeatherUI(question, correctAnswer, challengeType, weatherData, onComplete) {
            const overlay = document.createElement('div');
            overlay.className = 'visual-math-overlay';
            overlay.id = 'weather-overlay';

            let html = '<div class="visual-math-container">';
            html += '<h3 class="visual-math-title">🌡️ Weather Report</h3>';
            html += '<p class="visual-math-instruction">' + question + '</p>';

            // Draw thermometer
            if (weatherData.showThermometer) {
                const temp = weatherData.temp;
                const fillPct = Math.min(100, Math.max(0, (temp - 0) / 100 * 100));

                html += '<div style="display: flex; justify-content: center; margin: 20px 0;">';
                html += '<div style="position: relative; width: 40px; height: 200px; background: #222; border: 3px solid #0f0; border-radius: 20px; overflow: hidden;">';

                // Temperature scale
                html += '<div style="position: absolute; top: 0; left: 45px; height: 100%; display: flex; flex-direction: column; justify-content: space-between; color: #0f0; font-size: 0.8em;">';
                for (let t = 100; t >= 0; t -= 20) {
                    html += '<span>' + t + '°</span>';
                }
                html += '</div>';

                // Fill
                html += '<div style="position: absolute; bottom: 0; left: 0; right: 0; height: ' + fillPct + '%; background: linear-gradient(to top, #f00, #ff0, #0f0); transition: height 0.5s;"></div>';

                html += '</div>';
                html += '</div>';
            }

            // Comparison options
            if (challengeType === 'compare_temp') {
                html += '<div class="shape-grid" style="grid-template-columns: repeat(2, 1fr);">';
                weatherData.temps.forEach(t => {
                    html += '<div class="shape-option" data-answer="' + t + '°F" style="padding: 20px; font-size: 1.3em;">' + t + '°F</div>';
                });
                html += '</div>';
            } else {
                html += '<div style="text-align: center; margin: 20px 0;">';
                html += '<input type="number" id="weather-answer" class="terminal-input" style="width: 100px; font-size: 1.3em;" placeholder="°F">';
                html += '</div>';
            }

            html += '<button class="visual-submit-btn" id="weather-submit">Submit Answer</button>';
            html += '</div>';

            overlay.innerHTML = html;
            document.body.appendChild(overlay);

            let selectedAnswer = null;

            overlay.querySelectorAll('.shape-option').forEach(opt => {
                opt.addEventListener('click', function() {
                    overlay.querySelectorAll('.shape-option').forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedAnswer = this.dataset.answer;
                });
            });

            document.getElementById('weather-submit').onclick = function() {
                const inputField = document.getElementById('weather-answer');
                if (inputField) {
                    selectedAnswer = parseInt(inputField.value);
                }

                let isCorrect = false;
                if (typeof correctAnswer === 'number') {
                    isCorrect = parseInt(selectedAnswer) === correctAnswer;
                } else {
                    isCorrect = selectedAnswer === correctAnswer;
                }

                logPracticeSession('Basic Subtraction', isCorrect, {
                    type: 'weather_' + challengeType,
                    answer: selectedAnswer,
                    correctAnswer: correctAnswer
                });

                if (isCorrect) {
                    this.style.background = 'rgba(0, 200, 0, 0.8)';
                    this.textContent = '✓ Correct!';
                } else {
                    this.style.background = 'rgba(200, 0, 0, 0.8)';
                    this.textContent = '✗ Answer: ' + correctAnswer + (typeof correctAnswer === 'number' ? '°F' : '');
                }
                this.disabled = true;

                setTimeout(() => {
                    if (overlay.parentElement) {
                        document.body.removeChild(overlay);
                    }
                    if (onComplete) onComplete(isCorrect, selectedAnswer);
                }, 1500);
            };
        }

        // === COMPASS & ANGLE NAVIGATION ===
        // Teaches: Angles, directions, bearings, turns

        function showCompassChallenge(onComplete) {
            const gradeLevel = selectedGrade || 'advanced';
            const challengeTypes = [];

            if (['K-1', '2'].includes(gradeLevel)) {
                challengeTypes.push('cardinal_direction', 'left_right');
            } else if (['3', '4'].includes(gradeLevel)) {
                challengeTypes.push('quarter_turns', 'ordinal_direction');
            } else if (['5-6'].includes(gradeLevel)) {
                challengeTypes.push('angle_turn', 'degree_direction');
            } else {
                challengeTypes.push('bearing', 'vector_direction');
            }

            const challengeType = challengeTypes[Math.floor(Math.random() * challengeTypes.length)];

            const directions = ['North', 'Northeast', 'East', 'Southeast', 'South', 'Southwest', 'West', 'Northwest'];
            const cardinals = ['North', 'East', 'South', 'West'];

            let question, correctAnswer, compassData = {};

            switch (challengeType) {
                case 'cardinal_direction':
                    const cardinalIdx = Math.floor(Math.random() * 4);
                    question = 'You\'re facing ' + cardinals[cardinalIdx] + '. Which way is that?';
                    correctAnswer = cardinals[cardinalIdx];
                    compassData = { showCompass: true, facing: cardinals[cardinalIdx] };
                    break;

                case 'left_right':
                    const startDir = cardinals[Math.floor(Math.random() * 4)];
                    const turnDir = Math.random() < 0.5 ? 'left' : 'right';
                    const startIdx = cardinals.indexOf(startDir);
                    const newIdx = (startIdx + (turnDir === 'right' ? 1 : 3)) % 4;
                    question = 'You\'re facing ' + startDir + '. You turn ' + turnDir + '. Which way are you facing now?';
                    correctAnswer = cardinals[newIdx];
                    compassData = { showCompass: true };
                    break;

                case 'quarter_turns':
                    const qStartDir = cardinals[Math.floor(Math.random() * 4)];
                    const numTurns = Math.floor(Math.random() * 3) + 1;
                    const qTurnDir = Math.random() < 0.5 ? 'clockwise' : 'counterclockwise';
                    const qStartIdx = cardinals.indexOf(qStartDir);
                    const qNewIdx = (qStartIdx + (qTurnDir === 'clockwise' ? numTurns : 4 - numTurns)) % 4;
                    question = 'You face ' + qStartDir + '. After ' + numTurns + ' quarter-turn(s) ' + qTurnDir + ', which way do you face?';
                    correctAnswer = cardinals[qNewIdx];
                    compassData = { showCompass: true };
                    break;

                case 'ordinal_direction':
                    const ordinalDir = directions[Math.floor(Math.random() * 8)];
                    const angle = directions.indexOf(ordinalDir) * 45;
                    question = 'A bearing of ' + angle + '° points which direction? (0° = North, 90° = East)';
                    correctAnswer = ordinalDir;
                    compassData = { showCompass: true, angle: angle };
                    break;

                case 'angle_turn':
                    const aTurnDeg = [45, 90, 135, 180, 270][Math.floor(Math.random() * 5)];
                    const aTurnClockwise = Math.random() < 0.5;
                    const aStartDir = 'North';
                    const aNewAngle = aTurnClockwise ? aTurnDeg : 360 - aTurnDeg;
                    const aNewDir = directions[Math.floor(aNewAngle / 45) % 8];
                    question = 'You face North. You turn ' + aTurnDeg + '° ' + (aTurnClockwise ? 'clockwise' : 'counterclockwise') + '. Which way now?';
                    correctAnswer = aNewDir;
                    compassData = { showCompass: true, showAngle: aTurnDeg };
                    break;

                case 'degree_direction':
                    const degDir = Math.floor(Math.random() * 8);
                    const degAngle = degDir * 45;
                    question = 'Which compass direction is ' + degAngle + '°?';
                    correctAnswer = directions[degDir];
                    compassData = { showCompass: true };
                    break;

                case 'bearing':
                    const bearingDeg = Math.floor(Math.random() * 36) * 10; // 0, 10, 20, ... 350
                    question = 'What is the closest cardinal direction for bearing ' + bearingDeg + '°?';
                    const closestCardinalIdx = Math.round(bearingDeg / 90) % 4;
                    correctAnswer = cardinals[closestCardinalIdx];
                    compassData = { showCompass: true, bearing: bearingDeg };
                    break;

                case 'vector_direction':
                    const vx = [1, -1, 0, 1, -1][Math.floor(Math.random() * 5)];
                    const vy = [1, -1, 1, 0, 0][Math.floor(Math.random() * 5)];
                    let vectorDir = '';
                    if (vy > 0) vectorDir = 'North';
                    else if (vy < 0) vectorDir = 'South';
                    if (vx > 0) vectorDir += vectorDir ? 'east' : 'East';
                    else if (vx < 0) vectorDir += vectorDir ? 'west' : 'West';
                    question = 'A vector points (' + vx + ', ' + vy + ') where +y = North. What direction is this?';
                    correctAnswer = vectorDir || 'No movement';
                    compassData = { showCompass: true };
                    break;
            }

            showCompassUI(question, correctAnswer, challengeType, compassData, onComplete);
        }

        function showCompassUI(question, correctAnswer, challengeType, compassData, onComplete) {
            const overlay = document.createElement('div');
            overlay.className = 'visual-math-overlay';
            overlay.id = 'compass-overlay';

            let html = '<div class="visual-math-container">';
            html += '<h3 class="visual-math-title">🧭 Compass Navigation</h3>';
            html += '<p class="visual-math-instruction">' + question + '</p>';

            // Draw compass
            if (compassData.showCompass) {
                html += '<div style="text-align: center; margin: 20px 0;">';
                html += '<svg width="200" height="200" viewBox="0 0 200 200" style="background: #111; border: 3px solid #0f0; border-radius: 50%;">';

                // Compass rose
                const dirs = [
                    { label: 'N', angle: 0 },
                    { label: 'NE', angle: 45 },
                    { label: 'E', angle: 90 },
                    { label: 'SE', angle: 135 },
                    { label: 'S', angle: 180 },
                    { label: 'SW', angle: 225 },
                    { label: 'W', angle: 270 },
                    { label: 'NW', angle: 315 }
                ];

                dirs.forEach(d => {
                    const rad = (d.angle - 90) * Math.PI / 180;
                    const x = 100 + 80 * Math.cos(rad);
                    const y = 100 + 80 * Math.sin(rad);
                    const isCardinal = ['N', 'E', 'S', 'W'].includes(d.label);
                    html += '<text x="' + x + '" y="' + (y + 5) + '" fill="' + (isCardinal ? '#0f0' : '#0a0') + '" font-size="' + (isCardinal ? '16' : '12') + '" text-anchor="middle" font-weight="bold">' + d.label + '</text>';
                });

                // Needle pointing to angle
                if (compassData.angle !== undefined || compassData.bearing !== undefined) {
                    const needleAngle = (compassData.angle || compassData.bearing || 0) - 90;
                    const needleRad = needleAngle * Math.PI / 180;
                    const nx = 100 + 60 * Math.cos(needleRad);
                    const ny = 100 + 60 * Math.sin(needleRad);
                    html += '<line x1="100" y1="100" x2="' + nx + '" y2="' + ny + '" stroke="#f00" stroke-width="4" stroke-linecap="round"/>';
                    html += '<circle cx="100" cy="100" r="8" fill="#f00"/>';
                }

                html += '</svg>';
                html += '</div>';
            }

            // Direction options
            const allDirs = ['North', 'Northeast', 'East', 'Southeast', 'South', 'Southwest', 'West', 'Northwest'];
            const cardinals = ['North', 'East', 'South', 'West'];

            const optionsToShow = ['bearing', 'cardinal_direction', 'left_right', 'quarter_turns'].includes(challengeType) ? cardinals : allDirs;

            html += '<div class="shape-grid" style="grid-template-columns: repeat(' + (optionsToShow.length === 4 ? 2 : 4) + ', 1fr);">';
            optionsToShow.forEach(dir => {
                html += '<div class="shape-option" data-answer="' + dir + '" style="padding: 10px; font-size: 0.95em;">' + dir + '</div>';
            });
            html += '</div>';

            html += '<button class="visual-submit-btn" id="compass-submit">Submit Answer</button>';
            html += '</div>';

            overlay.innerHTML = html;
            document.body.appendChild(overlay);

            let selectedAnswer = null;

            overlay.querySelectorAll('.shape-option').forEach(opt => {
                opt.addEventListener('click', function() {
                    overlay.querySelectorAll('.shape-option').forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedAnswer = this.dataset.answer;
                });
            });

            document.getElementById('compass-submit').onclick = function() {
                const isCorrect = selectedAnswer === correctAnswer;

                logPracticeSession('Basic Geometry Concepts', isCorrect, {
                    type: 'compass_' + challengeType,
                    answer: selectedAnswer,
                    correctAnswer: correctAnswer
                });

                if (isCorrect) {
                    this.style.background = 'rgba(0, 200, 0, 0.8)';
                    this.textContent = '✓ Correct!';
                } else {
                    this.style.background = 'rgba(200, 0, 0, 0.8)';
                    this.textContent = '✗ Answer: ' + correctAnswer;
                }
                this.disabled = true;

                setTimeout(() => {
                    if (overlay.parentElement) {
                        document.body.removeChild(overlay);
                    }
                    if (onComplete) onComplete(isCorrect, selectedAnswer);
                }, 1500);
            };
        }

        // ============================================
        // PHASE 3: ADVANCED SYSTEMS
        // ============================================

        // === COMPANION SYSTEM ===
        // Teaches: Growth rates, feeding ratios, statistics, probability

        const COMPANIONS = {
            types: [
                // Canines & Felines
                { name: 'Scout Dog', icon: '🐕', baseStats: { hp: 50, damage: 15, speed: 4 }, foodType: 'meat' },
                { name: 'Wild Cat', icon: '🐈', baseStats: { hp: 35, damage: 18, speed: 5 }, foodType: 'meat' },
                { name: 'Desert Wolf', icon: '🐺', baseStats: { hp: 60, damage: 22, speed: 4 }, foodType: 'meat' },
                { name: 'Mountain Lion', icon: '🦁', baseStats: { hp: 70, damage: 28, speed: 4 }, foodType: 'meat' },

                // Birds
                { name: 'Hawk', icon: '🦅', baseStats: { hp: 25, damage: 12, speed: 6 }, foodType: 'meat' },
                { name: 'Crow', icon: '🐦‍⬛', baseStats: { hp: 15, damage: 5, speed: 5 }, foodType: 'scrap' },
                { name: 'Owl', icon: '🦉', baseStats: { hp: 20, damage: 10, speed: 4 }, foodType: 'meat' },

                // Reptiles & Amphibians
                { name: 'Giant Lizard', icon: '🦎', baseStats: { hp: 45, damage: 14, speed: 3 }, foodType: 'insects' },
                { name: 'Snapping Turtle', icon: '🐢', baseStats: { hp: 80, damage: 20, speed: 1 }, foodType: 'vegetables' },
                { name: 'Rock Viper', icon: '🐍', baseStats: { hp: 30, damage: 25, speed: 4 }, foodType: 'meat' },

                // Rodents & Small Mammals
                { name: 'Pack Rat', icon: '🐀', baseStats: { hp: 20, damage: 8, speed: 5 }, foodType: 'scrap' },
                { name: 'Badger', icon: '🦡', baseStats: { hp: 55, damage: 20, speed: 3 }, foodType: 'meat' },
                { name: 'Rabbit', icon: '🐇', baseStats: { hp: 15, damage: 3, speed: 6 }, foodType: 'vegetables' },

                // Large Animals
                { name: 'Pack Mule', icon: '🫏', baseStats: { hp: 90, damage: 12, speed: 2 }, foodType: 'grass' },
                { name: 'Wild Boar', icon: '🐗', baseStats: { hp: 75, damage: 24, speed: 3 }, foodType: 'vegetables' },
                { name: 'Mountain Goat', icon: '🐐', baseStats: { hp: 50, damage: 15, speed: 4 }, foodType: 'grass' },
                { name: 'Draft Horse', icon: '🐴', baseStats: { hp: 100, damage: 18, speed: 3 }, foodType: 'grass' },

                // Exotic/Rare
                { name: 'Armored Armadillo', icon: '🦔', baseStats: { hp: 65, damage: 10, speed: 2 }, foodType: 'insects' },
                { name: 'Cave Bear', icon: '🐻', baseStats: { hp: 120, damage: 35, speed: 2 }, foodType: 'meat' },
                { name: 'Storm Falcon', icon: '🦤', baseStats: { hp: 40, damage: 22, speed: 6 }, foodType: 'meat' }
            ],
            growthRates: { slow: 1.1, normal: 1.25, fast: 1.5 }
        };

        function showCompanionChallenge(onComplete) {
            const gradeLevel = selectedGrade || 'advanced';
            const challengeTypes = [];

            if (['K-1', '2'].includes(gradeLevel)) {
                challengeTypes.push('count_food', 'compare_stats');
            } else if (['3', '4'].includes(gradeLevel)) {
                challengeTypes.push('feeding_portions', 'growth_prediction');
            } else if (['5-6'].includes(gradeLevel)) {
                challengeTypes.push('ratio_feeding', 'stat_average');
            } else {
                challengeTypes.push('probability_trait', 'growth_rate');
            }

            const challengeType = challengeTypes[Math.floor(Math.random() * challengeTypes.length)];
            const companion = COMPANIONS.types[Math.floor(Math.random() * COMPANIONS.types.length)];

            let question, correctAnswer;

            switch (challengeType) {
                case 'count_food':
                    const foodCount = Math.floor(Math.random() * 10) + 3;
                    question = companion.name + ' ' + companion.icon + ' needs ' + foodCount + ' pieces of ' + companion.foodType + ' today. You have ' + (foodCount + 2) + '. How many will be left after feeding?';
                    correctAnswer = 2;
                    break;

                case 'compare_stats':
                    const comp2 = COMPANIONS.types[Math.floor(Math.random() * COMPANIONS.types.length)];
                    const stat = ['hp', 'damage', 'speed'][Math.floor(Math.random() * 3)];
                    const statName = { hp: 'HP', damage: 'Damage', speed: 'Speed' }[stat];
                    question = 'Which has higher ' + statName + '? ' + companion.name + ' ' + companion.icon + ' (' + companion.baseStats[stat] + ') or ' + comp2.name + ' ' + comp2.icon + ' (' + comp2.baseStats[stat] + ')?';
                    correctAnswer = companion.baseStats[stat] > comp2.baseStats[stat] ? companion.name :
                                   (companion.baseStats[stat] < comp2.baseStats[stat] ? comp2.name : 'Same');
                    break;

                case 'feeding_portions':
                    const mealsPerDay = Math.floor(Math.random() * 3) + 2;
                    const portionsPerMeal = Math.floor(Math.random() * 4) + 2;
                    question = companion.name + ' ' + companion.icon + ' eats ' + mealsPerDay + ' meals per day, ' + portionsPerMeal + ' portions each. How many total portions per day?';
                    correctAnswer = mealsPerDay * portionsPerMeal;
                    break;

                case 'growth_prediction':
                    const startStat = companion.baseStats.hp;
                    const growthAmount = [5, 10, 15][Math.floor(Math.random() * 3)];
                    const weeks = Math.floor(Math.random() * 4) + 2;
                    question = companion.name + ' ' + companion.icon + ' starts with ' + startStat + ' HP and gains ' + growthAmount + ' HP per week. After ' + weeks + ' weeks, what\'s the HP?';
                    correctAnswer = startStat + (growthAmount * weeks);
                    break;

                case 'ratio_feeding':
                    const meatRatio = Math.floor(Math.random() * 3) + 2;
                    const vegRatio = Math.floor(Math.random() * 2) + 1;
                    const totalFood = (meatRatio + vegRatio) * 3;
                    question = companion.name + ' ' + companion.icon + ' needs a ' + meatRatio + ':' + vegRatio + ' ratio of meat to vegetables. With ' + totalFood + ' total food pieces, how many should be meat?';
                    correctAnswer = (meatRatio / (meatRatio + vegRatio)) * totalFood;
                    break;

                case 'stat_average':
                    const stats = [companion.baseStats.hp, companion.baseStats.damage, companion.baseStats.speed * 10];
                    const avg = Math.round((stats[0] + stats[1] + stats[2]) / 3);
                    question = companion.name + ' ' + companion.icon + ' has HP: ' + stats[0] + ', Damage: ' + stats[1] + ', Speed×10: ' + stats[2] + '. What\'s the average?';
                    correctAnswer = avg;
                    break;

                case 'probability_trait':
                    const traitChance = [25, 50, 75][Math.floor(Math.random() * 3)];
                    const offspring = [4, 6, 8][Math.floor(Math.random() * 3)];
                    const expected = Math.round((traitChance / 100) * offspring);
                    question = 'A trait appears in ' + traitChance + '% of offspring. If ' + companion.name + ' has ' + offspring + ' babies, how many would you expect to have the trait?';
                    correctAnswer = expected;
                    break;

                case 'growth_rate':
                    const initialHP = companion.baseStats.hp;
                    const rateType = ['slow', 'normal', 'fast'][Math.floor(Math.random() * 3)];
                    const rate = COMPANIONS.growthRates[rateType];
                    const finalHP = Math.round(initialHP * rate * rate); // After 2 growth periods
                    question = companion.name + ' ' + companion.icon + ' has ' + initialHP + ' HP. With ' + rateType + ' growth (' + rate + 'x per period), what\'s the HP after 2 periods? Round to nearest.';
                    correctAnswer = finalHP;
                    break;
            }

            showCompanionUI(question, correctAnswer, challengeType, companion, onComplete);
        }

        function showCompanionUI(question, correctAnswer, challengeType, companion, onComplete) {
            const overlay = document.createElement('div');
            overlay.className = 'visual-math-overlay';
            overlay.id = 'companion-overlay';

            let html = '<div class="visual-math-container">';
            html += '<h3 class="visual-math-title">🐾 Companion Care</h3>';
            html += '<div style="text-align: center; font-size: 3em; margin: 10px 0;">' + companion.icon + '</div>';
            html += '<p class="visual-math-instruction">' + question + '</p>';

            // Options for compare challenges
            if (challengeType === 'compare_stats') {
                html += '<div class="shape-grid" style="grid-template-columns: repeat(3, 1fr);">';
                [companion.name, 'Same', COMPANIONS.types.find(c => c.name !== companion.name)?.name || 'Other'].forEach(opt => {
                    html += '<div class="shape-option" data-answer="' + opt + '" style="padding: 15px;">' + opt + '</div>';
                });
                html += '</div>';
            } else {
                html += '<div style="text-align: center; margin: 20px 0;">';
                html += '<input type="number" id="companion-answer" class="terminal-input" style="width: 120px; font-size: 1.3em;" placeholder="?">';
                html += '</div>';
            }

            html += '<button class="visual-submit-btn" id="companion-submit">Submit Answer</button>';
            html += '</div>';

            overlay.innerHTML = html;
            document.body.appendChild(overlay);

            let selectedAnswer = null;

            overlay.querySelectorAll('.shape-option').forEach(opt => {
                opt.addEventListener('click', function() {
                    overlay.querySelectorAll('.shape-option').forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedAnswer = this.dataset.answer;
                });
            });

            document.getElementById('companion-submit').onclick = function() {
                const inputField = document.getElementById('companion-answer');
                if (inputField) {
                    selectedAnswer = parseFloat(inputField.value);
                }

                const isCorrect = selectedAnswer == correctAnswer;

                logPracticeSession('Basic Multiplication', isCorrect, {
                    type: 'companion_' + challengeType,
                    answer: selectedAnswer,
                    correctAnswer: correctAnswer
                });

                if (isCorrect) {
                    this.style.background = 'rgba(0, 200, 0, 0.8)';
                    this.textContent = '✓ Correct!';
                } else {
                    this.style.background = 'rgba(200, 0, 0, 0.8)';
                    this.textContent = '✗ Answer: ' + correctAnswer;
                }
                this.disabled = true;

                setTimeout(() => {
                    if (overlay.parentElement) {
                        document.body.removeChild(overlay);
                    }
                    if (onComplete) onComplete(isCorrect, selectedAnswer);
                }, 1500);
            };
        }

        // === SCIENCE LAB / CRAFTING SYSTEM ===
        // Teaches: Measurement, unit conversion, formulas, ratios

        const SCIENCE_LAB = {
            chemicals: [
                { name: 'Distilled Water', icon: '💧', unit: 'mL' },
                { name: 'Herb Extract', icon: '🌿', unit: 'mL' },
                { name: 'Charcoal Powder', icon: '⚫', unit: 'g' },
                { name: 'Antiseptic', icon: '🧪', unit: 'mL' },
                { name: 'Bandage Cloth', icon: '🩹', unit: 'cm' }
            ],
            recipes: [
                { name: 'Med Kit', ratio: [2, 1, 0.5], units: ['mL', 'mL', 'cm'], ingredients: ['Distilled Water', 'Antiseptic', 'Bandage Cloth'] },
                { name: 'Antitoxin', ratio: [3, 2, 1], units: ['mL', 'g', 'mL'], ingredients: ['Distilled Water', 'Charcoal Powder', 'Herb Extract'] }
            ]
        };

        function showLabChallenge(onComplete) {
            const gradeLevel = selectedGrade || 'advanced';
            const challengeTypes = [];

            if (['K-1', '2'].includes(gradeLevel)) {
                challengeTypes.push('measure_simple', 'compare_amounts');
            } else if (['3', '4'].includes(gradeLevel)) {
                challengeTypes.push('unit_convert_simple', 'recipe_double');
            } else if (['5-6'].includes(gradeLevel)) {
                challengeTypes.push('unit_convert', 'ratio_mix');
            } else {
                challengeTypes.push('formula_solve', 'concentration');
            }

            const challengeType = challengeTypes[Math.floor(Math.random() * challengeTypes.length)];

            let question, correctAnswer, hint = '';

            switch (challengeType) {
                case 'measure_simple':
                    const amount = Math.floor(Math.random() * 10) + 1;
                    const chem = SCIENCE_LAB.chemicals[Math.floor(Math.random() * SCIENCE_LAB.chemicals.length)];
                    question = 'You need ' + amount + ' ' + chem.unit + ' of ' + chem.name + ' ' + chem.icon + '. The beaker shows ' + (amount + 3) + ' ' + chem.unit + '. How much should you pour out?';
                    correctAnswer = 3;
                    break;

                case 'compare_amounts':
                    const a1 = Math.floor(Math.random() * 50) + 10;
                    const a2 = Math.floor(Math.random() * 50) + 10;
                    question = 'Which is more? ' + a1 + ' mL or ' + a2 + ' mL?';
                    correctAnswer = Math.max(a1, a2) + ' mL';
                    break;

                case 'unit_convert_simple':
                    const liters = Math.floor(Math.random() * 5) + 1;
                    question = 'You have ' + liters + ' liter(s) of water. How many milliliters is that? (1 L = 1000 mL)';
                    correctAnswer = liters * 1000;
                    hint = '1 Liter = 1000 milliliters';
                    break;

                case 'recipe_double':
                    const recipe = SCIENCE_LAB.recipes[Math.floor(Math.random() * SCIENCE_LAB.recipes.length)];
                    const baseAmount = recipe.ratio[0] * 10;
                    question = 'A recipe calls for ' + baseAmount + ' mL of ' + recipe.ingredients[0] + '. To make double the recipe, how many mL do you need?';
                    correctAnswer = baseAmount * 2;
                    break;

                case 'unit_convert':
                    const convTypes = [
                        { from: 'kg', to: 'g', factor: 1000, amount: Math.floor(Math.random() * 5) + 1 },
                        { from: 'L', to: 'mL', factor: 1000, amount: Math.floor(Math.random() * 3) + 1 },
                        { from: 'cm', to: 'mm', factor: 10, amount: Math.floor(Math.random() * 20) + 5 }
                    ];
                    const conv = convTypes[Math.floor(Math.random() * convTypes.length)];
                    question = 'Convert ' + conv.amount + ' ' + conv.from + ' to ' + conv.to + '.';
                    correctAnswer = conv.amount * conv.factor;
                    hint = '1 ' + conv.from + ' = ' + conv.factor + ' ' + conv.to;
                    break;

                case 'ratio_mix':
                    const r1 = Math.floor(Math.random() * 3) + 2;
                    const r2 = Math.floor(Math.random() * 2) + 1;
                    const totalMix = (r1 + r2) * 5;
                    question = 'Mix chemicals in a ' + r1 + ':' + r2 + ' ratio. With ' + totalMix + ' mL total, how much of the first chemical?';
                    correctAnswer = (r1 / (r1 + r2)) * totalMix;
                    hint = 'First part = (ratio1 ÷ total ratio) × total amount';
                    break;

                case 'formula_solve':
                    const mass = [10, 20, 50][Math.floor(Math.random() * 3)];
                    const volume = [100, 200, 500][Math.floor(Math.random() * 3)];
                    const concentration = mass / volume * 100;
                    question = 'Concentration = (mass ÷ volume) × 100. With ' + mass + 'g in ' + volume + ' mL, what\'s the concentration %?';
                    correctAnswer = concentration;
                    hint = 'C = (m/v) × 100';
                    break;

                case 'concentration':
                    const targetConc = [5, 10, 20][Math.floor(Math.random() * 3)];
                    const solventVol = [100, 200][Math.floor(Math.random() * 2)];
                    const soluteNeeded = (targetConc / 100) * solventVol;
                    question = 'To make a ' + targetConc + '% solution with ' + solventVol + ' mL, how many grams of solute do you need?';
                    correctAnswer = soluteNeeded;
                    hint = 'mass = (concentration% / 100) × volume';
                    break;
            }

            showLabUI(question, correctAnswer, hint, challengeType, onComplete);
        }

        function showLabUI(question, correctAnswer, hint, challengeType, onComplete) {
            const overlay = document.createElement('div');
            overlay.className = 'visual-math-overlay';
            overlay.id = 'lab-overlay';

            let html = '<div class="visual-math-container">';
            html += '<h3 class="visual-math-title">🔬 Science Lab</h3>';
            html += '<p class="visual-math-instruction">' + question + '</p>';

            if (hint) {
                html += '<p style="color: #888; font-size: 0.9em; text-align: center;"><em>' + hint + '</em></p>';
            }

            if (challengeType === 'compare_amounts') {
                html += '<div class="shape-grid" style="grid-template-columns: repeat(2, 1fr);">';
                const amounts = question.match(/(\d+) mL/g);
                amounts.forEach(amt => {
                    html += '<div class="shape-option" data-answer="' + amt + '" style="padding: 20px; font-size: 1.3em;">' + amt + '</div>';
                });
                html += '</div>';
            } else {
                html += '<div style="text-align: center; margin: 20px 0;">';
                html += '<input type="number" id="lab-answer" class="terminal-input" style="width: 150px; font-size: 1.3em;" placeholder="?">';
                html += '</div>';
            }

            html += '<button class="visual-submit-btn" id="lab-submit">Submit Answer</button>';
            html += '</div>';

            overlay.innerHTML = html;
            document.body.appendChild(overlay);

            let selectedAnswer = null;

            overlay.querySelectorAll('.shape-option').forEach(opt => {
                opt.addEventListener('click', function() {
                    overlay.querySelectorAll('.shape-option').forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedAnswer = this.dataset.answer;
                });
            });

            document.getElementById('lab-submit').onclick = function() {
                const inputField = document.getElementById('lab-answer');
                if (inputField) {
                    selectedAnswer = parseFloat(inputField.value);
                }

                let isCorrect = false;
                if (typeof correctAnswer === 'number') {
                    isCorrect = Math.abs(selectedAnswer - correctAnswer) < 0.01;
                } else {
                    isCorrect = selectedAnswer === correctAnswer;
                }

                logPracticeSession('Basic Division', isCorrect, {
                    type: 'lab_' + challengeType,
                    answer: selectedAnswer,
                    correctAnswer: correctAnswer
                });

                if (isCorrect) {
                    this.style.background = 'rgba(0, 200, 0, 0.8)';
                    this.textContent = '✓ Correct!';
                } else {
                    this.style.background = 'rgba(200, 0, 0, 0.8)';
                    this.textContent = '✗ Answer: ' + correctAnswer;
                }
                this.disabled = true;

                setTimeout(() => {
                    if (overlay.parentElement) {
                        document.body.removeChild(overlay);
                    }
                    if (onComplete) onComplete(isCorrect, selectedAnswer);
                }, 1500);
            };
        }

        // === STATISTICS CENTER ===
        // Teaches: Data collection, graphing, mean/median/mode, probability

        function showStatisticsChallenge(onComplete) {
            const gradeLevel = selectedGrade || 'advanced';
            const challengeTypes = [];

            if (['K-1', '2'].includes(gradeLevel)) {
                challengeTypes.push('tally_count', 'simple_bar');
            } else if (['3', '4'].includes(gradeLevel)) {
                challengeTypes.push('bar_graph_read', 'data_range');
            } else if (['5-6'].includes(gradeLevel)) {
                challengeTypes.push('mean', 'median', 'mode');
            } else {
                challengeTypes.push('probability', 'expected_value');
            }

            const challengeType = challengeTypes[Math.floor(Math.random() * challengeTypes.length)];

            let question, correctAnswer, data = [];

            switch (challengeType) {
                case 'tally_count':
                    const tallyCount = Math.floor(Math.random() * 10) + 3;
                    data = tallyCount;
                    question = 'Count the tally marks: ' + generateTallyMarks(tallyCount);
                    correctAnswer = tallyCount;
                    break;

                case 'simple_bar':
                    const categories = ['Raiders', 'Ghouls', 'Mutants'];
                    data = categories.map(() => Math.floor(Math.random() * 8) + 1);
                    const maxCat = categories[data.indexOf(Math.max(...data))];
                    question = 'Which enemy type appears most? Raiders: ' + data[0] + ', Ghouls: ' + data[1] + ', Mutants: ' + data[2];
                    correctAnswer = maxCat;
                    break;

                case 'bar_graph_read':
                    data = Array(4).fill(0).map(() => Math.floor(Math.random() * 10) + 1);
                    const dayIdx = Math.floor(Math.random() * 4);
                    const days = ['Mon', 'Tue', 'Wed', 'Thu'];
                    question = 'Dollars earned: Mon=$' + data[0] + ', Tue=$' + data[1] + ', Wed=$' + data[2] + ', Thu=$' + data[3] + '. How many on ' + days[dayIdx] + '?';
                    correctAnswer = data[dayIdx];
                    break;

                case 'data_range':
                    data = Array(5).fill(0).map(() => Math.floor(Math.random() * 20) + 5);
                    question = 'Data: ' + data.join(', ') + '. What\'s the range (max - min)?';
                    correctAnswer = Math.max(...data) - Math.min(...data);
                    break;

                case 'mean':
                    data = Array(5).fill(0).map(() => Math.floor(Math.random() * 10) + 1);
                    const sum = data.reduce((a, b) => a + b, 0);
                    question = 'Damage dealt in 5 rounds: ' + data.join(', ') + '. What\'s the average (mean)?';
                    correctAnswer = sum / data.length;
                    break;

                case 'median':
                    data = Array(5).fill(0).map(() => Math.floor(Math.random() * 20) + 1);
                    const sorted = [...data].sort((a, b) => a - b);
                    question = 'HP values: ' + data.join(', ') + '. What\'s the median? (Sort first!)';
                    correctAnswer = sorted[2]; // Middle of 5 elements
                    break;

                case 'mode':
                    data = [3, 5, 3, 7, 3, 5, 8];
                    const counts = {};
                    data.forEach(d => counts[d] = (counts[d] || 0) + 1);
                    const modeVal = parseInt(Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b));
                    question = 'Loot drops: ' + data.join(', ') + '. What\'s the mode (most frequent)?';
                    correctAnswer = modeVal;
                    break;

                case 'probability':
                    const favorable = Math.floor(Math.random() * 5) + 1;
                    const total = favorable + Math.floor(Math.random() * 10) + 5;
                    const prob = Math.round((favorable / total) * 100);
                    question = 'A loot box has ' + favorable + ' rare items out of ' + total + ' total. What\'s the probability (%) of getting a rare item?';
                    correctAnswer = prob;
                    break;

                case 'expected_value':
                    const winChance = [20, 25, 50][Math.floor(Math.random() * 3)];
                    const winAmount = [10, 20, 50][Math.floor(Math.random() * 3)];
                    const ev = (winChance / 100) * winAmount;
                    question = 'A gamble has ' + winChance + '% chance to win ' + winAmount + ' dollars. What\'s the expected value (EV)?';
                    correctAnswer = ev;
                    break;
            }

            showStatisticsUI(question, correctAnswer, challengeType, data, onComplete);
        }

        function generateTallyMarks(count) {
            let marks = '';
            const groups = Math.floor(count / 5);
            const remainder = count % 5;

            for (let i = 0; i < groups; i++) {
                marks += '||||̶ ';
            }
            for (let i = 0; i < remainder; i++) {
                marks += '|';
            }
            return marks || '(none)';
        }

        function showStatisticsUI(question, correctAnswer, challengeType, data, onComplete) {
            const overlay = document.createElement('div');
            overlay.className = 'visual-math-overlay';
            overlay.id = 'stats-overlay';

            let html = '<div class="visual-math-container">';
            html += '<h3 class="visual-math-title">📊 Data Analysis</h3>';
            html += '<p class="visual-math-instruction">' + question + '</p>';

            if (challengeType === 'simple_bar') {
                html += '<div class="shape-grid" style="grid-template-columns: repeat(3, 1fr);">';
                ['Raiders', 'Ghouls', 'Mutants'].forEach(cat => {
                    html += '<div class="shape-option" data-answer="' + cat + '" style="padding: 15px;">' + cat + '</div>';
                });
                html += '</div>';
            } else {
                html += '<div style="text-align: center; margin: 20px 0;">';
                html += '<input type="number" step="any" id="stats-answer" class="terminal-input" style="width: 120px; font-size: 1.3em;" placeholder="?">';
                html += '</div>';
            }

            html += '<button class="visual-submit-btn" id="stats-submit">Submit Answer</button>';
            html += '</div>';

            overlay.innerHTML = html;
            document.body.appendChild(overlay);

            let selectedAnswer = null;

            overlay.querySelectorAll('.shape-option').forEach(opt => {
                opt.addEventListener('click', function() {
                    overlay.querySelectorAll('.shape-option').forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedAnswer = this.dataset.answer;
                });
            });

            document.getElementById('stats-submit').onclick = function() {
                const inputField = document.getElementById('stats-answer');
                if (inputField) {
                    selectedAnswer = parseFloat(inputField.value);
                }

                let isCorrect = false;
                if (typeof correctAnswer === 'number') {
                    isCorrect = Math.abs(selectedAnswer - correctAnswer) < 0.1;
                } else {
                    isCorrect = selectedAnswer === correctAnswer;
                }

                logPracticeSession('Probability and Statistics', isCorrect, {
                    type: 'stats_' + challengeType,
                    answer: selectedAnswer,
                    correctAnswer: correctAnswer
                });

                if (isCorrect) {
                    this.style.background = 'rgba(0, 200, 0, 0.8)';
                    this.textContent = '✓ Correct!';
                } else {
                    this.style.background = 'rgba(200, 0, 0, 0.8)';
                    this.textContent = '✗ Answer: ' + correctAnswer;
                }
                this.disabled = true;

                setTimeout(() => {
                    if (overlay.parentElement) {
                        document.body.removeChild(overlay);
                    }
                    if (onComplete) onComplete(isCorrect, selectedAnswer);
                }, 1500);
            };
        }

        // === SIGNAL/COMMUNICATION SYSTEM ===
        // Teaches: Patterns, sequences, binary, functions

        function showSignalChallenge(onComplete) {
            const gradeLevel = selectedGrade || 'advanced';
            const challengeTypes = [];

            if (['K-1', '2'].includes(gradeLevel)) {
                challengeTypes.push('simple_pattern', 'ab_pattern');
            } else if (['3', '4'].includes(gradeLevel)) {
                challengeTypes.push('number_pattern', 'growing_pattern');
            } else if (['5-6'].includes(gradeLevel)) {
                challengeTypes.push('function_rule', 'sequence_nth');
            } else {
                challengeTypes.push('arithmetic_sequence', 'geometric_sequence', 'binary_decode');
            }

            const challengeType = challengeTypes[Math.floor(Math.random() * challengeTypes.length)];

            let question, correctAnswer, patternData = [];

            switch (challengeType) {
                case 'simple_pattern':
                    const shapes = ['🔴', '🟢', '🔵'];
                    patternData = [shapes[0], shapes[1], shapes[0], shapes[1], shapes[0]];
                    question = 'Complete the pattern: ' + patternData.join(' ') + ' ?';
                    correctAnswer = shapes[1];
                    break;

                case 'ab_pattern':
                    const items = ['⚡', '💧'];
                    patternData = [items[0], items[0], items[1], items[0], items[0], items[1], items[0], items[0]];
                    question = 'Pattern: ' + patternData.join(' ') + ' ?';
                    correctAnswer = items[1];
                    break;

                case 'number_pattern':
                    const start = Math.floor(Math.random() * 5) + 2;
                    const step = [2, 3, 5, 10][Math.floor(Math.random() * 4)];
                    patternData = [start, start + step, start + step * 2, start + step * 3];
                    question = 'Radio frequency pattern: ' + patternData.join(', ') + ', ?';
                    correctAnswer = start + step * 4;
                    break;

                case 'growing_pattern':
                    // 1, 3, 6, 10 (triangular) or 1, 4, 9, 16 (squares)
                    const isSquare = Math.random() < 0.5;
                    if (isSquare) {
                        patternData = [1, 4, 9, 16];
                        correctAnswer = 25;
                        question = 'Signal strength: 1, 4, 9, 16, ? (squares)';
                    } else {
                        patternData = [1, 3, 6, 10];
                        correctAnswer = 15;
                        question = 'Signal strength: 1, 3, 6, 10, ? (+2, +3, +4...)';
                    }
                    break;

                case 'function_rule':
                    const mult = [2, 3, 5][Math.floor(Math.random() * 3)];
                    const add = [1, 2, 3][Math.floor(Math.random() * 3)];
                    const inputVal = Math.floor(Math.random() * 5) + 1;
                    question = 'Decryption rule: multiply by ' + mult + ', then add ' + add + '. Input: ' + inputVal + '. Output: ?';
                    correctAnswer = inputVal * mult + add;
                    break;

                case 'sequence_nth':
                    const seqStart = Math.floor(Math.random() * 3) + 1;
                    const seqStep = [3, 4, 5][Math.floor(Math.random() * 3)];
                    const nthTerm = Math.floor(Math.random() * 5) + 5;
                    question = 'Sequence starts at ' + seqStart + ', increases by ' + seqStep + ' each time. What\'s the ' + nthTerm + 'th term?';
                    correctAnswer = seqStart + (nthTerm - 1) * seqStep;
                    break;

                case 'arithmetic_sequence':
                    const a1 = Math.floor(Math.random() * 10) + 1;
                    const d = [2, 3, 5, 7][Math.floor(Math.random() * 4)];
                    patternData = [a1, a1 + d, a1 + 2 * d, a1 + 3 * d];
                    question = 'Arithmetic sequence: ' + patternData.join(', ') + '. What\'s the 10th term? (a_n = a_1 + (n-1)d)';
                    correctAnswer = a1 + 9 * d;
                    break;

                case 'geometric_sequence':
                    const g1 = [2, 3][Math.floor(Math.random() * 2)];
                    const r = [2, 3][Math.floor(Math.random() * 2)];
                    patternData = [g1, g1 * r, g1 * r * r];
                    question = 'Geometric sequence: ' + patternData.join(', ') + ', ?, ?. What\'s the 5th term?';
                    correctAnswer = g1 * Math.pow(r, 4);
                    break;

                case 'binary_decode':
                    const binaryNums = [[1, 0, 1], [1, 1, 0], [1, 0, 0], [1, 1, 1]];
                    const binChoice = binaryNums[Math.floor(Math.random() * binaryNums.length)];
                    const decimal = binChoice[0] * 4 + binChoice[1] * 2 + binChoice[2] * 1;
                    question = 'Decode binary signal: ' + binChoice.join('') + ' = ? (binary to decimal)';
                    correctAnswer = decimal;
                    break;
            }

            showSignalUI(question, correctAnswer, challengeType, patternData, onComplete);
        }

        function showSignalUI(question, correctAnswer, challengeType, patternData, onComplete) {
            const overlay = document.createElement('div');
            overlay.className = 'visual-math-overlay';
            overlay.id = 'signal-overlay';

            let html = '<div class="visual-math-container">';
            html += '<h3 class="visual-math-title">📡 Signal Decoding</h3>';
            html += '<p class="visual-math-instruction">' + question + '</p>';

            // Pattern display for visual patterns
            if (['simple_pattern', 'ab_pattern'].includes(challengeType)) {
                html += '<div class="shape-grid" style="grid-template-columns: repeat(4, 1fr);">';
                const options = [...new Set(patternData)];
                options.forEach(opt => {
                    html += '<div class="shape-option" data-answer="' + opt + '" style="padding: 15px; font-size: 1.5em;">' + opt + '</div>';
                });
                html += '</div>';
            } else {
                html += '<div style="text-align: center; margin: 20px 0;">';
                html += '<input type="number" id="signal-answer" class="terminal-input" style="width: 120px; font-size: 1.3em;" placeholder="?">';
                html += '</div>';
            }

            html += '<button class="visual-submit-btn" id="signal-submit">Submit Answer</button>';
            html += '</div>';

            overlay.innerHTML = html;
            document.body.appendChild(overlay);

            let selectedAnswer = null;

            overlay.querySelectorAll('.shape-option').forEach(opt => {
                opt.addEventListener('click', function() {
                    overlay.querySelectorAll('.shape-option').forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedAnswer = this.dataset.answer;
                });
            });

            document.getElementById('signal-submit').onclick = function() {
                const inputField = document.getElementById('signal-answer');
                if (inputField) {
                    selectedAnswer = parseFloat(inputField.value);
                }

                let isCorrect = false;
                if (typeof correctAnswer === 'number') {
                    isCorrect = selectedAnswer === correctAnswer;
                } else {
                    isCorrect = selectedAnswer === correctAnswer;
                }

                logPracticeSession('Basic Algebraic Expressions', isCorrect, {
                    type: 'signal_' + challengeType,
                    answer: selectedAnswer,
                    correctAnswer: correctAnswer
                });

                if (isCorrect) {
                    this.style.background = 'rgba(0, 200, 0, 0.8)';
                    this.textContent = '✓ Signal decoded!';
                } else {
                    this.style.background = 'rgba(200, 0, 0, 0.8)';
                    this.textContent = '✗ Answer: ' + correctAnswer;
                }
                this.disabled = true;

                setTimeout(() => {
                    if (overlay.parentElement) {
                        document.body.removeChild(overlay);
                    }
                    if (onComplete) onComplete(isCorrect, selectedAnswer);
                }, 1500);
            };
        }

        // ============================================
        // PHASE 5: INTEGRATION - MASTER CHALLENGE SYSTEM
        // ============================================

        // All available challenge systems mapped by category
        const CHALLENGE_SYSTEMS = {
            // Visual math (K-2)
            counting: { fn: () => showVisualMathForGrade('counting', () => {}), grades: ['K-1', '2'] },
            coins: { fn: showCurrencyChallenge, grades: ['K-1', '2', '3', '4'] },
            shapes: { fn: showShapeChallenge, grades: ['K-1', '2', '3', '4', '5-6'] },
            comparison: { fn: () => showVisualMathForGrade('comparison', () => {}), grades: ['K-1', '2'] },
            tenFrame: { fn: () => showVisualMathForGrade('tenFrame', () => {}), grades: ['K-1'] },
            numberLine: { fn: () => showVisualMathForGrade('numberLine', () => {}), grades: ['K-1', '2'] },

            // Phase 1: Foundation
            building: { fn: showBaseBuildingChallenge, grades: ['K-1', '2', '3', '4', '5-6', 'advanced'] },
            time: { fn: showTimeChallenge, grades: ['K-1', '2', '3', '4', '5-6', 'advanced'] },
            currency: { fn: showCurrencyChallenge, grades: ['K-1', '2', '3', '4', '5-6', 'advanced'] },

            // Phase 2: Navigation
            map: { fn: showMapChallenge, grades: ['K-1', '2', '3', '4', '5-6', 'advanced'] },
            weather: { fn: showWeatherChallenge, grades: ['K-1', '2', '3', '4', '5-6', 'advanced'] },
            compass: { fn: showCompassChallenge, grades: ['K-1', '2', '3', '4', '5-6', 'advanced'] },

            // Phase 3: Advanced
            companion: { fn: showCompanionChallenge, grades: ['K-1', '2', '3', '4', '5-6', 'advanced'] },
            lab: { fn: showLabChallenge, grades: ['K-1', '2', '3', '4', '5-6', 'advanced'] },
            statistics: { fn: showStatisticsChallenge, grades: ['K-1', '2', '3', '4', '5-6', 'advanced'] },
            signal: { fn: showSignalChallenge, grades: ['K-1', '2', '3', '4', '5-6', 'advanced'] }
        };

        // Show a random challenge appropriate for the player's grade
        function showRandomChallenge(onComplete) {
            const gradeLevel = selectedGrade || 'advanced';

            // Filter systems available for this grade
            const availableSystems = Object.entries(CHALLENGE_SYSTEMS)
                .filter(([key, sys]) => sys.grades.includes(gradeLevel))
                .map(([key, sys]) => ({ key, ...sys }));

            if (availableSystems.length === 0) {
                console.warn('No challenge systems available for grade:', gradeLevel);
                if (onComplete) onComplete(true, 0);
                return;
            }

            // Pick a random system
            const system = availableSystems[Math.floor(Math.random() * availableSystems.length)];
            console.log('🎮 Launching challenge:', system.key);

            system.fn(onComplete);
        }

        // Show a specific type of challenge
        function showChallengeByType(type, onComplete) {
            const system = CHALLENGE_SYSTEMS[type];
            if (system) {
                system.fn(onComplete);
            } else {
                console.warn('Unknown challenge type:', type);
                showRandomChallenge(onComplete);
            }
        }

        // Show challenges appropriate for an in-game scenario
        function showScenarioChallenge(scenario, onComplete) {
            // Map game scenarios to challenge types
            const scenarioMap = {
                'explore': ['map', 'compass', 'weather'],
                'combat': ['counting', 'subtraction', 'statistics'],
                'trade': ['currency', 'coins', 'comparison'],
                'craft': ['lab', 'building'],
                'care': ['companion', 'time'],
                'puzzle': ['signal', 'shapes', 'comparison'],
                'survival': ['weather', 'time', 'building']
            };

            const types = scenarioMap[scenario] || Object.keys(CHALLENGE_SYSTEMS);
            const type = types[Math.floor(Math.random() * types.length)];

            showChallengeByType(type, onComplete);
        }

        // Get summary of player's math progress this session
        function getSessionStats() {
            return {
                problemsAttempted: skillSystem.problemsAttempted,
                problemsCorrect: skillSystem.problemsCorrect,
                accuracy: skillSystem.problemsAttempted > 0 ?
                    Math.round((skillSystem.problemsCorrect / skillSystem.problemsAttempted) * 100) : 0,
                sessionDuration: skillSystem.sessionStartTime ?
                    Math.round((new Date() - skillSystem.sessionStartTime) / 1000 / 60) : 0
            };
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            initializeSkillSystem();
            loadTutorialState(); // Load tutorial progress
            initStartScreen(); // Check for saved games
        });

        // ============================================
        // GRID AND GAME CONSTANTS
        // ============================================

        // Grid dimensions - each square is 5ft x 5ft
        const GRID_WIDTH = 12;
        const GRID_HEIGHT = 10;
        const SQUARE_FEET = 5; // Each square represents 5 feet

        // Weapon definitions with ranges (in squares) and ammo types
        // 50 Real-World Weapons organized by category
        const WEAPONS = {
            // ========== UNARMED ==========
            'Fists': {
                damage: 8, accuracy: 65, apCost: 8,
                minRange: 0, optimalRange: 1, maxRange: 1.5,
                type: 'melee', category: 'unarmed', description: 'Your bare hands',
                ammoType: null, ammoPerShot: 0
            },

            // ========== KNIVES (5) ==========
            'Pocket Knife': {
                damage: 12, accuracy: 70, apCost: 10,
                minRange: 0, optimalRange: 1, maxRange: 1.5,
                type: 'melee', category: 'knife', description: 'Small folding blade',
                ammoType: null, ammoPerShot: 0
            },
            'Hunting Knife': {
                damage: 18, accuracy: 68, apCost: 12,
                minRange: 0, optimalRange: 1, maxRange: 1.5,
                type: 'melee', category: 'knife', description: 'Fixed blade survival knife',
                ammoType: null, ammoPerShot: 0
            },
            'Bowie Knife': {
                damage: 22, accuracy: 65, apCost: 14,
                minRange: 0, optimalRange: 1, maxRange: 1.5,
                type: 'melee', category: 'knife', description: 'Large fighting knife',
                ammoType: null, ammoPerShot: 0
            },
            'Machete': {
                damage: 28, accuracy: 60, apCost: 16,
                minRange: 0, optimalRange: 1, maxRange: 2,
                type: 'melee', category: 'knife', description: 'Heavy clearing blade',
                ammoType: null, ammoPerShot: 0
            },
            'Ka-Bar': {
                damage: 20, accuracy: 70, apCost: 12,
                minRange: 0, optimalRange: 1, maxRange: 1.5,
                type: 'melee', category: 'knife', description: 'Military combat knife',
                ammoType: null, ammoPerShot: 0
            },
            'Hunting Knife': {
                damage: 18, accuracy: 72, apCost: 10,
                minRange: 0, optimalRange: 1, maxRange: 1.5,
                type: 'melee', category: 'knife', description: 'Sharp blade for skinning game',
                ammoType: null, ammoPerShot: 0,
                canSkin: true  // Special property for skinning animals
            },

            // ========== BLUNT WEAPONS (5) ==========
            'Baseball Bat': {
                damage: 25, accuracy: 55, apCost: 15,
                minRange: 0, optimalRange: 1, maxRange: 2,
                type: 'melee', category: 'blunt', description: 'Wooden sports bat',
                ammoType: null, ammoPerShot: 0
            },
            'Crowbar': {
                damage: 28, accuracy: 52, apCost: 16,
                minRange: 0, optimalRange: 1, maxRange: 2,
                type: 'melee', category: 'blunt', description: 'Heavy steel pry bar',
                ammoType: null, ammoPerShot: 0
            },
            'Sledgehammer': {
                damage: 45, accuracy: 40, apCost: 25,
                minRange: 0, optimalRange: 1, maxRange: 2,
                type: 'melee', category: 'blunt', description: 'Devastating but slow',
                ammoType: null, ammoPerShot: 0
            },
            'Pipe Wrench': {
                damage: 22, accuracy: 55, apCost: 14,
                minRange: 0, optimalRange: 1, maxRange: 1.5,
                type: 'melee', category: 'blunt', description: 'Heavy plumbing tool',
                ammoType: null, ammoPerShot: 0
            },
            'Fire Axe': {
                damage: 38, accuracy: 48, apCost: 20,
                minRange: 0, optimalRange: 1, maxRange: 2,
                type: 'melee', category: 'blunt', description: 'Emergency firefighting axe',
                ammoType: null, ammoPerShot: 0
            },

            // ========== HANDGUNS - REVOLVERS (5) ==========
            'Colt Single Action Army': {
                damage: 28, accuracy: 42, apCost: 16,
                minRange: 1, optimalRange: 4, maxRange: 8,
                type: 'ranged', category: 'revolver', description: 'Classic western revolver',
                ammoType: '.45 LC', ammoPerShot: 1
            },
            'Smith & Wesson Model 29': {
                damage: 42, accuracy: 38, apCost: 20,
                minRange: 1, optimalRange: 4, maxRange: 10,
                type: 'ranged', category: 'revolver', description: '.44 Magnum revolver',
                ammoType: '.44 Magnum', ammoPerShot: 1
            },
            'Ruger GP100': {
                damage: 32, accuracy: 45, apCost: 17,
                minRange: 1, optimalRange: 4, maxRange: 9,
                type: 'ranged', category: 'revolver', description: 'Reliable .357 revolver',
                ammoType: '.357 Magnum', ammoPerShot: 1
            },
            'Colt Python': {
                damage: 35, accuracy: 48, apCost: 18,
                minRange: 1, optimalRange: 5, maxRange: 10,
                type: 'ranged', category: 'revolver', description: 'Premium .357 revolver',
                ammoType: '.357 Magnum', ammoPerShot: 1
            },
            'Taurus Judge': {
                damage: 38, accuracy: 35, apCost: 19,
                minRange: 1, optimalRange: 3, maxRange: 6,
                type: 'ranged', category: 'revolver', description: 'Fires .410 shells or .45 LC',
                ammoType: '.45 LC', ammoPerShot: 1
            },

            // ========== HANDGUNS - SEMI-AUTO (8) ==========
            'Colt M1911': {
                damage: 30, accuracy: 45, apCost: 15,
                minRange: 1, optimalRange: 4, maxRange: 8,
                type: 'ranged', category: 'pistol', description: 'Classic .45 ACP pistol',
                ammoType: '.45 ACP', ammoPerShot: 1
            },
            'Beretta 92': {
                damage: 24, accuracy: 50, apCost: 14,
                minRange: 1, optimalRange: 4, maxRange: 8,
                type: 'ranged', category: 'pistol', description: '9mm military sidearm',
                ammoType: '9mm', ammoPerShot: 1
            },
            'Glock 17': {
                damage: 22, accuracy: 52, apCost: 13,
                minRange: 1, optimalRange: 4, maxRange: 8,
                type: 'ranged', category: 'pistol', description: 'Reliable polymer 9mm',
                ammoType: '9mm', ammoPerShot: 1
            },
            'Glock 19': {
                damage: 22, accuracy: 50, apCost: 12,
                minRange: 1, optimalRange: 4, maxRange: 7,
                type: 'ranged', category: 'pistol', description: 'Compact 9mm pistol',
                ammoType: '9mm', ammoPerShot: 1
            },
            'SIG Sauer P226': {
                damage: 25, accuracy: 52, apCost: 14,
                minRange: 1, optimalRange: 4, maxRange: 8,
                type: 'ranged', category: 'pistol', description: 'Premium 9mm service pistol',
                ammoType: '9mm', ammoPerShot: 1
            },
            'Desert Eagle': {
                damage: 48, accuracy: 35, apCost: 22,
                minRange: 1, optimalRange: 4, maxRange: 10,
                type: 'ranged', category: 'pistol', description: 'Powerful .50 AE pistol',
                ammoType: '.50 AE', ammoPerShot: 1
            },
            'CZ 75': {
                damage: 24, accuracy: 54, apCost: 14,
                minRange: 1, optimalRange: 4, maxRange: 8,
                type: 'ranged', category: 'pistol', description: 'Accurate Czech 9mm',
                ammoType: '9mm', ammoPerShot: 1
            },
            'Walther PPK': {
                damage: 18, accuracy: 55, apCost: 11,
                minRange: 1, optimalRange: 3, maxRange: 6,
                type: 'ranged', category: 'pistol', description: 'Compact .380 pistol',
                ammoType: '.380 ACP', ammoPerShot: 1
            },

            // ========== SHOTGUNS (6) ==========
            'Remington 870': {
                damage: 52, accuracy: 45, apCost: 20,
                minRange: 1, optimalRange: 3, maxRange: 5,
                type: 'ranged', category: 'shotgun', description: 'Pump-action 12 gauge',
                ammoType: '12 gauge', ammoPerShot: 1
            },
            'Mossberg 500': {
                damage: 50, accuracy: 46, apCost: 19,
                minRange: 1, optimalRange: 3, maxRange: 5,
                type: 'ranged', category: 'shotgun', description: 'Reliable pump shotgun',
                ammoType: '12 gauge', ammoPerShot: 1
            },
            'Benelli M4': {
                damage: 48, accuracy: 48, apCost: 17,
                minRange: 1, optimalRange: 3, maxRange: 5,
                type: 'ranged', category: 'shotgun', description: 'Semi-auto tactical shotgun',
                ammoType: '12 gauge', ammoPerShot: 1
            },
            'Double-Barrel Shotgun': {
                damage: 60, accuracy: 42, apCost: 22,
                minRange: 1, optimalRange: 2, maxRange: 4,
                type: 'ranged', category: 'shotgun', description: 'Classic side-by-side',
                ammoType: '12 gauge', ammoPerShot: 2
            },
            'Winchester Model 1897': {
                damage: 55, accuracy: 44, apCost: 21,
                minRange: 1, optimalRange: 3, maxRange: 5,
                type: 'ranged', category: 'shotgun', description: 'Classic pump shotgun',
                ammoType: '12 gauge', ammoPerShot: 1
            },
            'Ithaca 37': {
                damage: 50, accuracy: 47, apCost: 19,
                minRange: 1, optimalRange: 3, maxRange: 5,
                type: 'ranged', category: 'shotgun', description: 'Bottom-ejecting pump',
                ammoType: '12 gauge', ammoPerShot: 1
            },

            // ========== RIFLES - BOLT ACTION (5) ==========
            'Remington 700': {
                damage: 55, accuracy: 55, apCost: 24,
                minRange: 3, optimalRange: 10, maxRange: 20,
                type: 'ranged', category: 'rifle', description: 'Precision bolt-action rifle',
                ammoType: '.308 Win', ammoPerShot: 1
            },
            'Winchester Model 70': {
                damage: 52, accuracy: 54, apCost: 23,
                minRange: 3, optimalRange: 10, maxRange: 18,
                type: 'ranged', category: 'rifle', description: 'Classic hunting rifle',
                ammoType: '.30-06', ammoPerShot: 1
            },
            'Ruger 10/22': {
                damage: 18, accuracy: 58, apCost: 12,
                minRange: 2, optimalRange: 6, maxRange: 12,
                type: 'ranged', category: 'rifle', description: 'Semi-auto .22 rifle',
                ammoType: '.22 LR', ammoPerShot: 1
            },
            'Mosin-Nagant': {
                damage: 58, accuracy: 48, apCost: 25,
                minRange: 3, optimalRange: 10, maxRange: 18,
                type: 'ranged', category: 'rifle', description: 'Russian military rifle',
                ammoType: '7.62x54R', ammoPerShot: 1
            },
            'Marlin 336': {
                damage: 42, accuracy: 50, apCost: 18,
                minRange: 2, optimalRange: 7, maxRange: 14,
                type: 'ranged', category: 'rifle', description: 'Lever-action .30-30',
                ammoType: '.30-30', ammoPerShot: 1
            },

            // ========== RIFLES - SEMI-AUTO/AUTO (8) ==========
            'AR-15': {
                damage: 32, accuracy: 50, apCost: 16,
                minRange: 2, optimalRange: 8, maxRange: 15,
                type: 'ranged', category: 'rifle', description: 'Modern sporting rifle',
                ammoType: '5.56mm', ammoPerShot: 1
            },
            'AK-47': {
                damage: 38, accuracy: 42, apCost: 17,
                minRange: 2, optimalRange: 7, maxRange: 14,
                type: 'ranged', category: 'rifle', description: 'Reliable assault rifle',
                ammoType: '7.62x39', ammoPerShot: 1
            },
            'M1 Garand': {
                damage: 48, accuracy: 52, apCost: 20,
                minRange: 3, optimalRange: 9, maxRange: 16,
                type: 'ranged', category: 'rifle', description: 'WWII battle rifle',
                ammoType: '.30-06', ammoPerShot: 1
            },
            'M14': {
                damage: 45, accuracy: 50, apCost: 19,
                minRange: 3, optimalRange: 9, maxRange: 16,
                type: 'ranged', category: 'rifle', description: 'Military battle rifle',
                ammoType: '7.62x51', ammoPerShot: 1
            },
            'Mini-14': {
                damage: 30, accuracy: 52, apCost: 15,
                minRange: 2, optimalRange: 7, maxRange: 14,
                type: 'ranged', category: 'rifle', description: 'Ranch rifle in 5.56',
                ammoType: '5.56mm', ammoPerShot: 1
            },
            'SKS': {
                damage: 36, accuracy: 46, apCost: 17,
                minRange: 2, optimalRange: 7, maxRange: 14,
                type: 'ranged', category: 'rifle', description: 'Soviet semi-auto carbine',
                ammoType: '7.62x39', ammoPerShot: 1
            },
            'FN FAL': {
                damage: 46, accuracy: 48, apCost: 20,
                minRange: 3, optimalRange: 9, maxRange: 16,
                type: 'ranged', category: 'rifle', description: 'NATO battle rifle',
                ammoType: '7.62x51', ammoPerShot: 1
            },
            'M1 Carbine': {
                damage: 28, accuracy: 54, apCost: 14,
                minRange: 2, optimalRange: 6, maxRange: 12,
                type: 'ranged', category: 'rifle', description: 'Lightweight WWII carbine',
                ammoType: '.30 Carbine', ammoPerShot: 1
            },

            // ========== SUBMACHINE GUNS (4) ==========
            'Thompson M1A1': {
                damage: 28, accuracy: 40, apCost: 16,
                minRange: 1, optimalRange: 4, maxRange: 8,
                type: 'ranged', category: 'smg', description: 'Classic Tommy Gun',
                ammoType: '.45 ACP', ammoPerShot: 3
            },
            'MP5': {
                damage: 22, accuracy: 48, apCost: 14,
                minRange: 1, optimalRange: 5, maxRange: 10,
                type: 'ranged', category: 'smg', description: 'Precision SMG',
                ammoType: '9mm', ammoPerShot: 3
            },
            'Uzi': {
                damage: 20, accuracy: 42, apCost: 13,
                minRange: 1, optimalRange: 4, maxRange: 8,
                type: 'ranged', category: 'smg', description: 'Compact Israeli SMG',
                ammoType: '9mm', ammoPerShot: 3
            },
            'MAC-10': {
                damage: 18, accuracy: 38, apCost: 12,
                minRange: 1, optimalRange: 3, maxRange: 6,
                type: 'ranged', category: 'smg', description: 'Ultra-compact SMG',
                ammoType: '.45 ACP', ammoPerShot: 4
            },

            // ========== BOWS & CROSSBOWS (3) ==========
            'Recurve Bow': {
                damage: 25, accuracy: 45, apCost: 18,
                minRange: 2, optimalRange: 6, maxRange: 12,
                type: 'ranged', category: 'bow', description: 'Traditional hunting bow',
                ammoType: 'arrows', ammoPerShot: 1
            },
            'Compound Bow': {
                damage: 32, accuracy: 52, apCost: 20,
                minRange: 2, optimalRange: 8, maxRange: 15,
                type: 'ranged', category: 'bow', description: 'Modern mechanical bow',
                ammoType: 'arrows', ammoPerShot: 1
            },
            'Crossbow': {
                damage: 38, accuracy: 55, apCost: 25,
                minRange: 2, optimalRange: 7, maxRange: 14,
                type: 'ranged', category: 'bow', description: 'Powerful and quiet',
                ammoType: 'bolts', ammoPerShot: 1
            }
        };

        // Ammo type definitions (for display names)
        const AMMO_TYPES = {
            // Pistol calibers
            '9mm': { name: '9mm Parabellum', icon: '🔫' },
            '.45 ACP': { name: '.45 ACP', icon: '🔫' },
            '.380 ACP': { name: '.380 ACP', icon: '🔫' },
            '.50 AE': { name: '.50 Action Express', icon: '💥' },
            // Revolver calibers
            '.357 Magnum': { name: '.357 Magnum', icon: '🎯' },
            '.44 Magnum': { name: '.44 Magnum', icon: '🎯' },
            '.45 LC': { name: '.45 Long Colt', icon: '🎯' },
            // Rifle calibers
            '.22 LR': { name: '.22 Long Rifle', icon: '🎯' },
            '5.56mm': { name: '5.56x45mm NATO', icon: '🎯' },
            '7.62x39': { name: '7.62x39mm Soviet', icon: '🎯' },
            '7.62x51': { name: '7.62x51mm NATO', icon: '🎯' },
            '7.62x54R': { name: '7.62x54R Russian', icon: '🎯' },
            '.30-06': { name: '.30-06 Springfield', icon: '🎯' },
            '.308 Win': { name: '.308 Winchester', icon: '🎯' },
            '.30-30': { name: '.30-30 Winchester', icon: '🎯' },
            '.30 Carbine': { name: '.30 Carbine', icon: '🎯' },
            // Shotgun
            '12 gauge': { name: '12 Gauge Shells', icon: '💥' },
            // Archery
            'arrows': { name: 'Arrows', icon: '🏹' },
            'bolts': { name: 'Crossbow Bolts', icon: '🏹' }
        };

        // ============================================
        // PATHFINDING SYSTEM
        // ============================================

        // Movement difficulty levels determine allowed directions
        // simple = cardinal only (4-dir), medium = +diagonal (8-dir), hard = 8-dir with euclidean cost
        function getMovementDifficulty() {
            var grade = getPlayerGradeLevel();
            if (grade === 'K-1' || grade === '2') return 'simple';
            if (grade === '3' || grade === '4') return 'medium';
            return 'hard'; // 5-6, advanced
        }

        // Get allowed neighbor offsets based on difficulty
        function getNeighborOffsets(difficulty) {
            var cardinal = [
                { dx: 0, dy: -1 }, // up
                { dx: 0, dy: 1 },  // down
                { dx: -1, dy: 0 }, // left
                { dx: 1, dy: 0 }   // right
            ];
            var diagonal = [
                { dx: -1, dy: -1 }, // up-left
                { dx: 1, dy: -1 },  // up-right
                { dx: -1, dy: 1 },  // down-left
                { dx: 1, dy: 1 }    // down-right
            ];

            if (difficulty === 'simple') return cardinal;
            return cardinal.concat(diagonal); // medium and hard get diagonals
        }

        // Calculate step cost between adjacent cells
        function getStepCost(fromX, fromY, toX, toY, difficulty) {
            var dx = Math.abs(toX - fromX);
            var dy = Math.abs(toY - fromY);

            if (difficulty === 'hard') {
                // Euclidean distance, rounded to 1 decimal
                var dist = Math.sqrt(dx * dx + dy * dy);
                return Math.round(dist * 10) / 10;
            }
            // Simple and medium: each step costs 1
            return 1;
        }

        // Check if a cell is walkable (not a wall, not enemy position)
        function isCellWalkable(x, y) {
            if (x < 0 || x >= GRID_WIDTH || y < 0 || y >= GRID_HEIGHT) return false;

            var cover = gameState.combat.cover.find(function(c) {
                return c.x === x && c.y === y;
            });
            if (cover && cover.type === 'wall') return false;

            // Can't walk through any alive enemy
            for (var i = 0; i < gameState.combat.enemies.length; i++) {
                var enemy = gameState.combat.enemies[i];
                if (enemy.alive && enemy.x === x && enemy.y === y) return false;
            }

            return true;
        }

        // A* Pathfinding algorithm
        function findPath(startX, startY, endX, endY, difficulty) {
            if (!isCellWalkable(endX, endY)) return null;
            if (startX === endX && startY === endY) return [];

            var offsets = getNeighborOffsets(difficulty);

            // Priority queue (simple array sorted by f score)
            var openSet = [];
            var closedSet = {};
            var cameFrom = {};
            var gScore = {};
            var fScore = {};

            var startKey = startX + ',' + startY;
            gScore[startKey] = 0;
            fScore[startKey] = heuristic(startX, startY, endX, endY, difficulty);
            openSet.push({ x: startX, y: startY, f: fScore[startKey] });

            while (openSet.length > 0) {
                // Get node with lowest f score
                openSet.sort(function(a, b) { return a.f - b.f; });
                var current = openSet.shift();
                var currentKey = current.x + ',' + current.y;

                if (current.x === endX && current.y === endY) {
                    // Reconstruct path
                    return reconstructPath(cameFrom, current);
                }

                closedSet[currentKey] = true;

                // Check all neighbors
                for (var i = 0; i < offsets.length; i++) {
                    var nx = current.x + offsets[i].dx;
                    var ny = current.y + offsets[i].dy;
                    var neighborKey = nx + ',' + ny;

                    if (closedSet[neighborKey]) continue;
                    if (!isCellWalkable(nx, ny)) continue;

                    var stepCost = getStepCost(current.x, current.y, nx, ny, difficulty);
                    var tentativeG = gScore[currentKey] + stepCost;

                    if (gScore[neighborKey] === undefined || tentativeG < gScore[neighborKey]) {
                        cameFrom[neighborKey] = { x: current.x, y: current.y };
                        gScore[neighborKey] = tentativeG;
                        fScore[neighborKey] = tentativeG + heuristic(nx, ny, endX, endY, difficulty);

                        // Add to open set if not already there
                        var inOpen = openSet.find(function(n) { return n.x === nx && n.y === ny; });
                        if (!inOpen) {
                            openSet.push({ x: nx, y: ny, f: fScore[neighborKey] });
                        }
                    }
                }
            }

            return null; // No path found
        }

        // Heuristic for A* (estimated cost to goal)
        function heuristic(x1, y1, x2, y2, difficulty) {
            var dx = Math.abs(x2 - x1);
            var dy = Math.abs(y2 - y1);

            if (difficulty === 'simple') {
                // Manhattan distance for cardinal-only movement
                return dx + dy;
            }
            // Chebyshev for diagonal movement (or euclidean approximation)
            return Math.max(dx, dy);
        }

        // Reconstruct path from A* result
        function reconstructPath(cameFrom, end) {
            var path = [{ x: end.x, y: end.y }];
            var key = end.x + ',' + end.y;

            while (cameFrom[key]) {
                var prev = cameFrom[key];
                path.unshift({ x: prev.x, y: prev.y });
                key = prev.x + ',' + prev.y;
            }

            // Remove start position from path (player is already there)
            path.shift();
            return path;
        }

        // Calculate total path cost
        function calculatePathCost(path, difficulty) {
            if (!path || path.length === 0) return 0;

            var totalCost = 0;
            var prevX = gameState.combat.player.x;
            var prevY = gameState.combat.player.y;

            for (var i = 0; i < path.length; i++) {
                var stepCost = getStepCost(prevX, prevY, path[i].x, path[i].y, difficulty);
                totalCost += stepCost;
                prevX = path[i].x;
                prevY = path[i].y;
            }

            // Round total to 1 decimal for hard mode
            if (difficulty === 'hard') {
                totalCost = Math.round(totalCost * 10) / 10;
            }

            return totalCost;
        }

        // Convert path distance to AP cost (5 AP per square)
        function pathDistanceToAP(distance) {
            return Math.ceil(distance * 5);
        }

        // Validate a manually drawn path
        function validateDrawnPath(path, difficulty) {
            if (!path || path.length === 0) return { valid: false, reason: 'Empty path' };

            var offsets = getNeighborOffsets(difficulty);
            var prevX = gameState.combat.player.x;
            var prevY = gameState.combat.player.y;

            for (var i = 0; i < path.length; i++) {
                var cell = path[i];

                // Check if walkable
                if (!isCellWalkable(cell.x, cell.y)) {
                    return { valid: false, reason: 'Path blocked at (' + cell.x + ', ' + cell.y + ')' };
                }

                // Check if adjacent to previous cell
                var dx = cell.x - prevX;
                var dy = cell.y - prevY;
                var isAdjacent = offsets.some(function(o) {
                    return o.dx === dx && o.dy === dy;
                });

                if (!isAdjacent) {
                    return { valid: false, reason: 'Path not connected at (' + cell.x + ', ' + cell.y + ')' };
                }

                prevX = cell.x;
                prevY = cell.y;
            }

            return { valid: true };
        }

        // Path state for drawing mode
        var pathState = {
            mode: 'auto', // 'auto' or 'draw'
            currentPath: [],
            isDrawing: false
        };

        var gameState = {
            distance: 0,
            encountersWon: 0,
            player: {
                hp: 100,
                maxHp: 100,
                weapons: {
                    slot1: 'Glock 17',
                    slot2: 'Hunting Knife'
                },
                weaponDurability: {
                    slot1: 100,
                    slot2: 100
                },
                activeSlot: 1, // 1 or 2
                medkits: 2,
                money: 5000, // Starting money in cents ($50.00)
                ammo: {
                    '9mm': 24,
                    '.45 ACP': 0,
                    '.357 Magnum': 0,
                    '.44 Magnum': 0,
                    '.45 LC': 0,
                    '.380 ACP': 0,
                    '.50 AE': 0,
                    '12 gauge': 0,
                    '.22 LR': 0,
                    '5.56mm': 0,
                    '7.62x39': 0,
                    '7.62x51': 0,
                    '7.62x54R': 0,
                    '.30-06': 0,
                    '.308 Win': 0,
                    '.30-30': 0,
                    '.30 Carbine': 0,
                    'arrows': 0,
                    'bolts': 0
                },
                // Starting inventory includes materials
                inventory: [
                    'Scrap Metal', 'Scrap Metal', 'Scrap Metal', 'Scrap Metal', 'Scrap Metal',
                    'Chemicals', 'Chemicals', 'Chemicals',
                    'Electronics', 'Electronics',
                    'Cloth', 'Cloth', 'Cloth', 'Cloth'
                ],
                carryWeight: 0,
                maxCarryWeight: 100,
                mathStreak: 0,
                bestStreak: 0,
                totalCorrect: 0,
                totalAttempted: 0,
                // Vitals system - all values 0-100 (100 = full/satisfied, 0 = critical)
                vitals: {
                    hunger: 100,      // Decreases over time, restored by eating
                    thirst: 100,      // Decreases faster than hunger, restored by drinking
                    energy: 100,      // Decreases with activity, restored by sleeping
                    warmth: 75        // Affected by environment, clothing, fire
                }
            },
            combat: null,
            currentAction: null,
            currentProblem: null,
            explorationAction: null,
            mode: null, // 'move', 'attack', or null
            selectedCell: null,
            shopItem: null,
            currentShop: null, // Persistent shop inventory for current visit
            hackingState: null,
            lockpickState: null,
            craftingState: null,
            pendingCalculation: null // Universal pending calculation
        };

        // ============ LOCAL STORAGE SAVE/LOAD SYSTEM ============
        var SAVE_KEY = 'wasteland_adventure_save';
        var SAVE_VERSION = 6; // Increment when save format changes - v6: added tutorial state
        var TUTORIAL_KEY = 'wasteland_adventure_tutorial';

        // ============ TUTORIAL SYSTEM ============
        // Seamless contextual tips that appear once per trigger
        var tutorialState = {
            enabled: true,
            shownTips: {} // Track which tips have been shown
        };

        var tutorialTipTimeout = null;
        var tutorialAutoHideTimeout = null;

        // All tutorial tips defined here
        var TUTORIAL_TIPS = {
            // Base/Camp tips
            'first_base': {
                title: 'Welcome to Your Camp',
                text: 'This is your home base. Build structures to gain bonuses, manage your inventory, and prepare before venturing into the wasteland.',
                icon: '🏕️'
            },
            'first_explore': {
                title: 'Exploration',
                text: 'The wasteland is dangerous but full of loot. The further you travel, the harder it gets—but rewards increase too. Return to base before your supplies run out!',
                icon: '🗺️'
            },
            'first_combat': {
                title: 'Tactical Combat',
                text: 'Combat uses a grid. Click MOVE to plan a path, or ATTACK to target enemies. Solve math problems to confirm your actions. Melee weapons need you adjacent to enemies.',
                icon: '⚔️'
            },
            'first_math': {
                title: 'Math Powers Everything',
                text: 'Correct answers make your actions succeed. Build streaks for bonus damage! Wrong answers may cause you to miss or take penalties.',
                icon: '🧮'
            },
            'first_shop': {
                title: 'Trading Post',
                text: 'Buy supplies with cash. Prices involve math—calculate totals correctly to complete purchases. Some items may be discounted!',
                icon: '🏪'
            },
            'first_location': {
                title: 'Exploring Locations',
                text: 'Search containers for loot. Some are locked (requiring lockpicking) or electronic (requiring hacking). Each search costs energy.',
                icon: '🔍'
            },
            'first_vitals': {
                title: 'Survival Vitals',
                text: 'Watch your hunger, thirst, energy, and warmth. Low vitals cause penalties. Eat food, drink water, and rest at camp to recover.',
                icon: '❤️'
            },
            'first_weight': {
                title: 'Carry Weight',
                text: 'Items have weight. Calculate your total to reveal your carry capacity. Being overloaded slows you down!',
                icon: '🎒'
            },
            'first_crafting': {
                title: 'Crafting',
                text: 'Workbenches let you craft items from materials. Combine Scrap Metal, Chemicals, Electronics, and Cloth to make useful gear.',
                icon: '🔧'
            },
            'first_building': {
                title: 'Base Building',
                text: 'Construct buildings on your base grid. Each provides permanent bonuses like extra carry capacity, better healing, or shop discounts.',
                icon: '🏗️'
            },
            'low_hp': {
                title: 'Health Warning',
                text: 'Your HP is low! Use a Medkit from your inventory, or return to base to rest and heal. Reaching 0 HP ends the game.',
                icon: '💔'
            },
            'low_ammo': {
                title: 'Low Ammunition',
                text: 'Running low on ammo for your equipped weapon. Find more at trading posts, or switch to a melee weapon that doesn\'t need ammo.',
                icon: '🔫'
            },
            'first_return': {
                title: 'Returning to Base',
                text: 'Head back home! You\'ll travel back the distance you came. Encounters may happen on the way, but you\'ll get there eventually.',
                icon: '🏠'
            },

            // Math skill tutorials - shown first time each skill type appears
            'math_addition': {
                title: 'Addition',
                text: 'Combine numbers together. Start from the larger number and count up. Example: 7 + 5 = 12 (start at 7, count up 5).',
                icon: '➕'
            },
            'math_subtraction': {
                title: 'Subtraction',
                text: 'Find the difference between numbers. Count down from the larger number. Example: 15 - 6 = 9 (start at 15, count down 6).',
                icon: '➖'
            },
            'math_multiplication': {
                title: 'Multiplication',
                text: 'Repeated addition made fast! 4 × 3 means "4 added 3 times" = 4 + 4 + 4 = 12. Think of it as groups of items.',
                icon: '✖️'
            },
            'math_division': {
                title: 'Division',
                text: 'Splitting into equal groups. 12 ÷ 3 means "12 split into 3 groups" = 4 in each group. It\'s the opposite of multiplication!',
                icon: '➗'
            },
            'math_percentages': {
                title: 'Percentages',
                text: '"Per cent" means "per hundred." 25% = 25/100 = 0.25. To find 25% of something, multiply by 0.25 (or divide by 4).',
                icon: '%'
            },
            'math_fractions': {
                title: 'Fractions',
                text: 'Parts of a whole! The top number (numerator) is how many parts you have. The bottom (denominator) is total parts. 3/4 = 3 out of 4 pieces.',
                icon: '½'
            },
            'math_decimals': {
                title: 'Decimals',
                text: 'Numbers between whole numbers. The decimal point separates ones from tenths. $5.75 = 5 dollars and 75 cents (75/100 of a dollar).',
                icon: '•'
            },
            'math_geometry': {
                title: 'Distance & Geometry',
                text: 'Use the Pythagorean theorem for diagonal distances: distance² = horizontal² + vertical². Take the square root for the final answer.',
                icon: '📐'
            },
            'math_area': {
                title: 'Area Calculation',
                text: 'Area = length × width. It measures how much space something covers. A 3×4 rectangle has 12 square units of area.',
                icon: '⬜'
            },
            'math_money': {
                title: 'Money Math',
                text: 'Work with dollars and cents. $5.00 = 500 cents. Add prices carefully and don\'t forget to calculate change: paid - cost = change.',
                icon: '💵'
            },
            'math_ratios': {
                title: 'Ratios & Proportions',
                text: 'Comparing quantities! A 2:3 ratio means for every 2 of one thing, there are 3 of another. Cross-multiply to solve proportions.',
                icon: '⚖️'
            },
            'math_algebra': {
                title: 'Algebra',
                text: 'Solve for the unknown (x). Whatever you do to one side, do to the other! To isolate x, use inverse operations (+ ↔ -, × ↔ ÷).',
                icon: '𝑥'
            },
            'math_exponents': {
                title: 'Exponents & Roots',
                text: '2³ means 2 × 2 × 2 = 8. Square root (√) is the opposite: √9 = 3 because 3 × 3 = 9. These appear in distance calculations!',
                icon: '²'
            },
            'math_negative': {
                title: 'Negative Numbers',
                text: 'Numbers below zero! Adding a negative is like subtracting. Two negatives make a positive when multiplying: -3 × -2 = 6.',
                icon: '−'
            }
        };

        // Map skill names to tutorial IDs
        var SKILL_TO_TUTORIAL = {
            'Basic Addition': 'math_addition',
            'Counting and Number Recognition': 'math_addition',
            'Basic Subtraction': 'math_subtraction',
            'Multiplication': 'math_multiplication',
            'Division': 'math_division',
            'Percentages': 'math_percentages',
            'Basic Fractions': 'math_fractions',
            'Decimals': 'math_decimals',
            'Basic Geometry Concepts': 'math_geometry',
            'Triangles and Pythagorean Theorem': 'math_geometry',
            'Area and Perimeter': 'math_area',
            'Volume': 'math_area',
            'Money and Coins': 'math_money',
            'Ratio and Proportion': 'math_ratios',
            'Basic Algebraic Expressions': 'math_algebra',
            'Solving Simple Equations': 'math_algebra',
            'Linear Equations': 'math_algebra',
            'Quadratic Equations': 'math_exponents',
            'Exponential and Logarithmic Functions': 'math_exponents',
            'Negatives': 'math_negative'
        };

        // Show tutorial for a math skill if not seen before
        function showMathTutorial(skillName) {
            var tutorialId = SKILL_TO_TUTORIAL[skillName];
            if (tutorialId) {
                showTutorialTip(tutorialId, 400);
            }
        }

        // Infer skill and show tutorial based on problem text content
        function showMathTutorialFromProblem(problemHtml) {
            if (!problemHtml) return;
            var text = problemHtml.toLowerCase();

            // Check for various math types based on problem content
            if (text.includes('√') || text.includes('sqrt') || text.includes('square root')) {
                showMathTutorial('Quadratic Equations');
            } else if (text.includes('²') || text.includes('squared')) {
                showMathTutorial('Quadratic Equations');
            } else if (text.includes('%') || text.includes('percent') || text.includes('discount')) {
                showMathTutorial('Percentages');
            } else if (text.includes('÷') || text.includes('divided') || text.includes('split into')) {
                showMathTutorial('Division');
            } else if (text.includes('×') || text.includes('multiply') || text.includes('times') || text.includes(' x ')) {
                showMathTutorial('Multiplication');
            } else if (text.includes('area') || text.includes('perimeter')) {
                showMathTutorial('Area and Perimeter');
            } else if (text.includes('distance') || text.includes('diagonal') || text.includes('pythagorean')) {
                showMathTutorial('Basic Geometry Concepts');
            } else if (text.includes('$') || text.includes('cents') || text.includes('change') || text.includes('cost')) {
                showMathTutorial('Money and Coins');
            } else if (text.includes('ratio') || text.includes('proportion')) {
                showMathTutorial('Ratio and Proportion');
            } else if (text.includes('negative') || text.includes('below zero')) {
                showMathTutorial('Negatives');
            } else if (text.includes('-') && !text.includes('+')) {
                showMathTutorial('Basic Subtraction');
            } else if (text.includes('+')) {
                showMathTutorial('Basic Addition');
            }
        }

        // Show combat math phase with tutorial
        function showCombatMathPhase(problemHtml) {
            document.getElementById('choice-phase').style.display = 'none';
            document.getElementById('mode-indicator').style.display = 'none';
            document.getElementById('math-phase').style.display = 'block';
            document.getElementById('math-problem').innerHTML = problemHtml;
            document.getElementById('answer-input').value = '';
            document.getElementById('answer-input').focus();

            // Show appropriate math tutorial
            showMathTutorialFromProblem(problemHtml);
        }

        function loadTutorialState() {
            try {
                var saved = localStorage.getItem(TUTORIAL_KEY);
                if (saved) {
                    var data = JSON.parse(saved);
                    tutorialState.enabled = data.enabled !== false;
                    tutorialState.shownTips = data.shownTips || {};
                }
            } catch (e) {
                console.error('Failed to load tutorial state:', e);
            }
        }

        function saveTutorialState() {
            try {
                localStorage.setItem(TUTORIAL_KEY, JSON.stringify(tutorialState));
            } catch (e) {
                console.error('Failed to save tutorial state:', e);
            }
        }

        function showTutorialTip(tipId, delay) {
            // Don't show if disabled or already shown
            if (!tutorialState.enabled) return;
            if (tutorialState.shownTips[tipId]) return;

            var tip = TUTORIAL_TIPS[tipId];
            if (!tip) return;

            // Clear any pending tip
            if (tutorialTipTimeout) clearTimeout(tutorialTipTimeout);
            if (tutorialAutoHideTimeout) clearTimeout(tutorialAutoHideTimeout);

            // Delay showing the tip slightly for seamless feel
            tutorialTipTimeout = setTimeout(function() {
                var tipEl = document.getElementById('tutorial-tip');
                var iconEl = tipEl.querySelector('.tutorial-tip-icon');
                var titleEl = document.getElementById('tutorial-tip-title');
                var textEl = document.getElementById('tutorial-tip-text');

                iconEl.textContent = tip.icon || '💡';
                titleEl.textContent = tip.title;
                textEl.textContent = tip.text;

                tipEl.classList.add('active');

                // Mark as shown
                tutorialState.shownTips[tipId] = true;
                saveTutorialState();

                // Auto-hide after 12 seconds
                tutorialAutoHideTimeout = setTimeout(function() {
                    dismissTutorialTip();
                }, 12000);
            }, delay || 800);
        }

        function dismissTutorialTip() {
            if (tutorialTipTimeout) clearTimeout(tutorialTipTimeout);
            if (tutorialAutoHideTimeout) clearTimeout(tutorialAutoHideTimeout);
            document.getElementById('tutorial-tip').classList.remove('active');
        }

        function disableTutorial() {
            tutorialState.enabled = false;
            saveTutorialState();
            dismissTutorialTip();
        }

        function enableTutorial() {
            tutorialState.enabled = true;
            saveTutorialState();
        }

        function resetTutorial() {
            tutorialState.enabled = true;
            tutorialState.shownTips = {};
            saveTutorialState();
        }

        function saveGame() {
            try {
                // Only save if not in combat (to avoid saving mid-fight state)
                if (gameState.combat) {
                    console.log('Cannot save during combat');
                    return false;
                }

                var saveData = {
                    version: SAVE_VERSION,
                    timestamp: Date.now(),
                    distance: gameState.distance,
                    encountersWon: gameState.encountersWon,
                    player: {
                        hp: gameState.player.hp,
                        maxHp: gameState.player.maxHp,
                        weapons: gameState.player.weapons,
                        weaponDurability: gameState.player.weaponDurability,
                        equipmentDurability: gameState.player.equipmentDurability || {},
                        meatTimestamps: gameState.player.meatTimestamps || {},
                        activeSlot: gameState.player.activeSlot,
                        medkits: gameState.player.medkits,
                        money: gameState.player.money,
                        ammo: gameState.player.ammo,
                        inventory: gameState.player.inventory,
                        carryWeight: gameState.player.carryWeight,
                        maxCarryWeight: gameState.player.maxCarryWeight,
                        mathStreak: gameState.player.mathStreak,
                        bestStreak: gameState.player.bestStreak,
                        totalCorrect: gameState.player.totalCorrect,
                        totalAttempted: gameState.player.totalAttempted,
                        vitals: gameState.player.vitals
                    },
                    base: {
                        established: baseState.established,
                        name: baseState.name,
                        buildings: baseState.buildings,
                        resources: baseState.resources,
                        totalBenefits: baseState.totalBenefits,
                        stash: baseState.stash
                    },
                    travel: {
                        atBase: travelState.atBase,
                        distanceFromBase: travelState.distanceFromBase,
                        isReturning: travelState.isReturning
                    },
                    // Save current location state
                    currentShop: gameState.currentShop,
                    inLocation: gameState.inLocation || false,
                    currentLocationData: currentLocation || null,
                    // Save exploration screen state so we restore exactly where player was
                    explorationNarrative: document.getElementById('exploration-narrative') ? document.getElementById('exploration-narrative').innerHTML : null,
                    explorationChoices: document.getElementById('exploration-choices') ? document.getElementById('exploration-choices').innerHTML : null
                };

                localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
                console.log('Game saved:', new Date(saveData.timestamp).toLocaleString());
                return true;
            } catch (e) {
                console.error('Failed to save game:', e);
                return false;
            }
        }

        function loadGame() {
            try {
                var savedJson = localStorage.getItem(SAVE_KEY);
                if (!savedJson) {
                    console.log('No save data found');
                    return false;
                }

                var saveData = JSON.parse(savedJson);

                // Version check - can add migration logic here later
                if (saveData.version !== SAVE_VERSION) {
                    console.log('Save version mismatch, may need migration');
                    // For now, still try to load
                }

                // Reset revealed stats for loaded game (must recalculate each session)
                revealedStats.weight = false;
                revealedStats.durability1 = false;
                revealedStats.durability2 = false;

                // Restore game state
                gameState.distance = saveData.distance || 0;
                gameState.encountersWon = saveData.encountersWon || 0;

                // Restore player state with defaults for any missing properties
                if (saveData.player) {
                    gameState.player.hp = saveData.player.hp || 100;
                    gameState.player.maxHp = saveData.player.maxHp || 100;
                    gameState.player.weapons = saveData.player.weapons || { slot1: 'Glock 17', slot2: 'Hunting Knife' };
                    gameState.player.weaponDurability = saveData.player.weaponDurability || { slot1: 100, slot2: 100 };
                    gameState.player.equipmentDurability = saveData.player.equipmentDurability || {};

                    // Migrate old weaponStash to inventory (from save version < 5)
                    if (saveData.player.weaponStash && saveData.player.weaponStash.length > 0) {
                        saveData.player.weaponStash.forEach(function(w) {
                            gameState.player.inventory.push({
                                type: 'weapon',
                                name: w.name,
                                durability: w.durability || 100
                            });
                        });
                    }
                    gameState.player.meatTimestamps = saveData.player.meatTimestamps || {};
                    gameState.player.activeSlot = saveData.player.activeSlot || 1;
                    gameState.player.medkits = saveData.player.medkits || 0;
                    // Migrate old caps to money (caps were whole numbers, convert to cents)
                    if (saveData.player.caps !== undefined && saveData.player.money === undefined) {
                        gameState.player.money = saveData.player.caps * 100; // Convert old caps to cents
                    } else {
                        gameState.player.money = saveData.player.money || 0;
                    }
                    gameState.player.ammo = saveData.player.ammo || {};
                    gameState.player.inventory = saveData.player.inventory || [];

                    // Migrate old materials object to inventory items
                    if (saveData.player.materials) {
                        var mats = saveData.player.materials;
                        for (var i = 0; i < (mats.metal || 0); i++) gameState.player.inventory.push('Scrap Metal');
                        for (var i = 0; i < (mats.chem || 0); i++) gameState.player.inventory.push('Chemicals');
                        for (var i = 0; i < (mats.elec || 0); i++) gameState.player.inventory.push('Electronics');
                        for (var i = 0; i < (mats.cloth || 0); i++) gameState.player.inventory.push('Cloth');
                    }
                    gameState.player.carryWeight = saveData.player.carryWeight || 0;
                    gameState.player.maxCarryWeight = saveData.player.maxCarryWeight || 100;
                    gameState.player.mathStreak = saveData.player.mathStreak || 0;
                    gameState.player.bestStreak = saveData.player.bestStreak || 0;
                    gameState.player.totalCorrect = saveData.player.totalCorrect || 0;
                    gameState.player.totalAttempted = saveData.player.totalAttempted || 0;
                    gameState.player.vitals = saveData.player.vitals || {
                        hunger: 100,
                        thirst: 100,
                        energy: 100,
                        warmth: 75
                    };
                }

                // Restore base state
                if (saveData.base) {
                    baseState.established = saveData.base.established || false;
                    baseState.name = saveData.base.name || 'Camp';
                    baseState.buildings = saveData.base.buildings || [];
                    baseState.resources = saveData.base.resources || { wood: 20, steel: 10 };
                    baseState.totalBenefits = saveData.base.totalBenefits || {
                        carryCapacity: 0,
                        restBonus: 0,
                        cookingBonus: 0,
                        healingBonus: 0,
                        accuracyBonus: 0,
                        ambushReduction: 0,
                        hungerDecayReduction: 0,
                        shopDiscount: 0,
                        hasCraftingStation: false,
                        hasPower: false
                    };
                    // Restore home stash
                    var savedStash = saveData.base.stash || {
                        items: [],
                        materials: { metal: 0, chem: 0, elec: 0, cloth: 0 },
                        ammo: {},
                        money: 0
                    };
                    // Migrate old caps to money in stash
                    if (savedStash.caps !== undefined && savedStash.money === undefined) {
                        savedStash.money = savedStash.caps * 100;
                        delete savedStash.caps;
                    }
                    baseState.stash = savedStash;
                    // Reapply carry capacity bonus
                    gameState.player.maxCarryWeight = 100 + baseState.totalBenefits.carryCapacity;
                }

                // Restore travel state
                if (saveData.travel) {
                    travelState.atBase = saveData.travel.atBase !== undefined ? saveData.travel.atBase : true;
                    travelState.distanceFromBase = saveData.travel.distanceFromBase || 0;
                    travelState.isReturning = saveData.travel.isReturning || false;
                } else {
                    // Default to being at base for older saves
                    travelState.atBase = true;
                    travelState.distanceFromBase = 0;
                    travelState.isReturning = false;
                }

                // Reset transient state (except shop which is preserved)
                gameState.combat = null;
                gameState.currentAction = null;
                gameState.currentProblem = null;
                gameState.explorationAction = null;
                gameState.mode = null;
                gameState.selectedCell = null;
                gameState.shopItem = null;
                gameState.hackingState = null;
                gameState.lockpickState = null;
                gameState.craftingState = null;
                gameState.pendingCalculation = null;

                // Restore shop and location state
                gameState.currentShop = saveData.currentShop || null;
                gameState.inLocation = saveData.inLocation || false;
                if (saveData.currentLocationData) {
                    currentLocation = saveData.currentLocationData;
                } else {
                    currentLocation = null;
                }

                // Restore exploration screen state
                gameState.savedExplorationNarrative = saveData.explorationNarrative || null;
                gameState.savedExplorationChoices = saveData.explorationChoices || null;

                console.log('Game loaded from:', new Date(saveData.timestamp).toLocaleString());
                return true;
            } catch (e) {
                console.error('Failed to load game:', e);
                return false;
            }
        }

        function hasSaveData() {
            return localStorage.getItem(SAVE_KEY) !== null;
        }

        function getSaveInfo() {
            try {
                var savedJson = localStorage.getItem(SAVE_KEY);
                if (!savedJson) return null;

                var saveData = JSON.parse(savedJson);
                return {
                    timestamp: saveData.timestamp,
                    distance: saveData.distance,
                    encounters: saveData.encountersWon,
                    correctAnswers: saveData.player.totalCorrect || 0
                };
            } catch (e) {
                return null;
            }
        }

        function deleteSave() {
            localStorage.removeItem(SAVE_KEY);
            console.log('Save data deleted');
        }

        function autoSave() {
            if (saveGame()) {
                showAutoSaveIndicator();
            }
        }

        function showAutoSaveIndicator() {
            var indicator = document.getElementById('autosave-indicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'autosave-indicator';
                indicator.style.cssText = 'position: fixed; top: 10px; right: 10px; background: rgba(0,255,0,0.8); color: #000; padding: 5px 10px; border-radius: 5px; font-size: 0.8em; z-index: 9999; opacity: 0; transition: opacity 0.3s;';
                document.body.appendChild(indicator);
            }
            indicator.textContent = '💾 Saved';
            indicator.style.opacity = '1';
            setTimeout(function() {
                indicator.style.opacity = '0';
            }, 1500);
        }

        function updateSaveButtonVisibility() {
            var saveBtn = document.getElementById('save-btn');
            if (saveBtn) {
                saveBtn.style.display = gameState.combat ? 'none' : '';
            }
        }

        function manualSave() {
            if (gameState.combat) {
                showPopup('Cannot save during combat!', 'error', 'SAVE ERROR');
                return;
            }
            if (saveGame()) {
                showPopup('Game saved successfully!', 'success', 'SAVED');
            } else {
                showPopup('Failed to save game.', 'error', 'SAVE ERROR');
            }
        }

        function showMainMenu() {
            if (gameState.combat) {
                if (!confirm('Return to main menu? Current combat will be lost!')) {
                    return;
                }
            }
            // Save before going to menu
            if (!gameState.combat) {
                saveGame();
            }
            showScreen('start-screen');
            initStartScreen();
        }

        // ============ REVEALED STATS TRACKING ============
        // Tracks which stats have been calculated and revealed (resets each session)
        var revealedStats = {
            weight: false,
            durability1: false,
            durability2: false
        };

        function resetRevealedStats() {
            revealedStats.weight = false;
            revealedStats.durability1 = false;
            revealedStats.durability2 = false;
            updateInventoryDisplay();
        }

        function calculateWeightCheck() {
            // Build weight calculation problem
            var components = [];
            var total = 0;

            // Equipped weapons
            if (gameState.player.weapons) {
                if (gameState.player.weapons.slot1) {
                    var w1 = getWeaponWeight(gameState.player.weapons.slot1);
                    if (w1 > 0) {
                        components.push(gameState.player.weapons.slot1 + ': ' + w1.toFixed(1) + ' lb');
                        total += w1;
                    }
                }
                if (gameState.player.weapons.slot2) {
                    var w2 = getWeaponWeight(gameState.player.weapons.slot2);
                    if (w2 > 0) {
                        components.push(gameState.player.weapons.slot2 + ': ' + w2.toFixed(1) + ' lb');
                        total += w2;
                    }
                }
            }

            // Med kits
            var medkitWeight = (gameState.player.medkits || 0) * 2;
            if (medkitWeight > 0) {
                components.push('Med Kits (' + gameState.player.medkits + '×2): ' + medkitWeight.toFixed(1) + ' lb');
                total += medkitWeight;
            }

            // Simplified: just show total for ammo and inventory
            calculateCarryWeight();
            var actualTotal = gameState.player.carryWeight;

            // If there are more items, show remainder
            var remainder = actualTotal - total;
            if (remainder > 0.1) {
                components.push('Other items: ' + remainder.toFixed(1) + ' lb');
            }

            requireCalculation({
                title: '⚖️ WEIGHT CHECK',
                description: 'Calculate your total carry weight:<br><br>' + components.join('<br>'),
                formula: 'Add all weights',
                answer: Math.round(actualTotal * 10) / 10,
                xpReward: 10,
                context: 'inventory',
                onSuccess: function() {
                    revealedStats.weight = true;
                    updateInventoryDisplay();
                    showPopup('Weight calculated: ' + actualTotal.toFixed(1) + ' / ' + gameState.player.maxCarryWeight + ' lbs', 'success', 'WEIGHT CHECK');
                },
                onFailure: function() {
                    showPopup('Miscounted! Try again by clicking the ?', 'error', 'WEIGHT CHECK');
                }
            });
        }

        function calculateDurabilityCheck(slot) {
            var weaponName = gameState.player.weapons['slot' + slot];
            if (!weaponName) return;

            var durability = gameState.player.weaponDurability['slot' + slot] || 100;

            // Create a simple problem about the durability
            var usesLeft = Math.floor(durability / 5); // Rough estimate of uses
            var damagePenalty = durability < 50 ? Math.floor((50 - durability) / 10) * 5 : 0;

            requireCalculation({
                title: '🔧 CONDITION CHECK: ' + weaponName,
                description: 'Your ' + weaponName + ' has been used.<br><br>' +
                    'Maximum condition: 100%<br>' +
                    'Wear from use: ' + (100 - durability) + '%<br><br>' +
                    '<strong>What is the current condition?</strong>',
                formula: '100 - ' + (100 - durability),
                answer: durability,
                xpReward: 10,
                context: 'inventory',
                onSuccess: function() {
                    revealedStats['durability' + slot] = true;
                    updateInventoryDisplay();
                    var status = durability >= 75 ? 'Good' : durability >= 50 ? 'Worn' : durability >= 25 ? 'Damaged' : 'Critical';
                    showPopup(weaponName + ' condition: ' + durability + '% (' + status + ')', 'success', 'CONDITION CHECK');
                },
                onFailure: function() {
                    showPopup('Miscounted! Try again by clicking the ?', 'error', 'CONDITION CHECK');
                }
            });
        }

        // ============ UNIVERSAL MATH VERIFICATION SYSTEM ============
        // All game calculations go through this system
        
        function requireCalculation(options) {
            // options: {
            //   title: string,
            //   description: string,
            //   formula: string (e.g., "25 + 30"),
            //   numbers: array of numbers used,
            //   operation: string describing what we're calculating,
            //   answer: correct answer,
            //   skill: string (optional - inferred from formula if not provided),
            //   onSuccess: function(answer),
            //   onFailure: function() (optional),
            //   context: string (combat, shop, inventory, etc.)
            // }

            // Infer skill from formula if not provided
            if (!options.skill && options.formula) {
                options.skill = inferSkillFromFormula(options.formula, options.context);
            }

            gameState.pendingCalculation = options;

            // Tutorial: first math problem (general)
            showTutorialTip('first_math', 300);

            // Tutorial: specific math skill tutorial
            if (options.skill) {
                showMathTutorial(options.skill);
            }

            // Build the problem display
            var html = options.description + '<br><br>';
            html += '<div style="background: rgba(255,255,0,0.1); padding: 10px; border-radius: 5px; margin: 10px 0;">';
            html += '<strong>Calculate:</strong><br>';
            html += '<span style="font-size: 1.2em;">' + options.formula + ' = ?</span>';
            html += '</div>';
            
            // Always use the calc-overlay popup for consistency
            showCalculationPopup(html, options);
        }
        
        function showCalculationPopup(html, options) {
            // Create/show a calculation modal
            var overlay = document.getElementById('calc-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'calc-overlay';
                overlay.className = 'popup-overlay active';
                overlay.innerHTML = `
                    <div class="popup-box info" style="max-width: 450px;">
                        <div id="calc-title" class="popup-title">CALCULATE</div>
                        <div id="calc-content" class="popup-content"></div>
                        <input type="number" id="calc-answer" class="answer-input" placeholder="Enter answer" style="margin-bottom: 10px;">
                        <div style="display: flex; gap: 10px;">
                            <button class="popup-btn" onclick="submitCalculation()" style="flex: 1;">CONFIRM</button>
                            <button class="popup-btn" onclick="cancelCalculation()" style="flex: 1; background: #666;">CANCEL</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(overlay);
                
                document.getElementById('calc-answer').addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') submitCalculation();
                });
            }
            
            overlay.classList.add('active');
            document.getElementById('calc-title').textContent = options.title;
            document.getElementById('calc-content').innerHTML = html.replace('<strong>' + options.title + '</strong><br><br>', '');
            document.getElementById('calc-answer').value = '';
            setTimeout(function() { document.getElementById('calc-answer').focus(); }, 100);
        }
        
        function submitCalculation() {
            // Guard against null pendingCalculation
            if (!gameState.pendingCalculation) {
                var overlay = document.getElementById('calc-overlay');
                if (overlay) overlay.classList.remove('active');
                return;
            }

            var input = document.getElementById('calc-answer');
            if (!input) return;

            var userAnswer = parseFloat(input.value);

            if (isNaN(userAnswer)) {
                return;
            }

            var calc = gameState.pendingCalculation;
            gameState.pendingCalculation = null; // Clear immediately to prevent double-submit

            // For money calculations, convert answer from cents to dollars for comparison
            var expectedAnswer = calc.answer;
            var returnAnswer = calc.answer; // What we pass to onSuccess
            if (calc.isMoney) {
                expectedAnswer = calc.answer / 100; // Convert cents to dollars for comparison
                returnAnswer = Math.round(userAnswer * 100); // Convert user's dollars back to cents
            }

            var correct = Math.abs(userAnswer - expectedAnswer) < 0.1;

            // For HP/damage calculations where result is negative, also accept 0
            // (since HP floors at 0, answering 0 is practically correct)
            if (!correct && expectedAnswer < 0 && Math.abs(userAnswer) < 0.1) {
                correct = true;
                returnAnswer = 0; // Use 0 as the HP value
            }

            recordMathResult(correct);

            // Track skill progress if skill was specified
            if (calc.skill) {
                logPracticeSession(calc.skill, correct, {
                    question: calc.formula,
                    answer: calc.answer,
                    userAnswer: userAnswer,
                    context: calc.context || 'game'
                });
                showSkillProgress(calc.skill, correct);
            }

            // Hide calculation overlay
            var overlay = document.getElementById('calc-overlay');
            if (overlay) overlay.classList.remove('active');

            if (correct) {
                if (calc.onSuccess) calc.onSuccess(returnAnswer);
            } else {
                // Show expected answer in same format user entered (dollars for money)
                var displayExpected = calc.isMoney ? expectedAnswer.toFixed(2) : calc.answer;
                showPopup(
                    '<strong>Incorrect!</strong><br><br>' +
                    'Your answer: ' + userAnswer + '<br>' +
                    'Correct answer: ' + displayExpected + '<br><br>' +
                    (calc.failMessage || 'The calculation failed.'),
                    'error',
                    'WRONG'
                );
                if (calc.onFailure) {
                    var origClose = closePopup;
                    closePopup = function() {
                        document.getElementById('popup-overlay').classList.remove('active');
                        closePopup = origClose;
                        calc.onFailure();
                    };
                }
            }
        }
        
        function cancelCalculation() {
            var overlay = document.getElementById('calc-overlay');
            if (overlay) overlay.classList.remove('active');
            
            var calc = gameState.pendingCalculation;
            gameState.pendingCalculation = null;
            
            if (calc && calc.onCancel) calc.onCancel();
            
            // Clear pending calc queue too
            pendingCalcs = [];
        }
        
        // Item definitions with weights and values
        // All weights in pounds (lb), all values in cents (e.g., 2500 = $25.00)
        var ITEMS = {
            // Medical Consumables (realistic post-scarcity prices)
            'Med Kit': { weight: 2, value: 2500, type: 'consumable', effect: 'heal', amount: 40, desc: 'Heals 40% HP' }, // $25.00 - first aid kit
            'Antitoxin': { weight: 0.1, value: 1500, type: 'consumable', effect: 'rads', desc: 'Removes toxins' }, // $15.00 - medicine vial
            'Painkillers': { weight: 0.1, value: 800, type: 'consumable', effect: 'damage_resist', desc: '+25% damage resist' }, // $8.00 - OTC painkillers
            'Energy Drink': { weight: 1, value: 350, type: 'consumable', effect: 'ap', desc: 'Restores AP' }, // $3.50 - energy drink

            // Food items (realistic grocery/scarcity prices)
            'Canned Beans': { weight: 1, value: 250, type: 'food', desc: 'Hunger +25' }, // $2.50 - can of beans
            'Canned Meat': { weight: 0.75, value: 450, type: 'food', desc: 'Hunger +35' }, // $4.50 - canned meat
            'Dried Fruit': { weight: 0.25, value: 400, type: 'food', desc: 'Hunger +15' }, // $4.00 - dried fruit bag
            'MRE': { weight: 1.5, value: 1200, type: 'food', desc: 'Hunger +50, Energy +10' }, // $12.00 - military MRE
            'Raw Meat': { weight: 1, value: 500, type: 'food', desc: 'Cook before eating!' }, // $5.00 - raw meat
            'Cooked Meat': { weight: 0.75, value: 800, type: 'food', desc: 'Hunger +40, HP +5' }, // $8.00 - prepared meat
            'Stew': { weight: 1.5, value: 550, type: 'food', desc: 'Hunger +45, Thirst +10' }, // $5.50 - canned stew
            'Jerky': { weight: 0.25, value: 600, type: 'food', desc: 'Hunger +20' }, // $6.00 - beef jerky bag
            'Candy Bar': { weight: 0.15, value: 150, type: 'food', desc: 'Hunger +10, Energy +15' }, // $1.50 - candy bar
            'InstaMash': { weight: 0.5, value: 300, type: 'food', desc: 'Hunger +30' }, // $3.00 - instant potatoes
            'Trail Mix': { weight: 0.5, value: 450, type: 'food', desc: 'Hunger +20, Energy +10' }, // $4.50 - trail mix
            'Granola Bar': { weight: 0.15, value: 200, type: 'food', desc: 'Hunger +15, Energy +15' }, // $2.00 - granola bar
            'Beef Jerky': { weight: 0.25, value: 600, type: 'food', desc: 'Hunger +20' }, // $6.00 - jerky

            // Drink items
            'Water Bottle': { weight: 1, value: 200, type: 'drink', desc: 'Thirst +40' }, // $2.00 - bottled water
            'Stream Water': { weight: 1, value: 0, type: 'drink', desc: 'Thirst +25, HP -5' }, // Free but risky
            'Sports Drink': { weight: 1.25, value: 300, type: 'drink', desc: 'Thirst +35, Energy +15' }, // $3.00 - Gatorade
            'Coffee': { weight: 1, value: 350, type: 'drink', desc: 'Thirst +15, Energy +30' }, // $3.50 - coffee
            'Whiskey': { weight: 1.5, value: 1500, type: 'drink', desc: 'Warmth +20, Energy -10' }, // $15.00 - whiskey
            'Soup': { weight: 1, value: 350, type: 'drink', desc: 'Thirst +20, Hunger +15' }, // $3.50 - canned soup

            // Crafting Materials - Basic (stackable)
            'Scrap Metal': { weight: 0.5, value: 200, type: 'material', desc: 'Metal scraps for crafting' },
            'Chemicals': { weight: 0.25, value: 300, type: 'material', desc: 'Chemical compounds for crafting' },
            'Electronics': { weight: 0.1, value: 400, type: 'material', desc: 'Electronic components for crafting' },
            'Cloth': { weight: 0.1, value: 150, type: 'material', desc: 'Cloth scraps for crafting' },

            // Crafting Materials - Hunting
            'Animal Hide': { weight: 2, value: 800, type: 'material', desc: 'Raw hide, needs tanning' },
            'Leather': { weight: 1, value: 2000, type: 'material', desc: 'Tanned leather for crafting' },

            // Junk/Trade goods (salvage prices)
            'Old Cash': { weight: 0.1, value: 100, type: 'junk', desc: 'Pre-collapse currency' }, // $1.00 - novelty value
            'Super Glue': { weight: 0.1, value: 500, type: 'junk', desc: 'Useful adhesive' }, // $5.00 - super glue
            'Duct Tape': { weight: 0.5, value: 800, type: 'junk', desc: 'Fixes everything' }, // $8.00 - duct tape roll
            'Sensor Module': { weight: 0.5, value: 2500, type: 'junk', desc: 'Electronic component' }, // $25.00 - electronics
            'Circuitry': { weight: 0.25, value: 1500, type: 'junk', desc: 'Valuable electronics' }, // $15.00 - circuit board
            'Gold Watch': { weight: 0.2, value: 7500, type: 'junk', desc: 'Valuable timepiece' }, // $75.00 - gold watch
            'Silver Locket': { weight: 0.1, value: 4000, type: 'junk', desc: 'Antique jewelry' }, // $40.00 - silver jewelry

            // Armor pieces (tactical gear prices)
            'Leather Vest': { weight: 3, value: 4500, type: 'armor', dr: 5, desc: '+5 damage resist' }, // $45.00 - leather vest
            'Metal Plate': { weight: 8, value: 12000, type: 'armor', dr: 10, desc: '+10 damage resist' }, // $120.00 - steel plate
            'Tactical Vest': { weight: 7, value: 25000, type: 'armor', dr: 15, desc: '+15 damage resist' }, // $250.00 - plate carrier

            // Ammo (realistic ammo prices - slightly inflated for scarcity)
            '9mm Rounds (24)': { weight: 0.6, value: 1200, type: 'ammo', ammoType: '9mm', ammoAmount: 24, desc: 'Pistol ammunition' }, // $12.00 (~$0.50/round)
            '12 Gauge Shells (12)': { weight: 1.1, value: 1000, type: 'ammo', ammoType: '12 gauge', ammoAmount: 12, desc: 'Shotgun ammunition' }, // $10.00 (~$0.83/shell)
            '.308 Rounds (10)': { weight: 0.6, value: 1500, type: 'ammo', ammoType: '.308 Win', ammoAmount: 10, desc: 'Rifle ammunition' }, // $15.00 (~$1.50/round)
            '5.56mm Rounds (30)': { weight: 0.75, value: 1800, type: 'ammo', ammoType: '5.56mm', ammoAmount: 30, desc: 'Rifle ammunition' }, // $18.00 (~$0.60/round)
            'Arrows (12)': { weight: 0.75, value: 2400, type: 'ammo', ammoType: 'arrows', ammoAmount: 12, desc: 'Bow ammunition' }, // $24.00 (~$2/arrow)

            // Camping Equipment (outdoor gear prices)
            'Camping Set': { weight: 12, value: 15000, type: 'equipment', desc: 'Set up camp to rest in the field' }, // $150.00 - tent kit
            'Portable Stove': { weight: 2, value: 4500, type: 'equipment', desc: 'Cook food while camping' }, // $45.00 - camp stove
            'Sleeping Bag': { weight: 3, value: 6000, type: 'equipment', desc: 'Better rest quality at camp' }, // $60.00 - sleeping bag
            'Water Purifier': { weight: 1, value: 3500, type: 'equipment', desc: 'Purify stream water at camp' } // $35.00 - water filter
        };

        // ============ DISTANCE-BASED DIFFICULTY SYSTEM ============
        // The further from base, the harder enemies but better loot

        // Get difficulty tier based on distance from base
        function getDistanceTier() {
            var dist = travelState.distanceFromBase;
            if (dist < 10) return { tier: 1, name: 'Safe Zone', color: '#0f0', enemyMult: 1.0, lootMult: 1.0 };
            if (dist < 25) return { tier: 2, name: 'Frontier', color: '#ff0', enemyMult: 1.3, lootMult: 1.5 };
            if (dist < 50) return { tier: 3, name: 'Danger Zone', color: '#f80', enemyMult: 1.6, lootMult: 2.0 };
            if (dist < 80) return { tier: 4, name: 'Deep Wastes', color: '#f44', enemyMult: 2.0, lootMult: 3.0 };
            return { tier: 5, name: 'The Abyss', color: '#a0f', enemyMult: 2.5, lootMult: 4.0 };
        }

        // Update the distance tier indicator UI
        function updateDistanceTierIndicator() {
            var indicator = document.getElementById('distance-tier-indicator');
            if (!indicator) return;

            // Hide when at base, show when exploring
            if (travelState.atBase) {
                indicator.style.display = 'none';
                return;
            }

            indicator.style.display = 'block';
            var tier = getDistanceTier();

            // Update tier name with color
            var tierNameEl = document.getElementById('tier-name');
            if (tierNameEl) {
                tierNameEl.textContent = tier.name;
                tierNameEl.style.color = tier.color;
            }

            // Update distance
            var distEl = document.getElementById('tier-distance');
            if (distEl) {
                distEl.textContent = Math.floor(travelState.distanceFromBase) + ' km from base';
            }

            // Update multipliers
            var enemyMultEl = document.getElementById('tier-enemy-mult');
            if (enemyMultEl) {
                enemyMultEl.textContent = '×' + tier.enemyMult.toFixed(1);
            }

            var lootMultEl = document.getElementById('tier-loot-mult');
            if (lootMultEl) {
                lootMultEl.textContent = '×' + tier.lootMult.toFixed(1);
            }
        }

        // Check if player has camping equipment
        function hasCampingGear() {
            return gameState.player.inventory.includes('Camping Set');
        }

        function hasPortableStove() {
            return gameState.player.inventory.includes('Portable Stove');
        }

        function hasSleepingBag() {
            return gameState.player.inventory.includes('Sleeping Bag');
        }

        function hasWaterPurifier() {
            return gameState.player.inventory.includes('Water Purifier');
        }

        // ============ GEAR MAINTENANCE / DURABILITY SYSTEM ============
        // Weapons and equipment degrade with use
        // Repair requires scrapping a weapon of the same type
        // Field repairs cost 2x, broken items are destroyed

        // Track if we're at base or in field (affects repair costs)
        function isAtBase() {
            return travelState.atBase;
        }

        // Get durability for the active weapon slot
        function getActiveWeaponDurability() {
            var slot = gameState.player.activeSlot === 1 ? 'slot1' : 'slot2';
            if (!gameState.player.weaponDurability) {
                gameState.player.weaponDurability = { slot1: 100, slot2: 100 };
            }
            return gameState.player.weaponDurability[slot];
        }

        // Degrade weapon durability after use - destroys weapon if it hits 0
        function degradeWeaponDurability(amount) {
            var slot = gameState.player.activeSlot === 1 ? 'slot1' : 'slot2';
            if (!gameState.player.weaponDurability) {
                gameState.player.weaponDurability = { slot1: 100, slot2: 100 };
            }
            var current = gameState.player.weaponDurability[slot];
            var newDurability = Math.max(0, current - amount);
            gameState.player.weaponDurability[slot] = newDurability;

            // Check for weapon destruction
            if (newDurability <= 0) {
                var weaponName = slot === 'slot1' ? gameState.player.weapons.slot1 : gameState.player.weapons.slot2;
                if (weaponName !== 'Fists') {
                    destroyEquippedWeapon(slot);
                }
            }
            return amount;
        }

        // Destroy a weapon that has reached 0 durability
        function destroyEquippedWeapon(slot) {
            var weaponName = slot === 'slot1' ? gameState.player.weapons.slot1 : gameState.player.weapons.slot2;

            // Replace with Fists
            if (slot === 'slot1') {
                gameState.player.weapons.slot1 = 'Fists';
                gameState.player.weaponDurability.slot1 = 100;
            } else {
                gameState.player.weapons.slot2 = 'Fists';
                gameState.player.weaponDurability.slot2 = 100;
            }

            showPopup(
                '<strong>⚠️ WEAPON DESTROYED!</strong><br><br>' +
                'Your <span style="color: #f44;">' + weaponName + '</span> has broken beyond repair!<br><br>' +
                'It has been replaced with your Fists.<br>' +
                '<span style="color: #888;">Find or craft a replacement, or check your weapon stash.</span>',
                'error',
                'EQUIPMENT LOST'
            );
            updateInventoryDisplay();
        }

        // Degrade camping equipment durability
        function degradeCampingEquipment(itemName, amount) {
            if (!gameState.player.equipmentDurability) {
                gameState.player.equipmentDurability = {};
            }
            if (gameState.player.equipmentDurability[itemName] === undefined) {
                gameState.player.equipmentDurability[itemName] = 100;
            }

            var current = gameState.player.equipmentDurability[itemName];
            var newDur = Math.max(0, current - amount);
            gameState.player.equipmentDurability[itemName] = newDur;

            // Destroy equipment if it breaks
            if (newDur <= 0) {
                destroyCampingEquipment(itemName);
            }
            return newDur;
        }

        // Destroy camping equipment that has broken
        function destroyCampingEquipment(itemName) {
            // Remove from inventory
            var idx = gameState.player.inventory.indexOf(itemName);
            if (idx > -1) {
                gameState.player.inventory.splice(idx, 1);
                delete gameState.player.equipmentDurability[itemName];
                calculateCarryWeight();

                showPopup(
                    '<strong>⚠️ EQUIPMENT BROKEN!</strong><br><br>' +
                    'Your <span style="color: #f44;">' + itemName + '</span> has worn out and is no longer usable!<br><br>' +
                    '<span style="color: #888;">Find a replacement while exploring or buy one from a trader.</span>',
                    'error',
                    'EQUIPMENT LOST'
                );
            }
        }

        // Get equipment durability
        function getEquipmentDurability(itemName) {
            if (!gameState.player.equipmentDurability) {
                gameState.player.equipmentDurability = {};
            }
            if (gameState.player.equipmentDurability[itemName] === undefined) {
                gameState.player.equipmentDurability[itemName] = 100;
            }
            return gameState.player.equipmentDurability[itemName];
        }

        // Get damage penalty based on durability (0-50% reduction at 0 durability)
        function getDurabilityDamagePenalty() {
            var durability = getActiveWeaponDurability();
            if (durability >= 50) return 0;
            return Math.floor((50 - durability));
        }

        // Get accuracy penalty based on durability
        function getDurabilityAccuracyPenalty() {
            var durability = getActiveWeaponDurability();
            if (durability >= 50) return 0;
            return Math.floor((50 - durability) / 2);
        }

        // Get durability color for display
        function getDurabilityColor(durability) {
            if (durability >= 75) return '#0f0';
            if (durability >= 50) return '#ff0';
            if (durability >= 25) return '#f80';
            return '#f44';
        }

        // Get durability status text
        function getDurabilityStatus(durability) {
            if (durability >= 90) return 'Excellent';
            if (durability >= 75) return 'Good';
            if (durability >= 50) return 'Worn';
            if (durability >= 25) return 'Damaged';
            if (durability > 0) return 'Broken';
            return 'Destroyed';
        }

        // ============ WEAPON INVENTORY SYSTEM ============
        // Weapons are stored in inventory as objects: {type: 'weapon', name: 'AK-47', durability: 85}
        // Weight is determined by weapon category
        // Players can equip weapons from inventory outside of combat

        function getWeaponWeight(weaponName) {
            var weapon = WEAPONS[weaponName];
            if (!weapon) return 0;

            // Weight by category in pounds (based on real weapons)
            // Knife: 0.5-1 lb (pocket knife to machete)
            // Blunt: 2-10 lb (bat to sledgehammer)
            // Revolver: 2-3 lb (loaded)
            // Pistol: 1.5-4 lb (Glock to Desert Eagle)
            // Shotgun: 7-8 lb (pump shotgun)
            // Rifle: 7-10 lb (hunting rifle to battle rifle)
            // SMG: 5-7 lb (loaded)
            // Bow: 3-4 lb (compound bow)
            var categoryWeights = {
                'unarmed': 0,
                'knife': 0.75,    // Average knife
                'blunt': 4,       // Average blunt weapon
                'revolver': 2.5,  // Loaded revolver
                'pistol': 2,      // Loaded semi-auto
                'shotgun': 7.5,   // Pump shotgun
                'rifle': 8,       // Average rifle
                'smg': 6,         // Loaded SMG
                'bow': 3.5        // Compound bow
            };

            return categoryWeights[weapon.category] || 3;
        }

        // Get all weapons from inventory
        function getInventoryWeapons() {
            var weapons = [];
            for (var i = 0; i < gameState.player.inventory.length; i++) {
                var item = gameState.player.inventory[i];
                if (typeof item === 'object' && item.type === 'weapon') {
                    weapons.push({ index: i, weapon: item });
                }
            }
            return weapons;
        }

        // Get weapons from inventory that match a type (ranged/melee)
        function getInventoryWeaponsByType(type) {
            var weapons = getInventoryWeapons();
            return weapons.filter(function(w) {
                var weaponData = WEAPONS[w.weapon.name];
                return weaponData && weaponData.type === type;
            });
        }

        // Add weapon to inventory (as object with durability)
        function addWeaponToInventory(weaponName, durability) {
            var weapon = WEAPONS[weaponName];
            if (!weapon) return false;

            var weaponWeight = getWeaponWeight(weaponName);
            if ((gameState.player.carryWeight + weaponWeight) > gameState.player.maxCarryWeight) {
                return false; // Can't carry
            }

            gameState.player.inventory.push({
                type: 'weapon',
                name: weaponName,
                durability: durability || 100
            });
            calculateCarryWeight();
            return true;
        }

        // Remove weapon from inventory by index
        function removeWeaponFromInventory(index) {
            if (index >= 0 && index < gameState.player.inventory.length) {
                var item = gameState.player.inventory[index];
                if (typeof item === 'object' && item.type === 'weapon') {
                    gameState.player.inventory.splice(index, 1);
                    calculateCarryWeight();
                    return item;
                }
            }
            return null;
        }

        // Open weapon management menu (only available outside combat)
        function openWeaponStash() {
            if (gameState.combat) {
                showPopup('Cannot change weapons during combat!', 'error', 'IN COMBAT');
                return;
            }

            var inventoryWeapons = getInventoryWeapons();

            var html = '<div style="max-height: 450px; overflow-y: auto;">';
            html += '<p style="color: #888; margin-bottom: 10px;">Equip weapons from inventory or unequip to inventory. <span style="color: #ff0;">Cannot change during combat.</span></p>';

            // Current equipped weapons
            html += '<div style="border: 2px solid #0f0; padding: 10px; border-radius: 5px; margin-bottom: 15px;">';
            html += '<strong style="color: #0f0;">EQUIPPED WEAPONS:</strong><br>';
            var w1 = gameState.player.weapons.slot1;
            var w2 = gameState.player.weapons.slot2;
            var d1 = gameState.player.weaponDurability ? gameState.player.weaponDurability.slot1 : 100;
            var d2 = gameState.player.weaponDurability ? gameState.player.weaponDurability.slot2 : 100;

            html += '<div style="margin: 5px 0;">Slot 1' + (gameState.player.activeSlot === 1 ? ' [ACTIVE]' : '') + ': ' + w1;
            html += ' <span style="color:' + getDurabilityColor(d1) + ';">[' + d1 + '%]</span>';
            html += ' <span style="color: #888;">(' + getWeaponWeight(w1) + ' lb)</span>';
            if (w1 !== 'Fists') {
                html += ' <button class="btn small" onclick="unequipWeaponToInventory(\'slot1\')" style="margin-left: 10px;">Unequip</button>';
            }
            html += '</div>';

            html += '<div style="margin: 5px 0;">Slot 2' + (gameState.player.activeSlot === 2 ? ' [ACTIVE]' : '') + ': ' + w2;
            html += ' <span style="color:' + getDurabilityColor(d2) + ';">[' + d2 + '%]</span>';
            html += ' <span style="color: #888;">(' + getWeaponWeight(w2) + ' lb)</span>';
            if (w2 !== 'Fists') {
                html += ' <button class="btn small" onclick="unequipWeaponToInventory(\'slot2\')" style="margin-left: 10px;">Unequip</button>';
            }
            html += '</div>';
            html += '</div>';

            // Inventory weapons
            html += '<strong>WEAPONS IN INVENTORY (' + inventoryWeapons.length + '):</strong><br>';
            if (inventoryWeapons.length === 0) {
                html += '<p style="color: #888;">No weapons in inventory. Find or buy weapons to collect them.</p>';
            } else {
                for (var i = 0; i < inventoryWeapons.length; i++) {
                    var iw = inventoryWeapons[i];
                    var wData = WEAPONS[iw.weapon.name];
                    var wWeight = getWeaponWeight(iw.weapon.name);
                    html += '<div style="border: 1px solid #444; padding: 8px; margin: 5px 0; border-radius: 3px;">';
                    html += '<strong>' + iw.weapon.name + '</strong> ';
                    html += '<span style="color:' + getDurabilityColor(iw.weapon.durability) + ';">[' + iw.weapon.durability + '%]</span>';
                    html += ' <span style="color: #888;">(' + wWeight + ' lb)</span>';
                    if (wData) {
                        html += ' <span style="color: #aaa;">(Dmg: ' + wData.damage + ', ' + wData.type + ')</span>';
                    }
                    html += '<br>';
                    html += '<button class="btn small" onclick="equipWeaponFromInventory(' + iw.index + ', \'slot1\')">Equip Slot 1</button> ';
                    html += '<button class="btn small" onclick="equipWeaponFromInventory(' + iw.index + ', \'slot2\')">Equip Slot 2</button> ';
                    html += '<button class="btn small" onclick="scrapWeaponFromInventory(' + iw.index + ')" style="background: #633;">Scrap</button>';
                    html += '</div>';
                }
            }
            html += '</div>';

            showPopup(html, 'info', '⚔️ WEAPON MANAGEMENT');
        }

        // Unequip a weapon to inventory
        function unequipWeaponToInventory(slot) {
            var weaponName = slot === 'slot1' ? gameState.player.weapons.slot1 : gameState.player.weapons.slot2;
            var durability = gameState.player.weaponDurability[slot] || 100;

            if (weaponName === 'Fists') {
                showPopup('Cannot unequip your fists!', 'error', 'INVALID');
                return;
            }

            // Check if we can carry it
            var weaponWeight = getWeaponWeight(weaponName);
            if ((gameState.player.carryWeight + weaponWeight) > gameState.player.maxCarryWeight) {
                showPopup('Inventory too heavy! Cannot unequip.', 'error', 'OVERWEIGHT');
                return;
            }

            // Add to inventory
            addWeaponToInventory(weaponName, durability);

            // Replace with fists
            if (slot === 'slot1') {
                gameState.player.weapons.slot1 = 'Fists';
                gameState.player.weaponDurability.slot1 = 100;
            } else {
                gameState.player.weapons.slot2 = 'Fists';
                gameState.player.weaponDurability.slot2 = 100;
            }

            updateInventoryDisplay();
            openWeaponStash(); // Refresh
        }

        // Equip a weapon from inventory
        function equipWeaponFromInventory(invIndex, slot) {
            var item = gameState.player.inventory[invIndex];
            if (!item || typeof item !== 'object' || item.type !== 'weapon') return;

            // Get current equipped weapon
            var currentWeapon = slot === 'slot1' ? gameState.player.weapons.slot1 : gameState.player.weapons.slot2;
            var currentDur = gameState.player.weaponDurability[slot] || 100;

            // Remove weapon from inventory first
            var removed = removeWeaponFromInventory(invIndex);
            if (!removed) return;

            // Add current weapon to inventory if not fists
            if (currentWeapon !== 'Fists') {
                addWeaponToInventory(currentWeapon, currentDur);
            }

            // Equip from inventory
            if (slot === 'slot1') {
                gameState.player.weapons.slot1 = removed.name;
                gameState.player.weaponDurability.slot1 = removed.durability;
            } else {
                gameState.player.weapons.slot2 = removed.name;
                gameState.player.weaponDurability.slot2 = removed.durability;
            }

            updateInventoryDisplay();
            openWeaponStash(); // Refresh
        }

        // Scrap a weapon from inventory (for parts)
        function scrapWeaponFromInventory(invIndex) {
            var item = gameState.player.inventory[invIndex];
            if (!item || typeof item !== 'object' || item.type !== 'weapon') return;

            var weaponData = WEAPONS[item.name];
            removeWeaponFromInventory(invIndex);

            // Get some materials back
            var metalGained = weaponData && weaponData.type === 'ranged' ? 3 : 1;
            addMaterial('Scrap Metal', metalGained);

            showPopup(
                '<strong>Weapon Scrapped!</strong><br><br>' +
                item.name + ' dismantled.<br>' +
                'Gained: ' + metalGained + ' Metal Scrap',
                'success',
                'SCRAPPED'
            );
            updateInventoryDisplay();
            openWeaponStash(); // Refresh after delay
        }

        // ============ WEAPON REPAIR SYSTEM ============
        // Requires scrapping a weapon of the same type to repair

        // Get repair requirements (needs a weapon of same type in inventory)
        function getRepairRequirements(slot) {
            var weaponName = slot === 'slot1' ? gameState.player.weapons.slot1 : gameState.player.weapons.slot2;
            var weapon = WEAPONS[weaponName];
            if (!weapon || weaponName === 'Fists') return null;

            var durability = gameState.player.weaponDurability[slot] || 100;
            if (durability >= 100) return null; // No repair needed

            // Find weapons of same type in inventory
            var matchingWeapons = getInventoryWeaponsByType(weapon.type);

            // Field repairs cost 2x - need 2 weapons instead of 1
            var weaponsNeeded = isAtBase() ? 1 : 2;

            return {
                weaponType: weapon.type,
                category: weapon.category,
                currentDurability: durability,
                repairAmount: 100 - durability,
                weaponsNeeded: weaponsNeeded,
                availableWeapons: matchingWeapons,
                canRepair: matchingWeapons.length >= weaponsNeeded
            };
        }

        // Open repair menu
        function openRepairMenu() {
            var weapon1 = gameState.player.weapons.slot1;
            var weapon2 = gameState.player.weapons.slot2;
            var dur1 = gameState.player.weaponDurability ? gameState.player.weaponDurability.slot1 : 100;
            var dur2 = gameState.player.weaponDurability ? gameState.player.weaponDurability.slot2 : 100;

            var fieldMultiplier = isAtBase() ? '' : ' <span style="color: #f80;">(Field: 2x cost)</span>';

            var html = '<div style="max-height: 450px; overflow-y: auto;">';
            html += '<p style="color: #888; margin-bottom: 10px;">Repair weapons by scrapping another weapon of the same type (ranged/melee).' + fieldMultiplier + '</p>';

            // Weapon 1
            if (weapon1 !== 'Fists') {
                var req1 = getRepairRequirements('slot1');
                html += '<div style="border: 1px solid #444; padding: 12px; border-radius: 5px; margin-bottom: 10px;">';
                html += '<div style="display: flex; justify-content: space-between; align-items: center;">';
                html += '<strong>' + weapon1 + '</strong>';
                html += '<span style="color: ' + getDurabilityColor(dur1) + ';">' + dur1 + '% - ' + getDurabilityStatus(dur1) + '</span>';
                html += '</div>';
                html += '<div style="background: #333; height: 8px; border-radius: 4px; margin: 8px 0;">';
                html += '<div style="background: ' + getDurabilityColor(dur1) + '; height: 100%; width: ' + dur1 + '%; border-radius: 4px;"></div>';
                html += '</div>';

                if (req1) {
                    if (req1.canRepair) {
                        html += '<button class="btn small" onclick="selectRepairPart(\'slot1\')">';
                        html += '🔧 Repair (Need ' + req1.weaponsNeeded + ' ' + req1.weaponType + ' weapon' + (req1.weaponsNeeded > 1 ? 's' : '') + ')</button>';
                        html += ' <span style="color: #0f0;">(' + req1.availableWeapons.length + ' in inventory)</span>';
                    } else {
                        html += '<span style="color: #f44;">Need ' + req1.weaponsNeeded + ' ' + req1.weaponType + ' weapon' + (req1.weaponsNeeded > 1 ? 's' : '') + ' in inventory (' + req1.availableWeapons.length + ' available)</span>';
                    }
                } else {
                    html += '<span style="color: #0f0;">✓ No repair needed</span>';
                }
                html += '</div>';
            }

            // Weapon 2
            if (weapon2 !== 'Fists') {
                var req2 = getRepairRequirements('slot2');
                html += '<div style="border: 1px solid #444; padding: 12px; border-radius: 5px; margin-bottom: 10px;">';
                html += '<div style="display: flex; justify-content: space-between; align-items: center;">';
                html += '<strong>' + weapon2 + '</strong>';
                html += '<span style="color: ' + getDurabilityColor(dur2) + ';">' + dur2 + '% - ' + getDurabilityStatus(dur2) + '</span>';
                html += '</div>';
                html += '<div style="background: #333; height: 8px; border-radius: 4px; margin: 8px 0;">';
                html += '<div style="background: ' + getDurabilityColor(dur2) + '; height: 100%; width: ' + dur2 + '%; border-radius: 4px;"></div>';
                html += '</div>';

                if (req2) {
                    if (req2.canRepair) {
                        html += '<button class="btn small" onclick="selectRepairPart(\'slot2\')">';
                        html += '🔧 Repair (Need ' + req2.weaponsNeeded + ' ' + req2.weaponType + ' weapon' + (req2.weaponsNeeded > 1 ? 's' : '') + ')</button>';
                        html += ' <span style="color: #0f0;">(' + req2.availableWeapons.length + ' in inventory)</span>';
                    } else {
                        html += '<span style="color: #f44;">Need ' + req2.weaponsNeeded + ' ' + req2.weaponType + ' weapon' + (req2.weaponsNeeded > 1 ? 's' : '') + ' in inventory (' + req2.availableWeapons.length + ' available)</span>';
                    }
                } else {
                    html += '<span style="color: #0f0;">✓ No repair needed</span>';
                }
                html += '</div>';
            }

            if (weapon1 === 'Fists' && weapon2 === 'Fists') {
                html += '<p style="color: #888;">No weapons equipped to repair.</p>';
            }

            // Equipment durability section
            html += '<hr style="border-color: #444; margin: 15px 0;">';
            html += '<strong>CAMPING EQUIPMENT:</strong><br>';
            var campItems = ['Camping Set', 'Portable Stove', 'Sleeping Bag', 'Water Purifier'];
            var hasEquipment = false;
            for (var i = 0; i < campItems.length; i++) {
                if (gameState.player.inventory.includes(campItems[i])) {
                    hasEquipment = true;
                    var equipDur = getEquipmentDurability(campItems[i]);
                    html += '<div style="margin: 5px 0;">' + campItems[i] + ': ';
                    html += '<span style="color:' + getDurabilityColor(equipDur) + ';">' + equipDur + '%</span>';
                    html += '</div>';
                }
            }
            if (!hasEquipment) {
                html += '<p style="color: #888;">No camping equipment in inventory.</p>';
            }

            html += '</div>';

            showPopup(html, 'info', '🔧 REPAIR GEAR');
        }

        // Select which inventory weapon to use for repair
        function selectRepairPart(slot) {
            var req = getRepairRequirements(slot);
            if (!req || !req.canRepair) return;

            closePopup();

            var html = '<div style="max-height: 400px; overflow-y: auto;">';
            html += '<p style="color: #888;">Select ' + req.weaponsNeeded + ' weapon' + (req.weaponsNeeded > 1 ? 's' : '') + ' to scrap for parts:</p>';

            for (var i = 0; i < req.availableWeapons.length; i++) {
                var iw = req.availableWeapons[i];
                html += '<div style="border: 1px solid #444; padding: 8px; margin: 5px 0; border-radius: 3px;">';
                html += '<strong>' + iw.weapon.name + '</strong> ';
                html += '<span style="color:' + getDurabilityColor(iw.weapon.durability) + ';">[' + iw.weapon.durability + '%]</span>';
                html += '<button class="btn small" onclick="repairWithWeapon(\'' + slot + '\', ' + iw.index + ')" style="margin-left: 10px;">Use for Parts</button>';
                html += '</div>';
            }
            html += '</div>';

            showPopup(html, 'info', '🔧 SELECT PARTS');
        }

        // Repair a weapon using another weapon from inventory
        function repairWithWeapon(slot, invIndex) {
            var req = getRepairRequirements(slot);
            if (!req) return;

            var weaponName = slot === 'slot1' ? gameState.player.weapons.slot1 : gameState.player.weapons.slot2;
            var partWeapon = gameState.player.inventory[invIndex];
            if (!partWeapon || typeof partWeapon !== 'object' || partWeapon.type !== 'weapon') return;

            closePopup();

            // Math problem for repair
            var grade = getPlayerGradeLevel();
            var durability = req.currentDurability;
            var repairAmount = req.repairAmount;
            var inventoryWeapons = getInventoryWeapons();
            var problem, answer, hint;

            if (['K-1', '2'].includes(grade)) {
                problem = weaponName + ' is at ' + durability + '% durability.<br>' +
                         'Repairing adds ' + repairAmount + '%.<br><br>' +
                         'What will the durability be?';
                answer = 100;
                hint = durability + ' + ' + repairAmount + ' = ?';
            } else if (['3', '4'].includes(grade)) {
                problem = 'You have ' + inventoryWeapons.length + ' weapons in inventory.<br>' +
                         'Using ' + req.weaponsNeeded + ' for parts.<br><br>' +
                         'How many will remain?';
                answer = inventoryWeapons.length - req.weaponsNeeded;
                hint = inventoryWeapons.length + ' - ' + req.weaponsNeeded + ' = ?';
            } else {
                var damagePct = 100 - durability;
                problem = weaponName + ' has ' + damagePct + '% damage.<br>' +
                         'Repair restores to 100%.<br><br>' +
                         'How much durability is gained?';
                answer = repairAmount;
                hint = '100 - ' + durability + ' = ?';
            }

            requireCalculation({
                title: '🔧 REPAIR: ' + weaponName,
                description: problem,
                formula: hint,
                answer: answer,
                xpReward: 0,
                context: 'repair',
                onSuccess: function() {
                    // Remove parts weapons from inventory (find matching type)
                    for (var i = 0; i < req.weaponsNeeded; i++) {
                        var matchingWeapons = getInventoryWeaponsByType(req.weaponType);
                        if (matchingWeapons.length > 0) {
                            removeWeaponFromInventory(matchingWeapons[0].index);
                        }
                    }

                    // Restore durability
                    gameState.player.weaponDurability[slot] = 100;

                    showPopup(
                        '<strong>' + weaponName + ' repaired!</strong><br><br>' +
                        'Durability: ' + durability + '% → 100%<br>' +
                        'Used ' + req.weaponsNeeded + ' ' + req.weaponType + ' weapon' + (req.weaponsNeeded > 1 ? 's' : '') + ' for parts.',
                        'success',
                        'REPAIR COMPLETE'
                    );
                    updateInventoryDisplay();
                },
                onFailure: function() {
                    // Still use parts but only partial repair
                    for (var i = 0; i < req.weaponsNeeded; i++) {
                        var matchingWeapons = getInventoryWeaponsByType(req.weaponType);
                        if (matchingWeapons.length > 0) {
                            removeWeaponFromInventory(matchingWeapons[0].index);
                        }
                    }

                    var partialRepair = Math.floor(repairAmount / 2);
                    gameState.player.weaponDurability[slot] = Math.min(100, durability + partialRepair);

                    showPopup(
                        '<strong>Sloppy Work!</strong><br><br>' +
                        'Repair was rushed and only partially effective.<br><br>' +
                        'Durability: ' + durability + '% → ' + gameState.player.weaponDurability[slot] + '%',
                        'info',
                        'PARTIAL REPAIR'
                    );
                    updateInventoryDisplay();
                }
            });
        }

        // Check if weapon needs repair warning
        function getWeaponDurabilityWarning() {
            var dur1 = gameState.player.weaponDurability ? gameState.player.weaponDurability.slot1 : 100;
            var dur2 = gameState.player.weaponDurability ? gameState.player.weaponDurability.slot2 : 100;

            if (dur1 <= 25 || dur2 <= 25) {
                return 'critical';
            } else if (dur1 <= 50 || dur2 <= 50) {
                return 'warning';
            }
            return null;
        }

        // ============ MEAT SPOILAGE SYSTEM ============
        // Raw meat and cooked meat spoil over time

        // Check and process meat spoilage (called periodically)
        function processMeatSpoilage() {
            if (!gameState.player.meatTimestamps) {
                gameState.player.meatTimestamps = {};
            }

            var now = Date.now();
            var spoiledItems = [];
            var inventory = gameState.player.inventory;

            // Check each meat item
            for (var i = inventory.length - 1; i >= 0; i--) {
                var item = inventory[i];
                if (item === 'Raw Meat' || item === 'Cooked Meat') {
                    var key = item + '_' + i;
                    if (!gameState.player.meatTimestamps[key]) {
                        // Mark when this meat was acquired
                        gameState.player.meatTimestamps[key] = now;
                    } else {
                        // Check spoilage time
                        var age = now - gameState.player.meatTimestamps[key];
                        var spoilTime = item === 'Raw Meat' ? 300000 : 600000; // 5 min raw, 10 min cooked

                        if (age > spoilTime) {
                            spoiledItems.push(item);
                            inventory.splice(i, 1);
                            delete gameState.player.meatTimestamps[key];
                        }
                    }
                }
            }

            // Reindex timestamps after removal
            reindexMeatTimestamps();

            if (spoiledItems.length > 0) {
                calculateCarryWeight();
                showPopup(
                    '<strong>⚠️ FOOD SPOILED!</strong><br><br>' +
                    spoiledItems.length + ' meat item' + (spoiledItems.length > 1 ? 's have' : ' has') + ' spoiled and been discarded.<br><br>' +
                    '<span style="color: #888;">Cook raw meat and eat cooked meat before it goes bad!</span>',
                    'info',
                    'SPOILAGE'
                );
                updateInventoryDisplay();
            }
        }

        // Reindex meat timestamps after inventory changes
        function reindexMeatTimestamps() {
            if (!gameState.player.meatTimestamps) return;

            var newTimestamps = {};
            var now = Date.now();
            var inventory = gameState.player.inventory;

            for (var i = 0; i < inventory.length; i++) {
                var item = inventory[i];
                if (item === 'Raw Meat' || item === 'Cooked Meat') {
                    var newKey = item + '_' + i;
                    // Find oldest matching timestamp
                    var found = false;
                    for (var oldKey in gameState.player.meatTimestamps) {
                        if (oldKey.startsWith(item + '_') && !newTimestamps[newKey]) {
                            newTimestamps[newKey] = gameState.player.meatTimestamps[oldKey];
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        newTimestamps[newKey] = now;
                    }
                }
            }

            gameState.player.meatTimestamps = newTimestamps;
        }

        // Mark new meat with timestamp
        function markMeatAcquired(itemName) {
            if (itemName === 'Raw Meat' || itemName === 'Cooked Meat') {
                if (!gameState.player.meatTimestamps) {
                    gameState.player.meatTimestamps = {};
                }
                reindexMeatTimestamps();
            }
        }

        // ============ WEAPON ACQUISITION CHOICE ============
        // When finding a weapon, offer choices: Equip, Take to Inventory, or Leave
        // Cannot equip during combat - must add to inventory

        function showWeaponChoice(weaponName, durability, onComplete) {
            durability = durability || 100;

            var weaponData = WEAPONS[weaponName];
            if (!weaponData) {
                console.error('Unknown weapon:', weaponName);
                if (onComplete) onComplete();
                return;
            }

            var inCombat = gameState.combat && !gameState.combat.ended;
            var weaponWeight = getWeaponWeight(weaponName);
            var canCarry = (gameState.player.carryWeight + weaponWeight) <= gameState.player.maxCarryWeight;

            // Build the popup content
            var content = '<strong>🔫 FOUND: ' + weaponName + '</strong><br><br>';
            content += '<div style="text-align: left; margin: 10px 0; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px;">';
            content += '• Damage: ' + weaponData.damage + '<br>';
            content += '• Range: ' + weaponData.minRange + '-' + weaponData.maxRange + ' sq<br>';
            content += '• Type: ' + weaponData.type + ' (' + weaponData.category + ')<br>';
            content += '• Weight: ' + weaponWeight + ' lb<br>';
            content += '• Durability: ' + durability + '%';
            content += '</div>';

            // Current equipped weapons
            var w1 = gameState.player.weapons.slot1;
            var w2 = gameState.player.weapons.slot2;
            var d1 = gameState.player.weaponDurability ? gameState.player.weaponDurability.slot1 : 100;
            var d2 = gameState.player.weaponDurability ? gameState.player.weaponDurability.slot2 : 100;

            content += '<div style="text-align: left; margin: 10px 0; font-size: 0.9em; color: #aaa;">';
            content += '<strong>Currently Equipped:</strong><br>';
            content += 'Slot 1: ' + w1 + ' (' + d1 + '%) - ' + getWeaponWeight(w1) + ' lb<br>';
            content += 'Slot 2: ' + w2 + ' (' + d2 + '%) - ' + getWeaponWeight(w2) + ' lb<br>';
            content += 'Carry: ' + gameState.player.carryWeight.toFixed(1) + '/' + gameState.player.maxCarryWeight + ' lb';
            content += '</div>';

            content += '<div style="margin-top: 15px;">';

            if (inCombat) {
                // During combat - can only take to inventory or leave
                content += '<p style="color: #ff6; margin-bottom: 10px;">⚔️ In combat - cannot equip now!</p>';
                if (canCarry) {
                    content += '<button class="btn" onclick="weaponChoiceTake(\'' + weaponName + '\', ' + durability + ')" style="margin: 5px; background: #4a4a6a;">📦 Take to Inventory</button>';
                } else {
                    content += '<p style="color: #f66;">Too heavy to carry!</p>';
                }
                content += '<button class="btn" onclick="weaponChoiceLeave()" style="margin: 5px; background: #444;">❌ Leave It</button>';
            } else {
                // Not in combat - can equip, take, or leave
                content += '<button class="btn" onclick="weaponChoiceEquip(\'' + weaponName + '\', ' + durability + ', \'slot1\')" style="margin: 5px; background: #3a5a3a;">⚔️ Equip to Slot 1</button>';
                content += '<button class="btn" onclick="weaponChoiceEquip(\'' + weaponName + '\', ' + durability + ', \'slot2\')" style="margin: 5px; background: #3a5a3a;">🗡️ Equip to Slot 2</button><br>';
                if (canCarry) {
                    content += '<button class="btn" onclick="weaponChoiceTake(\'' + weaponName + '\', ' + durability + ')" style="margin: 5px; background: #4a4a6a;">📦 Take to Inventory</button>';
                } else {
                    content += '<span style="color: #f66; margin: 5px; display: inline-block;">📦 Too heavy!</span>';
                }
                content += '<button class="btn" onclick="weaponChoiceLeave()" style="margin: 5px; background: #444;">❌ Leave It</button>';
            }

            content += '</div>';

            // Store callback
            gameState.weaponChoiceCallback = onComplete;

            showPopup(content, 'info', 'WEAPON FOUND');

            // Disable default close behavior
            var origClose = closePopup;
            closePopup = function() {
                // Do nothing - must choose an option
            };
            gameState.weaponChoiceOrigClose = origClose;
        }

        function weaponChoiceEquip(weaponName, durability, slot) {
            var weaponData = WEAPONS[weaponName];

            // Put current weapon into inventory if not Fists
            var currentWeapon = slot === 'slot1' ? gameState.player.weapons.slot1 : gameState.player.weapons.slot2;
            var currentDur = (gameState.player.weaponDurability ? gameState.player.weaponDurability[slot] : 100) || 100;

            var storedMsg = '';
            if (currentWeapon !== 'Fists') {
                // Check if we can carry the old weapon
                var oldWeight = getWeaponWeight(currentWeapon);
                if ((gameState.player.carryWeight + oldWeight) <= gameState.player.maxCarryWeight) {
                    addWeaponToInventory(currentWeapon, currentDur);
                    storedMsg = '<br>(Previous weapon moved to inventory)';
                } else {
                    storedMsg = '<br>(Previous weapon dropped - too heavy!)';
                }
            }

            // Equip new weapon
            if (slot === 'slot1') {
                gameState.player.weapons.slot1 = weaponName;
                gameState.player.weaponDurability.slot1 = durability;
            } else {
                gameState.player.weapons.slot2 = weaponName;
                gameState.player.weaponDurability.slot2 = durability;
            }

            // Close popup and continue
            document.getElementById('popup-overlay').classList.remove('active');
            closePopup = gameState.weaponChoiceOrigClose;

            showPopup('<strong>EQUIPPED!</strong><br>' + weaponName + ' in ' + (slot === 'slot1' ? 'Slot 1' : 'Slot 2') + storedMsg, 'success', 'WEAPON EQUIPPED');

            var callback = gameState.weaponChoiceCallback;
            var origClose = closePopup;
            closePopup = function() {
                document.getElementById('popup-overlay').classList.remove('active');
                closePopup = origClose;
                updateInventoryDisplay();
                if (callback) callback();
            };
        }

        function weaponChoiceTake(weaponName, durability) {
            if (!addWeaponToInventory(weaponName, durability)) {
                showPopup('Cannot carry - too heavy!', 'error', 'OVERWEIGHT');
                return;
            }

            // Close popup and continue
            document.getElementById('popup-overlay').classList.remove('active');
            closePopup = gameState.weaponChoiceOrigClose;

            showPopup('<strong>COLLECTED!</strong><br>' + weaponName + ' added to inventory.', 'success', 'WEAPON COLLECTED');

            var callback = gameState.weaponChoiceCallback;
            var origClose = closePopup;
            closePopup = function() {
                document.getElementById('popup-overlay').classList.remove('active');
                closePopup = origClose;
                updateInventoryDisplay();
                if (callback) callback();
            };
        }

        function weaponChoiceLeave() {
            // Close popup and continue
            document.getElementById('popup-overlay').classList.remove('active');
            closePopup = gameState.weaponChoiceOrigClose;

            showPopup('Left the weapon behind.', 'info', 'WEAPON LEFT');

            var callback = gameState.weaponChoiceCallback;
            var origClose = closePopup;
            closePopup = function() {
                document.getElementById('popup-overlay').classList.remove('active');
                closePopup = origClose;
                if (callback) callback();
            };
        }

        // ============ END GEAR MAINTENANCE SYSTEM ============

        // ============ HOME STASH SYSTEM ============
        // Unlimited storage at base - deposit items to save weight, withdraw when needed

        function initHomeStash() {
            if (!baseState.stash) {
                baseState.stash = {
                    items: [],
                    materials: { metal: 0, chem: 0, elec: 0, cloth: 0 },
                    ammo: {},
                    money: 0
                };
            }
            if (!baseState.stash.materials) {
                baseState.stash.materials = { metal: 0, chem: 0, elec: 0, cloth: 0 };
            }
            if (!baseState.stash.ammo) {
                baseState.stash.ammo = {};
            }
        }

        function openHomeStash() {
            if (!travelState.atBase) {
                showPopup('You must be at base to access your storage stash!', 'error', 'NOT AT BASE');
                return;
            }

            initHomeStash();
            renderHomeStash();
        }

        function renderHomeStash() {
            var html = '<div style="max-height: 500px; overflow-y: auto;">';
            html += '<p style="color: #888; margin-bottom: 15px;">Store items here to save carry weight. Withdraw when you need them.</p>';

            // Current carry weight
            html += '<div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; margin-bottom: 15px;">';
            html += '<strong>Your Carry Weight:</strong> ' + gameState.player.carryWeight.toFixed(1) + ' / ' + gameState.player.maxCarryWeight + ' lb';
            html += '</div>';

            // Tab buttons
            html += '<div style="display: flex; gap: 5px; margin-bottom: 15px;">';
            html += '<button class="btn small" onclick="renderStashTab(\'deposit\')" id="stash-tab-deposit" style="flex: 1;">📥 Deposit</button>';
            html += '<button class="btn small" onclick="renderStashTab(\'withdraw\')" id="stash-tab-withdraw" style="flex: 1;">📤 Withdraw</button>';
            html += '<button class="btn small" onclick="renderStashTab(\'materials\')" id="stash-tab-materials" style="flex: 1;">🔧 Materials</button>';
            html += '<button class="btn small" onclick="renderStashTab(\'ammo\')" id="stash-tab-ammo" style="flex: 1;">🔫 Ammo</button>';
            html += '<button class="btn small" onclick="renderStashTab(\'money\')" id="stash-tab-money" style="flex: 1;">💵 Money</button>';
            html += '</div>';

            html += '<div id="stash-content"></div>';
            html += '</div>';

            showPopup(html, 'info', '📦 STORAGE STASH');

            // Default to deposit tab
            setTimeout(function() { renderStashTab('deposit'); }, 50);
        }

        function renderStashTab(tab) {
            var content = document.getElementById('stash-content');
            if (!content) return;

            var html = '';

            if (tab === 'deposit') {
                html = renderDepositTab();
            } else if (tab === 'withdraw') {
                html = renderWithdrawTab();
            } else if (tab === 'materials') {
                html = renderMaterialsTab();
            } else if (tab === 'ammo') {
                html = renderAmmoTab();
            } else if (tab === 'money') {
                html = renderMoneyTab();
            }

            content.innerHTML = html;
        }

        function renderDepositTab() {
            var html = '<strong>DEPOSIT FROM INVENTORY:</strong><br>';

            // Group inventory items
            var itemCounts = {};
            var weaponItems = [];

            for (var i = 0; i < gameState.player.inventory.length; i++) {
                var item = gameState.player.inventory[i];
                if (typeof item === 'object' && item.type === 'weapon') {
                    weaponItems.push({ index: i, weapon: item });
                } else if (typeof item === 'string') {
                    if (!itemCounts[item]) itemCounts[item] = { count: 0, indices: [] };
                    itemCounts[item].count++;
                    itemCounts[item].indices.push(i);
                }
            }

            if (Object.keys(itemCounts).length === 0 && weaponItems.length === 0) {
                html += '<p style="color: #888;">No items to deposit.</p>';
            } else {
                // Regular items
                for (var itemName in itemCounts) {
                    var itemData = ITEMS[itemName];
                    var weight = itemData ? itemData.weight : 1;
                    html += '<div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; border: 1px solid #333; margin: 3px 0; border-radius: 3px;">';
                    html += '<span>' + itemName + ' <span style="color: #888;">(' + weight + ' lb) x' + itemCounts[itemName].count + '</span></span>';
                    html += '<button class="btn small" onclick="depositItem(\'' + itemName.replace(/'/g, "\\'") + '\')">Deposit 1</button>';
                    html += '</div>';
                }

                // Weapons
                for (var w = 0; w < weaponItems.length; w++) {
                    var wItem = weaponItems[w];
                    var wWeight = getWeaponWeight(wItem.weapon.name);
                    html += '<div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; border: 1px solid #444; margin: 3px 0; border-radius: 3px; background: rgba(100,50,0,0.2);">';
                    html += '<span>⚔️ ' + wItem.weapon.name + ' <span style="color:' + getDurabilityColor(wItem.weapon.durability) + ';">[' + wItem.weapon.durability + '%]</span> <span style="color: #888;">(' + wWeight + ' lb)</span></span>';
                    html += '<button class="btn small" onclick="depositWeapon(' + wItem.index + ')">Deposit</button>';
                    html += '</div>';
                }
            }

            return html;
        }

        function renderWithdrawTab() {
            var html = '<strong>WITHDRAW FROM STASH:</strong><br>';

            // Group stash items
            var itemCounts = {};
            var weaponItems = [];

            for (var i = 0; i < baseState.stash.items.length; i++) {
                var item = baseState.stash.items[i];
                if (typeof item === 'object' && item.type === 'weapon') {
                    weaponItems.push({ index: i, weapon: item });
                } else if (typeof item === 'string') {
                    if (!itemCounts[item]) itemCounts[item] = { count: 0, indices: [] };
                    itemCounts[item].count++;
                    itemCounts[item].indices.push(i);
                }
            }

            if (Object.keys(itemCounts).length === 0 && weaponItems.length === 0) {
                html += '<p style="color: #888;">Stash is empty.</p>';
            } else {
                // Regular items
                for (var itemName in itemCounts) {
                    var itemData = ITEMS[itemName];
                    var weight = itemData ? itemData.weight : 1;
                    var canCarry = (gameState.player.carryWeight + weight) <= gameState.player.maxCarryWeight;
                    html += '<div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; border: 1px solid #333; margin: 3px 0; border-radius: 3px;">';
                    html += '<span>' + itemName + ' <span style="color: #888;">(' + weight + ' lb) x' + itemCounts[itemName].count + '</span></span>';
                    if (canCarry) {
                        html += '<button class="btn small" onclick="withdrawItem(\'' + itemName.replace(/'/g, "\\'") + '\')">Take 1</button>';
                    } else {
                        html += '<span style="color: #f44;">Too heavy</span>';
                    }
                    html += '</div>';
                }

                // Weapons
                for (var w = 0; w < weaponItems.length; w++) {
                    var wItem = weaponItems[w];
                    var wWeight = getWeaponWeight(wItem.weapon.name);
                    var canCarryW = (gameState.player.carryWeight + wWeight) <= gameState.player.maxCarryWeight;
                    html += '<div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; border: 1px solid #444; margin: 3px 0; border-radius: 3px; background: rgba(100,50,0,0.2);">';
                    html += '<span>⚔️ ' + wItem.weapon.name + ' <span style="color:' + getDurabilityColor(wItem.weapon.durability) + ';">[' + wItem.weapon.durability + '%]</span> <span style="color: #888;">(' + wWeight + ' lb)</span></span>';
                    if (canCarryW) {
                        html += '<button class="btn small" onclick="withdrawWeapon(' + wItem.index + ')">Take</button>';
                    } else {
                        html += '<span style="color: #f44;">Too heavy</span>';
                    }
                    html += '</div>';
                }
            }

            return html;
        }

        function renderMaterialsTab() {
            var html = '<strong>MATERIALS:</strong><br>';
            html += '<p style="color: #888; font-size: 0.9em;">Transfer materials between inventory and stash.</p>';

            var mats = [
                { name: 'Scrap Metal', stashKey: 'metal', weight: 0.5 },
                { name: 'Chemicals', stashKey: 'chem', weight: 0.25 },
                { name: 'Electronics', stashKey: 'elec', weight: 0.1 },
                { name: 'Cloth', stashKey: 'cloth', weight: 0.1 }
            ];

            for (var m = 0; m < mats.length; m++) {
                var mat = mats[m];
                var playerAmt = countInventoryItem(mat.name);
                var stashAmt = baseState.stash.materials[mat.stashKey] || 0;

                html += '<div style="border: 1px solid #444; padding: 10px; margin: 5px 0; border-radius: 5px;">';
                html += '<strong>' + mat.name + '</strong> <span style="color: #888;">(' + mat.weight + ' lb each)</span><br>';
                html += '<div style="display: flex; justify-content: space-between; align-items: center; margin-top: 5px;">';
                html += '<span>Carrying: <span style="color: #ff0;">' + playerAmt + '</span></span>';
                html += '<span>Stashed: <span style="color: #0f0;">' + stashAmt + '</span></span>';
                html += '</div>';
                html += '<div style="display: flex; gap: 5px; margin-top: 8px;">';
                if (playerAmt > 0) {
                    html += '<button class="btn small" onclick="depositMaterial(\'' + mat.name + '\', 1)">Deposit 1</button>';
                    html += '<button class="btn small" onclick="depositMaterial(\'' + mat.name + '\', ' + playerAmt + ')">Deposit All</button>';
                }
                if (stashAmt > 0) {
                    html += '<button class="btn small" onclick="withdrawMaterial(\'' + mat.name + '\', 1)">Take 1</button>';
                    html += '<button class="btn small" onclick="withdrawMaterial(\'' + mat.name + '\', ' + stashAmt + ')">Take All</button>';
                }
                html += '</div>';
                html += '</div>';
            }

            return html;
        }

        function renderAmmoTab() {
            var html = '<strong>AMMUNITION:</strong><br>';
            html += '<p style="color: #888; font-size: 0.9em;">Transfer ammo between inventory and stash.</p>';

            // Get all ammo types from both player and stash
            var allAmmoTypes = {};
            if (gameState.player.ammo) {
                for (var type in gameState.player.ammo) {
                    allAmmoTypes[type] = true;
                }
            }
            if (baseState.stash.ammo) {
                for (var type in baseState.stash.ammo) {
                    allAmmoTypes[type] = true;
                }
            }

            if (Object.keys(allAmmoTypes).length === 0) {
                html += '<p style="color: #888;">No ammunition.</p>';
                return html;
            }

            for (var ammoType in allAmmoTypes) {
                var playerAmt = (gameState.player.ammo && gameState.player.ammo[ammoType]) || 0;
                var stashAmt = (baseState.stash.ammo && baseState.stash.ammo[ammoType]) || 0;
                var weightPer = AMMO_WEIGHTS[ammoType] || 0.03;

                html += '<div style="border: 1px solid #444; padding: 10px; margin: 5px 0; border-radius: 5px;">';
                html += '<strong>' + ammoType + '</strong> <span style="color: #888;">(' + (weightPer * 10).toFixed(2) + ' lb per 10)</span><br>';
                html += '<div style="display: flex; justify-content: space-between; align-items: center; margin-top: 5px;">';
                html += '<span>Carrying: <span style="color: #ff0;">' + playerAmt + '</span></span>';
                html += '<span>Stashed: <span style="color: #0f0;">' + stashAmt + '</span></span>';
                html += '</div>';
                html += '<div style="display: flex; gap: 5px; margin-top: 8px;">';
                if (playerAmt > 0) {
                    html += '<button class="btn small" onclick="depositAmmo(\'' + ammoType + '\', 10)">Deposit 10</button>';
                    html += '<button class="btn small" onclick="depositAmmo(\'' + ammoType + '\', ' + playerAmt + ')">Deposit All</button>';
                }
                if (stashAmt > 0) {
                    html += '<button class="btn small" onclick="withdrawAmmo(\'' + ammoType + '\', 10)">Take 10</button>';
                    html += '<button class="btn small" onclick="withdrawAmmo(\'' + ammoType + '\', ' + stashAmt + ')">Take All</button>';
                }
                html += '</div>';
                html += '</div>';
            }

            return html;
        }

        // Deposit functions
        function depositItem(itemName) {
            var index = gameState.player.inventory.indexOf(itemName);
            if (index === -1) return;

            gameState.player.inventory.splice(index, 1);
            baseState.stash.items.push(itemName);
            calculateCarryWeight();
            updateInventoryDisplay();
            renderStashTab('deposit');
        }

        function depositWeapon(invIndex) {
            var item = gameState.player.inventory[invIndex];
            if (!item || typeof item !== 'object' || item.type !== 'weapon') return;

            gameState.player.inventory.splice(invIndex, 1);
            baseState.stash.items.push(item);
            calculateCarryWeight();
            updateInventoryDisplay();
            renderStashTab('deposit');
        }

        function depositMaterial(matName, amount) {
            // Map inventory item names to stash keys
            var stashKeyMap = { 'Scrap Metal': 'metal', 'Chemicals': 'chem', 'Electronics': 'elec', 'Cloth': 'cloth' };
            var stashKey = stashKeyMap[matName];
            if (!stashKey) return;

            var current = countInventoryItem(matName);
            amount = Math.min(amount, current);
            if (amount <= 0) return;

            removeInventoryItems(matName, amount);
            baseState.stash.materials[stashKey] = (baseState.stash.materials[stashKey] || 0) + amount;
            calculateCarryWeight();
            updateInventoryDisplay();
            renderStashTab('materials');
        }

        function depositAmmo(ammoType, amount) {
            var current = (gameState.player.ammo && gameState.player.ammo[ammoType]) || 0;
            amount = Math.min(amount, current);
            if (amount <= 0) return;

            gameState.player.ammo[ammoType] = current - amount;
            if (!baseState.stash.ammo) baseState.stash.ammo = {};
            baseState.stash.ammo[ammoType] = (baseState.stash.ammo[ammoType] || 0) + amount;
            calculateCarryWeight();
            updateInventoryDisplay();
            renderStashTab('ammo');
        }

        // Withdraw functions
        function withdrawItem(itemName) {
            var index = baseState.stash.items.indexOf(itemName);
            if (index === -1) return;

            var itemData = ITEMS[itemName];
            var weight = itemData ? itemData.weight : 1;
            if ((gameState.player.carryWeight + weight) > gameState.player.maxCarryWeight) {
                showPopup('Too heavy to carry!', 'error', 'OVERWEIGHT');
                return;
            }

            baseState.stash.items.splice(index, 1);
            gameState.player.inventory.push(itemName);
            calculateCarryWeight();
            updateInventoryDisplay();
            renderStashTab('withdraw');
        }

        function withdrawWeapon(stashIndex) {
            var item = baseState.stash.items[stashIndex];
            if (!item || typeof item !== 'object' || item.type !== 'weapon') return;

            var weight = getWeaponWeight(item.name);
            if ((gameState.player.carryWeight + weight) > gameState.player.maxCarryWeight) {
                showPopup('Too heavy to carry!', 'error', 'OVERWEIGHT');
                return;
            }

            baseState.stash.items.splice(stashIndex, 1);
            gameState.player.inventory.push(item);
            calculateCarryWeight();
            updateInventoryDisplay();
            renderStashTab('withdraw');
        }

        function withdrawMaterial(matName, amount) {
            // Map inventory item names to stash keys
            var stashKeyMap = { 'Scrap Metal': 'metal', 'Chemicals': 'chem', 'Electronics': 'elec', 'Cloth': 'cloth' };
            var stashKey = stashKeyMap[matName];
            if (!stashKey) return;

            var stashed = baseState.stash.materials[stashKey] || 0;
            amount = Math.min(amount, stashed);
            if (amount <= 0) return;

            // Check weight using ITEMS data
            var itemData = ITEMS[matName];
            var matWeight = itemData ? itemData.weight : 0.1;
            var addWeight = amount * matWeight;
            if ((gameState.player.carryWeight + addWeight) > gameState.player.maxCarryWeight) {
                // Take as many as we can
                var maxAmount = Math.floor((gameState.player.maxCarryWeight - gameState.player.carryWeight) / matWeight);
                if (maxAmount <= 0) {
                    showPopup('Too heavy to carry!', 'error', 'OVERWEIGHT');
                    return;
                }
                amount = maxAmount;
            }

            baseState.stash.materials[stashKey] = stashed - amount;
            addMaterial(matName, amount);
            calculateCarryWeight();
            updateInventoryDisplay();
            renderStashTab('materials');
        }

        function withdrawAmmo(ammoType, amount) {
            var stashed = (baseState.stash.ammo && baseState.stash.ammo[ammoType]) || 0;
            amount = Math.min(amount, stashed);
            if (amount <= 0) return;

            // Check weight
            var weightPer = AMMO_WEIGHTS[ammoType] || 0.03;
            var addWeight = amount * weightPer;
            if ((gameState.player.carryWeight + addWeight) > gameState.player.maxCarryWeight) {
                // Take as many as we can
                var maxAmount = Math.floor((gameState.player.maxCarryWeight - gameState.player.carryWeight) / weightPer);
                if (maxAmount <= 0) {
                    showPopup('Too heavy to carry!', 'error', 'OVERWEIGHT');
                    return;
                }
                amount = maxAmount;
            }

            baseState.stash.ammo[ammoType] = stashed - amount;
            if (!gameState.player.ammo) gameState.player.ammo = {};
            gameState.player.ammo[ammoType] = (gameState.player.ammo[ammoType] || 0) + amount;
            calculateCarryWeight();
            updateInventoryDisplay();
            renderStashTab('ammo');
        }

        function renderMoneyTab() {
            var html = '';
            html += '<p style="color: #888; font-size: 0.9em;">Store cash safely at your base.</p>';

            var playerMoney = gameState.player.money || 0;
            var stashedMoney = baseState.stash.money || 0;

            html += '<div style="display: flex; justify-content: space-between; margin: 15px 0; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px;">';
            html += '<div style="text-align: center;"><span style="color: #888;">On Hand:</span><br><span style="color: #0f0; font-size: 1.2em;">' + formatMoney(playerMoney) + '</span></div>';
            html += '<div style="text-align: center;"><span style="color: #888;">In Stash:</span><br><span style="color: #0af; font-size: 1.2em;">' + formatMoney(stashedMoney) + '</span></div>';
            html += '</div>';

            html += '<div style="display: flex; gap: 10px; margin-bottom: 15px;">';
            html += '<div style="flex: 1;">';
            html += '<strong style="color: #0f0;">DEPOSIT:</strong><br>';
            if (playerMoney >= 100) {
                html += '<button class="btn small" onclick="depositMoney(100)" style="margin: 2px;">$1</button>';
            }
            if (playerMoney >= 500) {
                html += '<button class="btn small" onclick="depositMoney(500)" style="margin: 2px;">$5</button>';
            }
            if (playerMoney >= 1000) {
                html += '<button class="btn small" onclick="depositMoney(1000)" style="margin: 2px;">$10</button>';
            }
            if (playerMoney >= 2000) {
                html += '<button class="btn small" onclick="depositMoney(2000)" style="margin: 2px;">$20</button>';
            }
            if (playerMoney >= 5000) {
                html += '<button class="btn small" onclick="depositMoney(5000)" style="margin: 2px;">$50</button>';
            }
            if (playerMoney > 0) {
                html += '<button class="btn small" onclick="depositMoney(' + playerMoney + ')" style="margin: 2px; background: #0a0;">All (' + formatMoney(playerMoney) + ')</button>';
            }
            if (playerMoney <= 0) {
                html += '<span style="color: #888;">No cash on hand</span>';
            }
            html += '</div>';

            html += '<div style="flex: 1;">';
            html += '<strong style="color: #0af;">WITHDRAW:</strong><br>';
            if (stashedMoney >= 100) {
                html += '<button class="btn small" onclick="withdrawMoney(100)" style="margin: 2px;">$1</button>';
            }
            if (stashedMoney >= 500) {
                html += '<button class="btn small" onclick="withdrawMoney(500)" style="margin: 2px;">$5</button>';
            }
            if (stashedMoney >= 1000) {
                html += '<button class="btn small" onclick="withdrawMoney(1000)" style="margin: 2px;">$10</button>';
            }
            if (stashedMoney >= 2000) {
                html += '<button class="btn small" onclick="withdrawMoney(2000)" style="margin: 2px;">$20</button>';
            }
            if (stashedMoney >= 5000) {
                html += '<button class="btn small" onclick="withdrawMoney(5000)" style="margin: 2px;">$50</button>';
            }
            if (stashedMoney > 0) {
                html += '<button class="btn small" onclick="withdrawMoney(' + stashedMoney + ')" style="margin: 2px; background: #05a;">All (' + formatMoney(stashedMoney) + ')</button>';
            }
            if (stashedMoney <= 0) {
                html += '<span style="color: #888;">No cash in stash</span>';
            }
            html += '</div>';
            html += '</div>';

            return html;
        }

        function depositMoney(amount) {
            var playerMoney = gameState.player.money || 0;
            amount = Math.min(amount, playerMoney);
            if (amount <= 0) return;

            gameState.player.money -= amount;
            baseState.stash.money = (baseState.stash.money || 0) + amount;
            updateInventoryDisplay();
            renderStashTab('money');
        }

        function withdrawMoney(amount) {
            var stashedMoney = baseState.stash.money || 0;
            amount = Math.min(amount, stashedMoney);
            if (amount <= 0) return;

            baseState.stash.money -= amount;
            gameState.player.money = (gameState.player.money || 0) + amount;
            updateInventoryDisplay();
            renderStashTab('money');
        }

        // ============ END HOME STASH SYSTEM ============

        // XP System
        // Queue of pending calculations that need player input
        var pendingCalcs = [];
        
        function queueCalculation(calc) {
            pendingCalcs.push(calc);
        }
        
        function processPendingCalcs(callback) {
            if (!pendingCalcs || pendingCalcs.length === 0) {
                if (callback) callback();
                return;
            }
            
            var calc = pendingCalcs.shift();
            if (!calc) {
                if (callback) callback();
                return;
            }
            
            requireCalculation({
                title: calc.title,
                description: calc.description,
                formula: calc.formula,
                answer: calc.answer,
                xpReward: 0,
                context: 'exploration',
                onSuccess: function(result) {
                    if (calc.onSuccess) calc.onSuccess(result);
                    // Small delay to prevent UI issues
                    setTimeout(function() {
                        processPendingCalcs(callback);
                    }, 100);
                },
                onFailure: function() {
                    if (calc.onFailure) calc.onFailure();
                    setTimeout(function() {
                        processPendingCalcs(callback);
                    }, 100);
                },
                onCancel: function() {
                    // Cancel remaining calcs
                    pendingCalcs = [];
                    if (callback) callback();
                }
            });
        }
        
        // XP system removed - replaced with skill-based progress
        // awardXP is now a no-op that returns empty string for compatibility
        function awardXP(amount, reason) {
            // XP system removed - skill tracking is handled elsewhere
            return '';
        }

        // Update the skill/streak display in the exploration screen
        function updateXPDisplay() {
            // Update streak display
            var streakDisplay = document.getElementById('streak-display');
            if (streakDisplay) {
                if (gameState.player.mathStreak >= 2) {
                    streakDisplay.style.display = 'inline-block';
                    document.getElementById('streak-count').textContent = gameState.player.mathStreak;
                    if (gameState.player.mathStreak >= 5) {
                        streakDisplay.classList.add('hot');
                    } else {
                        streakDisplay.classList.remove('hot');
                    }
                } else {
                    streakDisplay.style.display = 'none';
                }
            }

            // Update skills mastered count if connected
            var masteredEl = document.getElementById('skills-mastered-count');
            if (masteredEl && skillSystem.playerSkills) {
                var mastered = Object.values(skillSystem.playerSkills).filter(function(s) {
                    return s.mastery >= 100;
                }).length;
                masteredEl.textContent = mastered + ' Mastered';
            }
        }

        function recordMathResult(correct) {
            gameState.player.totalAttempted++;
            if (correct) {
                gameState.player.totalCorrect++;
                gameState.player.mathStreak++;
                if (gameState.player.mathStreak > gameState.player.bestStreak) {
                    gameState.player.bestStreak = gameState.player.mathStreak;
                }
            } else {
                gameState.player.mathStreak = 0;
            }
            updateXPDisplay();
        }
        
        // Determine the skill practiced by a calculation based on its formula
        function inferSkillFromFormula(formula, context) {
            if (!formula) return 'Basic Addition';

            var formulaLower = formula.toLowerCase();

            // Check for specific operations
            if (formulaLower.includes('×') || formulaLower.includes('*')) {
                return 'Multiplication';
            }
            if (formulaLower.includes('÷') || formulaLower.includes('/')) {
                return 'Division';
            }
            if (formulaLower.includes('%') || formulaLower.includes('percent')) {
                return 'Percentages';
            }
            if (formulaLower.includes('√') || formulaLower.includes('sqrt')) {
                return 'Quadratic Equations';
            }
            if (formulaLower.includes('²') || formulaLower.includes('squared')) {
                return 'Quadratic Equations';
            }
            if (formulaLower.includes('sin') || formulaLower.includes('cos') || formulaLower.includes('tan')) {
                return 'Trigonometry';
            }
            if (formulaLower.includes('log') || formulaLower.includes('ln')) {
                return 'Exponential and Logarithmic Functions';
            }
            if (formulaLower.includes('area') || formulaLower.includes('perimeter')) {
                return 'Area and Perimeter';
            }
            if (formulaLower.includes('volume')) {
                return 'Volume';
            }

            // Check context for clues
            if (context === 'movement' || context === 'navigation') {
                return 'Basic Geometry Concepts';
            }

            // Default based on operations
            if (formula.includes('-')) {
                return 'Basic Subtraction';
            }
            if (formula.includes('+')) {
                return 'Basic Addition';
            }

            return 'Basic Addition';
        }

        // Adaptive Math Problem Generator
        function generateMathProblem(context) {
            var grade = getPlayerGradeLevel();
            var problem = { question: '', answer: 0, skill: 'Basic Addition' };

            switch(grade) {
                case 'K-1':
                    problem = generateGradeK1Problem(context);
                    break;
                case '2':
                    problem = generateGrade2Problem(context);
                    break;
                case '3':
                    problem = generateGrade3Problem(context);
                    break;
                case '4':
                    problem = generateGrade4Problem(context);
                    break;
                case '5-6':
                    problem = generateGrade56Problem(context);
                    break;
                case 'advanced':
                    problem = generateAdvancedProblem(context);
                    break;
                case '7-8':
                    problem = generateMiddleSchoolProblem(context);
                    break;
                case '9-12':
                    problem = generateHighSchoolProblem(context);
                    break;
                default:
                    problem = generateGrade3Problem(context);
            }

            // Infer skill if not already set
            if (!problem.skill && problem.question) {
                problem.skill = inferSkillFromFormula(problem.question, context);
            }

            return problem;
        }
        
        // K-1st Grade: Counting, single-digit +/-
        function generateGradeK1Problem(context) {
            var type = Math.floor(Math.random() * 3);
            var a, b, answer, question, skill;

            if (type === 0) {
                // Counting
                a = Math.floor(Math.random() * 10) + 1;
                b = Math.floor(Math.random() * 5) + 1;
                answer = a + b;
                question = 'You have ' + a + ' bullets.<br>You find ' + b + ' more.<br><strong>How many bullets total?</strong>';
                skill = 'Counting and Number Recognition';
            } else if (type === 1) {
                // Addition
                a = Math.floor(Math.random() * 9) + 1;
                b = Math.floor(Math.random() * (10 - a)) + 1;
                answer = a + b;
                question = '<strong>' + a + ' + ' + b + ' = ?</strong>';
                skill = 'Basic Addition';
            } else {
                // Subtraction
                a = Math.floor(Math.random() * 10) + 5;
                b = Math.floor(Math.random() * Math.min(a, 9)) + 1;
                answer = a - b;
                question = 'You have $' + a + '.<br>You spend $' + b + '.<br><strong>How many dollars left?</strong><br>' + a + ' - ' + b + ' = ?';
                skill = 'Basic Subtraction';
            }

            return { question: question, answer: answer, skill: skill };
        }
        
        // 2nd Grade: 2-digit +/-, skip counting
        function generateGrade2Problem(context) {
            var type = Math.floor(Math.random() * 3);
            var a, b, answer, question, skill;

            if (type === 0) {
                // 2-digit addition
                a = Math.floor(Math.random() * 50) + 10;
                b = Math.floor(Math.random() * 40) + 5;
                answer = a + b;
                question = 'You have ' + a + ' dollars.<br>You earn ' + b + ' more.<br><strong>' + a + ' + ' + b + ' = ?</strong>';
                skill = 'Basic Addition';
            } else if (type === 1) {
                // 2-digit subtraction
                a = Math.floor(Math.random() * 50) + 30;
                b = Math.floor(Math.random() * 25) + 5;
                answer = a - b;
                question = 'Starting HP: ' + a + '<br>Damage taken: ' + b + '<br><strong>' + a + ' - ' + b + ' = ?</strong>';
                skill = 'Basic Subtraction';
            } else {
                // Skip counting
                var skip = [2, 5, 10][Math.floor(Math.random() * 3)];
                var count = Math.floor(Math.random() * 5) + 3;
                answer = skip * count;
                question = 'Count by ' + skip + 's: ';
                for (var i = 1; i < count; i++) {
                    question += (skip * i) + ', ';
                }
                question += '<strong>?</strong>';
                skill = 'Skip Counting';
            }

            return { question: question, answer: answer, skill: skill };
        }
        
        // 3rd Grade: Multiplication, division, basic fractions
        function generateGrade3Problem(context) {
            var type = Math.floor(Math.random() * 3);
            var a, b, answer, question, skill;

            if (type === 0) {
                // Multiplication
                a = Math.floor(Math.random() * 10) + 2;
                b = Math.floor(Math.random() * 10) + 2;
                answer = a * b;
                question = a + ' enemies × ' + b + ' damage each<br><strong>' + a + ' × ' + b + ' = ?</strong>';
                skill = 'Multiplication';
            } else if (type === 1) {
                // Division
                b = Math.floor(Math.random() * 8) + 2;
                answer = Math.floor(Math.random() * 10) + 2;
                a = b * answer;
                question = 'Split ' + a + ' dollars among ' + b + ' people.<br><strong>' + a + ' ÷ ' + b + ' = ?</strong>';
                skill = 'Division';
            } else {
                // Basic fractions (half, quarter)
                var fractions = [{num: 1, den: 2, name: 'half'}, {num: 1, den: 4, name: 'quarter'}];
                var frac = fractions[Math.floor(Math.random() * 2)];
                var total = frac.den * (Math.floor(Math.random() * 6) + 2);
                answer = total / frac.den * frac.num;
                question = 'Find ' + frac.num + '/' + frac.den + ' of ' + total + '<br><strong>(' + frac.name + ' of ' + total + ') = ?</strong>';
                skill = 'Basic Fractions';
            }

            return { question: question, answer: answer, skill: skill };
        }
        
        // 4th Grade: Multi-digit multiplication, long division
        function generateGrade4Problem(context) {
            var type = Math.floor(Math.random() * 3);
            var a, b, answer, question;
            
            if (type === 0) {
                // Multi-digit multiplication
                a = Math.floor(Math.random() * 20) + 10;
                b = Math.floor(Math.random() * 8) + 3;
                answer = a * b;
                question = 'XP needed: ' + a + ' × ' + b + '<br><strong>= ?</strong>';
            } else if (type === 1) {
                // Long division
                b = Math.floor(Math.random() * 8) + 3;
                answer = Math.floor(Math.random() * 15) + 5;
                a = b * answer;
                question = 'Distribute ' + a + ' supplies to ' + b + ' settlers.<br><strong>' + a + ' ÷ ' + b + ' = ?</strong>';
            } else {
                // Factors
                var numbers = [12, 18, 24, 36, 48];
                a = numbers[Math.floor(Math.random() * numbers.length)];
                b = Math.floor(Math.random() * 3) + 2;
                answer = a / b;
                if (a % b !== 0) {
                    answer = a / 2;
                    b = 2;
                }
                question = 'What is ' + a + ' divided by ' + b + '?<br><strong>' + a + ' ÷ ' + b + ' = ?</strong>';
            }
            
            return { question: question, answer: answer, xpReward: 20 };
        }
        
        // 5th-6th Grade: Percentages, decimals, basic algebra
        function generateGrade56Problem(context) {
            var type = Math.floor(Math.random() * 3);
            var a, b, answer, question;
            
            if (type === 0) {
                // Percentages
                var percents = [10, 20, 25, 50, 75];
                var percent = percents[Math.floor(Math.random() * percents.length)];
                a = Math.floor(Math.random() * 100) + 20;
                a = Math.round(a / 10) * 10; // Round to nearest 10
                answer = a * percent / 100;
                question = 'Calculate ' + percent + '% of ' + a + '<br><strong>= ?</strong>';
            } else if (type === 1) {
                // Decimal operations
                a = Math.floor(Math.random() * 50) + 10;
                b = [0.5, 0.25, 0.1, 0.2][Math.floor(Math.random() * 4)];
                answer = a * b;
                question = a + ' × ' + b + ' = ?<br><strong>= ?</strong>';
            } else {
                // Simple algebra (solve for x)
                answer = Math.floor(Math.random() * 15) + 3;
                b = Math.floor(Math.random() * 10) + 5;
                a = answer + b;
                question = 'Solve for x:<br><strong>x + ' + b + ' = ' + a + '</strong><br>x = ?';
            }
            
            return { question: question, answer: answer, xpReward: 25 };
        }
        
        // Advanced: Square roots, coordinates, complex formulas
        function generateAdvancedProblem(context) {
            var type = Math.floor(Math.random() * 3);
            var answer, question;
            
            if (type === 0) {
                // Perfect squares
                var roots = [4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144];
                var square = roots[Math.floor(Math.random() * roots.length)];
                answer = Math.sqrt(square);
                question = 'Calculate:<br><strong>√' + square + ' = ?</strong>';
            } else if (type === 1) {
                // Distance formula (simplified)
                var x1 = Math.floor(Math.random() * 5);
                var y1 = Math.floor(Math.random() * 5);
                var x2 = x1 + Math.floor(Math.random() * 5) + 1;
                var y2 = y1 + Math.floor(Math.random() * 5) + 1;
                var dx = x2 - x1;
                var dy = y2 - y1;
                var distSquared = dx * dx + dy * dy;
                // Pick coordinates that give nice answers
                var nicePairs = [[3,4], [0,5], [5,0], [6,8], [0,3]];
                var pair = nicePairs[Math.floor(Math.random() * nicePairs.length)];
                dx = pair[0]; dy = pair[1];
                distSquared = dx * dx + dy * dy;
                answer = Math.round(Math.sqrt(distSquared) * 10) / 10;
                question = 'Distance from (0,0) to (' + dx + ',' + dy + '):<br>';
                question += '√(' + dx + '² + ' + dy + '²) = √' + distSquared + '<br><strong>= ? (round to 1 decimal)</strong>';
            } else {
                // Order of operations
                var a = Math.floor(Math.random() * 5) + 2;
                var b = Math.floor(Math.random() * 5) + 2;
                var c = Math.floor(Math.random() * 10) + 5;
                answer = a * b + c;
                question = 'Order of operations:<br><strong>' + a + ' × ' + b + ' + ' + c + ' = ?</strong>';
            }
            
            return { question: question, answer: answer, xpReward: 30 };
        }
        
        // Middle School (Grades 7-8): Algebra, Probability, Negative numbers, Proportions
        function generateMiddleSchoolProblem(context) {
            var type = Math.floor(Math.random() * 6);
            var answer, question;
            
            if (type === 0) {
                // Two-step algebra: ax + b = c
                var x = Math.floor(Math.random() * 10) + 2;
                var a = Math.floor(Math.random() * 5) + 2;
                var b = Math.floor(Math.random() * 15) + 5;
                var c = a * x + b;
                answer = x;
                question = '<strong>🔢 SOLVE FOR X</strong><br><br>';
                question += a + 'x + ' + b + ' = ' + c + '<br><br>';
                question += 'First: ' + a + 'x = ' + c + ' - ' + b + ' = ' + (c - b) + '<br>';
                question += 'Then: x = ' + (c - b) + ' ÷ ' + a + '<br><strong>x = ?</strong>';
            } else if (type === 1) {
                // Probability: compound events
                var p1 = [0.5, 0.25, 0.2, 0.1][Math.floor(Math.random() * 4)];
                var p2 = [0.5, 0.25, 0.2, 0.1][Math.floor(Math.random() * 4)];
                answer = Math.round(p1 * p2 * 100);
                var p1Pct = p1 * 100;
                var p2Pct = p2 * 100;
                question = '<strong>🎲 PROBABILITY</strong><br><br>';
                question += 'Hit chance: ' + p1Pct + '%<br>';
                question += 'Critical chance: ' + p2Pct + '%<br><br>';
                question += 'Probability of critical hit?<br>';
                question += '<strong>' + p1Pct + '% × ' + p2Pct + '% = ?%</strong><br>';
                question += '<span style="font-size:0.85em">(Multiply decimals, convert to %)</span>';
            } else if (type === 2) {
                // Negative numbers
                var a = Math.floor(Math.random() * 20) + 10;
                var b = Math.floor(Math.random() * 30) + 15;
                answer = a - b;
                question = '<strong>➖ NEGATIVE NUMBERS</strong><br><br>';
                question += 'Temperature change in wasteland:<br>';
                question += 'Started at: ' + a + '°C<br>';
                question += 'Dropped by: ' + b + '°C<br><br>';
                question += '<strong>' + a + ' - ' + b + ' = ?</strong>';
            } else if (type === 3) {
                // Proportions: cross multiply
                var a = Math.floor(Math.random() * 5) + 2;
                var b = Math.floor(Math.random() * 8) + 4;
                var c = Math.floor(Math.random() * 6) + 3;
                answer = Math.round((b * c) / a);
                question = '<strong>⚖️ PROPORTION</strong><br><br>';
                question += 'Trade ratio: ' + a + ' medkits = ' + b + ' ammo boxes<br>';
                question += 'If you have ' + c + ' medkits, how many ammo?<br><br>';
                question += a + '/' + b + ' = ' + c + '/x<br>';
                question += '<strong>x = ' + b + ' × ' + c + ' ÷ ' + a + ' = ?</strong>';
            } else if (type === 4) {
                // Exponents
                var base = Math.floor(Math.random() * 4) + 2;
                var exp = Math.floor(Math.random() * 3) + 2;
                answer = Math.pow(base, exp);
                question = '<strong>📈 EXPONENTS</strong><br><br>';
                question += 'Radiation multiplies ' + base + 'x each hour.<br>';
                question += 'After ' + exp + ' hours, multiplier is:<br><br>';
                question += '<strong>' + base + '^' + exp + ' = ?</strong>';
            } else {
                // Inequalities
                var threshold = Math.floor(Math.random() * 50) + 30;
                var perItem = Math.floor(Math.random() * 8) + 3;
                answer = Math.ceil(threshold / perItem);
                question = '<strong>≥ INEQUALITY</strong><br><br>';
                question += 'Need at least ' + threshold + ' dollars.<br>';
                question += 'Each item sells for ' + perItem + ' dollars.<br><br>';
                question += 'Minimum items to sell?<br>';
                question += '<strong>' + perItem + 'n ≥ ' + threshold + ', n = ?</strong>';
            }
            
            return { question: question, answer: answer, xpReward: 35 };
        }
        
        // High School (Grades 9-12): Quadratics, Trig, Logarithms, Systems
        function generateHighSchoolProblem(context) {
            var type = Math.floor(Math.random() * 6);
            var answer, question;
            
            if (type === 0) {
                // Quadratic: find when projectile hits ground
                // h = -t² + vt (simplified, hits at t = v)
                var v = Math.floor(Math.random() * 6) + 4;
                answer = v;
                question = '<strong>📐 QUADRATIC - PROJECTILE</strong><br><br>';
                question += 'Grenade arc: h = -t² + ' + v + 't<br>';
                question += 'When does it hit the ground? (h = 0)<br><br>';
                question += '0 = -t² + ' + v + 't<br>';
                question += '0 = t(-t + ' + v + ')<br>';
                question += '<strong>t = ? (non-zero answer)</strong>';
            } else if (type === 1) {
                // Trigonometry: right triangle
                var angles = [30, 45, 60];
                var angle = angles[Math.floor(Math.random() * 3)];
                var hypotenuse = [10, 20, 50][Math.floor(Math.random() * 3)];
                var sinVals = {30: 0.5, 45: 0.707, 60: 0.866};
                answer = Math.round(hypotenuse * sinVals[angle]);
                question = '<strong>📐 TRIGONOMETRY</strong><br><br>';
                question += 'Firing at ' + angle + '° angle<br>';
                question += 'Bullet travels ' + hypotenuse + ' meters<br><br>';
                question += 'Vertical distance = hyp × sin(' + angle + '°)<br>';
                question += 'sin(' + angle + '°) = ' + sinVals[angle] + '<br>';
                question += '<strong>' + hypotenuse + ' × ' + sinVals[angle] + ' = ?</strong>';
            } else if (type === 2) {
                // Logarithms: XP scaling
                var base = 2;
                var result = [2, 4, 8, 16, 32][Math.floor(Math.random() * 5)];
                answer = Math.log2(result);
                question = '<strong>📊 LOGARITHM - XP SCALING</strong><br><br>';
                question += 'XP needed doubles each level.<br>';
                question += 'If XP needed = 2^L, and you need ' + result + ' XP...<br><br>';
                question += '<strong>log₂(' + result + ') = L = ?</strong><br>';
                question += '<span style="font-size:0.85em">(2 to what power = ' + result + '?)</span>';
            } else if (type === 3) {
                // Systems of equations
                var x = Math.floor(Math.random() * 5) + 2;
                var y = Math.floor(Math.random() * 5) + 2;
                var sum = x + y;
                var diff = x - y;
                answer = x;
                question = '<strong>🔢 SYSTEMS OF EQUATIONS</strong><br><br>';
                question += 'You have medkits (x) and ammo (y):<br>';
                question += 'x + y = ' + sum + '<br>';
                question += 'x - y = ' + (diff >= 0 ? diff : '(' + diff + ')') + '<br><br>';
                question += 'Add equations: 2x = ' + (sum + diff) + '<br>';
                question += '<strong>x = ?</strong>';
            } else if (type === 4) {
                // Exponential decay: half-life
                var initial = [100, 200, 80, 160][Math.floor(Math.random() * 4)];
                var halfLives = Math.floor(Math.random() * 3) + 1;
                answer = initial / Math.pow(2, halfLives);
                question = '<strong>☢️ EXPONENTIAL DECAY</strong><br><br>';
                question += 'Radiation initial level: ' + initial + ' rads<br>';
                question += 'Half-life: 1 hour<br>';
                question += 'After ' + halfLives + ' hour(s), radiation = ?<br><br>';
                question += '<strong>' + initial + ' ÷ 2^' + halfLives + ' = ?</strong>';
            } else {
                // Area of sector (pie slice)
                var radius = [4, 5, 6, 10][Math.floor(Math.random() * 4)];
                var fraction = [0.25, 0.5][Math.floor(Math.random() * 2)];
                var fractionName = fraction === 0.25 ? '90° (1/4)' : '180° (1/2)';
                // Area = fraction × π × r²
                answer = Math.round(fraction * 3.14159 * radius * radius);
                question = '<strong>⭕ SECTOR AREA - BLAST ZONE</strong><br><br>';
                question += 'Explosion radius: ' + radius + ' meters<br>';
                question += 'Blast arc: ' + fractionName + ' of circle<br><br>';
                question += 'Area = ' + fraction + ' × π × ' + radius + '²<br>';
                question += 'π ≈ 3.14<br>';
                question += '<strong>Area = ? (round to whole)</strong>';
            }
            
            return { question: question, answer: answer, xpReward: 45 };
        }
        
        // ============ TRADING POST SYSTEM ============
        
        // Shop stock templates - used to generate shop inventory
        // All prices in CENTS (divide by 100 for dollars)
        var shopStockTemplates = [
            // Medical
            { name: 'Med Kit', price: 2500, type: 'item' },                                           // $25.00
            { name: 'Antitoxin', price: 2000, type: 'item' },                                         // $20.00
            { name: 'Painkillers', price: 3000, type: 'item' },                                       // $30.00
            // Food & Drink
            { name: 'Water Bottle', price: 300, type: 'item', desc: 'Thirst +40' },                   // $3.00
            { name: 'Sports Drink', price: 500, type: 'item', desc: 'Thirst +35, Energy +15' },       // $5.00
            { name: 'Canned Beans', price: 400, type: 'item', desc: 'Hunger +25' },                   // $4.00
            { name: 'Canned Meat', price: 600, type: 'item', desc: 'Hunger +35' },                    // $6.00
            { name: 'MRE', price: 1500, type: 'item', desc: 'Hunger +50, Energy +10' },               // $15.00
            { name: 'Beef Jerky', price: 500, type: 'item', desc: 'Hunger +20' },                     // $5.00
            { name: 'Trail Mix', price: 800, type: 'item', desc: 'Hunger +20, Energy +10' },          // $8.00
            { name: 'Granola Bar', price: 600, type: 'item', desc: 'Hunger +15, Energy +15' },        // $6.00
            { name: 'Dried Fruit', price: 500, type: 'item', desc: 'Hunger +15' },                    // $5.00
            // Ammo
            { name: '9mm Rounds (24)', price: 1500, type: 'item' },                                   // $15.00
            { name: '12 Gauge Shells (12)', price: 2000, type: 'item' },                              // $20.00
            { name: '.308 Rounds (10)', price: 2500, type: 'item' },                                  // $25.00
            // Weapons (realistic prices in cents)
            { name: 'Remington 870', desc: 'Dmg: 52, Range: 1-5 sq', price: 45000, type: 'weapon', weapon: 'Remington 870' },      // $450
            { name: 'Remington 700', desc: 'Dmg: 55, Range: 3-20 sq', price: 80000, type: 'weapon', weapon: 'Remington 700' },    // $800
            { name: 'Colt M1911', desc: 'Dmg: 30, Range: 1-8 sq', price: 55000, type: 'weapon', weapon: 'Colt M1911' },            // $550
            { name: 'Sledgehammer', desc: 'Dmg: 45, Melee', price: 4000, type: 'weapon', weapon: 'Sledgehammer' },                 // $40
            { name: 'AR-15', desc: 'Dmg: 32, Range: 2-15 sq', price: 85000, type: 'weapon', weapon: 'AR-15' },                     // $850
            { name: 'Compound Bow', desc: 'Dmg: 32, Range: 2-15 sq, Silent', price: 35000, type: 'weapon', weapon: 'Compound Bow' }, // $350
            // Armor/Materials
            { name: 'Leather Vest', price: 12000, type: 'item' },                                     // $120
            { name: 'Metal Plate', price: 8000, type: 'item' }                                        // $80
        ];
        
        function openTradingPost() {
            document.getElementById('exploration-narrative').style.display = 'none';
            document.getElementById('exploration-choices').style.display = 'none';
            document.getElementById('trading-post').style.display = 'block';

            // Generate shop stock only once per visit
            if (!gameState.currentShop) {
                generateShopStock();
            }

            updateShopDisplay();
            switchShopTab('buy');

            // Tutorial: first shop visit
            showTutorialTip('first_shop', 1000);
        }
        
        // Tier-specific shop items (prices in CENTS)
        var tierShopItems = {
            // Tier 3+ items (Danger Zone)
            tier3: [
                { name: 'Camping Set', price: 15000, type: 'item', desc: 'Set up camp in the field' },    // $150
                { name: 'Portable Stove', price: 6000, type: 'item', desc: 'Cook food at camp' },         // $60
                { name: 'Sleeping Bag', price: 4500, type: 'item', desc: 'Better rest at camp' },         // $45
                { name: 'AK-47', desc: 'Dmg: 35, Range: 2-14 sq', price: 75000, type: 'weapon', weapon: 'AK-47' },  // $750
                { name: 'Tactical Vest', price: 18000, type: 'item' }                                      // $180
            ],
            // Tier 4+ items (Deep Wastes)
            tier4: [
                { name: 'Water Purifier', price: 8000, type: 'item', desc: 'Purify stream water' },       // $80
                { name: 'Remington 700', desc: 'Dmg: 55, Range: 3-20 sq', price: 80000, type: 'weapon', weapon: 'Remington 700' }, // $800
                { name: '5.56mm Rounds (30)', price: 3500, type: 'item' },                                 // $35
                { name: 'Sensor Module', price: 5000, type: 'item' }                                       // $50
            ],
            // Tier 5 items (The Abyss) - rare and powerful
            tier5: [
                { name: 'Gold Watch', price: 25000, type: 'item', desc: 'Valuable trade good' },          // $250
                { name: 'Circuitry', price: 4000, type: 'item', desc: 'High-tech component' }             // $40
            ]
        };

        function generateShopStock() {
            var tier = getDistanceTier();

            // Build available items based on tier
            var availableItems = shopStockTemplates.slice();

            // Add tier-specific items
            if (tier.tier >= 3) {
                availableItems = availableItems.concat(tierShopItems.tier3);
            }
            if (tier.tier >= 4) {
                availableItems = availableItems.concat(tierShopItems.tier4);
            }
            if (tier.tier >= 5) {
                availableItems = availableItems.concat(tierShopItems.tier5);
            }

            // Randomly select 6-10 items (more at higher tiers)
            var shuffled = availableItems.slice().sort(function() { return Math.random() - 0.5; });
            var stockSize = Math.floor(Math.random() * 3) + 6 + Math.floor(tier.tier / 2);

            gameState.currentShop = {
                tier: tier, // Store the tier for display
                stock: shuffled.slice(0, stockSize).map(function(template, i) {
                    return {
                        id: i,
                        name: template.name,
                        price: template.price,
                        type: template.type,
                        weapon: template.weapon,
                        desc: template.desc || (ITEMS[template.name] ? ITEMS[template.name].desc : ''),
                        sold: false // Track if item has been sold
                    };
                }),
                money: Math.floor(Math.random() * 10000) + 10000 // Shop has $100-$200 to buy your stuff
            };
        }
        
        function updateShopDisplay() {
            document.getElementById('shop-money').textContent = formatMoney(gameState.player.money);
            document.getElementById('shop-weight').textContent = gameState.player.carryWeight.toFixed(1);
            document.getElementById('shop-max-weight').textContent = gameState.player.maxCarryWeight;
        }
        
        function switchShopTab(tab) {
            document.getElementById('tab-buy').classList.toggle('active', tab === 'buy');
            document.getElementById('tab-sell').classList.toggle('active', tab === 'sell');
            document.getElementById('tab-invest').classList.toggle('active', tab === 'invest');
            document.getElementById('shop-buy-section').classList.toggle('active', tab === 'buy');
            document.getElementById('shop-sell-section').classList.toggle('active', tab === 'sell');
            document.getElementById('shop-invest-section').classList.toggle('active', tab === 'invest');
            
            if (tab === 'buy') {
                renderShopBuyItems();
            } else if (tab === 'sell') {
                renderShopSellItems();
            } else if (tab === 'invest') {
                renderInvestOptions();
            }
        }
        
        function renderShopBuyItems() {
            var html = '';
            var hasItems = false;

            // Apply trading post discount from base
            var shopDiscount = baseState.totalBenefits.shopDiscount || 0;

            gameState.currentShop.stock.forEach(function(item, i) {
                if (item.sold) return; // Skip sold items
                hasItems = true;

                // Calculate discounted price
                var originalPrice = item.price;
                var discountedPrice = shopDiscount > 0 ? Math.floor(originalPrice * (1 - shopDiscount / 100)) : originalPrice;

                var canAfford = gameState.player.money >= discountedPrice;
                var itemData = ITEMS[item.name];
                var weight = itemData ? itemData.weight : 5;
                var canCarry = (gameState.player.carryWeight + weight) <= gameState.player.maxCarryWeight;

                html += '<div class="shop-item">';
                html += '<div class="item-info">';
                html += '<span class="item-name">' + item.name + '</span>';

                // Build description with ammo type for weapons
                var descParts = [];
                if (item.desc) descParts.push(item.desc);

                // Add ammo type for weapons
                if (item.type === 'weapon' && item.weapon) {
                    var weaponData = WEAPONS[item.weapon];
                    if (weaponData && weaponData.ammoType) {
                        descParts.push('Ammo: ' + weaponData.ammoType);
                    } else if (weaponData && !weaponData.ammoType) {
                        descParts.push('No ammo needed');
                    }
                }

                descParts.push(weight + ' lb');
                html += '<span class="item-desc">' + descParts.join(' | ') + '</span>';
                html += '</div>';
                if (shopDiscount > 0) {
                    html += '<span class="item-price"><s style="color:#888;">' + formatMoney(originalPrice) + '</s> <span style="color:#0f0;">' + formatMoney(discountedPrice) + '</span> 💵</span>';
                } else {
                    html += '<span class="item-price">' + formatMoney(originalPrice) + ' 💵</span>';
                }

                var disabled = !canAfford || !canCarry;
                var btnText = !canAfford ? 'NO CASH' : (!canCarry ? 'TOO HEAVY' : 'BUY');
                html += '<button class="btn support small" onclick="initiatePurchase(' + i + ')" ' +
                        (disabled ? 'disabled' : '') + '>' + btnText + '</button>';
                html += '</div>';
            });

            if (!hasItems) {
                html = '<div class="empty-inventory">Shop is sold out!</div>';
            }

            // Show discount notification if applicable
            if (shopDiscount > 0) {
                html = '<div style="background: rgba(0,255,0,0.1); border: 1px solid #0f0; padding: 8px; margin-bottom: 10px; border-radius: 5px; text-align: center; font-size: 0.9em;">' +
                       '🏪 Trading Post Bonus: <span style="color:#0f0;">-' + shopDiscount + '% on all purchases!</span></div>' + html;
            }

            document.getElementById('shop-items').innerHTML = html;
        }
        
        function renderShopSellItems() {
            var html = '';

            // Apply trading post sell bonus from base
            var shopDiscount = baseState.totalBenefits.shopDiscount || 0;
            var sellMultiplier = shopDiscount > 0 ? (1 + shopDiscount / 100) : 1;

            // Show sell bonus notification if applicable
            if (shopDiscount > 0) {
                html += '<div style="background: rgba(0,255,0,0.1); border: 1px solid #0f0; padding: 8px; margin-bottom: 10px; border-radius: 5px; text-align: center; font-size: 0.9em;">' +
                       '🏪 Trading Post Bonus: <span style="color:#0f0;">+' + shopDiscount + '% on all sales!</span></div>';
            }

            if (gameState.player.inventory.length === 0 && gameState.player.medkits === 0) {
                html += '<div class="empty-inventory">You have nothing to sell</div>';
            } else {
                // Group items by name
                var itemCounts = {};
                gameState.player.inventory.forEach(function(name, idx) {
                    if (!itemCounts[name]) {
                        itemCounts[name] = { count: 0, indices: [] };
                    }
                    itemCounts[name].count++;
                    itemCounts[name].indices.push(idx);
                });

                for (var itemName in itemCounts) {
                    var itemData = ITEMS[itemName];
                    var basePrice = itemData ? Math.floor(itemData.value * 0.6) : 500; // 60% of value
                    var sellPrice = Math.floor(basePrice * sellMultiplier); // Apply trading post bonus
                    var count = itemCounts[itemName].count;
                    var canShopAfford = gameState.currentShop.money >= sellPrice;

                    html += '<div class="shop-item">';
                    html += '<div class="item-info">';
                    html += '<span class="item-name">' + itemName + (count > 1 ? ' (×' + count + ')' : '') + '</span>';
                    html += '<span class="item-desc">' + (itemData ? itemData.desc : '') + '</span>';
                    html += '</div>';
                    if (shopDiscount > 0 && sellPrice > basePrice) {
                        html += '<span class="item-price" style="color: #4f4;">+<span style="color:#0f0;">' + formatMoney(sellPrice) + '</span> <s style="color:#888;">' + formatMoney(basePrice) + '</s> 💵</span>';
                    } else {
                        html += '<span class="item-price" style="color: #4f4;">+' + formatMoney(sellPrice) + ' 💵</span>';
                    }
                    html += '<button class="btn small" style="background: #4a4;" onclick="initiateSale(\'' + itemName + '\', ' + sellPrice + ')" ' +
                            (canShopAfford ? '' : 'disabled') + '>' + (canShopAfford ? 'SELL' : 'NO CASH') + '</button>';
                    html += '</div>';
                }

                // Also allow selling medkits
                if (gameState.player.medkits > 0) {
                    var baseStimpakPrice = 1500; // $15.00
                    var stimpakPrice = Math.floor(baseStimpakPrice * sellMultiplier);
                    html += '<div class="shop-item">';
                    html += '<div class="item-info">';
                    html += '<span class="item-name">Med Kit (×' + gameState.player.medkits + ')</span>';
                    html += '<span class="item-desc">Your healing supplies</span>';
                    html += '</div>';
                    if (shopDiscount > 0 && stimpakPrice > baseStimpakPrice) {
                        html += '<span class="item-price" style="color: #4f4;">+<span style="color:#0f0;">' + formatMoney(stimpakPrice) + '</span> <s style="color:#888;">' + formatMoney(baseStimpakPrice) + '</s> 💵</span>';
                    } else {
                        html += '<span class="item-price" style="color: #4f4;">+' + formatMoney(stimpakPrice) + ' 💵</span>';
                    }
                    html += '<button class="btn small" style="background: #4a4;" onclick="initiateSale(\'__stimpak__\', ' + stimpakPrice + ')">SELL</button>';
                    html += '</div>';
                }
            }

            html += '<div style="margin-top: 10px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 4px; font-size: 0.85em;">';
            html += 'Trader\'s cash: ' + formatMoney(gameState.currentShop.money) + ' 💵';
            html += '</div>';

            document.getElementById('sell-items').innerHTML = html;
        }
        
        // ============ INVESTMENT SYSTEM ============
        // Compound interest calculations for middle/high school math
        
        function renderInvestOptions() {
            var grade = getPlayerGradeLevel();
            var money = gameState.player.money;
            var html = '';

            // Investment options with different risk/reward (amounts in cents)
            var investments = [
                {
                    name: 'Safe Caravan Route',
                    minInvest: 2000, // $20.00
                    rate: 10, // 10% return
                    periods: 2,
                    risk: 'Low',
                    riskColor: '#4f4'
                },
                {
                    name: 'Scavenger Expedition',
                    minInvest: 4000, // $40.00
                    rate: 25, // 25% return
                    periods: 2,
                    risk: 'Medium',
                    riskColor: '#ff0'
                },
                {
                    name: 'Risky Salvage Operation',
                    minInvest: 6000, // $60.00
                    rate: 50, // 50% return
                    periods: 2,
                    risk: 'High',
                    riskColor: '#f44'
                }
            ];

            html += '<div style="margin-bottom: 15px; font-size: 0.9em; color: #aaa;">';
            html += 'Your cash: <strong style="color: #ffd700;">' + formatMoney(money) + ' 💵</strong>';
            html += '</div>';

            investments.forEach(function(inv, index) {
                var canAfford = money >= inv.minInvest;

                html += '<div class="shop-item" style="flex-direction: column; align-items: stretch;">';
                html += '<div style="display: flex; justify-content: space-between; align-items: center;">';
                html += '<div class="item-info">';
                html += '<span class="item-name">📈 ' + inv.name + '</span>';
                html += '<span class="item-desc">Min: ' + formatMoney(inv.minInvest) + ' | Return: ' + inv.rate + '% | Periods: ' + inv.periods + '</span>';
                html += '</div>';
                html += '<span style="color: ' + inv.riskColor + '; font-weight: bold;">' + inv.risk + ' Risk</span>';
                html += '</div>';

                // Formula preview for educational purposes
                if (grade === '9-12') {
                    html += '<div style="font-size: 0.75em; color: #888; margin-top: 5px;">';
                    html += 'Formula: A = P(1 + r)^t where r = ' + (inv.rate / 100) + ', t = ' + inv.periods;
                    html += '</div>';
                } else if (grade === '7-8') {
                    html += '<div style="font-size: 0.75em; color: #888; margin-top: 5px;">';
                    html += 'Compound: principal × (1 + rate)^periods';
                    html += '</div>';
                }

                html += '<button class="btn small support" style="margin-top: 8px;" onclick="initiateInvestment(' + index + ', ' + inv.minInvest + ', ' + inv.rate + ', ' + inv.periods + ')" ' +
                        (canAfford ? '' : 'disabled') + '>' + (canAfford ? 'INVEST ' + formatMoney(inv.minInvest) : 'NEED MORE CASH') + '</button>';
                html += '</div>';
            });

            // Add explanation based on grade level
            html += '<div style="margin-top: 15px; padding: 10px; background: rgba(0,100,200,0.1); border: 1px solid #48f; border-radius: 5px; font-size: 0.85em;">';
            if (grade === '9-12') {
                html += '<strong>📚 Compound Interest Formula:</strong><br>';
                html += 'A = P(1 + r)^t<br>';
                html += 'A = Final amount, P = Principal (initial), r = Rate (decimal), t = Time periods';
            } else if (grade === '7-8') {
                html += '<strong>📚 Compound Growth:</strong><br>';
                html += 'Each period, your investment grows by the rate percentage.<br>';
                html += 'Final = Initial × (1 + rate/100) × (1 + rate/100) ...';
            } else {
                html += '<strong>📚 Investment Returns:</strong><br>';
                html += 'Invest money now, get more back!<br>';
                html += 'Higher risk = higher potential reward.';
            }
            html += '</div>';

            document.getElementById('invest-options').innerHTML = html;
        }
        
        function initiateInvestment(index, principal, rate, periods) {
            var grade = getPlayerGradeLevel();
            var playerMoney = gameState.player.money;

            if (playerMoney < principal) {
                showPopup('Not enough cash!', 'error', 'FAILED');
                return;
            }
            
            // Calculate expected return using compound interest
            var rateDecimal = rate / 100;
            var multiplier = Math.pow(1 + rateDecimal, periods);
            var finalAmount = Math.round(principal * multiplier);
            var profit = finalAmount - principal;
            
            gameState.shopItem = {
                action: 'invest',
                principal: principal,
                rate: rate,
                periods: periods,
                finalAmount: finalAmount,
                profit: profit
            };
            
            if (grade === '9-12') {
                // High school: Full compound interest formula
                requireCalculation({
                    title: '📈 COMPOUND INTEREST',
                    description: '<strong>Investment Calculation</strong><br><br>' +
                        'Formula: A = P(1 + r)^t<br><br>' +
                        'P = ' + principal + ' dollars (principal)<br>' +
                        'r = ' + rate + '% = ' + rateDecimal + ' (rate)<br>' +
                        't = ' + periods + ' periods<br><br>' +
                        'A = ' + principal + ' × (1 + ' + rateDecimal + ')^' + periods + '<br>' +
                        'A = ' + principal + ' × ' + multiplier.toFixed(4),
                    formula: principal + ' × ' + multiplier.toFixed(2) + ' = ? (round)',
                    answer: finalAmount,
                    xpReward: 40,
                    context: 'shop',
                    onSuccess: function(amount) {
                        processInvestmentResult(principal, amount, true);
                    },
                    onFailure: function() {
                        processInvestmentResult(principal, finalAmount, false);
                    }
                });
            } else if (grade === '7-8') {
                // Middle school: Step by step multiplication
                var step1 = Math.round(principal * (1 + rateDecimal));
                requireCalculation({
                    title: '📈 COMPOUND GROWTH',
                    description: '<strong>Investment Calculation</strong><br><br>' +
                        'Initial: ' + principal + ' dollars<br>' +
                        'Growth rate: ' + rate + '% per period<br>' +
                        'Number of periods: ' + periods + '<br><br>' +
                        'After period 1: ' + principal + ' × 1.' + rate + ' = ' + step1 + '<br>' +
                        'After period 2: ' + step1 + ' × 1.' + rate + ' = ?',
                    formula: step1 + ' × 1.' + rate + ' = ?',
                    answer: finalAmount,
                    xpReward: 35,
                    context: 'shop',
                    onSuccess: function(amount) {
                        processInvestmentResult(principal, amount, true);
                    },
                    onFailure: function() {
                        processInvestmentResult(principal, finalAmount, false);
                    }
                });
            } else {
                // Lower grades: Simple percentage calculation
                requireCalculation({
                    title: '📈 INVESTMENT RETURN',
                    description: '<strong>Calculate Your Return!</strong><br><br>' +
                        'You invested: ' + principal + ' dollars<br>' +
                        'Profit earned: ' + profit + ' dollars<br><br>' +
                        'Total return = invested + profit',
                    formula: principal + ' + ' + profit + ' = ?',
                    answer: finalAmount,
                    xpReward: 20,
                    context: 'shop',
                    onSuccess: function(amount) {
                        processInvestmentResult(principal, amount, true);
                    },
                    onFailure: function() {
                        processInvestmentResult(principal, finalAmount, false);
                    }
                });
            }
        }
        
        function processInvestmentResult(principal, finalAmount, calculatedCorrectly) {
            var currentMoney = gameState.player.money;
            var profit = finalAmount - principal;
            
            if (calculatedCorrectly) {
                // Deduct principal, then add return
                requireCalculation({
                    title: '💰 INVESTMENT COMPLETE',
                    description: 'Investment successful!<br><br>' +
                        'You invested: ' + formatMoney(principal) + '<br>' +
                        'Return: ' + formatMoney(finalAmount) + '<br>' +
                        'Profit: +' + formatMoney(profit) + '<br><br>' +
                        'Your cash: ' + formatMoney(currentMoney),
                    formula: formatMoney(currentMoney) + ' - ' + formatMoney(principal) + ' + ' + formatMoney(finalAmount) + ' = ?',
                    answer: currentMoney - principal + finalAmount,
                    isMoney: true,
                    xpReward: 25,
                    context: 'shop',
                    onSuccess: function(newMoney) {
                        gameState.player.money = newMoney;
                        updateShopDisplay();
                        showPopup(
                            '<strong>📈 INVESTMENT SUCCESS!</strong><br><br>' +
                            'Profit: +' + formatMoney(profit) + '<br>' +
                            'New total: ' + formatMoney(newMoney),
                            'success',
                            'PROFIT!'
                        );
                        var origClose = closePopup;
                        closePopup = function() {
                            document.getElementById('popup-overlay').classList.remove('active');
                            closePopup = origClose;
                            awardXP(30, 'successful investment');
                            processPendingCalcs(function() {
                                renderInvestOptions();
                            });
                        };
                    },
                    onFailure: function() {
                        // Calculation error - lose some profit
                        var reducedProfit = Math.floor(profit / 2);
                        gameState.player.money = currentMoney - principal + principal + reducedProfit;
                        updateShopDisplay();
                        showPopup(
                            '<strong>📉 CALCULATION ERROR!</strong><br><br>' +
                            'Bad math cost you half the profit!<br>' +
                            'Profit: +' + formatMoney(reducedProfit) + ' (instead of ' + formatMoney(profit) + ')',
                            'error',
                            'REDUCED PROFIT'
                        );
                        var origClose = closePopup;
                        closePopup = function() {
                            document.getElementById('popup-overlay').classList.remove('active');
                            closePopup = origClose;
                            renderInvestOptions();
                        };
                    }
                });
            } else {
                // Wrong compound interest calculation - risky investment fails
                var loss = Math.floor(principal * 0.3);
                gameState.player.money = currentMoney - loss;
                updateShopDisplay();
                showPopup(
                    '<strong>📉 INVESTMENT FAILED!</strong><br><br>' +
                    'Your miscalculation scared off the traders!<br>' +
                    'Lost: ' + formatMoney(loss) + '<br>' +
                    'Remaining: ' + formatMoney(gameState.player.money),
                    'error',
                    'LOSS!'
                );
                var origClose = closePopup;
                closePopup = function() {
                    document.getElementById('popup-overlay').classList.remove('active');
                    closePopup = origClose;
                    renderInvestOptions();
                };
            }
        }
        
        function initiatePurchase(stockIndex) {
            var item = gameState.currentShop.stock[stockIndex];

            // Apply trading post discount from base
            var shopDiscount = baseState.totalBenefits.shopDiscount || 0;
            var discountedPrice = shopDiscount > 0 ? Math.floor(item.price * (1 - shopDiscount / 100)) : item.price;

            gameState.shopItem = { stockIndex: stockIndex, item: item, action: 'buy', discountedPrice: discountedPrice };

            var problem = generateShopMathProblem(discountedPrice, item.name, 'buy');

            document.getElementById('shop-buy-section').style.display = 'none';
            document.getElementById('shop-sell-section').style.display = 'none';
            document.getElementById('shop-invest-section').style.display = 'none';
            document.querySelector('.shop-tabs').style.display = 'none';
            document.getElementById('leave-shop-btn').style.display = 'none';
            document.getElementById('shop-math').style.display = 'block';
            document.getElementById('shop-problem').innerHTML = problem.question;
            document.getElementById('shop-answer').value = '';
            document.getElementById('shop-answer').focus();

            gameState.currentProblem = {
                answer: problem.answer,
                action: 'buy',
                xpReward: problem.xpReward,
                item: item,
                stockIndex: stockIndex,
                discountedPrice: discountedPrice,
                isMoney: problem.isMoney
            };
        }
        
        function initiateSale(itemName, price) {
            gameState.shopItem = { itemName: itemName, price: price, action: 'sell' };
            
            var problem = generateShopMathProblem(price, itemName, 'sell');
            
            document.getElementById('shop-buy-section').style.display = 'none';
            document.getElementById('shop-sell-section').style.display = 'none';
            document.getElementById('shop-invest-section').style.display = 'none';
            document.querySelector('.shop-tabs').style.display = 'none';
            document.getElementById('leave-shop-btn').style.display = 'none';
            document.getElementById('shop-math').style.display = 'block';
            document.getElementById('shop-problem').innerHTML = problem.question;
            document.getElementById('shop-answer').value = '';
            document.getElementById('shop-answer').focus();
            
            gameState.currentProblem = {
                answer: problem.answer,
                action: 'sell',
                xpReward: problem.xpReward,
                itemName: itemName,
                price: price,
                isMoney: problem.isMoney
            };
        }

        function generateShopMathProblem(price, itemName, action) {
            var playerMoney = gameState.player.money;
            var question, answer, xpReward;
            var isMoney = false;

            // Advanced level math problems
            if (action === 'buy') {
                var problemType = Math.floor(Math.random() * 3);

                if (problemType === 0) {
                    // Calculate remaining after purchase
                    answer = playerMoney - price;
                    question = '<strong>💰 PURCHASE: ' + itemName + '</strong><br><br>';
                    question += 'Your cash: ' + formatMoney(playerMoney) + '<br>';
                    question += 'Price: ' + formatMoney(price) + '<br><br>';
                    question += '<strong>Cash remaining after purchase?</strong><br>' + formatMoney(playerMoney) + ' - ' + formatMoney(price) + ' = ?';
                    isMoney = true;
                } else if (problemType === 1) {
                    // Percentage calculation (answer is a whole number percentage, not money)
                    var percent = Math.round((price / playerMoney) * 100);
                    answer = percent;
                    question = '<strong>💰 PURCHASE: ' + itemName + '</strong><br><br>';
                    question += 'Price: ' + formatMoney(price) + '<br>';
                    question += 'Your total: ' + formatMoney(playerMoney) + '<br><br>';
                    question += '<strong>What % of your cash is this?</strong><br>Round to nearest whole number';
                } else {
                    // With tax
                    var tax = Math.floor(price * 0.1);
                    answer = price + tax;
                    question = '<strong>💰 PURCHASE: ' + itemName + '</strong><br><br>';
                    question += 'Price: ' + formatMoney(price) + '<br>';
                    question += 'Wasteland tax (10%): ' + formatMoney(tax) + '<br><br>';
                    question += '<strong>Total cost?</strong><br>' + formatMoney(price) + ' + ' + formatMoney(tax) + ' = ?';
                    isMoney = true;
                }
                xpReward = 25;
            } else {
                // Selling
                var problemType = Math.floor(Math.random() * 3);

                if (problemType === 0) {
                    // Calculate new total
                    answer = playerMoney + price;
                    question = '<strong>💰 SELL: ' + itemName + '</strong><br><br>';
                    question += 'Your cash: ' + formatMoney(playerMoney) + '<br>';
                    question += 'Sale price: +' + formatMoney(price) + '<br><br>';
                    question += '<strong>Cash after sale?</strong><br>' + formatMoney(playerMoney) + ' + ' + formatMoney(price) + ' = ?';
                    // This problem expects answer in dollars
                    isMoney = true;
                } else if (problemType === 1) {
                    // Calculate profit margin (convert to dollars for display)
                    var originalValue = Math.floor(price / 0.6);
                    var loss = originalValue - price;
                    answer = loss;
                    question = '<strong>💰 SELL: ' + itemName + '</strong><br><br>';
                    question += 'Item value: ' + formatMoney(originalValue) + '<br>';
                    question += 'Trader offers: ' + formatMoney(price) + ' (60%)<br><br>';
                    question += '<strong>How much less than full value?</strong><br>' + formatMoney(originalValue) + ' - ' + formatMoney(price) + ' = ?';
                    // This problem expects answer in dollars
                    isMoney = true;
                } else {
                    // Multiple items calculation (convert to dollars for display)
                    var qty = Math.floor(Math.random() * 3) + 2;
                    answer = price * qty;
                    question = '<strong>💰 BULK SALE</strong><br><br>';
                    question += 'Selling ' + qty + ' ' + itemName + '<br>';
                    question += 'Each worth: ' + formatMoney(price) + '<br><br>';
                    question += '<strong>Total earnings?</strong><br>' + qty + ' × ' + formatMoney(price) + ' = ?';
                    // This problem expects answer in dollars
                    isMoney = true;
                }
                xpReward = 25;
            }

            return { question: question, answer: answer, xpReward: xpReward, isMoney: isMoney };
        }
        
        function submitShopAnswer() {
            var userAnswer = parseFloat(document.getElementById('shop-answer').value);
            if (isNaN(userAnswer)) {
                showExplorationMessage('Enter a number!', 'error');
                return;
            }

            // For money problems, convert user's dollar answer to cents for comparison
            var expectedAnswer = gameState.currentProblem.answer;
            if (gameState.currentProblem.isMoney) {
                expectedAnswer = gameState.currentProblem.answer / 100; // Convert cents to dollars
            }

            var correct = Math.abs(userAnswer - expectedAnswer) < 0.1; // Allow small rounding
            var action = gameState.currentProblem.action;
            
            recordMathResult(correct);
            
            if (correct) {
                var xpText = awardXP(gameState.currentProblem.xpReward, 'shop math');
                
                if (action === 'buy') {
                    var item = gameState.currentProblem.item;
                    var stockIndex = gameState.currentProblem.stockIndex;
                    var currentMoney = gameState.player.money;
                    var price = item.price;
                    
                    // Require money subtraction calculation
                    requireCalculation({
                        title: '💵 CASH PAYMENT',
                        description: 'Purchasing ' + item.name + '!<br><br>Your cash: ' + formatMoney(currentMoney) + '<br>Price: ' + formatMoney(price),
                        formula: formatMoney(currentMoney) + ' - ' + formatMoney(price),
                        answer: currentMoney - price,
                        isMoney: true,
                        xpReward: 0,
                        context: 'shop',
                        onSuccess: function(remainingMoney) {
                            // Mark item as sold in shop
                            gameState.currentShop.stock[stockIndex].sold = true;
                            gameState.player.money = remainingMoney;

                            // Add to player inventory or apply effect
                            if (item.type === 'weapon') {
                                // Use weapon choice system for purchased weapons
                                showWeaponChoice(item.weapon, 100, function() {
                                    processPendingCalcs(function() {
                                        updateInventoryDisplay();
                                        returnToShop();
                                    });
                                });
                                return; // Exit early, weapon choice handles the rest
                            } else if (ITEMS[item.name]) {
                                addToInventory(item.name);
                            } else if (item.name === 'Med Kit') {
                                gameState.player.medkits++;
                            }

                            showPopup(
                                '<strong>✓ PURCHASED!</strong><br><br>' +
                                'Acquired: ' + item.name + '<br>' +
                                'Paid: ' + formatMoney(price) + '<br>' +
                                'Remaining: ' + formatMoney(remainingMoney),
                                'success',
                                'PURCHASE COMPLETE'
                            );

                            var origClose = closePopup;
                            closePopup = function() {
                                document.getElementById('popup-overlay').classList.remove('active');
                                closePopup = origClose;
                                processPendingCalcs(function() {
                                    updateInventoryDisplay();
                                    returnToShop();
                                });
                            };
                        },
                        onFailure: function() {
                            // Fumbled payment - pay extra!
                            var extraCost = Math.floor(price * 0.2);
                            var totalPaid = price + extraCost;
                            gameState.currentShop.stock[stockIndex].sold = true;
                            gameState.player.money = Math.max(0, currentMoney - totalPaid);

                            // Still get the item
                            if (item.type === 'weapon') {
                                // Use weapon choice system for purchased weapons
                                showPopup(
                                    '<strong>⚠️ OVERPAID!</strong><br><br>' +
                                    'Miscounted your cash!<br>' +
                                    'Paid: ' + formatMoney(totalPaid) + ' (extra ' + formatMoney(extraCost) + ')<br>' +
                                    'Remaining: ' + formatMoney(gameState.player.money),
                                    'error',
                                    'PURCHASE COMPLETE'
                                );
                                var oc = closePopup;
                                closePopup = function() {
                                    document.getElementById('popup-overlay').classList.remove('active');
                                    closePopup = oc;
                                    showWeaponChoice(item.weapon, 100, function() {
                                        processPendingCalcs(function() {
                                            updateInventoryDisplay();
                                            returnToShop();
                                        });
                                    });
                                };
                                return; // Exit early, weapon choice handles the rest
                            } else if (ITEMS[item.name]) {
                                addToInventory(item.name);
                            } else if (item.name === 'Med Kit') {
                                gameState.player.medkits++;
                            }

                            showPopup(
                                '<strong>⚠️ OVERPAID!</strong><br><br>' +
                                'Miscounted your cash!<br>' +
                                'Paid: ' + formatMoney(totalPaid) + ' (extra ' + formatMoney(extraCost) + ')<br>' +
                                'Remaining: ' + formatMoney(gameState.player.money),
                                'error',
                                'PURCHASE COMPLETE'
                            );

                            var origClose = closePopup;
                            closePopup = function() {
                                document.getElementById('popup-overlay').classList.remove('active');
                                closePopup = origClose;
                                processPendingCalcs(function() {
                                    updateInventoryDisplay();
                                    returnToShop();
                                });
                            };
                        }
                    });
                    return;
                } else {
                    // Selling
                    var itemName = gameState.currentProblem.itemName;
                    var price = gameState.currentProblem.price;
                    var currentMoney = gameState.player.money;
                    
                    // Require money addition calculation
                    requireCalculation({
                        title: '💵 CASH RECEIVED',
                        description: 'Selling ' + (itemName === '__stimpak__' ? 'Med Kit' : itemName) + '!<br><br>Your cash: ' + formatMoney(currentMoney) + '<br>Sale price: +' + formatMoney(price),
                        formula: formatMoney(currentMoney) + ' + ' + formatMoney(price),
                        answer: currentMoney + price,
                        isMoney: true,
                        xpReward: 0,
                        context: 'shop',
                        onSuccess: function(newTotal) {
                            // Remove from player, add money
                            if (itemName === '__stimpak__') {
                                gameState.player.medkits--;
                            } else {
                                removeFromInventory(itemName);
                            }
                            gameState.player.money = newTotal;
                            gameState.currentShop.money -= price;
                            
                            showPopup(
                                '<strong>✓ SOLD!</strong><br><br>' +
                                'Sold: ' + (itemName === '__stimpak__' ? 'Med Kit' : itemName) + '<br>' +
                                'Earned: +' + formatMoney(price) + '<br>' +
                                'Total cash: ' + formatMoney(newTotal),
                                'success',
                                'SALE COMPLETE'
                            );
                            
                            var origClose = closePopup;
                            closePopup = function() {
                                document.getElementById('popup-overlay').classList.remove('active');
                                closePopup = origClose;
                                processPendingCalcs(function() {
                                    updateInventoryDisplay();
                                    returnToShop();
                                });
                            };
                        },
                        onFailure: function() {
                            // Fumbled sale - get less money
                            var lostMoney = Math.floor(price * 0.3);
                            var actualPrice = price - lostMoney;
                            
                            if (itemName === '__stimpak__') {
                                gameState.player.medkits--;
                            } else {
                                removeFromInventory(itemName);
                            }
                            gameState.player.money = currentMoney + actualPrice;
                            gameState.currentShop.money -= actualPrice;
                            
                            showPopup(
                                '<strong>⚠️ SHORT-CHANGED!</strong><br><br>' +
                                'Miscounted! Trader gave you less.<br>' +
                                'Expected: ' + formatMoney(price) + '<br>' +
                                'Received: ' + formatMoney(actualPrice) + '<br>' +
                                'Total: ' + formatMoney(gameState.player.money),
                                'error',
                                'SALE COMPLETE'
                            );
                            
                            var origClose = closePopup;
                            closePopup = function() {
                                document.getElementById('popup-overlay').classList.remove('active');
                                closePopup = origClose;
                                processPendingCalcs(function() {
                                    updateInventoryDisplay();
                                    returnToShop();
                                });
                            };
                        }
                    });
                    return;
                }
                
                updateInventoryDisplay();
            } else {
                var correctDisplay = gameState.currentProblem.isMoney
                    ? formatMoney(gameState.currentProblem.answer)
                    : gameState.currentProblem.answer;
                showPopup(
                    '<strong>✗ WRONG CALCULATION!</strong><br><br>' +
                    'Your answer: ' + userAnswer + '<br>' +
                    'Correct: ' + correctDisplay + '<br><br>' +
                    'The trader looks confused. Transaction cancelled.',
                    'error',
                    'TRANSACTION FAILED'
                );
            }
            
            // Return to shop
            returnToShop();
        }
        
        function cancelShopPurchase() {
            returnToShop();
        }
        
        function returnToShop() {
            document.getElementById('shop-math').style.display = 'none';
            document.querySelector('.shop-tabs').style.display = 'flex';
            document.getElementById('leave-shop-btn').style.display = 'block';

            // Clear inline display styles so CSS classes work properly
            document.getElementById('shop-buy-section').style.display = '';
            document.getElementById('shop-sell-section').style.display = '';
            document.getElementById('shop-invest-section').style.display = '';

            // Return to whichever tab was active
            if (document.getElementById('tab-sell').classList.contains('active')) {
                switchShopTab('sell');
            } else if (document.getElementById('tab-invest').classList.contains('active')) {
                switchShopTab('invest');
            } else {
                switchShopTab('buy');
            }

            updateShopDisplay();
        }
        
        function leaveShop() {
            document.getElementById('trading-post').style.display = 'none';
            document.getElementById('exploration-narrative').style.display = 'block';
            document.getElementById('exploration-choices').style.display = 'block';

            // Clear shop stock when leaving - next shop will have new stock
            gameState.currentShop = null;

            autoSave(); // Save after leaving shop
            nextExplorationEvent();
        }
        
        // ============ CRAFTING SYSTEM ============
        
        var craftingRecipes = [
            {
                name: 'Med Kit',
                inventoryIngredients: { 'Chemicals': 3, 'Cloth': 1 },
                result: { type: 'medkit', amount: 1 },
                desc: 'Heals 40% HP'
            },
            {
                name: 'Weapon Repair Kit',
                inventoryIngredients: { 'Scrap Metal': 4, 'Electronics': 1 },
                result: { type: 'money', amount: 30 },
                desc: 'Trade value: $30'
            },
            {
                name: 'Armor Patch',
                inventoryIngredients: { 'Scrap Metal': 2, 'Cloth': 3 },
                result: { type: 'hp', amount: 10 },
                desc: '+10 Max HP permanently'
            },
            {
                name: 'Signal Jammer',
                inventoryIngredients: { 'Electronics': 4, 'Chemicals': 2 },
                result: { type: 'weapon', weapon: 'Crossbow' },
                desc: 'Grants Crossbow'
            },
            {
                name: 'Field Surgery Kit (x2 Med Kits)',
                inventoryIngredients: { 'Chemicals': 5, 'Cloth': 2 },
                result: { type: 'medkit', amount: 2 },
                desc: 'More efficient healing'
            },
            {
                name: 'Tan Hide → Leather',
                inventoryIngredients: { 'Animal Hide': 2 },
                result: { type: 'item', item: 'Leather', amount: 1 },
                desc: 'Convert 2 hides into 1 leather'
            },
            {
                name: 'Leather Armor Patch',
                inventoryIngredients: { 'Leather': 2, 'Scrap Metal': 1 },
                result: { type: 'hp', amount: 15 },
                desc: '+15 Max HP permanently'
            },
            {
                name: 'Leather Satchel',
                inventoryIngredients: { 'Leather': 3, 'Cloth': 2 },
                result: { type: 'carryWeight', amount: 10 },
                desc: '+10 Carry Weight permanently'
            }
        ];
        
        function openCraftingBench() {
            document.getElementById('exploration-narrative').style.display = 'none';
            document.getElementById('exploration-choices').style.display = 'none';
            document.getElementById('crafting-bench').style.display = 'block';

            updateMaterialsDisplay();
            renderRecipes();

            // Tutorial: first crafting
            showTutorialTip('first_crafting', 1000);
        }
        
        function updateMaterialsDisplay() {
            // Display inventory-based materials - only show those we have
            var materials = [
                { name: 'Scrap Metal', label: 'Metal' },
                { name: 'Chemicals', label: 'Chem' },
                { name: 'Electronics', label: 'Elec' },
                { name: 'Cloth', label: 'Cloth' },
                { name: 'Animal Hide', label: 'Hide' },
                { name: 'Leather', label: 'Leather' }
            ];
            var parts = [];
            for (var i = 0; i < materials.length; i++) {
                var count = countInventoryItem(materials[i].name);
                if (count > 0) {
                    parts.push(materials[i].label + ': ' + count);
                }
            }
            var listEl = document.getElementById('materials-list');
            if (listEl) {
                listEl.textContent = parts.length > 0 ? parts.join(' | ') : 'None';
            }
        }

        function countInventoryItem(itemName) {
            var count = 0;
            for (var i = 0; i < gameState.player.inventory.length; i++) {
                if (gameState.player.inventory[i] === itemName) count++;
            }
            return count;
        }

        function addMaterial(materialName, amount) {
            // Add materials to inventory
            for (var i = 0; i < amount; i++) {
                addToInventory(materialName);
            }
        }

        function renderRecipes() {
            var html = '';
            craftingRecipes.forEach(function(recipe, index) {
                var canCraft = true;
                var ingredientList = '';

                // Check inventory item ingredients (all materials are now inventory items)
                if (recipe.inventoryIngredients) {
                    for (var item in recipe.inventoryIngredients) {
                        var needed = recipe.inventoryIngredients[item];
                        var have = countInventoryItem(item);
                        ingredientList += item + ': ' + needed + ' (have ' + have + ')<br>';
                        if (have < needed) canCraft = false;
                    }
                }

                html += '<div class="recipe-card">';
                html += '<div class="recipe-name">🔧 ' + recipe.name + '</div>';
                html += '<div class="recipe-ingredients">' + ingredientList + '</div>';
                html += '<div class="recipe-result">→ ' + recipe.desc + '</div>';
                html += '<button class="btn support" onclick="initiateCraft(' + index + ')" ' +
                        (canCraft ? '' : 'disabled') + ' style="margin-top: 10px;">CRAFT</button>';
                html += '</div>';
            });

            document.getElementById('recipe-list').innerHTML = html;
        }
        
        function initiateCraft(index) {
            var recipe = craftingRecipes[index];
            gameState.craftingState = { recipe: recipe, index: index };
            
            // Generate a math problem based on the recipe
            var problem = generateCraftingProblem(recipe);
            
            document.getElementById('recipe-list').style.display = 'none';
            document.getElementById('leave-craft-btn').style.display = 'none';
            document.getElementById('crafting-math').style.display = 'block';
            document.getElementById('craft-problem').innerHTML = problem.question;
            document.getElementById('craft-answer').value = '';
            document.getElementById('craft-answer').focus();
            
            gameState.currentProblem = {
                answer: problem.answer,
                action: 'craft',
                xpReward: 25,
                recipe: recipe
            };
        }
        
        function generateCraftingProblem(recipe) {
            var question, answer;

            // Gather all ingredients into a unified list
            var allIngredients = [];
            if (recipe.ingredients) {
                for (var mat in recipe.ingredients) {
                    var matName = {metal: 'Scrap Metal', chem: 'Chemicals', elec: 'Electronics', cloth: 'Cloth'}[mat];
                    allIngredients.push({ name: matName || mat, amount: recipe.ingredients[mat] });
                }
            }
            if (recipe.inventoryIngredients) {
                for (var item in recipe.inventoryIngredients) {
                    allIngredients.push({ name: item, amount: recipe.inventoryIngredients[item] });
                }
            }

            // Pick problem type based on what's available
            var types = ['scale', 'total'];
            if (allIngredients.length >= 2) types.push('ratio');
            if (allIngredients.length >= 1) types.push('fraction');
            var type = types[Math.floor(Math.random() * types.length)];

            if (type === 'ratio' && allIngredients.length >= 2) {
                // Find ratio between two ingredients
                var a = allIngredients[0].amount;
                var b = allIngredients[1].amount;
                var gcd = function(x, y) { return y === 0 ? x : gcd(y, x % y); };
                var g = gcd(a, b);
                answer = a / g;
                question = '<strong>🔧 CRAFTING: ' + recipe.name + '</strong><br><br>';
                question += 'Recipe requires ' + a + ' ' + allIngredients[0].name + ' and ' + b + ' ' + allIngredients[1].name + '.<br><br>';
                question += 'What is the simplified ratio?<br>';
                question += '<strong>' + a + ':' + b + ' = ?:' + (b/g) + '</strong>';
            } else if (type === 'scale') {
                // Scale recipe up
                var multiplier = Math.floor(Math.random() * 3) + 2;
                var ing = allIngredients[Math.floor(Math.random() * allIngredients.length)];
                var base = ing.amount;
                answer = base * multiplier;
                question = '<strong>🔧 CRAFTING: ' + recipe.name + '</strong><br><br>';
                question += 'Base recipe needs ' + base + ' ' + ing.name + '.<br>';
                question += 'To make ' + multiplier + ' batches, how much ' + ing.name + '?<br><br>';
                question += '<strong>' + base + ' × ' + multiplier + ' = ?</strong>';
            } else if (type === 'fraction') {
                // Calculate percentage
                var total = 0;
                for (var i = 0; i < allIngredients.length; i++) total += allIngredients[i].amount;
                var ing = allIngredients[0];
                answer = Math.round((ing.amount / total) * 100);
                question = '<strong>🔧 CRAFTING: ' + recipe.name + '</strong><br><br>';
                question += 'Total materials needed: ' + total + '<br>';
                question += ing.name + ' needed: ' + ing.amount + '<br><br>';
                question += 'What percentage is ' + ing.name + '?<br>';
                question += '<strong>(' + ing.amount + ' ÷ ' + total + ') × 100 = ?%</strong>';
            } else {
                // Calculate total materials (type === 'total')
                var total = 0;
                for (var i = 0; i < allIngredients.length; i++) total += allIngredients[i].amount;
                answer = total;
                question = '<strong>🔧 CRAFTING: ' + recipe.name + '</strong><br><br>';
                question += 'Materials needed:<br>';
                for (var i = 0; i < allIngredients.length; i++) {
                    question += '• ' + allIngredients[i].name + ': ' + allIngredients[i].amount + '<br>';
                }
                question += '<br><strong>Total materials = ?</strong>';
            }

            return { question: question, answer: answer };
        }
        
        function removeInventoryItems(itemName, count) {
            // Remove specified number of items from inventory
            var removed = 0;
            for (var i = gameState.player.inventory.length - 1; i >= 0 && removed < count; i--) {
                if (gameState.player.inventory[i] === itemName) {
                    gameState.player.inventory.splice(i, 1);
                    removed++;
                }
            }
            return removed;
        }

        function submitCraftAnswer() {
            var userAnswer = parseFloat(document.getElementById('craft-answer').value);
            if (isNaN(userAnswer)) {
                showExplorationMessage('Enter a number!', 'error');
                return;
            }

            var correct = Math.abs(userAnswer - gameState.currentProblem.answer) < 0.5;
            var recipe = gameState.currentProblem.recipe;

            recordMathResult(correct);

            if (correct) {
                // Store what we need to consume - all materials are now inventory items
                var inventoryToConsume = [];

                if (recipe.inventoryIngredients) {
                    for (var item in recipe.inventoryIngredients) {
                        var before = countInventoryItem(item);
                        var used = recipe.inventoryIngredients[item];
                        inventoryToConsume.push({ item: item, before: before, used: used, after: before - used });
                    }
                }

                // Use first ingredient for math challenge
                var firstIng = inventoryToConsume[0];
                var ingName = firstIng.item;
                var ingBefore = firstIng.before;
                var ingUsed = firstIng.used;
                var ingAfter = firstIng.after;

                requireCalculation({
                    title: '🔧 MATERIAL CONSUMPTION',
                    description: 'Crafting ' + recipe.name + '!<br><br>Current ' + ingName + ': ' + ingBefore + '<br>Used: ' + ingUsed,
                    formula: ingBefore + ' - ' + ingUsed,
                    answer: ingAfter,
                    xpReward: 0,
                    context: 'crafting',
                    onSuccess: function(remaining) {
                        // Consume all inventory items
                        for (var i = 0; i < inventoryToConsume.length; i++) {
                            var inv = inventoryToConsume[i];
                            removeInventoryItems(inv.item, inv.used);
                        }

                        // Now require calculation for the result
                        applyCraftingResult(recipe);
                    },
                    onFailure: function() {
                        // Consume inventory items plus waste extra on fumble
                        for (var i = 0; i < inventoryToConsume.length; i++) {
                            var inv = inventoryToConsume[i];
                            var extraLoss = Math.ceil(inv.used / 2);
                            removeInventoryItems(inv.item, inv.used + extraLoss);
                        }
                        showCombatMessage('<strong>⚠️ FUMBLED!</strong><br><br>Wasted extra materials!', 'error');

                        // Still apply result but continue
                        applyCraftingResult(recipe);
                    }
                });
                return;
            } else {
                showPopup(
                    '<strong>✗ CRAFTING FAILED!</strong><br><br>' +
                    'Your answer: ' + userAnswer + '<br>' +
                    'Correct: ' + gameState.currentProblem.answer + '<br><br>' +
                    'Materials wasted! The components fizzle.',
                    'error',
                    'CRAFTING FAILED'
                );

                // Lose half the inventory items on failure
                if (recipe.inventoryIngredients) {
                    for (var item in recipe.inventoryIngredients) {
                        var loss = Math.ceil(recipe.inventoryIngredients[item] / 2);
                        removeInventoryItems(item, loss);
                    }
                }
                updateMaterialsDisplay();
            }

            document.getElementById('crafting-math').style.display = 'none';
            document.getElementById('recipe-list').style.display = 'block';
            document.getElementById('leave-craft-btn').style.display = 'block';
            renderRecipes();
        }
        
        function cancelCraft() {
            document.getElementById('crafting-math').style.display = 'none';
            document.getElementById('recipe-list').style.display = 'block';
            document.getElementById('leave-craft-btn').style.display = 'block';
        }
        
        function applyCraftingResult(recipe) {
            // Apply crafting result with calculation
            if (recipe.result.type === 'medkit') {
                var currentStims = gameState.player.medkits;
                var amount = recipe.result.amount;
                requireCalculation({
                    title: '💉 CRAFTING RESULT',
                    description: 'Created ' + amount + ' Med Kit(s)!<br>Current medkits: ' + currentStims,
                    formula: currentStims + ' + ' + amount,
                    answer: currentStims + amount,
                    xpReward: 0,
                    context: 'crafting',
                    onSuccess: function(newTotal) {
                        gameState.player.medkits = newTotal;
                        finishCrafting(recipe);
                    },
                    onFailure: function() {
                        // Still give them the medkits
                        gameState.player.medkits += amount;
                        finishCrafting(recipe);
                    }
                });
            } else if (recipe.result.type === 'money') {
                var currentMoney = gameState.player.money;
                var amount = recipe.result.amount;
                requireCalculation({
                    title: '💰 CRAFTING RESULT',
                    description: 'Crafted item worth ' + amount + ' dollars!<br>Your cash: ' + currentMoney,
                    formula: currentMoney + ' + ' + amount,
                    answer: currentMoney + amount,
                    xpReward: 0,
                    context: 'crafting',
                    onSuccess: function(newTotal) {
                        gameState.player.money = newTotal;
                        finishCrafting(recipe);
                    },
                    onFailure: function() {
                        gameState.player.money += amount;
                        finishCrafting(recipe);
                    }
                });
            } else if (recipe.result.type === 'hp') {
                var currentMaxHp = gameState.player.maxHp;
                var amount = recipe.result.amount;
                requireCalculation({
                    title: '❤️ MAX HP INCREASE',
                    description: 'Armor upgrade grants +' + amount + ' Max HP!<br>Current Max HP: ' + currentMaxHp,
                    formula: currentMaxHp + ' + ' + amount,
                    answer: currentMaxHp + amount,
                    xpReward: 0,
                    context: 'crafting',
                    onSuccess: function(newMax) {
                        gameState.player.maxHp = newMax;
                        gameState.player.hp = newMax; // Full heal
                        finishCrafting(recipe);
                    },
                    onFailure: function() {
                        gameState.player.maxHp += amount;
                        gameState.player.hp += amount;
                        finishCrafting(recipe);
                    }
                });
            } else if (recipe.result.type === 'weapon') {
                // Use weapon choice system for crafted weapons
                var craftedRecipe = recipe; // Capture for closure
                showWeaponChoice(recipe.result.weapon, 100, function() {
                    finishCrafting(craftedRecipe);
                });
                return; // Exit early, weapon choice handles continuation
            } else if (recipe.result.type === 'item') {
                // Add item(s) to inventory
                var itemName = recipe.result.item;
                var amount = recipe.result.amount || 1;
                var currentCount = countInventoryItem(itemName);

                requireCalculation({
                    title: '📦 CRAFTING RESULT',
                    description: 'Created ' + amount + ' ' + itemName + '!<br>Current ' + itemName + ': ' + currentCount,
                    formula: currentCount + ' + ' + amount,
                    answer: currentCount + amount,
                    xpReward: 0,
                    context: 'crafting',
                    onSuccess: function(newTotal) {
                        for (var i = 0; i < amount; i++) {
                            addToInventory(itemName);
                        }
                        finishCrafting(recipe);
                    },
                    onFailure: function() {
                        for (var i = 0; i < amount; i++) {
                            addToInventory(itemName);
                        }
                        finishCrafting(recipe);
                    }
                });
            } else if (recipe.result.type === 'carryWeight') {
                // Increase carry weight
                var currentWeight = gameState.player.maxCarryWeight;
                var amount = recipe.result.amount;
                requireCalculation({
                    title: '🎒 CARRY WEIGHT INCREASE',
                    description: 'Satchel upgrade grants +' + amount + ' Carry Weight!<br>Current Max: ' + currentWeight + ' lbs',
                    formula: currentWeight + ' + ' + amount,
                    answer: currentWeight + amount,
                    xpReward: 0,
                    context: 'crafting',
                    onSuccess: function(newMax) {
                        gameState.player.maxCarryWeight = newMax;
                        finishCrafting(recipe);
                    },
                    onFailure: function() {
                        gameState.player.maxCarryWeight += amount;
                        finishCrafting(recipe);
                    }
                });
            } else {
                finishCrafting(recipe);
            }
        }
        
        function finishCrafting(recipe) {
            awardXP(gameState.currentProblem.xpReward, 'crafting ' + recipe.name);
            
            showPopup(
                '<strong>✓ CRAFTED!</strong><br><br>' +
                'Created: ' + recipe.name + '<br>' +
                recipe.desc,
                'success',
                'CRAFTING SUCCESS'
            );
            
            var origClose = closePopup;
            closePopup = function() {
                document.getElementById('popup-overlay').classList.remove('active');
                closePopup = origClose;
                processPendingCalcs(function() {
                    updateInventoryDisplay();
                    updateMaterialsDisplay();
                    document.getElementById('crafting-math').style.display = 'none';
                    document.getElementById('recipe-list').style.display = 'block';
                    document.getElementById('leave-craft-btn').style.display = 'block';
                    renderRecipes();
                });
            };
        }
        
        function leaveCrafting() {
            document.getElementById('crafting-bench').style.display = 'none';
            document.getElementById('exploration-narrative').style.display = 'block';
            document.getElementById('exploration-choices').style.display = 'block';
            nextExplorationEvent();
        }
        
        // ============ HACKING TERMINAL SYSTEM ============
        
        function startHacking(reward) {
            document.getElementById('exploration-narrative').style.display = 'none';
            document.getElementById('exploration-choices').style.display = 'none';
            document.getElementById('hacking-terminal').style.display = 'block';
            
            gameState.hackingState = {
                puzzlesSolved: 0,
                puzzlesNeeded: 3,
                attempts: 0,
                maxAttempts: 5,
                reward: reward || { type: 'money', amount: 50 }
            };
            
            updateHackProgress();
            generateHackPuzzle();
        }
        
        function updateHackProgress() {
            var html = '';
            for (var i = 0; i < gameState.hackingState.puzzlesNeeded; i++) {
                var cls = 'hack-pip';
                if (i < gameState.hackingState.puzzlesSolved) cls += ' complete';
                html += '<div class="' + cls + '"></div>';
            }
            document.getElementById('hack-progress').innerHTML = html;
        }
        
        function generateHackPuzzle() {
            var puzzleTypes = ['sequence', 'pattern', 'algebra', 'binary'];
            var type = puzzleTypes[Math.floor(Math.random() * puzzleTypes.length)];
            var question, answer;
            
            if (type === 'sequence') {
                // Arithmetic or geometric sequence
                var start = Math.floor(Math.random() * 10) + 1;
                var diff = Math.floor(Math.random() * 5) + 2;
                var isGeometric = Math.random() < 0.3;
                
                if (isGeometric && start <= 3) {
                    // Geometric: multiply
                    var mult = 2;
                    var seq = [start, start * mult, start * mult * mult];
                    answer = start * mult * mult * mult;
                    question = 'SEQUENCE DETECTED:<br>' + seq.join(' → ') + ' → ?';
                } else {
                    // Arithmetic: add
                    var seq = [start, start + diff, start + diff * 2, start + diff * 3];
                    answer = start + diff * 4;
                    question = 'SEQUENCE DETECTED:<br>' + seq.join(' → ') + ' → ?';
                }
            }
            
            if (type === 'pattern') {
                // Pattern with operation
                var a = Math.floor(Math.random() * 5) + 2;
                var b = Math.floor(Math.random() * 5) + 2;
                var c = Math.floor(Math.random() * 5) + 2;
                
                // a*b + c pattern
                var examples = [
                    [a, b, a * b + c],
                    [a + 1, b, (a + 1) * b + c],
                    [a + 2, b, (a + 2) * b + c]
                ];
                var testA = a + 3;
                answer = testA * b + c;
                
                question = 'PATTERN ANALYSIS:<br>';
                question += '(' + examples[0][0] + ', ' + examples[0][1] + ') = ' + examples[0][2] + '<br>';
                question += '(' + examples[1][0] + ', ' + examples[1][1] + ') = ' + examples[1][2] + '<br>';
                question += '(' + examples[2][0] + ', ' + examples[2][1] + ') = ' + examples[2][2] + '<br><br>';
                question += '(' + testA + ', ' + b + ') = ?';
            }
            
            if (type === 'algebra') {
                // Solve for x
                answer = Math.floor(Math.random() * 15) + 3;
                var coef = Math.floor(Math.random() * 5) + 2;
                var constant = Math.floor(Math.random() * 20) + 5;
                var result = coef * answer + constant;
                
                question = 'DECRYPT VARIABLE:<br><br>';
                question += coef + 'x + ' + constant + ' = ' + result + '<br><br>';
                question += 'x = ?';
            }
            
            if (type === 'binary') {
                // Simple binary or power of 2
                var powers = [1, 2, 4, 8, 16, 32, 64, 128];
                var idx = Math.floor(Math.random() * 6);
                answer = powers[idx + 1];
                
                question = 'BINARY SEQUENCE:<br>';
                question += powers.slice(0, idx + 1).join(', ') + ', ?<br><br>';
                question += 'Next power of 2 = ?';
            }
            
            document.getElementById('hack-prompt').innerHTML = 'ENCRYPTION LAYER ' + 
                (gameState.hackingState.puzzlesSolved + 1) + '/' + gameState.hackingState.puzzlesNeeded + 
                '<br>Attempts remaining: ' + (gameState.hackingState.maxAttempts - gameState.hackingState.attempts);
            document.getElementById('hack-sequence').innerHTML = question;
            document.getElementById('hack-answer').value = '';
            document.getElementById('hack-answer').focus();
            
            gameState.currentProblem = {
                answer: answer,
                action: 'hack',
                xpReward: 30,
                question: question // Store the original question for redisplay on failure
            };
        }
        
        function submitHackAnswer() {
            var userAnswer = parseFloat(document.getElementById('hack-answer').value);
            if (isNaN(userAnswer)) {
                return;
            }
            
            gameState.hackingState.attempts++;
            var correct = Math.abs(userAnswer - gameState.currentProblem.answer) < 0.1;
            
            recordMathResult(correct);
            
            if (correct) {
                gameState.hackingState.puzzlesSolved++;
                awardXP(gameState.currentProblem.xpReward, 'hacking layer ' + gameState.hackingState.puzzlesSolved);
                updateHackProgress();
                
                if (gameState.hackingState.puzzlesSolved >= gameState.hackingState.puzzlesNeeded) {
                    // Hacking complete - require calculation for reward!
                    var reward = gameState.hackingState.reward;
                    var currentValue = reward.type === 'money' ? gameState.player.money : gameState.player.medkits;
                    var rewardDisplay = reward.type === 'money' ? formatMoney(reward.amount) : reward.amount + ' medkits';
                    var currentDisplay = reward.type === 'money' ? formatMoney(currentValue) : currentValue;

                    showPopup(
                        '<strong>◈ SYSTEM BREACHED ◈</strong><br><br>' +
                        'ACCESS GRANTED<br><br>' +
                        'Reward: ' + rewardDisplay + '<br>' +
                        'Calculate to claim!',
                        'success',
                        'HACK COMPLETE'
                    );

                    var originalClose = closePopup;
                    closePopup = function() {
                        document.getElementById('popup-overlay').classList.remove('active');
                        closePopup = originalClose;

                        requireCalculation({
                            title: '💻 HACK REWARD',
                            description: 'Reward: +' + rewardDisplay + '<br>Current: ' + currentDisplay,
                            formula: currentDisplay + ' + ' + rewardDisplay,
                            answer: currentValue + reward.amount,
                            isMoney: reward.type === 'money',
                            context: 'exploration',
                            onSuccess: function(newTotal) {
                                if (reward.type === 'money') gameState.player.money = newTotal;
                                else gameState.player.medkits = newTotal;
                                
                                awardXP(60, 'hack complete bonus');
                                processPendingCalcs(function() {
                                    updateInventoryDisplay();
                                    exitHacking();
                                });
                            },
                            onFailure: function() {
                                // Get half reward
                                if (reward.type === 'money') gameState.player.money += Math.floor(reward.amount / 2);
                                else gameState.player.medkits += Math.floor(reward.amount / 2);
                                updateInventoryDisplay();
                                exitHacking();
                            }
                        });
                    };
                } else {
                    // Next puzzle - process XP calcs first
                    document.getElementById('hack-sequence').innerHTML = '<span style="color: #0f0;">✓ LAYER BREACHED</span><br><br>Processing...';
                    processPendingCalcs(function() {
                        setTimeout(generateHackPuzzle, 500);
                    });
                }
            } else {
                if (gameState.hackingState.attempts >= gameState.hackingState.maxAttempts) {
                    // Locked out
                    showPopup(
                        '<strong>⚠ LOCKOUT ⚠</strong><br><br>' +
                        'Too many failed attempts!<br>' +
                        'Terminal has locked you out.',
                        'error',
                        'HACK FAILED'
                    );
                    
                    var originalClose = closePopup;
                    closePopup = function() {
                        document.getElementById('popup-overlay').classList.remove('active');
                        closePopup = originalClose;
                        exitHacking();
                    };
                } else {
                    // Show error but preserve the full original question
                    document.getElementById('hack-sequence').innerHTML = 
                        '<span style="color: #f00;">✗ INCORRECT (You answered: ' + userAnswer + ')</span><br><br>' +
                        gameState.currentProblem.question;
                    document.getElementById('hack-prompt').innerHTML = 'ENCRYPTION LAYER ' + 
                        (gameState.hackingState.puzzlesSolved + 1) + '/' + gameState.hackingState.puzzlesNeeded + 
                        '<br>Attempts remaining: ' + (gameState.hackingState.maxAttempts - gameState.hackingState.attempts);
                    document.getElementById('hack-answer').value = '';
                    document.getElementById('hack-answer').focus();
                }
            }
            
            updateInventoryDisplay();
        }
        
        function exitHacking() {
            document.getElementById('hacking-terminal').style.display = 'none';
            document.getElementById('exploration-narrative').style.display = 'block';
            document.getElementById('exploration-choices').style.display = 'block';
            gameState.hackingState = null;

            // Check for callback (used when hacking from location search)
            if (gameState.postHackCallback) {
                var callback = gameState.postHackCallback;
                gameState.postHackCallback = null;
                callback();
            } else {
                nextExplorationEvent();
            }
        }
        
        // ============ LOCKPICKING SYSTEM ============
        
        function startLockpick(reward) {
            document.getElementById('exploration-narrative').style.display = 'none';
            document.getElementById('exploration-choices').style.display = 'none';
            document.getElementById('lockpick-screen').style.display = 'block';
            
            // Generate a 4-digit lock with math-based hints
            var digits = [];
            for (var i = 0; i < 4; i++) {
                digits.push(Math.floor(Math.random() * 9) + 1);
            }
            
            gameState.lockpickState = {
                solution: digits,
                currentDigit: 0,
                solved: [false, false, false, false],
                attempts: 0,
                reward: reward || { type: 'money', amount: 40 }
            };
            
            updateLockDisplay();
            generateLockHint();
        }
        
        function updateLockDisplay() {
            var html = '';
            for (var i = 0; i < 4; i++) {
                var cls = 'lock-tumbler';
                if (gameState.lockpickState.solved[i]) {
                    cls += ' solved';
                    html += '<div class="' + cls + '">' + gameState.lockpickState.solution[i] + '</div>';
                } else if (i === gameState.lockpickState.currentDigit) {
                    cls += ' current';
                    html += '<div class="' + cls + '">?</div>';
                } else {
                    html += '<div class="' + cls + '">•</div>';
                }
            }
            document.getElementById('lock-display').innerHTML = html;
        }
        
        function generateLockHint() {
            var digit = gameState.lockpickState.solution[gameState.lockpickState.currentDigit];
            var hintTypes = ['sum', 'product', 'square', 'equation'];
            var type = hintTypes[Math.floor(Math.random() * hintTypes.length)];
            var hint;
            
            if (type === 'sum') {
                var a = Math.floor(Math.random() * digit);
                var b = digit - a;
                hint = 'This digit equals ' + a + ' + ' + b;
            } else if (type === 'product') {
                // Find factors if possible
                var factors = [];
                for (var i = 1; i <= digit; i++) {
                    if (digit % i === 0) factors.push([i, digit / i]);
                }
                var pair = factors[Math.floor(Math.random() * factors.length)];
                if (pair[0] === 1 && pair[1] === digit) {
                    hint = 'This digit is ' + digit + ' × 1';
                } else {
                    hint = 'This digit equals ' + pair[0] + ' × ' + pair[1];
                }
            } else if (type === 'square') {
                var squares = {1: 1, 4: 2, 9: 3};
                if (squares[digit]) {
                    hint = 'This digit is ' + squares[digit] + '²';
                } else {
                    var a = Math.floor(Math.random() * (digit - 1)) + 1;
                    hint = 'This digit equals ' + a + ' + ' + (digit - a);
                }
            } else {
                // Simple equation
                var mult = Math.floor(Math.random() * 3) + 2;
                var result = digit * mult;
                hint = 'If x × ' + mult + ' = ' + result + ', this digit is x';
            }
            
            document.getElementById('lock-hint').innerHTML = 'Tumbler ' + (gameState.lockpickState.currentDigit + 1) + ' hint:<br><strong>' + hint + '</strong>';
            document.getElementById('lock-answer').value = '';
            document.getElementById('lock-answer').focus();
            
            gameState.currentProblem = {
                answer: digit,
                action: 'lockpick',
                xpReward: 20
            };
        }
        
        function submitLockAnswer() {
            var userAnswer = parseInt(document.getElementById('lock-answer').value);
            if (isNaN(userAnswer)) {
                return;
            }
            
            gameState.lockpickState.attempts++;
            var correct = userAnswer === gameState.currentProblem.answer;
            
            recordMathResult(correct);
            
            if (correct) {
                gameState.lockpickState.solved[gameState.lockpickState.currentDigit] = true;
                gameState.lockpickState.currentDigit++;
                awardXP(gameState.currentProblem.xpReward, 'lockpick digit ' + gameState.lockpickState.currentDigit);
                
                updateLockDisplay();
                
                if (gameState.lockpickState.currentDigit >= 4) {
                    // Lock opened! Require calculation for reward
                    var reward = gameState.lockpickState.reward;
                    
                    showPopup(
                        '<strong>🔓 LOCK OPENED!</strong><br><br>' +
                        'Code: ' + gameState.lockpickState.solution.join('') + '<br><br>' +
                        'Calculate to claim reward!',
                        'success',
                        'UNLOCKED'
                    );
                    
                    var originalClose = closePopup;
                    closePopup = function() {
                        document.getElementById('popup-overlay').classList.remove('active');
                        closePopup = originalClose;
                        
                        if (reward.type === 'money') {
                            var currentMoney = gameState.player.money;
                            requireCalculation({
                                title: '🔓 LOCK REWARD',
                                description: 'Found ' + formatMoney(reward.amount) + '!<br>Your cash: ' + formatMoney(currentMoney),
                                formula: formatMoney(currentMoney) + ' + ' + formatMoney(reward.amount),
                                answer: currentMoney + reward.amount,
                                isMoney: true,
                                context: 'exploration',
                                onSuccess: function(newTotal) {
                                    gameState.player.money = newTotal;
                                    awardXP(20, 'lock opened bonus');
                                    processPendingCalcs(function() {
                                        updateInventoryDisplay();
                                        exitLockpick();
                                    });
                                },
                                onFailure: function() {
                                    gameState.player.money += Math.floor(reward.amount / 2);
                                    updateInventoryDisplay();
                                    exitLockpick();
                                }
                            });
                        } else if (reward.type === 'medkit') {
                            var currentStims = gameState.player.medkits;
                            requireCalculation({
                                title: '🔓 LOCK REWARD',
                                description: 'Found ' + reward.amount + ' medkits!<br>Current: ' + currentStims,
                                formula: currentStims + ' + ' + reward.amount,
                                answer: currentStims + reward.amount,
                                context: 'exploration',
                                onSuccess: function(newTotal) {
                                    gameState.player.medkits = newTotal;
                                    awardXP(20, 'lock opened bonus');
                                    processPendingCalcs(function() {
                                        updateInventoryDisplay();
                                        exitLockpick();
                                    });
                                },
                                onFailure: function() {
                                    gameState.player.medkits += 1;
                                    updateInventoryDisplay();
                                    exitLockpick();
                                }
                            });
                        } else if (reward.type === 'materials') {
                            var totalMats = 3 + 2 + 2 + 2;
                            requireCalculation({
                                title: '🔓 LOCK REWARD',
                                description: 'Found materials!<br>Metal: 3, Chem: 2, Elec: 2, Cloth: 2',
                                formula: '3 + 2 + 2 + 2',
                                answer: totalMats,
                                context: 'exploration',
                                onSuccess: function(total) {
                                    addMaterial('Scrap Metal', 3);
                                    addMaterial('Chemicals', 2);
                                    addMaterial('Electronics', 2);
                                    addMaterial('Cloth', 2);
                                    awardXP(20, 'lock opened bonus');
                                    processPendingCalcs(function() {
                                        updateInventoryDisplay();
                                        exitLockpick();
                                    });
                                },
                                onFailure: function() {
                                    addMaterial('Scrap Metal', 1);
                                    addMaterial('Chemicals', 1);
                                    updateInventoryDisplay();
                                    exitLockpick();
                                }
                            });
                        }
                    };
                } else {
                    // Process pending XP then next digit
                    processPendingCalcs(function() {
                        setTimeout(function() {
                            generateLockHint();
                            updateLockDisplay();
                        }, 300);
                    });
                }
            } else {
                document.getElementById('lock-hint').innerHTML = '<span style="color: #f44;">✗ Wrong! Try again.</span><br><br>' + 
                    document.getElementById('lock-hint').innerHTML;
                document.getElementById('lock-answer').value = '';
            }
            
            updateInventoryDisplay();
        }
        
        function exitLockpick() {
            document.getElementById('lockpick-screen').style.display = 'none';
            document.getElementById('exploration-narrative').style.display = 'block';
            document.getElementById('exploration-choices').style.display = 'block';
            gameState.lockpickState = null;

            // Check for callback (used when lockpicking from location search)
            if (gameState.postLockpickCallback) {
                var callback = gameState.postLockpickCallback;
                gameState.postLockpickCallback = null;
                callback();
            } else {
                nextExplorationEvent();
            }
        }
        
        // ============ BATTLEFIELD LOCATIONS ============
        // 10 specific themed battlefields plus random generation
        // Each battlefield has unique cover, hazards, and environmental flavor
        var BATTLEFIELDS = [
            {
                id: 'abandoned_building',
                name: 'Abandoned Building',
                description: 'The fight takes place inside a crumbling structure',
                icon: '🏚️',
                cover: [
                    {x: 2, y: 2, type: 'wall'}, {x: 2, y: 7, type: 'wall'},
                    {x: 4, y: 4, type: 'medium'}, {x: 4, y: 6, type: 'medium'},
                    {x: 6, y: 3, type: 'wall'}, {x: 6, y: 5, type: 'small'},
                    {x: 8, y: 4, type: 'medium'}, {x: 8, y: 7, type: 'wall'}
                ],
                hazards: [
                    {x: 5, y: 5, type: 'explosive', name: 'Gas Line', damage: 40, radius: 1.5}
                ],
                traps: [
                    {x: 7, y: 5, type: 'trap', name: 'Weak Floor', damage: 25, radius: 0}
                ]
            },
            {
                id: 'crossroads',
                name: 'Dusty Crossroads',
                description: 'An intersection of two old highways',
                icon: '🛤️',
                cover: [
                    {x: 3, y: 3, type: 'medium'}, {x: 3, y: 6, type: 'medium'},
                    {x: 5, y: 5, type: 'small'},
                    {x: 7, y: 2, type: 'medium'}, {x: 7, y: 7, type: 'medium'},
                    {x: 9, y: 4, type: 'small'}
                ],
                hazards: [
                    {x: 5, y: 4, type: 'explosive', name: 'Rusted Car', damage: 35, radius: 2}
                ],
                traps: []
            },
            {
                id: 'gas_station',
                name: 'Ruined Gas Station',
                description: 'An old fuel stop, pumps still leaking',
                icon: '⛽',
                cover: [
                    {x: 2, y: 4, type: 'wall'}, {x: 2, y: 6, type: 'wall'},
                    {x: 5, y: 3, type: 'medium'}, {x: 5, y: 7, type: 'medium'},
                    {x: 8, y: 5, type: 'wall'}
                ],
                hazards: [
                    {x: 4, y: 5, type: 'explosive', name: 'Fuel Pump', damage: 60, radius: 2.5},
                    {x: 7, y: 4, type: 'explosive', name: 'Oil Drum', damage: 45, radius: 2}
                ],
                traps: []
            },
            {
                id: 'highway_overpass',
                name: 'Highway Overpass',
                description: 'A collapsed overpass creates uneven terrain',
                icon: '🌉',
                cover: [
                    {x: 2, y: 3, type: 'wall'}, {x: 3, y: 5, type: 'medium'},
                    {x: 4, y: 7, type: 'wall'}, {x: 6, y: 2, type: 'medium'},
                    {x: 6, y: 6, type: 'wall'}, {x: 8, y: 4, type: 'medium'},
                    {x: 9, y: 7, type: 'small'}
                ],
                hazards: [],
                traps: [
                    {x: 5, y: 4, type: 'trap', name: 'Rebar Spikes', damage: 30, radius: 0},
                    {x: 7, y: 6, type: 'trap', name: 'Loose Concrete', damage: 20, radius: 0}
                ]
            },
            {
                id: 'parking_lot',
                name: 'Overgrown Parking Lot',
                description: 'Abandoned vehicles provide scattered cover',
                icon: '🅿️',
                cover: [
                    {x: 2, y: 2, type: 'medium'}, {x: 2, y: 5, type: 'medium'}, {x: 2, y: 8, type: 'medium'},
                    {x: 5, y: 3, type: 'medium'}, {x: 5, y: 6, type: 'medium'},
                    {x: 8, y: 2, type: 'medium'}, {x: 8, y: 5, type: 'medium'}, {x: 8, y: 8, type: 'medium'}
                ],
                hazards: [
                    {x: 6, y: 4, type: 'explosive', name: 'Leaking Van', damage: 50, radius: 2}
                ],
                traps: []
            },
            {
                id: 'train_yard',
                name: 'Train Yard',
                description: 'Rusty train cars line the abandoned tracks',
                icon: '🚂',
                cover: [
                    {x: 2, y: 3, type: 'wall'}, {x: 2, y: 4, type: 'wall'}, {x: 2, y: 5, type: 'wall'},
                    {x: 5, y: 6, type: 'wall'}, {x: 5, y: 7, type: 'wall'},
                    {x: 8, y: 2, type: 'wall'}, {x: 8, y: 3, type: 'wall'},
                    {x: 8, y: 6, type: 'wall'}, {x: 8, y: 7, type: 'wall'}
                ],
                hazards: [],
                traps: [
                    {x: 4, y: 5, type: 'trap', name: 'Rail Debris', damage: 25, radius: 0}
                ]
            },
            {
                id: 'forest_clearing',
                name: 'Forest Clearing',
                description: 'A small clearing among dead trees',
                icon: '🌲',
                cover: [
                    {x: 2, y: 2, type: 'small'}, {x: 2, y: 8, type: 'small'},
                    {x: 4, y: 4, type: 'medium'}, {x: 4, y: 6, type: 'medium'},
                    {x: 6, y: 3, type: 'small'}, {x: 6, y: 7, type: 'small'},
                    {x: 8, y: 5, type: 'medium'},
                    {x: 10, y: 2, type: 'small'}, {x: 10, y: 8, type: 'small'}
                ],
                hazards: [],
                traps: [
                    {x: 5, y: 5, type: 'trap', name: 'Bear Trap', damage: 35, radius: 0}
                ]
            },
            {
                id: 'warehouse',
                name: 'Warehouse Interior',
                description: 'Rows of shelving and crates fill the space',
                icon: '📦',
                cover: [
                    {x: 3, y: 2, type: 'wall'}, {x: 3, y: 4, type: 'wall'}, {x: 3, y: 6, type: 'wall'}, {x: 3, y: 8, type: 'wall'},
                    {x: 6, y: 2, type: 'wall'}, {x: 6, y: 4, type: 'wall'}, {x: 6, y: 6, type: 'wall'}, {x: 6, y: 8, type: 'wall'},
                    {x: 9, y: 3, type: 'medium'}, {x: 9, y: 7, type: 'medium'}
                ],
                hazards: [
                    {x: 5, y: 5, type: 'explosive', name: 'Chemical Barrel', damage: 45, radius: 1.5}
                ],
                traps: []
            },
            {
                id: 'rooftop',
                name: 'Building Rooftop',
                description: 'A flat rooftop with AC units and vents',
                icon: '🏗️',
                cover: [
                    {x: 2, y: 3, type: 'medium'}, {x: 2, y: 7, type: 'medium'},
                    {x: 5, y: 2, type: 'small'}, {x: 5, y: 5, type: 'medium'}, {x: 5, y: 8, type: 'small'},
                    {x: 8, y: 3, type: 'medium'}, {x: 8, y: 7, type: 'medium'}
                ],
                hazards: [
                    {x: 4, y: 4, type: 'explosive', name: 'AC Unit', damage: 30, radius: 1.5}
                ],
                traps: [
                    {x: 7, y: 5, type: 'trap', name: 'Skylight', damage: 40, radius: 0}
                ]
            },
            {
                id: 'bridge',
                name: 'Crumbling Bridge',
                description: 'A damaged bridge over a dried riverbed',
                icon: '🌁',
                cover: [
                    {x: 2, y: 4, type: 'wall'}, {x: 2, y: 6, type: 'wall'},
                    {x: 5, y: 3, type: 'medium'}, {x: 5, y: 5, type: 'small'}, {x: 5, y: 7, type: 'medium'},
                    {x: 8, y: 4, type: 'wall'}, {x: 8, y: 6, type: 'wall'}
                ],
                hazards: [],
                traps: [
                    {x: 4, y: 5, type: 'trap', name: 'Cracked Concrete', damage: 25, radius: 0},
                    {x: 6, y: 4, type: 'trap', name: 'Rusted Railing', damage: 20, radius: 0},
                    {x: 6, y: 6, type: 'trap', name: 'Hole in Bridge', damage: 35, radius: 0}
                ]
            }
        ];

        // Get a random battlefield, or generate one from encounter data
        function selectBattlefield(encounter) {
            // 70% chance to use a specific battlefield, 30% to use encounter's own layout
            if (Math.random() < 0.7 || !encounter.cover || encounter.cover.length === 0) {
                var battlefield = BATTLEFIELDS[Math.floor(Math.random() * BATTLEFIELDS.length)];
                return {
                    location: battlefield,
                    cover: battlefield.cover.map(function(c) { return {...c}; }),
                    hazards: battlefield.hazards.map(function(h) { return {...h, used: false}; }),
                    traps: (battlefield.traps || []).map(function(t) { return {...t, used: false}; })
                };
            } else {
                // Use encounter's own layout (random/legacy behavior)
                return {
                    location: { name: 'Open Wasteland', icon: '🏜️', description: 'The barren wasteland stretches around you' },
                    cover: encounter.cover.map(function(c) { return {...c}; }),
                    hazards: encounter.hazards.map(function(h) { return {...h, used: false}; }),
                    traps: (encounter.traps || []).map(function(t) { return {...t, used: false}; })
                };
            }
        }

        // ============ EXPLORATION LOCATIONS ============
        // Locations players can explore, with or without enemies
        // Each location has searchable features that may contain loot

        var EXPLORATION_LOCATIONS = [
            {
                id: 'abandoned_house',
                name: 'Abandoned House',
                icon: '🏚️',
                description: 'A weathered house stands silent, its windows dark and door ajar.',
                searchables: ['cabinet', 'drawer', 'container', 'body'],
                hasTerminal: false,
                hasSafe: true
            },
            {
                id: 'gas_station',
                name: 'Gas Station',
                icon: '⛽',
                description: 'An old gas station with rusted pumps and a dusty convenience store.',
                searchables: ['cabinet', 'container', 'drawer', 'vehicle'],
                hasTerminal: true,
                hasSafe: true
            },
            {
                id: 'office_building',
                name: 'Office Building',
                icon: '🏢',
                description: 'A small office building with overturned desks and scattered papers.',
                searchables: ['drawer', 'cabinet', 'container'],
                hasTerminal: true,
                hasSafe: true
            },
            {
                id: 'warehouse',
                name: 'Warehouse',
                icon: '🏭',
                description: 'A large warehouse with towering shelves and crates stacked high.',
                searchables: ['container', 'container', 'cabinet', 'vehicle'],
                hasTerminal: false,
                hasSafe: true
            },
            {
                id: 'convenience_store',
                name: 'Convenience Store',
                icon: '🏪',
                description: 'A looted convenience store with empty shelves and broken glass.',
                searchables: ['cabinet', 'drawer', 'container'],
                hasTerminal: true,
                hasSafe: true
            },
            {
                id: 'pharmacy',
                name: 'Pharmacy',
                icon: '💊',
                description: 'An old pharmacy with overturned medicine bottles and empty shelves.',
                searchables: ['cabinet', 'cabinet', 'drawer', 'container'],
                hasTerminal: true,
                hasSafe: true
            },
            {
                id: 'police_station',
                name: 'Police Station',
                icon: '🚔',
                description: 'An abandoned police station with holding cells and an armory.',
                searchables: ['cabinet', 'locker', 'container', 'drawer'],
                hasTerminal: true,
                hasSafe: true
            },
            {
                id: 'school',
                name: 'Abandoned School',
                icon: '🏫',
                description: 'A quiet school with overturned desks and faded posters on the walls.',
                searchables: ['locker', 'drawer', 'cabinet', 'container'],
                hasTerminal: true,
                hasSafe: false
            },
            {
                id: 'hospital',
                name: 'Hospital Wing',
                icon: '🏥',
                description: 'A dark hospital corridor with abandoned medical equipment.',
                searchables: ['cabinet', 'cabinet', 'drawer', 'container', 'body'],
                hasTerminal: true,
                hasSafe: true
            },
            {
                id: 'bunker',
                name: 'Underground Bunker',
                icon: '🛡️',
                description: 'A sealed bunker with thick walls and emergency supplies.',
                searchables: ['locker', 'container', 'cabinet', 'drawer'],
                hasTerminal: true,
                hasSafe: true
            },
            {
                id: 'campsite',
                name: 'Abandoned Campsite',
                icon: '🏕️',
                description: 'A campsite with torn tents and a cold fire pit.',
                searchables: ['container', 'body', 'vehicle'],
                hasTerminal: false,
                hasSafe: false
            },
            {
                id: 'military_outpost',
                name: 'Military Outpost',
                icon: '🎖️',
                description: 'A fortified military position with sandbags and equipment.',
                searchables: ['locker', 'locker', 'container', 'cabinet', 'body'],
                hasTerminal: true,
                hasSafe: true
            }
        ];

        // Searchable item types and their loot tables by tier
        var SEARCHABLE_TYPES = {
            cabinet: { name: 'Cabinet', icon: '🗄️', searchTime: 'quick' },
            drawer: { name: 'Desk Drawer', icon: '🗃️', searchTime: 'quick' },
            locker: { name: 'Locker', icon: '🔒', searchTime: 'quick' },
            container: { name: 'Crate', icon: '📦', searchTime: 'medium' },
            body: { name: 'Fallen Traveler', icon: '💀', searchTime: 'quick' },
            vehicle: { name: 'Abandoned Vehicle', icon: '🚗', searchTime: 'medium' }
        };

        // Current location state for searching
        var currentLocation = null;

        // Generate searchable items for a location based on tier
        function generateSearchables(location, tier) {
            var searchables = [];
            var baseSearchables = location.searchables.slice(); // Copy array

            // More items at higher tiers
            var extraItems = Math.floor((tier.tier - 1) * 0.5);
            for (var i = 0; i < extraItems && baseSearchables.length > 0; i++) {
                baseSearchables.push(baseSearchables[Math.floor(Math.random() * baseSearchables.length)]);
            }

            // Create searchable objects
            baseSearchables.forEach(function(type, index) {
                var typeInfo = SEARCHABLE_TYPES[type];
                searchables.push({
                    id: index,
                    type: type,
                    name: typeInfo.name,
                    icon: typeInfo.icon,
                    searched: false,
                    loot: generateSearchableLoot(type, tier)
                });
            });

            // Add terminal if location has one (chance based on tier)
            if (location.hasTerminal && Math.random() < 0.5 + tier.tier * 0.1) {
                searchables.push({
                    id: searchables.length,
                    type: 'terminal',
                    name: 'Computer Terminal',
                    icon: '💻',
                    searched: false,
                    isTerminal: true,
                    reward: generateTerminalReward(tier)
                });
            }

            // Add safe if location has one (chance based on tier)
            if (location.hasSafe && Math.random() < 0.4 + tier.tier * 0.1) {
                searchables.push({
                    id: searchables.length,
                    type: 'safe',
                    name: 'Locked Safe',
                    icon: '🔐',
                    searched: false,
                    isSafe: true,
                    reward: generateSafeReward(tier)
                });
            }

            return searchables;
        }

        // Generate loot for a searchable based on type and tier
        function generateSearchableLoot(type, tier) {
            var loot = { money: 0, items: [], materials: {} };

            // Base money chance and amount scale with tier
            if (Math.random() < 0.4 + tier.tier * 0.1) {
                loot.money = Math.floor((500 + Math.random() * 1000) * tier.lootMult);
            }

            // Item chances based on searchable type and tier
            var itemChance = 0.3 + tier.tier * 0.1;
            var possibleItems;

            if (type === 'body') {
                possibleItems = ['Water Bottle', 'Canned Beans', 'Bandages', 'Old Cash', '9mm Rounds (24)', 'Duct Tape'];
                itemChance += 0.2; // Bodies usually have something
            } else if (type === 'cabinet' || type === 'locker') {
                if (tier.tier <= 2) {
                    possibleItems = ['Med Kit', 'Water Bottle', 'Canned Beans', 'Bandages', 'Duct Tape', 'Trail Mix'];
                } else {
                    possibleItems = ['Med Kit', 'Sports Drink', 'MRE', 'Coffee', 'Circuitry', 'Leather Vest'];
                }
            } else if (type === 'drawer') {
                possibleItems = ['Old Cash', 'Duct Tape', 'Bandages', '9mm Rounds (24)', 'Circuitry'];
                if (Math.random() < 0.3) loot.money += Math.floor(500 * tier.lootMult); // Extra cash in drawers
            } else if (type === 'container') {
                if (tier.tier <= 2) {
                    possibleItems = ['Water Bottle', 'Canned Beans', 'Canned Meat', '9mm Rounds (24)', '.308 Rounds (10)', 'Duct Tape'];
                } else if (tier.tier === 3) {
                    possibleItems = ['Med Kit', '5.56mm Rounds (30)', '.308 Rounds (10)', 'Metal Plate', 'Circuitry', 'Sensor Module'];
                } else {
                    possibleItems = ['Med Kit', '5.56mm Rounds (30)', '12 Gauge Shells (12)', 'Tactical Vest', 'Gold Watch', 'Sensor Module'];
                }
            } else if (type === 'vehicle') {
                possibleItems = ['Water Bottle', 'Canned Beans', 'Duct Tape', '9mm Rounds (24)', 'Camping Set', 'Portable Stove'];
                // Vehicles often have materials
                if (Math.random() < 0.5) {
                    loot.materials.metal = Math.floor((1 + Math.random() * 2) * tier.lootMult);
                }
            }

            // Roll for items
            if (possibleItems && Math.random() < itemChance) {
                var item = possibleItems[Math.floor(Math.random() * possibleItems.length)];
                loot.items.push(item);

                // Chance for bonus item at higher tiers
                if (tier.tier >= 3 && Math.random() < 0.25) {
                    var bonusItem = possibleItems[Math.floor(Math.random() * possibleItems.length)];
                    if (bonusItem !== item) loot.items.push(bonusItem);
                }
            }

            // Material chance
            if (Math.random() < 0.2 + tier.tier * 0.05) {
                var matTypes = ['metal', 'chem', 'elec', 'cloth'];
                var mat = matTypes[Math.floor(Math.random() * matTypes.length)];
                loot.materials[mat] = (loot.materials[mat] || 0) + Math.floor((1 + Math.random()) * tier.lootMult);
            }

            return loot;
        }

        // Generate reward for hacking a terminal
        function generateTerminalReward(tier) {
            if (Math.random() < 0.6) {
                return { type: 'money', amount: Math.floor((4000 + Math.random() * 4000) * tier.lootMult) };
            } else {
                return { type: 'medkit', amount: Math.floor(1 + Math.random() * 2 * tier.lootMult) };
            }
        }

        // Generate reward for lockpicking a safe
        function generateSafeReward(tier) {
            var roll = Math.random();
            if (roll < 0.5) {
                return { type: 'money', amount: Math.floor((3000 + Math.random() * 5000) * tier.lootMult) };
            } else if (roll < 0.8) {
                return { type: 'medkit', amount: Math.floor(2 + Math.random() * tier.lootMult) };
            } else {
                return { type: 'materials', amount: Math.floor(3 + Math.random() * 3 * tier.lootMult) };
            }
        }

        // Enter a location (with or without enemies)
        function enterLocation(hasEnemies) {
            var tier = getDistanceTier();
            var location = EXPLORATION_LOCATIONS[Math.floor(Math.random() * EXPLORATION_LOCATIONS.length)];

            currentLocation = {
                info: location,
                tier: tier,
                searchables: generateSearchables(location, tier),
                enemiesCleared: !hasEnemies
            };

            if (hasEnemies) {
                // Show location, then go to combat
                document.getElementById('exploration-narrative').innerHTML =
                    '<strong>' + location.icon + ' ' + location.name.toUpperCase() + '</strong><br><br>' +
                    location.description + '<br><br>' +
                    '<span style="color: #f00;">⚠️ Hostiles detected inside!</span>';

                var html = '<button class="btn combat" onclick="startCombatAtLocation()">⚔️ CLEAR THE AREA<br><span style="font-size:0.85em">Engage hostiles</span></button>';
                html += '<button class="btn tactical" onclick="chooseExploration(\'sneak\')">🤫 SNEAK PAST<br><span style="font-size:0.85em">Try to avoid combat</span></button>';
                html += '<button class="btn" onclick="leaveLocation()">← LEAVE<br><span style="font-size:0.85em">Find somewhere else</span></button>';
                document.getElementById('exploration-choices').innerHTML = html;
            } else {
                // No enemies, go straight to search phase
                showLocationSearch();
            }
        }

        // Start combat at current location
        function startCombatAtLocation() {
            // Store that we're in a location for post-combat
            gameState.inLocation = true;
            startCombat();
        }

        // Show the location search interface
        function showLocationSearch() {
            if (!currentLocation) return;

            var location = currentLocation.info;
            var searchables = currentLocation.searchables;
            var allSearched = searchables.every(function(s) { return s.searched; });

            var html = '<strong>' + location.icon + ' ' + location.name.toUpperCase() + '</strong><br>';
            html += '<span style="color: ' + currentLocation.tier.color + ';">(' + currentLocation.tier.name + ')</span><br><br>';

            if (currentLocation.enemiesCleared && searchables.length > 0) {
                html += '<span style="color: #0f0;">Area secured. Search for supplies:</span><br><br>';
            } else if (searchables.length === 0) {
                html += '<span style="color: #888;">Nothing left to search.</span><br><br>';
            }

            document.getElementById('exploration-narrative').innerHTML = html;

            // Build searchable buttons
            var btnHtml = '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 15px;">';

            searchables.forEach(function(item) {
                var disabled = item.searched ? 'disabled style="opacity: 0.5;"' : '';
                var statusIcon = item.searched ? '✓' : '🔍';

                if (item.isTerminal) {
                    btnHtml += '<button class="btn" ' + disabled + ' onclick="searchTerminal(' + item.id + ')" style="background: #0a0;">' +
                        item.icon + ' ' + item.name + '<br><span style="font-size:0.8em;">' + (item.searched ? 'Hacked' : 'Hack it') + '</span></button>';
                } else if (item.isSafe) {
                    btnHtml += '<button class="btn" ' + disabled + ' onclick="searchSafe(' + item.id + ')" style="background: #666;">' +
                        item.icon + ' ' + item.name + '<br><span style="font-size:0.8em;">' + (item.searched ? 'Opened' : 'Pick lock') + '</span></button>';
                } else {
                    btnHtml += '<button class="btn" ' + disabled + ' onclick="searchItem(' + item.id + ')">' +
                        item.icon + ' ' + item.name + '<br><span style="font-size:0.8em;">' + (item.searched ? 'Searched' : 'Search') + '</span></button>';
                }
            });

            btnHtml += '</div>';

            // Leave button
            btnHtml += '<button class="btn" onclick="leaveLocation()" style="width: 100%;">✓ DONE - Continue Journey</button>';

            document.getElementById('exploration-choices').innerHTML = btnHtml;

            // Tutorial: first location search
            showTutorialTip('first_location', 1000);
        }

        // Search a regular item
        function searchItem(itemId) {
            var item = currentLocation.searchables.find(function(s) { return s.id === itemId; });
            if (!item || item.searched) return;

            item.searched = true;
            var loot = item.loot;

            // Check if there's anything
            var hasLoot = loot.money > 0 || loot.items.length > 0 || Object.keys(loot.materials).length > 0;

            if (!hasLoot) {
                showPopup(
                    '<strong>' + item.icon + ' ' + item.name + '</strong><br><br>' +
                    '<span style="color: #888;">Empty - nothing useful here.</span>',
                    'info',
                    'SEARCHED'
                );
                var oc = closePopup;
                closePopup = function() {
                    document.getElementById('popup-overlay').classList.remove('active');
                    closePopup = oc;
                    showLocationSearch();
                };
                return;
            }

            // Show what was found
            var content = '<strong>' + item.icon + ' ' + item.name + '</strong><br><br>';
            content += '<strong>Found:</strong><br>';
            if (loot.money > 0) content += '💵 ' + formatMoney(loot.money) + '<br>';
            if (loot.items.length > 0) content += '📦 ' + loot.items.join(', ') + '<br>';
            for (var mat in loot.materials) {
                content += '🔧 ' + mat.charAt(0).toUpperCase() + mat.slice(1) + ': +' + loot.materials[mat] + '<br>';
            }

            showPopup(content, 'success', 'LOOT FOUND');

            var origClose = closePopup;
            closePopup = function() {
                document.getElementById('popup-overlay').classList.remove('active');
                closePopup = origClose;
                collectSearchLoot(loot);
            };
        }

        // Collect loot from a search (with math challenge for money)
        function collectSearchLoot(loot) {
            if (loot.money > 0) {
                var currentMoney = gameState.player.money;
                requireCalculation({
                    title: '💵 COLLECT CASH',
                    description: 'Found: ' + formatMoney(loot.money) + '<br>Your cash: ' + formatMoney(currentMoney),
                    formula: formatMoney(currentMoney) + ' + ' + formatMoney(loot.money),
                    answer: currentMoney + loot.money,
                    isMoney: true,
                    xpReward: 10,
                    context: 'exploration',
                    onSuccess: function(newMoney) {
                        gameState.player.money = newMoney;
                        finishCollectingLoot(loot);
                    },
                    onFailure: function() {
                        gameState.player.money += Math.floor(loot.money / 2);
                        finishCollectingLoot(loot);
                    }
                });
            } else {
                finishCollectingLoot(loot);
            }
        }

        // Finish collecting loot (items and materials)
        function finishCollectingLoot(loot) {
            // Add items
            loot.items.forEach(function(itemName) {
                if (itemName === 'Med Kit') {
                    gameState.player.medkits++;
                } else if (canCarryItem(itemName)) {
                    addToInventory(itemName);
                }
            });

            // Add materials
            var matNameMap = { metal: 'Scrap Metal', chem: 'Chemicals', elec: 'Electronics', cloth: 'Cloth' };
            for (var mat in loot.materials) {
                var matName = matNameMap[mat];
                if (matName) addMaterial(matName, loot.materials[mat]);
            }

            updateInventoryDisplay();
            showLocationSearch();
        }

        // Search a terminal (triggers hacking minigame)
        function searchTerminal(itemId) {
            var item = currentLocation.searchables.find(function(s) { return s.id === itemId; });
            if (!item || item.searched) return;

            // Mark as searched now (will be set regardless of success)
            item.searched = true;

            // Store callback to return to search
            gameState.postHackCallback = function() {
                showLocationSearch();
            };

            startHacking(item.reward);
        }

        // Search a safe (triggers lockpicking minigame)
        function searchSafe(itemId) {
            var item = currentLocation.searchables.find(function(s) { return s.id === itemId; });
            if (!item || item.searched) return;

            // Mark as searched now
            item.searched = true;

            // Store callback to return to search
            gameState.postLockpickCallback = function() {
                showLocationSearch();
            };

            startLockpick(item.reward);
        }

        // Leave the current location and continue exploring
        function leaveLocation() {
            currentLocation = null;
            gameState.inLocation = false;
            updateInventoryDisplay();
            autoSave();
            nextExplorationEvent();
        }

        // 25 Original apocalyptic creature types (kid-safe, no humans, no gore)
        // Includes rare encounters: Aliens, Bigfoot, and other cryptids
        // enemyCount: number of enemies (default 1), hpPerEnemy: HP for each individual
        var encounterTypes = [
            // ========== WILD ANIMALS (6) ==========
            {
                name: 'Feral Dog',
                hp: 25,
                enemyCount: 3,
                type: 'melee',
                hasFur: true,
                hideYield: 1,
                description: 'A pack of feral dogs surrounds you, snarling!',
                cover: [
                    {x: 2, y: 4, type: 'small'}, {x: 4, y: 2, type: 'small'},
                    {x: 4, y: 7, type: 'small'}, {x: 6, y: 5, type: 'medium'},
                    {x: 8, y: 3, type: 'small'}
                ],
                hazards: [],
                traps: []
            },
            {
                name: 'Wild Boar',
                hp: 75,
                type: 'melee',
                hasFur: true,
                hideYield: 2,
                description: 'An angry wild boar charges at you!',
                cover: [
                    {x: 3, y: 3, type: 'medium'}, {x: 3, y: 6, type: 'medium'},
                    {x: 6, y: 4, type: 'wall'}, {x: 9, y: 5, type: 'small'}
                ],
                hazards: [
                    {x: 5, y: 5, type: 'explosive', name: 'Gas Can', damage: 35, radius: 1.5}
                ],
                traps: []
            },
            {
                name: 'Mountain Lion',
                hp: 80,
                type: 'melee',
                hasFur: true,
                hideYield: 2,
                description: 'A mountain lion stalks toward you!',
                cover: [
                    {x: 2, y: 5, type: 'small'}, {x: 4, y: 3, type: 'medium'},
                    {x: 7, y: 6, type: 'medium'}, {x: 9, y: 4, type: 'small'}
                ],
                hazards: [],
                traps: [
                    {x: 5, y: 4, type: 'trap', name: 'Pit Trap', damage: 30, radius: 0}
                ]
            },
            {
                name: 'Grizzly Bear',
                hp: 130,
                type: 'melee',
                hasFur: true,
                hideYield: 4,
                description: 'A massive grizzly bear rears up on its hind legs!',
                cover: [
                    {x: 2, y: 2, type: 'wall'}, {x: 2, y: 7, type: 'wall'},
                    {x: 5, y: 5, type: 'medium'}, {x: 8, y: 4, type: 'medium'},
                    {x: 10, y: 6, type: 'small'}
                ],
                hazards: [
                    {x: 6, y: 5, type: 'explosive', name: 'Old Generator', damage: 55, radius: 2}
                ],
                traps: []
            },
            {
                name: 'Wolf',
                hp: 30,
                enemyCount: 3,
                type: 'melee',
                hasFur: true,
                hideYield: 2,
                description: 'Hungry wolves emerge from the treeline!',
                cover: [
                    {x: 3, y: 4, type: 'small'}, {x: 5, y: 2, type: 'small'},
                    {x: 5, y: 7, type: 'small'}, {x: 7, y: 5, type: 'medium'}
                ],
                hazards: [],
                traps: []
            },
            {
                name: 'Coyote',
                hp: 20,
                enemyCount: 4,
                type: 'melee',
                hasFur: true,
                hideYield: 1,
                description: 'A group of coyotes circles around you!',
                cover: [
                    {x: 3, y: 3, type: 'small'}, {x: 5, y: 6, type: 'small'},
                    {x: 7, y: 4, type: 'medium'}, {x: 9, y: 7, type: 'small'}
                ],
                hazards: [],
                traps: []
            },

            // ========== INSECTS & REPTILES (6) ==========
            {
                name: 'Giant Scorpion',
                hp: 70,
                type: 'melee',
                description: 'A giant scorpion bursts from the sand!',
                cover: [
                    {x: 3, y: 3, type: 'small'}, {x: 3, y: 6, type: 'small'},
                    {x: 6, y: 4, type: 'medium'}, {x: 6, y: 5, type: 'medium'},
                    {x: 9, y: 2, type: 'wall'}, {x: 9, y: 7, type: 'wall'}
                ],
                hazards: [
                    {x: 7, y: 5, type: 'explosive', name: 'Oil Drum', damage: 50, radius: 2}
                ],
                traps: [
                    {x: 4, y: 4, type: 'trap', name: 'Claw Trap', damage: 35, radius: 0}
                ]
            },
            {
                name: 'Wasp',
                hp: 12,
                enemyCount: 5,
                type: 'melee',
                description: 'An angry swarm of wasps buzzes toward you!',
                cover: [
                    {x: 2, y: 3, type: 'small'}, {x: 4, y: 5, type: 'small'},
                    {x: 6, y: 2, type: 'small'}, {x: 8, y: 6, type: 'medium'}
                ],
                hazards: [
                    {x: 5, y: 4, type: 'explosive', name: 'Nest', damage: 25, radius: 1}
                ],
                traps: []
            },
            {
                name: 'Giant Rattlesnake',
                hp: 65,
                type: 'melee',
                description: 'A massive rattlesnake coils to strike!',
                cover: [
                    {x: 3, y: 4, type: 'medium'}, {x: 5, y: 6, type: 'small'},
                    {x: 7, y: 3, type: 'medium'}, {x: 9, y: 5, type: 'small'}
                ],
                hazards: [],
                traps: [
                    {x: 4, y: 5, type: 'trap', name: 'Venom Pool', damage: 25, radius: 0}
                ]
            },
            {
                name: 'Giant Tarantula',
                hp: 55,
                type: 'melee',
                description: 'A giant tarantula scuttles toward you!',
                cover: [
                    {x: 2, y: 4, type: 'small'}, {x: 4, y: 2, type: 'medium'},
                    {x: 6, y: 6, type: 'medium'}, {x: 8, y: 4, type: 'small'}
                ],
                hazards: [],
                traps: [
                    {x: 3, y: 5, type: 'trap', name: 'Web', damage: 15, radius: 0},
                    {x: 5, y: 3, type: 'trap', name: 'Web', damage: 15, radius: 0}
                ]
            },
            {
                name: 'Snapping Turtle',
                hp: 85,
                type: 'melee',
                description: 'A massive snapping turtle blocks your path!',
                cover: [
                    {x: 2, y: 5, type: 'wall'}, {x: 4, y: 3, type: 'medium'},
                    {x: 6, y: 7, type: 'medium'}, {x: 8, y: 4, type: 'wall'}
                ],
                hazards: [
                    {x: 5, y: 5, type: 'explosive', name: 'Gas Leak', damage: 40, radius: 2}
                ],
                traps: []
            },
            {
                name: 'Fire Ant',
                hp: 10,
                enemyCount: 6,
                type: 'melee',
                description: 'A swarm of aggressive fire ants attacks!',
                cover: [
                    {x: 3, y: 3, type: 'small'}, {x: 5, y: 5, type: 'small'},
                    {x: 7, y: 3, type: 'small'}, {x: 7, y: 7, type: 'small'}
                ],
                hazards: [
                    {x: 5, y: 4, type: 'explosive', name: 'Ant Mound', damage: 20, radius: 1}
                ],
                traps: []
            },

            // ========== MUTATED CREATURES (6) ==========
            {
                name: 'Giant Rat',
                hp: 20,
                enemyCount: 3,
                type: 'melee',
                hasFur: true,
                hideYield: 1,
                description: 'A pack of giant rats hisses and attacks!',
                cover: [
                    {x: 3, y: 4, type: 'small'}, {x: 5, y: 2, type: 'small'},
                    {x: 5, y: 7, type: 'small'}, {x: 7, y: 5, type: 'small'}
                ],
                hazards: [],
                traps: [
                    {x: 4, y: 5, type: 'trap', name: 'Debris', damage: 10, radius: 0}
                ]
            },
            {
                name: 'Toxic Toad',
                hp: 55,
                type: 'ranged',
                description: 'A giant toad spits toxic venom!',
                cover: [
                    {x: 2, y: 4, type: 'medium'}, {x: 4, y: 6, type: 'small'},
                    {x: 6, y: 3, type: 'small'}, {x: 8, y: 5, type: 'medium'}
                ],
                hazards: [
                    {x: 5, y: 4, type: 'explosive', name: 'Toxic Puddle', damage: 30, radius: 1.5}
                ],
                traps: []
            },
            {
                name: 'Razorback',
                hp: 90,
                type: 'melee',
                hasFur: true,
                hideYield: 3,
                description: 'A mutated boar with razor-sharp tusks charges!',
                cover: [
                    {x: 3, y: 3, type: 'medium'}, {x: 3, y: 6, type: 'medium'},
                    {x: 6, y: 5, type: 'wall'}, {x: 9, y: 4, type: 'small'}
                ],
                hazards: [
                    {x: 5, y: 5, type: 'explosive', name: 'Fuel Cache', damage: 55, radius: 2}
                ],
                traps: []
            },
            {
                name: 'Tunnel Crawler',
                hp: 75,
                type: 'melee',
                description: 'A strange creature emerges from an underground tunnel!',
                cover: [
                    {x: 2, y: 5, type: 'small'}, {x: 4, y: 3, type: 'medium'},
                    {x: 6, y: 6, type: 'medium'}, {x: 8, y: 4, type: 'small'}
                ],
                hazards: [],
                traps: [
                    {x: 3, y: 4, type: 'trap', name: 'Tunnel Hole', damage: 20, radius: 0},
                    {x: 5, y: 5, type: 'trap', name: 'Tunnel Hole', damage: 20, radius: 0}
                ]
            },
            {
                name: 'Storm Hawk',
                hp: 60,
                type: 'ranged',
                description: 'A massive hawk dives from the sky!',
                cover: [
                    {x: 2, y: 3, type: 'wall'}, {x: 4, y: 5, type: 'small'},
                    {x: 6, y: 2, type: 'small'}, {x: 8, y: 6, type: 'wall'}
                ],
                hazards: [],
                traps: []
            },
            {
                name: 'Glowing Salamander',
                hp: 50,
                type: 'ranged',
                description: 'A bioluminescent salamander spits acid!',
                cover: [
                    {x: 2, y: 4, type: 'small'}, {x: 4, y: 6, type: 'medium'},
                    {x: 6, y: 3, type: 'medium'}, {x: 8, y: 5, type: 'small'}
                ],
                hazards: [
                    {x: 5, y: 5, type: 'explosive', name: 'Acid Pool', damage: 35, radius: 1.5}
                ],
                traps: []
            },

            // ========== CRYPTIDS & MYSTERIES (4) ==========
            {
                name: 'Chupacabra',
                hp: 85,
                type: 'melee',
                description: 'The legendary Chupacabra lunges from the darkness!',
                cover: [
                    {x: 2, y: 3, type: 'medium'}, {x: 4, y: 6, type: 'small'},
                    {x: 6, y: 4, type: 'wall'}, {x: 8, y: 7, type: 'medium'}
                ],
                hazards: [],
                traps: [
                    {x: 4, y: 4, type: 'trap', name: 'Claw Marks', damage: 25, radius: 0}
                ]
            },
            {
                name: 'Mothman',
                hp: 70,
                type: 'ranged',
                description: 'A winged creature with glowing red eyes swoops down!',
                cover: [
                    {x: 2, y: 5, type: 'small'}, {x: 4, y: 2, type: 'medium'},
                    {x: 6, y: 7, type: 'medium'}, {x: 8, y: 4, type: 'small'}
                ],
                hazards: [
                    {x: 5, y: 5, type: 'explosive', name: 'Strange Light', damage: 30, radius: 2}
                ],
                traps: []
            },
            {
                name: 'Jersey Devil',
                hp: 80,
                type: 'melee',
                description: 'A bat-winged creature with hooves screeches overhead!',
                cover: [
                    {x: 3, y: 4, type: 'medium'}, {x: 5, y: 2, type: 'wall'},
                    {x: 5, y: 7, type: 'wall'}, {x: 7, y: 5, type: 'medium'}
                ],
                hazards: [],
                traps: [
                    {x: 4, y: 5, type: 'trap', name: 'Thorns', damage: 20, radius: 0}
                ]
            },
            {
                name: 'Wendigo',
                hp: 100,
                type: 'melee',
                description: 'A tall, gaunt creature emerges from the mist!',
                cover: [
                    {x: 2, y: 3, type: 'wall'}, {x: 2, y: 6, type: 'wall'},
                    {x: 5, y: 5, type: 'medium'}, {x: 8, y: 4, type: 'medium'},
                    {x: 8, y: 6, type: 'small'}
                ],
                hazards: [
                    {x: 5, y: 4, type: 'explosive', name: 'Frozen Ground', damage: 25, radius: 1.5}
                ],
                traps: []
            },

            // ========== RARE ENCOUNTERS (3) ==========
            {
                name: 'Bigfoot',
                hp: 150,
                type: 'melee',
                rare: true,
                hasFur: true,
                hideYield: 6,
                description: '🦶 RARE ENCOUNTER! The legendary Sasquatch towers before you!',
                cover: [
                    {x: 2, y: 2, type: 'wall'}, {x: 2, y: 7, type: 'wall'},
                    {x: 5, y: 4, type: 'medium'}, {x: 5, y: 6, type: 'medium'},
                    {x: 8, y: 3, type: 'wall'}, {x: 8, y: 7, type: 'wall'},
                    {x: 10, y: 5, type: 'medium'}
                ],
                hazards: [
                    {x: 6, y: 5, type: 'explosive', name: 'Fallen Tree', damage: 40, radius: 2}
                ],
                traps: [
                    {x: 4, y: 5, type: 'trap', name: 'Root Tangle', damage: 20, radius: 0}
                ]
            },
            {
                name: 'Grey Alien',
                hp: 100,
                type: 'ranged',
                rare: true,
                description: '👽 RARE ENCOUNTER! A small grey being with large eyes appears!',
                cover: [
                    {x: 2, y: 4, type: 'medium'}, {x: 4, y: 2, type: 'wall'},
                    {x: 4, y: 7, type: 'wall'}, {x: 6, y: 5, type: 'medium'},
                    {x: 8, y: 3, type: 'small'}, {x: 8, y: 6, type: 'small'}
                ],
                hazards: [
                    {x: 5, y: 4, type: 'explosive', name: 'Energy Field', damage: 50, radius: 2},
                    {x: 7, y: 5, type: 'explosive', name: 'Plasma Burst', damage: 45, radius: 1.5}
                ],
                traps: [
                    {x: 3, y: 5, type: 'trap', name: 'Gravity Well', damage: 30, radius: 0}
                ]
            },
            {
                name: 'Thunderbird',
                hp: 120,
                type: 'ranged',
                rare: true,
                description: '⚡ RARE ENCOUNTER! A massive bird crackling with electricity soars above!',
                cover: [
                    {x: 2, y: 3, type: 'wall'}, {x: 2, y: 6, type: 'wall'},
                    {x: 5, y: 5, type: 'medium'}, {x: 8, y: 2, type: 'wall'},
                    {x: 8, y: 7, type: 'wall'}, {x: 10, y: 5, type: 'medium'}
                ],
                hazards: [
                    {x: 4, y: 5, type: 'explosive', name: 'Lightning Strike', damage: 60, radius: 2.5},
                    {x: 6, y: 4, type: 'explosive', name: 'Static Charge', damage: 35, radius: 1.5}
                ],
                traps: []
            }
        ];
        
        // Initialize start screen - show continue button if save exists
        function initStartScreen() {
            var saveInfo = getSaveInfo();
            var continueBtn = document.getElementById('continue-btn');
            var saveInfoDiv = document.getElementById('save-info');

            if (saveInfo) {
                continueBtn.style.display = 'inline-block';
                var saveDate = new Date(saveInfo.timestamp);
                var dateStr = saveDate.toLocaleDateString() + ' ' + saveDate.toLocaleTimeString();
                saveInfoDiv.innerHTML = '💾 Save found: ' + saveInfo.distance + ' km | ' + saveInfo.encounters + ' encounters | ' + saveInfo.correctAnswers + ' problems solved<br><small>' + dateStr + '</small>';
            } else {
                continueBtn.style.display = 'none';
                saveInfoDiv.textContent = '';
            }
        }

        // Start a new game (clears any existing save)
        function startNewGame() {
            if (hasSaveData()) {
                if (!confirm('Start a new game? This will overwrite your existing save.')) {
                    return;
                }
                deleteSave();
            }
            startAdventure();
        }

        // Continue from saved game
        function continueGame() {
            if (loadGame()) {
                // Check if player was at base or exploring
                if (travelState.atBase) {
                    openBaseScreen();
                } else {
                    showScreen('exploration-screen');
                    updateInventoryDisplay();
                    updateXPDisplay();
                    updateReturnButton();
                    updateDistanceTierIndicator();

                    // Check if we were at a shop
                    if (gameState.currentShop) {
                        // Restore trading post view
                        openTradingPost();
                    } else if (gameState.inLocation && currentLocation) {
                        // Restore location search view
                        showLocationSearch();
                    } else if (gameState.savedExplorationNarrative && gameState.savedExplorationChoices) {
                        // Restore exactly where player was - no distance progression
                        document.getElementById('exploration-narrative').innerHTML = gameState.savedExplorationNarrative;
                        document.getElementById('exploration-choices').innerHTML = gameState.savedExplorationChoices;
                        // Clear saved state after restoring
                        gameState.savedExplorationNarrative = null;
                        gameState.savedExplorationChoices = null;
                    } else {
                        // No saved exploration state (old save) - generate new event
                        nextExplorationEvent();
                    }
                }
            } else {
                alert('Failed to load save data. Starting new game.');
                startAdventure();
            }
        }

        function startAdventure() {
            // Reset revealed stats for new game
            revealedStats.weight = false;
            revealedStats.durability1 = false;
            revealedStats.durability2 = false;

            gameState = {
                distance: 0,
                encountersWon: 0,
                player: {
                    hp: 100,
                    maxHp: 100,
                    weapons: {
                        slot1: 'Glock 17',
                        slot2: 'Hunting Knife'
                    },
                    weaponDurability: {
                        slot1: 100,  // 0-100, degrades with use
                        slot2: 100
                    },
                    activeSlot: 1,
                    medkits: 2,
                    money: 5000, // $50.00
                    ammo: {
                        '9mm': 24,
                        '.45 ACP': 0,
                        '.357 Magnum': 0,
                        '.44 Magnum': 0,
                        '.45 LC': 0,
                        '.380 ACP': 0,
                        '.50 AE': 0,
                        '12 gauge': 0,
                        '.22 LR': 0,
                        '5.56mm': 0,
                        '7.62x39': 0,
                        '7.62x51': 0,
                        '7.62x54R': 0,
                        '.30-06': 0,
                        '.308 Win': 0,
                        '.30-30': 0,
                        '.30 Carbine': 0,
                        'arrows': 0,
                        'bolts': 0
                    },
                    materials: {
                        metal: 5,
                        chem: 3,
                        elec: 2,
                        cloth: 4
                    },
                    inventory: [
                        'Canned Beans',
                        'Canned Beans',
                        'Water Bottle',
                        'Water Bottle',
                        'Water Bottle'
                    ],
                    carryWeight: 0,
                    maxCarryWeight: 100,
                    mathStreak: 0,
                    bestStreak: 0,
                    totalCorrect: 0,
                    totalAttempted: 0,
                    vitals: {
                        hunger: 100,
                        thirst: 100,
                        energy: 100,
                        warmth: 75
                    }
                },
                combat: null,
                currentAction: null,
                currentProblem: null,
                explorationAction: null,
                mode: null,
                selectedCell: null,
                shopItem: null,
                currentShop: null,
                hackingState: null,
                lockpickState: null,
                craftingState: null,
                pendingCalculation: null
            };

            // Reset base state for new game
            baseState = {
                established: false,
                name: 'Camp',
                buildings: [],
                grid: null,
                resources: { wood: 20, steel: 10 },
                totalBenefits: {
                    carryCapacity: 0,
                    restBonus: 0,
                    cookingBonus: 0,
                    healingBonus: 0,
                    accuracyBonus: 0,
                    ambushReduction: 0,
                    hungerDecayReduction: 0,
                    shopDiscount: 0,
                    hasCraftingStation: false,
                    hasPower: false
                }
            };
            initBaseGrid();

            // Reset travel state
            travelState = {
                atBase: true,
                distanceFromBase: 0,
                isReturning: false
            };

            // Start at base instead of exploration
            openBaseScreen();
        }

        function showScreen(screenId) {
            var screens = document.querySelectorAll('.screen');
            for (var i = 0; i < screens.length; i++) {
                screens[i].classList.remove('active');
            }
            document.getElementById(screenId).classList.add('active');
        }
        
        function updateInventoryDisplay() {
            // Check for meat spoilage
            processMeatSpoilage();

            document.getElementById('distance').textContent = gameState.distance;
            document.getElementById('encounters').textContent = gameState.encountersWon;
            document.getElementById('inv-hp').textContent = gameState.player.hp;
            document.getElementById('inv-max-hp').textContent = gameState.player.maxHp;
            
            // Calculate weight (always calculate internally for game logic)
            calculateCarryWeight();
            document.getElementById('inv-item-count').textContent = gameState.player.inventory.length;

            // Only display weight if revealed
            if (revealedStats.weight) {
                document.getElementById('inv-weight-unknown').style.display = 'none';
                document.getElementById('inv-weight-known').style.display = 'inline';
                document.getElementById('inv-weight').textContent = gameState.player.carryWeight.toFixed(1);
                document.getElementById('inv-max-weight').textContent = gameState.player.maxCarryWeight;

                // Update weight bar
                var weightPercent = (gameState.player.carryWeight / gameState.player.maxCarryWeight) * 100;
                var weightFill = document.getElementById('weight-fill');
                weightFill.style.width = Math.min(weightPercent, 100) + '%';
                weightFill.className = 'weight-fill';
                if (weightPercent >= 90) weightFill.classList.add('critical');
                else if (weightPercent >= 70) weightFill.classList.add('warning');
            } else {
                document.getElementById('inv-weight-unknown').style.display = 'inline';
                document.getElementById('inv-weight-known').style.display = 'none';
            }
            
            // Update ammo display - only show ammo types we have
            var ammoDisplay = document.getElementById('inv-ammo-display');
            if (ammoDisplay && gameState.player.ammo) {
                var ammoTypes = [
                    { key: '9mm', icon: '🔫', label: '9mm' },
                    { key: '.308 Win', icon: '🎯', label: '.308' },
                    { key: '12 gauge', icon: '💥', label: '12ga' },
                    { key: 'arrows', icon: '🏹', label: 'Arrows' }
                ];
                var ammoParts = [];
                for (var i = 0; i < ammoTypes.length; i++) {
                    var count = gameState.player.ammo[ammoTypes[i].key] || 0;
                    if (count > 0) {
                        ammoParts.push(ammoTypes[i].icon + ' ' + ammoTypes[i].label + ': ' + count);
                    }
                }
                ammoDisplay.innerHTML = ammoParts.length > 0 ? ammoParts.join(' | ') : '<span style="color:#888;">No ammo</span>';
            }
            
            // Update weapon displays (with null checks)
            if (gameState.player.weapons) {
                var weapon1 = WEAPONS[gameState.player.weapons.slot1];
                var weapon2 = WEAPONS[gameState.player.weapons.slot2];
                var dur1 = gameState.player.weaponDurability ? gameState.player.weaponDurability.slot1 : 100;
                var dur2 = gameState.player.weaponDurability ? gameState.player.weaponDurability.slot2 : 100;

                // Weapon 1 display (name and damage only, durability is separate)
                var weapon1Text = gameState.player.weapons.slot1 + (weapon1 ? ' (Dmg: ' + weapon1.damage + ')' : '');
                document.getElementById('inv-weapon1').textContent = weapon1Text;

                // Weapon 1 durability - show ? or actual value
                var dur1El = document.getElementById('inv-weapon1-durability');
                if (revealedStats.durability1) {
                    dur1El.textContent = '[' + dur1 + '%]';
                    dur1El.style.color = getDurabilityColor(dur1);
                    dur1El.style.cursor = 'default';
                    dur1El.style.textDecoration = 'none';
                    dur1El.onclick = null;
                } else {
                    dur1El.textContent = '[?%]';
                    dur1El.style.color = '#ff0';
                    dur1El.style.cursor = 'pointer';
                    dur1El.style.textDecoration = 'underline';
                    dur1El.onclick = function() { calculateDurabilityCheck(1); };
                }

                // Show ammo for weapon 1
                var ammo1El = document.getElementById('inv-weapon1-ammo');
                if (weapon1 && weapon1.ammoType) {
                    var ammoCount1 = gameState.player.ammo[weapon1.ammoType] || 0;
                    ammo1El.textContent = '[' + ammoCount1 + ' ' + weapon1.ammoType + ']';
                    ammo1El.style.color = ammoCount1 > 0 ? '#ff0' : '#f44';
                } else {
                    ammo1El.textContent = '[∞]';
                    ammo1El.style.color = '#0f0';
                }

                // Weapon 2 display (name and damage only)
                var weapon2Text = (gameState.player.weapons.slot2 || 'Empty') + (weapon2 ? ' (Dmg: ' + weapon2.damage + ')' : '');
                document.getElementById('inv-weapon2').textContent = weapon2Text;

                // Weapon 2 durability - show ? or actual value
                var dur2El = document.getElementById('inv-weapon2-durability');
                if (weapon2) {
                    dur2El.style.display = 'inline';
                    if (revealedStats.durability2) {
                        dur2El.textContent = '[' + dur2 + '%]';
                        dur2El.style.color = getDurabilityColor(dur2);
                        dur2El.style.cursor = 'default';
                        dur2El.style.textDecoration = 'none';
                        dur2El.onclick = null;
                    } else {
                        dur2El.textContent = '[?%]';
                        dur2El.style.color = '#ff0';
                        dur2El.style.cursor = 'pointer';
                        dur2El.style.textDecoration = 'underline';
                        dur2El.onclick = function() { calculateDurabilityCheck(2); };
                    }
                } else {
                    dur2El.style.display = 'none';
                }

                // Show ammo for weapon 2
                var ammo2El = document.getElementById('inv-weapon2-ammo');
                if (weapon2 && weapon2.ammoType) {
                    var ammoCount2 = gameState.player.ammo[weapon2.ammoType] || 0;
                    ammo2El.textContent = '[' + ammoCount2 + ' ' + weapon2.ammoType + ']';
                    ammo2El.style.color = ammoCount2 > 0 ? '#ff0' : '#f44';
                } else if (weapon2) {
                    ammo2El.textContent = '[∞]';
                    ammo2El.style.color = '#0f0';
                } else {
                    ammo2El.textContent = '';
                }

                document.getElementById('inv-weapon1-active').style.display = gameState.player.activeSlot === 1 ? 'inline' : 'none';
                document.getElementById('inv-weapon2-active').style.display = gameState.player.activeSlot === 2 ? 'inline' : 'none';
            }
            
            document.getElementById('inv-medkits').textContent = gameState.player.medkits;
            document.getElementById('inv-money').textContent = formatMoney(gameState.player.money);

            // Update vitals display
            updateVitalsDisplay();

            // Tutorial: low HP warning
            if (gameState.player.hp <= 30 && gameState.player.hp > 0) {
                showTutorialTip('low_hp', 500);
            }

            // Tutorial: weight system hint (when weight exists but not revealed)
            if (!revealedStats.weight && gameState.player.inventory.length > 3) {
                showTutorialTip('first_weight', 2000);
            }
        }

        // ============ VITALS SYSTEM ============

        // Food and drink items with their effects
        var CONSUMABLES = {
            // Food items
            'Canned Beans': { type: 'food', hunger: 25, description: 'Filling but bland' },
            'Canned Meat': { type: 'food', hunger: 35, description: 'Protein-rich preserved meat' },
            'Dried Fruit': { type: 'food', hunger: 15, description: 'Light snack' },
            'Trail Mix': { type: 'food', hunger: 20, energy: 10, description: 'Nuts and dried fruit' },
            'Granola Bar': { type: 'food', hunger: 15, energy: 15, description: 'Quick energy boost' },
            'Beef Jerky': { type: 'food', hunger: 20, thirst: -5, description: 'Salty dried meat' },
            'Raw Meat': { type: 'food', hunger: 20, hp: -10, description: 'Unsafe to eat raw!' },
            'Cooked Meat': { type: 'food', hunger: 40, hp: 5, description: 'Delicious and nutritious' },
            'Stew': { type: 'food', hunger: 45, thirst: 10, warmth: 15, description: 'Warm and hearty' },
            'Bread': { type: 'food', hunger: 20, description: 'Simple but filling' },
            'Canned Soup': { type: 'food', hunger: 30, thirst: 10, warmth: 10, description: 'Warm and comforting' },
            'MRE': { type: 'food', hunger: 50, energy: 10, description: 'Military ration - very filling' },

            // Drink items
            'Water Bottle': { type: 'drink', thirst: 40, description: 'Clean drinking water' },
            'Stream Water': { type: 'drink', thirst: 25, hp: -5, description: 'Untreated water - risky' },
            'Sports Drink': { type: 'drink', thirst: 35, energy: 15, description: 'Electrolytes and hydration' },
            'Coffee': { type: 'drink', thirst: 15, energy: 30, warmth: 10, description: 'Hot and energizing' },
            'Hot Cocoa': { type: 'drink', thirst: 20, warmth: 20, energy: 5, description: 'Warm and comforting' },
            'Tea': { type: 'drink', thirst: 25, warmth: 10, energy: 10, description: 'Soothing herbal tea' }
        };

        // Cooking recipes
        var COOKING_RECIPES = {
            'Cooked Meat': {
                ingredients: [{ item: 'Raw Meat', count: 1 }],
                result: 'Cooked Meat',
                skill: 'Basic Addition'
            },
            'Stew': {
                ingredients: [
                    { item: 'Cooked Meat', count: 1 },
                    { item: 'Water Bottle', count: 1 },
                    { item: 'Canned Beans', count: 1 }
                ],
                result: 'Stew',
                skill: 'Basic Addition'
            },
            'Coffee': {
                ingredients: [
                    { item: 'Water Bottle', count: 1 }
                ],
                result: 'Coffee',
                skill: 'Basic Subtraction'
            },
            'Soup': {
                ingredients: [
                    { item: 'Water Bottle', count: 1 },
                    { item: 'Canned Beans', count: 1 }
                ],
                result: 'Soup',
                skill: 'Basic Addition'
            },
            'Hot Cocoa': {
                ingredients: [
                    { item: 'Water Bottle', count: 1 }
                ],
                result: 'Hot Cocoa',
                skill: 'Basic Addition'
            },
            'Tea': {
                ingredients: [
                    { item: 'Water Bottle', count: 1 }
                ],
                result: 'Tea',
                skill: 'Basic Addition'
            }
        };

        // Update the vitals display bars
        function updateVitalsDisplay() {
            if (!gameState.player.vitals) return;

            var vitals = gameState.player.vitals;
            var hasCritical = false;

            // Update each vital bar
            ['hunger', 'thirst', 'energy', 'warmth'].forEach(function(vital) {
                var value = Math.max(0, Math.min(100, vitals[vital]));
                var fill = document.getElementById(vital + '-fill');
                var valueEl = document.getElementById(vital + '-value');

                if (fill && valueEl) {
                    fill.style.width = value + '%';
                    valueEl.textContent = Math.round(value);

                    // Remove existing status classes
                    fill.classList.remove('critical', 'warning');

                    // Add status class based on value
                    if (value <= 15) {
                        fill.classList.add('critical');
                        hasCritical = true;
                    } else if (value <= 35) {
                        fill.classList.add('warning');
                    }
                }
            });

            // Show/hide critical warning
            var warningEl = document.getElementById('vitals-warning');
            if (warningEl) {
                warningEl.style.display = hasCritical ? 'inline' : 'none';
            }

            // Tutorial: first time vitals drop below 60
            var anyLow = vitals.hunger < 60 || vitals.thirst < 60 || vitals.energy < 60;
            if (anyLow) {
                showTutorialTip('first_vitals', 500);
            }
        }

        // Decay vitals over time/distance
        function decayVitals(distance) {
            if (!gameState.player.vitals) return;

            var v = gameState.player.vitals;

            // Base decay rates per km traveled
            var hungerDecayRate = 2;  // Lose 2 hunger per km

            // Apply greenhouse hunger reduction bonus (reduces decay rate)
            var hungerReduction = baseState.totalBenefits.hungerDecayReduction || 0;
            if (hungerReduction > 0) {
                hungerDecayRate = hungerDecayRate * (1 - hungerReduction / 100);
            }

            v.hunger = Math.max(0, v.hunger - (distance * hungerDecayRate));
            v.thirst = Math.max(0, v.thirst - (distance * 3));    // Lose 3 thirst per km (faster)
            v.energy = Math.max(0, v.energy - (distance * 1.5));  // Lose 1.5 energy per km

            // Warmth decays slowly toward ambient (50)
            if (v.warmth > 50) {
                v.warmth = Math.max(50, v.warmth - distance);
            } else if (v.warmth < 50) {
                v.warmth = Math.min(50, v.warmth + distance * 0.5);
            }

            // Apply penalties for critical vitals
            applyVitalsPenalties();

            updateVitalsDisplay();
        }

        // Apply gameplay penalties for low vitals
        function applyVitalsPenalties() {
            if (!gameState.player.vitals) return;

            var v = gameState.player.vitals;
            var hpLoss = 0;
            var messages = [];

            // Starvation damage
            if (v.hunger <= 0) {
                hpLoss += 5;
                messages.push('Starving!');
            }

            // Dehydration damage (more severe)
            if (v.thirst <= 0) {
                hpLoss += 8;
                messages.push('Severely dehydrated!');
            }

            // Exhaustion damage
            if (v.energy <= 0) {
                hpLoss += 3;
                messages.push('Collapsing from exhaustion!');
            }

            // Hypothermia/heatstroke
            if (v.warmth <= 10) {
                hpLoss += 5;
                messages.push('Freezing!');
            } else if (v.warmth >= 95) {
                hpLoss += 3;
                messages.push('Overheating!');
            }

            // Apply HP loss
            if (hpLoss > 0) {
                gameState.player.hp = Math.max(1, gameState.player.hp - hpLoss);

                // Show warning if critical
                if (messages.length > 0 && !gameState.combat) {
                    showPopup(
                        '<strong>⚠️ SURVIVAL WARNING</strong><br><br>' +
                        messages.join('<br>') + '<br><br>' +
                        'Lost ' + hpLoss + ' HP!',
                        'error',
                        'VITALS CRITICAL'
                    );
                }
            }
        }

        // Get accuracy penalty from vitals (hunger + temperature affect accuracy)
        function getVitalsAccuracyPenalty() {
            if (!gameState.player.vitals) return 0;

            var v = gameState.player.vitals;
            var penalty = 0;

            // Low hunger affects accuracy (shaky hands, lack of focus)
            if (v.hunger < 15) penalty += 15;
            else if (v.hunger < 30) penalty += 10;
            else if (v.hunger < 50) penalty += 5;

            // Extreme temperatures affect accuracy (too cold = numb/shivering, too hot = sweating/dizzy)
            if (v.warmth < 15) penalty += 15;       // Freezing
            else if (v.warmth < 30) penalty += 10;  // Very cold
            else if (v.warmth < 45) penalty += 5;   // Cold
            else if (v.warmth > 90) penalty += 15;  // Overheating
            else if (v.warmth > 80) penalty += 10;  // Very hot
            else if (v.warmth > 70) penalty += 5;   // Hot

            return penalty;
        }

        // Get AP cost multiplier from vitals (low energy increases AP costs)
        function getVitalsAPMultiplier() {
            if (!gameState.player.vitals) return 1.0;

            var v = gameState.player.vitals;

            // Low energy increases AP costs (exhaustion makes everything harder)
            if (v.energy < 15) return 1.5;       // 50% more AP cost
            else if (v.energy < 30) return 1.35; // 35% more AP cost
            else if (v.energy < 50) return 1.2;  // 20% more AP cost
            else if (v.energy < 70) return 1.1;  // 10% more AP cost

            return 1.0;
        }

        // Get vitals status text for combat UI
        function getVitalsStatusText() {
            if (!gameState.player.vitals) return '';

            var v = gameState.player.vitals;
            var status = [];

            if (v.hunger < 30) status.push('🍖 Hungry');
            if (v.thirst < 30) status.push('💧 Thirsty');
            if (v.energy < 30) status.push('😴 Exhausted');
            if (v.warmth < 30) status.push('🥶 Cold');
            if (v.warmth > 80) status.push('🥵 Hot');

            return status.join(' | ');
        }

        // Open eat menu - show available food items
        function openEatMenu() {
            var foodItems = gameState.player.inventory.filter(function(item) {
                return CONSUMABLES[item] && CONSUMABLES[item].type === 'food';
            });

            if (foodItems.length === 0) {
                showPopup('You have no food to eat!', 'error', 'NO FOOD');
                return;
            }

            // Count duplicates
            var foodCounts = {};
            foodItems.forEach(function(item) {
                foodCounts[item] = (foodCounts[item] || 0) + 1;
            });

            var html = '<strong>🍖 FOOD SUPPLIES</strong><br><br>';
            html += '<div style="max-height: 300px; overflow-y: auto;">';

            Object.keys(foodCounts).forEach(function(item) {
                var consumable = CONSUMABLES[item];
                html += '<div style="background: rgba(139, 69, 19, 0.2); padding: 8px; margin: 5px 0; border-radius: 5px; cursor: pointer;" onclick="consumeItem(\'' + item.replace(/'/g, "\\'") + '\')">';
                html += '<strong>' + item + '</strong> (x' + foodCounts[item] + ')<br>';
                html += '<small style="color: #aaa;">' + consumable.description + '</small><br>';
                html += '<small style="color: #8f8;">Hunger: +' + (consumable.hunger || 0) + '</small>';
                if (consumable.energy) html += ' <small style="color: #da70d6;">Energy: +' + consumable.energy + '</small>';
                if (consumable.hp) html += ' <small style="color: ' + (consumable.hp > 0 ? '#8f8' : '#f88') + ';">HP: ' + (consumable.hp > 0 ? '+' : '') + consumable.hp + '</small>';
                html += '</div>';
            });

            html += '</div>';
            html += '<br><button class="btn" onclick="closePopup()">CANCEL</button>';

            showPopup(html, 'info', 'EAT');
        }

        // Open drink menu
        function openDrinkMenu() {
            var drinkItems = gameState.player.inventory.filter(function(item) {
                return CONSUMABLES[item] && CONSUMABLES[item].type === 'drink';
            });

            if (drinkItems.length === 0) {
                showPopup('You have no drinks!', 'error', 'NO DRINKS');
                return;
            }

            // Count duplicates
            var drinkCounts = {};
            drinkItems.forEach(function(item) {
                drinkCounts[item] = (drinkCounts[item] || 0) + 1;
            });

            var html = '<strong>💧 DRINK SUPPLIES</strong><br><br>';
            html += '<div style="max-height: 300px; overflow-y: auto;">';

            Object.keys(drinkCounts).forEach(function(item) {
                var consumable = CONSUMABLES[item];
                html += '<div style="background: rgba(30, 144, 255, 0.2); padding: 8px; margin: 5px 0; border-radius: 5px; cursor: pointer;" onclick="consumeItem(\'' + item.replace(/'/g, "\\'") + '\')">';
                html += '<strong>' + item + '</strong> (x' + drinkCounts[item] + ')<br>';
                html += '<small style="color: #aaa;">' + consumable.description + '</small><br>';
                html += '<small style="color: #00bfff;">Thirst: +' + (consumable.thirst || 0) + '</small>';
                if (consumable.energy) html += ' <small style="color: #da70d6;">Energy: ' + (consumable.energy > 0 ? '+' : '') + consumable.energy + '</small>';
                if (consumable.warmth) html += ' <small style="color: #ffa500;">Warmth: +' + consumable.warmth + '</small>';
                if (consumable.hp) html += ' <small style="color: ' + (consumable.hp > 0 ? '#8f8' : '#f88') + ';">HP: ' + (consumable.hp > 0 ? '+' : '') + consumable.hp + '</small>';
                html += '</div>';
            });

            html += '</div>';
            html += '<br><button class="btn" onclick="closePopup()">CANCEL</button>';

            showPopup(html, 'info', 'DRINK');
        }

        // Consume a food or drink item
        function consumeItem(itemName) {
            var consumable = CONSUMABLES[itemName];
            if (!consumable) return;

            // Remove from inventory
            var idx = gameState.player.inventory.indexOf(itemName);
            if (idx === -1) {
                showPopup('Item not found!', 'error', 'ERROR');
                return;
            }
            gameState.player.inventory.splice(idx, 1);

            // Calculate effects (require math)
            var effects = [];
            var totalEffect = 0;
            var formula = '';

            if (consumable.hunger) {
                var newHunger = Math.min(100, gameState.player.vitals.hunger + consumable.hunger);
                effects.push({ vital: 'hunger', amount: consumable.hunger, newValue: newHunger });
                formula += (formula ? ' + ' : '') + consumable.hunger;
                totalEffect += consumable.hunger;
            }
            if (consumable.thirst) {
                var newThirst = Math.min(100, gameState.player.vitals.thirst + consumable.thirst);
                effects.push({ vital: 'thirst', amount: consumable.thirst, newValue: newThirst });
                formula += (formula ? ' + ' : '') + consumable.thirst;
                totalEffect += consumable.thirst;
            }
            if (consumable.energy) {
                var newEnergy = Math.min(100, Math.max(0, gameState.player.vitals.energy + consumable.energy));
                effects.push({ vital: 'energy', amount: consumable.energy, newValue: newEnergy });
            }
            if (consumable.warmth) {
                var newWarmth = Math.min(100, Math.max(0, gameState.player.vitals.warmth + consumable.warmth));
                effects.push({ vital: 'warmth', amount: consumable.warmth, newValue: newWarmth });
            }

            closePopup();

            // Require calculation for the primary effect
            var primaryVital = consumable.type === 'food' ? 'hunger' : 'thirst';
            var currentValue = gameState.player.vitals[primaryVital];
            var addValue = consumable[primaryVital] || 0;
            var expectedNew = Math.min(100, currentValue + addValue);

            requireCalculation({
                title: consumable.type === 'food' ? '🍖 EATING' : '💧 DRINKING',
                description: 'Consuming: ' + itemName + '<br><br>Current ' + primaryVital + ': ' + Math.round(currentValue) + '<br>' + itemName + ' provides: +' + addValue,
                formula: Math.round(currentValue) + ' + ' + addValue + ' = ? (max 100)',
                answer: expectedNew,
                skill: 'Basic Addition',
                context: 'vitals',
                onSuccess: function() {
                    // Apply all effects
                    effects.forEach(function(e) {
                        gameState.player.vitals[e.vital] = e.newValue;
                    });
                    if (consumable.hp) {
                        gameState.player.hp = Math.max(1, Math.min(gameState.player.maxHp, gameState.player.hp + consumable.hp));
                    }

                    updateInventoryDisplay();

                    var resultMsg = 'You consumed ' + itemName + '!<br><br>';
                    effects.forEach(function(e) {
                        var icon = e.vital === 'hunger' ? '🍖' : e.vital === 'thirst' ? '💧' : e.vital === 'energy' ? '💤' : '🌡️';
                        resultMsg += icon + ' ' + e.vital.charAt(0).toUpperCase() + e.vital.slice(1) + ': ' + (e.amount > 0 ? '+' : '') + e.amount + '<br>';
                    });
                    if (consumable.hp) {
                        resultMsg += (consumable.hp > 0 ? '❤️' : '💔') + ' HP: ' + (consumable.hp > 0 ? '+' : '') + consumable.hp;
                    }

                    showPopup(resultMsg, 'success', 'CONSUMED');
                },
                onFailure: function() {
                    // Still apply effects but reduced
                    effects.forEach(function(e) {
                        var reduced = Math.floor(e.amount * 0.5);
                        gameState.player.vitals[e.vital] = Math.min(100, Math.max(0, gameState.player.vitals[e.vital] + reduced));
                    });
                    updateInventoryDisplay();
                    showPopup('Wrong calculation! You only absorbed half the nutrients.', 'error', 'REDUCED EFFECT');
                }
            });
        }

        // Try to sleep/rest
        function tryToSleep() {
            if (gameState.combat) {
                showPopup('You cannot sleep during combat!', 'error', 'CANNOT REST');
                return;
            }

            var energy = gameState.player.vitals.energy;
            var hunger = gameState.player.vitals.hunger;
            var thirst = gameState.player.vitals.thirst;

            // Check if too hungry/thirsty to sleep well
            var warnings = [];
            if (hunger < 20) warnings.push('You\'re too hungry to sleep well.');
            if (thirst < 20) warnings.push('You\'re too thirsty to rest properly.');

            var restAmount = 40; // Base rest recovery
            if (warnings.length > 0) restAmount = 20; // Reduced if hungry/thirsty

            var html = '<strong>💤 REST</strong><br><br>';

            if (energy >= 90) {
                html += 'You\'re not tired enough to sleep.';
                html += '<br><br><button class="btn" onclick="closePopup()">OK</button>';
                showPopup(html, 'info', 'REST');
                return;
            }

            if (warnings.length > 0) {
                html += '<span style="color: #ffa500;">' + warnings.join('<br>') + '</span><br><br>';
            }

            html += 'Current energy: ' + Math.round(energy) + '<br>';
            html += 'Rest will restore: +' + restAmount + ' energy<br>';
            html += 'Time passes: vitals will decay slightly<br><br>';
            html += '<button class="btn" onclick="performRest(' + restAmount + ')">REST NOW</button> ';
            html += '<button class="btn" onclick="closePopup()">CANCEL</button>';

            showPopup(html, 'info', 'REST');
        }

        // Perform rest action
        function performRest(restAmount) {
            closePopup();

            var currentEnergy = gameState.player.vitals.energy;
            var newEnergy = Math.min(100, currentEnergy + restAmount);

            requireCalculation({
                title: '💤 RESTING',
                description: 'You settle down to rest...<br><br>Current energy: ' + Math.round(currentEnergy) + '<br>Rest bonus: +' + restAmount,
                formula: Math.round(currentEnergy) + ' + ' + restAmount + ' = ? (max 100)',
                answer: newEnergy,
                skill: 'Basic Addition',
                context: 'vitals',
                onSuccess: function() {
                    gameState.player.vitals.energy = newEnergy;

                    // Time passes - vitals decay
                    gameState.player.vitals.hunger = Math.max(0, gameState.player.vitals.hunger - 10);
                    gameState.player.vitals.thirst = Math.max(0, gameState.player.vitals.thirst - 15);

                    // Warmth normalizes toward 50
                    if (gameState.player.vitals.warmth > 50) {
                        gameState.player.vitals.warmth = Math.max(50, gameState.player.vitals.warmth - 10);
                    }

                    // Small HP recovery if well-fed
                    if (gameState.player.vitals.hunger > 50 && gameState.player.vitals.thirst > 50) {
                        gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + 10);
                    }

                    updateInventoryDisplay();

                    showPopup(
                        'You feel rested!<br><br>' +
                        '💤 Energy: +' + restAmount + '<br>' +
                        '🍖 Hunger: -10<br>' +
                        '💧 Thirst: -15',
                        'success',
                        'RESTED'
                    );
                },
                onFailure: function() {
                    // Restless sleep - less effective
                    gameState.player.vitals.energy = Math.min(100, currentEnergy + Math.floor(restAmount / 2));
                    gameState.player.vitals.hunger = Math.max(0, gameState.player.vitals.hunger - 10);
                    gameState.player.vitals.thirst = Math.max(0, gameState.player.vitals.thirst - 15);
                    updateInventoryDisplay();
                    showPopup('Restless sleep... Only partial recovery.', 'error', 'POOR REST');
                }
            });
        }

        // Open cooking menu
        function openCookingMenu() {
            var html = '<strong>🔥 COOKING</strong><br><br>';
            html += '<div style="max-height: 350px; overflow-y: auto;">';

            var hasRecipe = false;

            Object.keys(COOKING_RECIPES).forEach(function(recipeName) {
                var recipe = COOKING_RECIPES[recipeName];
                var canCraft = true;
                var ingredientList = '';

                recipe.ingredients.forEach(function(ing) {
                    var count = gameState.player.inventory.filter(function(i) { return i === ing.item; }).length;
                    var hasEnough = count >= ing.count;
                    if (!hasEnough) canCraft = false;
                    ingredientList += '<span style="color: ' + (hasEnough ? '#8f8' : '#f88') + ';">' + ing.item + ' (' + count + '/' + ing.count + ')</span><br>';
                });

                hasRecipe = true;
                var bgColor = canCraft ? 'rgba(255, 140, 0, 0.2)' : 'rgba(100, 100, 100, 0.2)';
                var clickHandler = canCraft ? 'cookRecipe(\'' + recipeName.replace(/'/g, "\\'") + '\')' : '';

                html += '<div style="background: ' + bgColor + '; padding: 8px; margin: 5px 0; border-radius: 5px;' + (canCraft ? ' cursor: pointer;' : ' opacity: 0.6;') + '"' + (canCraft ? ' onclick="' + clickHandler + '"' : '') + '>';
                html += '<strong>' + recipeName + '</strong>' + (canCraft ? ' ✓' : ' ✗') + '<br>';
                html += '<small>' + ingredientList + '</small>';

                var result = CONSUMABLES[recipe.result];
                if (result) {
                    html += '<small style="color: #aaa;">→ ' + result.description + '</small>';
                }
                html += '</div>';
            });

            if (!hasRecipe) {
                html += '<p>No recipes known yet.</p>';
            }

            html += '</div>';
            html += '<br><button class="btn" onclick="closePopup()">CANCEL</button>';

            showPopup(html, 'info', 'COOK');
        }

        // Cook a recipe
        function cookRecipe(recipeName) {
            var recipe = COOKING_RECIPES[recipeName];
            if (!recipe) return;

            // Verify ingredients
            var tempInventory = gameState.player.inventory.slice();
            var canCraft = true;

            recipe.ingredients.forEach(function(ing) {
                for (var i = 0; i < ing.count; i++) {
                    var idx = tempInventory.indexOf(ing.item);
                    if (idx === -1) {
                        canCraft = false;
                        return;
                    }
                    tempInventory.splice(idx, 1);
                }
            });

            if (!canCraft) {
                showPopup('Missing ingredients!', 'error', 'CANNOT COOK');
                return;
            }

            closePopup();

            // Calculate total ingredients for math problem
            var totalIngredients = recipe.ingredients.reduce(function(sum, ing) { return sum + ing.count; }, 0);

            requireCalculation({
                title: '🔥 COOKING: ' + recipeName,
                description: 'Combining ingredients...<br><br>Ingredients used: ' + totalIngredients + '<br>Result: 1 ' + recipeName,
                formula: totalIngredients + ' ingredients → ' + totalIngredients + ' - ' + totalIngredients + ' + 1 = ?',
                answer: 1,
                skill: recipe.skill || 'Basic Subtraction',
                context: 'cooking',
                onSuccess: function() {
                    // Remove ingredients
                    recipe.ingredients.forEach(function(ing) {
                        for (var i = 0; i < ing.count; i++) {
                            var idx = gameState.player.inventory.indexOf(ing.item);
                            if (idx !== -1) gameState.player.inventory.splice(idx, 1);
                        }
                    });

                    // Add result
                    gameState.player.inventory.push(recipe.result);

                    // Degrade portable stove if not at base
                    if (!isAtBase() && hasPortableStove()) {
                        degradeCampingEquipment('Portable Stove', 8);
                    }

                    updateInventoryDisplay();

                    showPopup('Successfully cooked ' + recipeName + '!', 'success', 'COOKED');
                },
                onFailure: function() {
                    // Lose ingredients but get nothing
                    recipe.ingredients.forEach(function(ing) {
                        for (var i = 0; i < ing.count; i++) {
                            var idx = gameState.player.inventory.indexOf(ing.item);
                            if (idx !== -1) gameState.player.inventory.splice(idx, 1);
                        }
                    });
                    updateInventoryDisplay();
                    showPopup('You burned the food! Ingredients wasted.', 'error', 'BURNED');
                }
            });
        }

        // Ammo weight per round in pounds (realistic values)
        var AMMO_WEIGHTS = {
            '9mm': 0.025,           // ~0.4 oz per round
            '.45 ACP': 0.035,       // ~0.56 oz per round
            '.45 LC': 0.04,         // ~0.64 oz per round
            '.380 ACP': 0.02,       // ~0.32 oz per round
            '.50 AE': 0.08,         // ~1.3 oz per round
            '.44 Magnum': 0.05,     // ~0.8 oz per round
            '.357 Magnum': 0.035,   // ~0.56 oz per round
            '12 gauge': 0.09,       // ~1.5 oz per shell
            '.308 Win': 0.056,      // ~0.9 oz per round
            '.30-06': 0.06,         // ~0.96 oz per round
            '.22 LR': 0.006,        // ~0.1 oz per round
            '7.62x54R': 0.06,       // ~0.96 oz per round
            '.30-30': 0.045,        // ~0.72 oz per round
            '5.56mm': 0.025,        // ~0.4 oz per round
            '7.62x39': 0.04,        // ~0.64 oz per round
            '7.62x51': 0.056,       // ~0.9 oz per round
            '.30 Carbine': 0.03,    // ~0.48 oz per round
            'arrows': 0.06,         // ~1 oz per arrow
            'bolts': 0.08           // ~1.3 oz per bolt
        };

        function calculateCarryWeight() {
            var weight = 0;

            // Equipped weapons weight
            if (gameState.player.weapons) {
                if (gameState.player.weapons.slot1) {
                    weight += getWeaponWeight(gameState.player.weapons.slot1);
                }
                if (gameState.player.weapons.slot2) {
                    weight += getWeaponWeight(gameState.player.weapons.slot2);
                }
            }

            // Med Kits weight (first aid kit ~2 lb)
            weight += (gameState.player.medkits || 0) * 2;

            // Ammo weight (tracked separately from inventory)
            if (gameState.player.ammo) {
                for (var ammoType in gameState.player.ammo) {
                    var count = gameState.player.ammo[ammoType] || 0;
                    var perRound = AMMO_WEIGHTS[ammoType] || 0.03; // Default ~0.5 oz
                    weight += count * perRound;
                }
            }

            // Inventory items (including weapon objects)
            for (var i = 0; i < gameState.player.inventory.length; i++) {
                var item = gameState.player.inventory[i];
                if (typeof item === 'object' && item.type === 'weapon') {
                    // Weapon object - get weight from category
                    weight += getWeaponWeight(item.name);
                } else if (typeof item === 'string' && ITEMS[item]) {
                    // Regular item
                    weight += ITEMS[item].weight;
                }
            }

            gameState.player.carryWeight = weight;
            return weight;
        }
        
        function canCarryItem(itemName) {
            var itemWeight = ITEMS[itemName] ? ITEMS[itemName].weight : 1;
            return (gameState.player.carryWeight + itemWeight) <= gameState.player.maxCarryWeight;
        }
        
        function addToInventory(itemName) {
            var item = ITEMS[itemName];
            
            // Special handling for ammo - add to ammo count instead of inventory
            if (item && item.type === 'ammo' && item.ammoType) {
                if (!gameState.player.ammo[item.ammoType]) {
                    gameState.player.ammo[item.ammoType] = 0;
                }
                gameState.player.ammo[item.ammoType] += item.ammoAmount;
                return true;
            }
            
            if (!canCarryItem(itemName)) {
                return false;
            }
            gameState.player.inventory.push(itemName);
            calculateCarryWeight();
            return true;
        }
        
        function removeFromInventory(itemName) {
            var index = gameState.player.inventory.indexOf(itemName);
            if (index > -1) {
                gameState.player.inventory.splice(index, 1);
                calculateCarryWeight();
                return true;
            }
            return false;
        }
        
        // ============ INVENTORY MANAGER ============
        
        function openInventoryManager() {
            document.getElementById('inventory-manager').style.display = 'block';
            document.getElementById('exploration-choices').style.display = 'none';
            renderInventoryManager();
        }
        
        function closeInventoryManager() {
            document.getElementById('inventory-manager').style.display = 'none';
            document.getElementById('exploration-choices').style.display = 'block';
        }
        
        function renderInventoryManager() {
            document.getElementById('mgr-weight').textContent = gameState.player.carryWeight.toFixed(1);
            document.getElementById('mgr-max-weight').textContent = gameState.player.maxCarryWeight;
            
            var html = '';
            
            if (gameState.player.inventory.length === 0) {
                html = '<div class="empty-inventory">No items in inventory</div>';
            } else {
                // Group items by name
                var itemCounts = {};
                for (var i = 0; i < gameState.player.inventory.length; i++) {
                    var name = gameState.player.inventory[i];
                    itemCounts[name] = (itemCounts[name] || 0) + 1;
                }
                
                for (var itemName in itemCounts) {
                    var item = ITEMS[itemName];
                    var count = itemCounts[itemName];
                    html += '<div class="inv-item-row">';
                    html += '<span class="inv-item-name">' + itemName + (count > 1 ? ' (×' + count + ')' : '') + '</span>';
                    html += '<span class="inv-item-weight">' + (item ? item.weight : 1) + ' lb</span>';
                    html += '<span class="inv-item-value">' + (item ? item.value : 0) + '💰</span>';
                    html += '<span class="inv-item-actions">';
                    if (item && item.type === 'consumable') {
                        html += '<button class="btn small support" onclick="useItem(\'' + itemName + '\')">USE</button>';
                    }
                    html += '<button class="btn small" onclick="dropItem(\'' + itemName.replace(/'/g, "\\'") + '\', false)" style="background:#a44;">DROP</button>';
                    html += '</span>';
                    html += '</div>';
                }
            }
            
            // Show ammunition - only types we have (ammo is stored separately, not in inventory)
            var ammoTypes = [
                { key: '9mm', icon: '🔫', name: '9mm Rounds' },
                { key: '.308 Win', icon: '🎯', name: '.308 Win' },
                { key: '12 gauge', icon: '💥', name: '12 Gauge' },
                { key: '5.56mm', icon: '🔫', name: '5.56mm' },
                { key: '.30-06', icon: '🎯', name: '.30-06' },
                { key: '.30-30', icon: '🎯', name: '.30-30' },
                { key: '.30 Carbine', icon: '🔫', name: '.30 Carbine' },
                { key: 'arrows', icon: '🏹', name: 'Arrows' },
                { key: 'bolts', icon: '🏹', name: 'Bolts' }
            ];
            var hasAmmo = false;
            var ammoHtml = '';
            for (var a = 0; a < ammoTypes.length; a++) {
                var ammoCount = gameState.player.ammo[ammoTypes[a].key] || 0;
                if (ammoCount > 0) {
                    hasAmmo = true;
                    ammoHtml += '<div class="inv-item-row">';
                    ammoHtml += '<span class="inv-item-name">' + ammoTypes[a].icon + ' ' + ammoTypes[a].name + '</span>';
                    ammoHtml += '<span style="color: #ff0;">' + ammoCount + '</span>';
                    ammoHtml += '<button class="btn small" onclick="dropItem(\'' + ammoTypes[a].key + '\', true)" style="background:#a44; margin-left: 10px;">DROP</button>';
                    ammoHtml += '</div>';
                }
            }
            if (hasAmmo) {
                html += '<div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #ff0;">';
                html += '<strong style="color: #ff0;">Ammunition:</strong>';
                html += ammoHtml;
                html += '</div>';
            }
            
            document.getElementById('inventory-list').innerHTML = html;
        }
        
        function useItem(itemName) {
            var item = ITEMS[itemName];
            if (!item || item.type !== 'consumable') return;
            
            removeFromInventory(itemName);
            
            if (item.effect === 'heal') {
                var healAmount = Math.floor(gameState.player.maxHp * (item.amount / 100));
                gameState.player.hp = Math.min(gameState.player.hp + healAmount, gameState.player.maxHp);
                showPopup('<strong>Used ' + itemName + '</strong><br><br>Healed ' + healAmount + ' HP!', 'success', 'ITEM USED');
            } else if (item.effect === 'ap') {
                showPopup('<strong>Used ' + itemName + '</strong><br><br>Refreshed!', 'success', 'ITEM USED');
            }
            
            updateInventoryDisplay();
            renderInventoryManager();
        }
        
        function dropItem(itemName, isAmmo) {
            // Count how many we have
            var count;
            if (isAmmo) {
                count = gameState.player.ammo[itemName] || 0;
            } else {
                count = countInventoryItem(itemName);
            }

            if (count <= 0) return;

            if (count === 1) {
                // Only one, drop it directly
                confirmDropItem(itemName, 1, isAmmo);
            } else {
                // Show quantity selector
                showDropQuantityModal(itemName, count, isAmmo);
            }
        }

        function showDropQuantityModal(itemName, maxCount, isAmmo) {
            var modal = document.createElement('div');
            modal.id = 'drop-quantity-modal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 2000;';

            var content = '<div style="background: #1a1a2e; border: 2px solid #0f0; padding: 20px; border-radius: 10px; max-width: 350px; text-align: center;">';
            content += '<h3 style="color: #0f0; margin-top: 0;">DROP ' + itemName.toUpperCase() + '</h3>';
            content += '<p>You have <strong>' + maxCount + '</strong>. How many to drop?</p>';
            content += '<div style="margin: 15px 0;">';
            content += '<input type="number" id="drop-quantity-input" min="1" max="' + maxCount + '" value="1" style="width: 80px; padding: 8px; font-size: 1.2em; text-align: center; background: #0a0a15; color: #0f0; border: 1px solid #0f0; border-radius: 5px;">';
            content += '<div style="margin-top: 10px;">';
            content += '<button class="btn small" onclick="setDropQuantity(1)" style="margin: 2px;">1</button>';
            content += '<button class="btn small" onclick="setDropQuantity(' + Math.floor(maxCount/2) + ')" style="margin: 2px;">Half</button>';
            content += '<button class="btn small" onclick="setDropQuantity(' + maxCount + ')" style="margin: 2px;">All</button>';
            content += '</div>';
            content += '</div>';
            content += '<div style="display: flex; gap: 10px; justify-content: center;">';
            content += '<button class="btn" onclick="confirmDropFromModal(\'' + itemName.replace(/'/g, "\\'") + '\', ' + isAmmo + ')" style="background: #a44;">DROP</button>';
            content += '<button class="btn" onclick="closeDropQuantityModal()">CANCEL</button>';
            content += '</div>';
            content += '</div>';

            modal.innerHTML = content;
            document.body.appendChild(modal);

            // Focus the input
            document.getElementById('drop-quantity-input').focus();
            document.getElementById('drop-quantity-input').select();
        }

        function setDropQuantity(amount) {
            var input = document.getElementById('drop-quantity-input');
            if (input) {
                input.value = Math.max(1, Math.min(amount, parseInt(input.max)));
            }
        }

        function closeDropQuantityModal() {
            var modal = document.getElementById('drop-quantity-modal');
            if (modal) modal.remove();
        }

        function confirmDropFromModal(itemName, isAmmo) {
            var input = document.getElementById('drop-quantity-input');
            var quantity = parseInt(input.value) || 1;
            var max = parseInt(input.max);
            quantity = Math.max(1, Math.min(quantity, max));

            closeDropQuantityModal();
            confirmDropItem(itemName, quantity, isAmmo);
        }

        function confirmDropItem(itemName, quantity, isAmmo) {
            if (isAmmo) {
                // Drop ammo
                var current = gameState.player.ammo[itemName] || 0;
                gameState.player.ammo[itemName] = Math.max(0, current - quantity);
            } else {
                // Drop from inventory
                for (var i = 0; i < quantity; i++) {
                    removeFromInventory(itemName);
                }
            }

            var msg = quantity > 1 ? 'Dropped ' + quantity + 'x ' + itemName : 'Dropped ' + itemName;
            showExplorationMessage(msg, 'info');
            updateInventoryDisplay();
            renderInventoryManager();
        }
        
        function nextExplorationEvent() {
            var distanceTraveled = Math.floor(Math.random() * 3) + 2;
            gameState.distance += distanceTraveled;

            // Track distance from base for return journey
            travelState.distanceFromBase += distanceTraveled;
            updateReturnButton();
            updateDistanceTierIndicator();

            // Decay vitals based on distance traveled
            decayVitals(distanceTraveled);

            updateInventoryDisplay();
            updateXPDisplay();

            var roll = Math.random();
            if (roll < 0.35) {
                // Location with enemies (35%) - RPG-style: fight then loot
                enterLocation(true);
            } else if (roll < 0.50) {
                // Empty location to search (15%) - no enemies, just loot
                enterLocation(false);
            } else if (roll < 0.62) {
                // Trading post (12%)
                document.getElementById('exploration-narrative').innerHTML = '<strong>🏪 TRADING POST!</strong><br><br>You stumble upon a wasteland merchant! They have supplies for sale.';
                var html = '<button class="btn support" onclick="openTradingPost()">🛒 BROWSE WARES<br><span style="font-size:0.85em">Buy supplies with cash</span></button>';
                html += '<button class="btn" onclick="nextExplorationEvent()">CONTINUE JOURNEY</button>';
                document.getElementById('exploration-choices').innerHTML = html;
            } else if (roll < 0.74) {
                // Crafting workbench (12%)
                document.getElementById('exploration-narrative').innerHTML = '<strong>🔧 WORKBENCH FOUND!</strong><br><br>You discover an abandoned workshop with tools and a crafting station.';
                var html = '<div style="background: rgba(139,69,19,0.1); border: 1px solid #cd853f; padding: 10px; margin: 10px 0; border-radius: 5px;">';
                // Build materials display showing only non-empty
                var matTypes = [
                    { name: 'Scrap Metal', label: 'Metal' },
                    { name: 'Chemicals', label: 'Chem' },
                    { name: 'Electronics', label: 'Elec' },
                    { name: 'Cloth', label: 'Cloth' }
                ];
                var matParts = [];
                for (var m = 0; m < matTypes.length; m++) {
                    var cnt = countInventoryItem(matTypes[m].name);
                    if (cnt > 0) matParts.push(matTypes[m].label + ': ' + cnt);
                }
                html += '<strong>Your Materials:</strong> ' + (matParts.length > 0 ? matParts.join(' | ') : 'None') + '</div>';
                html += '<button class="btn" style="background: #cd853f; color: #000;" onclick="openCraftingBench()">🔧 USE WORKBENCH<br><span style="font-size:0.85em">Craft items from materials</span></button>';
                html += '<button class="btn" onclick="scavengeMaterials()">🔍 SCAVENGE AREA<br><span style="font-size:0.85em">Search for materials</span></button>';
                html += '<button class="btn" onclick="nextExplorationEvent()">CONTINUE JOURNEY</button>';
                document.getElementById('exploration-choices').innerHTML = html;
            } else if (roll < 0.82) {
                // Radiation Zone (8%) - Middle/High school math opportunity
                enterRadiationZone();
            } else if (roll < 0.92) {
                // Resource Gathering Site (10%) - Building materials
                enterResourceSite();
            } else {
                // Rest stop / nothing special (8%)
                document.getElementById('exploration-narrative').innerHTML = '<strong>🛤️ QUIET STRETCH</strong><br><br>The path ahead is clear. A good chance to catch your breath.';
                var html = '<button class="btn" onclick="nextExplorationEvent()">CONTINUE JOURNEY</button>';
                document.getElementById('exploration-choices').innerHTML = html;
            }
        }

        // ============ RESOURCE GATHERING SITE ============
        // Forests, ruins, and junkyards for building materials

        function enterResourceSite() {
            var siteTypes = [
                { type: 'forest', name: 'FOREST GROVE', icon: '🌲', resource: 'wood', baseAmount: 8, secondaryResource: 'steel', secondaryAmount: 2 },
                { type: 'ruins', name: 'RUINED FACTORY', icon: '🏭', resource: 'steel', baseAmount: 8, secondaryResource: 'wood', secondaryAmount: 3 },
                { type: 'junkyard', name: 'JUNKYARD', icon: '🗑️', resource: 'steel', baseAmount: 6, secondaryResource: 'wood', secondaryAmount: 5 }
            ];

            var site = siteTypes[Math.floor(Math.random() * siteTypes.length)];
            var currentPrimary = baseState.resources[site.resource];
            var currentSecondary = baseState.resources[site.secondaryResource];

            document.getElementById('exploration-narrative').innerHTML =
                '<strong>' + site.icon + ' ' + site.name + '</strong><br><br>' +
                'A promising site for gathering building materials!<br><br>' +
                '<div style="background: rgba(74,103,65,0.2); border: 1px solid #4a6741; padding: 10px; border-radius: 5px;">' +
                '<strong>Available Resources:</strong><br>' +
                '🪵 Wood: ~' + site.baseAmount + ' (current: ' + currentPrimary + ')<br>' +
                '🔩 Steel: ~' + site.secondaryAmount + ' (current: ' + currentSecondary + ')' +
                '</div><br>' +
                'Gathering requires calculating how much you can carry back.';

            var html = '<button class="btn" style="background: #4a6741;" onclick="gatherResources(\'' + site.type + '\',' + site.baseAmount + ',' + site.secondaryAmount + ',\'' + site.resource + '\',\'' + site.secondaryResource + '\')">🪓 GATHER RESOURCES<br><span style="font-size:0.85em">Math problem to collect</span></button>';
            html += '<button class="btn" onclick="quickGatherResources(' + Math.floor(site.baseAmount / 2) + ',' + Math.floor(site.secondaryAmount / 2) + ',\'' + site.resource + '\',\'' + site.secondaryResource + '\')">⏩ QUICK GRAB<br><span style="font-size:0.85em">Half resources, no math</span></button>';
            html += '<button class="btn" onclick="nextExplorationEvent()">CONTINUE JOURNEY</button>';

            document.getElementById('exploration-choices').innerHTML = html;
        }

        function gatherResources(siteType, primaryAmount, secondaryAmount, primaryResource, secondaryResource) {
            var grade = getPlayerGradeLevel();
            var problem, answer, hint;

            if (['K-1', '2'].includes(grade)) {
                // Simple addition
                var current = baseState.resources[primaryResource];
                problem = 'You have ' + current + ' ' + primaryResource + '.<br>You find ' + primaryAmount + ' more.<br><br>How much ' + primaryResource + ' will you have total?';
                answer = current + primaryAmount;
                hint = current + ' + ' + primaryAmount + ' = ?';
            } else if (['3', '4'].includes(grade)) {
                // Carrying capacity calculation
                var woodWeight = 2; // lbs per wood
                var steelWeight = 5; // lbs per steel
                var totalWeight = (primaryAmount * (primaryResource === 'wood' ? woodWeight : steelWeight)) +
                                  (secondaryAmount * (secondaryResource === 'wood' ? woodWeight : steelWeight));
                problem = 'Each wood weighs ' + woodWeight + ' lbs. Each steel weighs ' + steelWeight + ' lbs.<br>' +
                          'You want to carry ' + primaryAmount + ' ' + primaryResource + ' and ' + secondaryAmount + ' ' + secondaryResource + '.<br><br>' +
                          'What is the total weight?';
                answer = totalWeight;
                hint = '(' + primaryAmount + ' × ' + (primaryResource === 'wood' ? woodWeight : steelWeight) + ') + (' + secondaryAmount + ' × ' + (secondaryResource === 'wood' ? woodWeight : steelWeight) + ')';
            } else {
                // Division - trips needed
                var carryLimit = 15;
                var totalItems = primaryAmount + secondaryAmount;
                var trips = Math.ceil(totalItems / carryLimit);
                problem = 'You can carry ' + carryLimit + ' items per trip.<br>Total items: ' + primaryAmount + ' ' + primaryResource + ' + ' + secondaryAmount + ' ' + secondaryResource + ' = ' + totalItems + ' items.<br><br>How many trips to carry everything? (Round up)';
                answer = trips;
                hint = totalItems + ' ÷ ' + carryLimit + ' = ? (round up)';
            }

            requireCalculation({
                title: '🪓 RESOURCE GATHERING',
                description: problem,
                formula: hint,
                answer: answer,
                xpReward: 0,
                context: 'gathering',
                onSuccess: function() {
                    // Award full resources
                    baseState.resources[primaryResource] += primaryAmount;
                    baseState.resources[secondaryResource] += secondaryAmount;

                    showPopup(
                        '<strong>🪓 GATHERED!</strong><br><br>' +
                        (primaryResource === 'wood' ? '🪵' : '🔩') + ' ' + primaryResource.charAt(0).toUpperCase() + primaryResource.slice(1) + ': +' + primaryAmount + '<br>' +
                        (secondaryResource === 'wood' ? '🪵' : '🔩') + ' ' + secondaryResource.charAt(0).toUpperCase() + secondaryResource.slice(1) + ': +' + secondaryAmount,
                        'success',
                        'RESOURCES COLLECTED'
                    );

                    var originalClose = closePopup;
                    closePopup = function() {
                        document.getElementById('popup-overlay').classList.remove('active');
                        closePopup = originalClose;
                        nextExplorationEvent();
                    };
                },
                onFailure: function() {
                    // Partial resources
                    var partialPrimary = Math.floor(primaryAmount / 2);
                    var partialSecondary = Math.floor(secondaryAmount / 2);
                    baseState.resources[primaryResource] += partialPrimary;
                    baseState.resources[secondaryResource] += partialSecondary;

                    showPopup(
                        '<strong>Miscalculation!</strong><br><br>' +
                        'You dropped some materials. Only got half:<br>' +
                        (primaryResource === 'wood' ? '🪵' : '🔩') + ' ' + primaryResource.charAt(0).toUpperCase() + primaryResource.slice(1) + ': +' + partialPrimary + '<br>' +
                        (secondaryResource === 'wood' ? '🪵' : '🔩') + ' ' + secondaryResource.charAt(0).toUpperCase() + secondaryResource.slice(1) + ': +' + partialSecondary,
                        'info',
                        'PARTIAL GATHER'
                    );

                    var originalClose = closePopup;
                    closePopup = function() {
                        document.getElementById('popup-overlay').classList.remove('active');
                        closePopup = originalClose;
                        nextExplorationEvent();
                    };
                }
            });
        }

        function quickGatherResources(primaryAmount, secondaryAmount, primaryResource, secondaryResource) {
            baseState.resources[primaryResource] += primaryAmount;
            baseState.resources[secondaryResource] += secondaryAmount;

            showPopup(
                '<strong>⏩ QUICK GRAB</strong><br><br>' +
                'You grab what you can and move on:<br>' +
                (primaryResource === 'wood' ? '🪵' : '🔩') + ' ' + primaryResource.charAt(0).toUpperCase() + primaryResource.slice(1) + ': +' + primaryAmount + '<br>' +
                (secondaryResource === 'wood' ? '🪵' : '🔩') + ' ' + secondaryResource.charAt(0).toUpperCase() + secondaryResource.slice(1) + ': +' + secondaryAmount,
                'info',
                'RESOURCES COLLECTED'
            );

            var originalClose = closePopup;
            closePopup = function() {
                document.getElementById('popup-overlay').classList.remove('active');
                closePopup = originalClose;
                nextExplorationEvent();
            };
        }
        
        // ============ RADIATION ZONE SYSTEM ============
        // Features exponential decay, half-life calculations for middle/high school
        
        function enterRadiationZone() {
            var initialRads = [80, 100, 120, 160][Math.floor(Math.random() * 4)];
            var halfLife = [1, 2][Math.floor(Math.random() * 2)]; // hours
            var hoursToWait = Math.floor(Math.random() * 3) + 1;
            var lootQuality = ['common', 'rare', 'legendary'][Math.floor(Math.random() * 3)];
            
            var lootRewards = {
                common: { money: 3000, medkits: 1, materials: 3 },  // $30.00
                rare: { money: 6000, medkits: 2, materials: 5 },     // $60.00
                legendary: { money: 10000, medkits: 3, materials: 8 } // $100.00
            };
            
            document.getElementById('exploration-narrative').innerHTML = 
                '<strong>☢️ RADIATION ZONE!</strong><br><br>' +
                'Your Geiger counter crackles - radiation ahead!<br><br>' +
                '<div style="background: rgba(255,165,0,0.2); border: 1px solid #ffa500; padding: 10px; border-radius: 5px;">' +
                '<strong>Radiation Level:</strong> ' + initialRads + ' rads<br>' +
                '<strong>Half-life:</strong> ' + halfLife + ' hour(s)<br>' +
                '<strong>Loot Quality:</strong> <span style="color: ' + 
                    (lootQuality === 'legendary' ? '#ffd700' : lootQuality === 'rare' ? '#a855f7' : '#aaa') + 
                    ';">' + lootQuality.toUpperCase() + '</span>' +
                '</div><br>' +
                'You can wait for radiation to decay, or risk entering now!';
            
            var html = '<button class="btn" style="background: #ffa500; color: #000;" onclick="calculateRadDecay(' + 
                initialRads + ',' + halfLife + ',' + hoursToWait + ',\'' + lootQuality + '\')">⏳ WAIT ' + hoursToWait + ' HOUR(S)<br>' +
                '<span style="font-size:0.85em">Calculate decay (safer)</span></button>';
            html += '<button class="btn combat" onclick="rushRadZone(' + initialRads + ',\'' + lootQuality + '\')">☢️ RUSH IN NOW<br>' +
                '<span style="font-size:0.85em">Take full radiation damage</span></button>';
            html += '<button class="btn" onclick="nextExplorationEvent()">AVOID ZONE</button>';
            
            document.getElementById('exploration-choices').innerHTML = html;
        }
        
        function calculateRadDecay(initialRads, halfLife, hours, lootQuality) {
            var grade = getPlayerGradeLevel();
            
            // Calculate final radiation after decay
            var halfLivesPassed = hours / halfLife;
            var finalRads = Math.round(initialRads / Math.pow(2, halfLivesPassed));
            var damage = Math.floor(finalRads / 4); // Radiation damage
            
            if (grade === '9-12') {
                // High school: Use the exponential decay formula
                // N(t) = N₀ × (1/2)^(t/halfLife)
                requireCalculation({
                    title: '☢️ EXPONENTIAL DECAY',
                    description: '<strong>Radiation Decay Formula:</strong><br>' +
                        'N(t) = N₀ × (½)^(t/T)<br><br>' +
                        'N₀ = ' + initialRads + ' rads (initial)<br>' +
                        't = ' + hours + ' hours (time waited)<br>' +
                        'T = ' + halfLife + ' hours (half-life)<br><br>' +
                        'N(' + hours + ') = ' + initialRads + ' × (½)^(' + hours + '/' + halfLife + ')<br>' +
                        'N(' + hours + ') = ' + initialRads + ' × (½)^' + halfLivesPassed,
                    formula: initialRads + ' ÷ 2^' + halfLivesPassed + ' = ?',
                    answer: finalRads,
                    xpReward: 40,
                    context: 'exploration',
                    onSuccess: function(rads) {
                        processRadZoneEntry(rads, lootQuality, true);
                    },
                    onFailure: function() {
                        // Miscalculated - take more damage
                        processRadZoneEntry(initialRads, lootQuality, false);
                    }
                });
            } else if (grade === '7-8') {
                // Middle school: Simpler half-life calculation
                requireCalculation({
                    title: '☢️ HALF-LIFE DECAY',
                    description: '<strong>Half-Life Calculation:</strong><br><br>' +
                        'Initial radiation: ' + initialRads + ' rads<br>' +
                        'Half-life: ' + halfLife + ' hour(s)<br>' +
                        'Time waited: ' + hours + ' hours<br><br>' +
                        'After each half-life, radiation is halved.<br>' +
                        'Number of half-lives: ' + hours + ' ÷ ' + halfLife + ' = ' + halfLivesPassed,
                    formula: initialRads + ' ÷ ' + Math.pow(2, halfLivesPassed) + ' = ?',
                    answer: finalRads,
                    xpReward: 35,
                    context: 'exploration',
                    onSuccess: function(rads) {
                        processRadZoneEntry(rads, lootQuality, true);
                    },
                    onFailure: function() {
                        processRadZoneEntry(initialRads, lootQuality, false);
                    }
                });
            } else {
                // Lower grades: Simple division
                var divisor = Math.pow(2, halfLivesPassed);
                requireCalculation({
                    title: '☢️ RADIATION DECAY',
                    description: 'Radiation decreases over time!<br><br>' +
                        'Starting radiation: ' + initialRads + ' rads<br>' +
                        'It halves ' + halfLivesPassed + ' time(s).<br>' +
                        'Divide by ' + divisor + ':',
                    formula: initialRads + ' ÷ ' + divisor + ' = ?',
                    answer: finalRads,
                    xpReward: 20,
                    context: 'exploration',
                    onSuccess: function(rads) {
                        processRadZoneEntry(rads, lootQuality, true);
                    },
                    onFailure: function() {
                        processRadZoneEntry(initialRads, lootQuality, false);
                    }
                });
            }
        }
        
        function rushRadZone(rads, lootQuality) {
            var damage = Math.floor(rads / 3);
            var currentHP = gameState.player.hp;
            
            requireCalculation({
                title: '☢️ RADIATION DAMAGE',
                description: '<strong>RUSHING THROUGH RADIATION!</strong><br><br>' +
                    'Radiation level: ' + rads + ' rads<br>' +
                    'Damage = rads ÷ 3<br>' +
                    'Your HP: ' + currentHP,
                formula: 'Damage: ' + rads + ' ÷ 3 = ?',
                answer: damage,
                xpReward: 15,
                context: 'exploration',
                onSuccess: function(dmg) {
                    requireCalculation({
                        title: '💔 APPLY RAD DAMAGE',
                        description: 'You took ' + dmg + ' radiation damage!<br>Current HP: ' + currentHP,
                        formula: currentHP + ' - ' + dmg + ' = ?',
                        answer: currentHP - dmg,
                        xpReward: 10,
                        context: 'exploration',
                        onSuccess: function(newHP) {
                            gameState.player.hp = newHP;
                            if (newHP <= 0) {
                                gameState.player.hp = 0;
                                updateInventoryDisplay();
                                showPopup('<strong>☢️ RADIATION DEATH</strong><br><br>The radiation was too much...', 'error', 'DEATH');
                                var origClose = closePopup;
                                closePopup = function() {
                                    document.getElementById('popup-overlay').classList.remove('active');
                                    closePopup = origClose;
                                    defeat();
                                };
                            } else {
                                updateInventoryDisplay();
                                giveRadZoneLoot(lootQuality, dmg);
                            }
                        },
                        onFailure: function() {
                            var extraDmg = Math.floor(dmg * 0.5);
                            gameState.player.hp = currentHP - dmg - extraDmg;
                            if (gameState.player.hp <= 0) gameState.player.hp = 0;
                            updateInventoryDisplay();
                            if (gameState.player.hp <= 0) {
                                showPopup('<strong>☢️ RADIATION DEATH</strong><br><br>Panicked and absorbed extra rads!', 'error', 'DEATH');
                                var origClose = closePopup;
                                closePopup = function() {
                                    document.getElementById('popup-overlay').classList.remove('active');
                                    closePopup = origClose;
                                    defeat();
                                };
                            } else {
                                giveRadZoneLoot(lootQuality, dmg + extraDmg);
                            }
                        }
                    });
                },
                onFailure: function() {
                    // Take full damage
                    var fullDmg = Math.floor(rads / 2);
                    gameState.player.hp = currentHP - fullDmg;
                    if (gameState.player.hp <= 0) gameState.player.hp = 0;
                    updateInventoryDisplay();
                    if (gameState.player.hp <= 0) {
                        showPopup('<strong>☢️ RADIATION DEATH</strong><br><br>Miscalculated and absorbed lethal dose!', 'error', 'DEATH');
                        var origClose = closePopup;
                        closePopup = function() {
                            document.getElementById('popup-overlay').classList.remove('active');
                            closePopup = origClose;
                            defeat();
                        };
                    } else {
                        giveRadZoneLoot(lootQuality, fullDmg);
                    }
                }
            });
        }
        
        function processRadZoneEntry(rads, lootQuality, calculatedCorrectly) {
            var damage = Math.floor(rads / 4);
            var currentHP = gameState.player.hp;
            
            if (!calculatedCorrectly) {
                damage = Math.floor(damage * 1.5); // More damage for wrong calculation
            }
            
            if (damage <= 0) {
                // Safe to enter!
                showPopup(
                    '<strong>☢️ RADIATION SAFE!</strong><br><br>' +
                    'Radiation decayed to safe levels!<br>' +
                    'No damage taken.',
                    'success',
                    'SAFE ENTRY'
                );
                var origClose = closePopup;
                closePopup = function() {
                    document.getElementById('popup-overlay').classList.remove('active');
                    closePopup = origClose;
                    giveRadZoneLoot(lootQuality, 0);
                };
            } else {
                requireCalculation({
                    title: '💔 RADIATION DAMAGE',
                    description: (calculatedCorrectly ? 'Some radiation remains!' : 'WRONG! Higher radiation than expected!') + 
                        '<br><br>Remaining rads: ' + rads + '<br>Damage = rads ÷ 4<br>Your HP: ' + currentHP,
                    formula: currentHP + ' - ' + damage + ' = ?',
                    answer: currentHP - damage,
                    xpReward: 10,
                    context: 'exploration',
                    onSuccess: function(newHP) {
                        gameState.player.hp = newHP;
                        updateInventoryDisplay();
                        if (newHP <= 0) {
                            showPopup('<strong>☢️ RADIATION DEATH</strong>', 'error', 'DEATH');
                            var origClose = closePopup;
                            closePopup = function() {
                                document.getElementById('popup-overlay').classList.remove('active');
                                closePopup = origClose;
                                defeat();
                            };
                        } else {
                            giveRadZoneLoot(lootQuality, damage);
                        }
                    },
                    onFailure: function() {
                        var extraDmg = Math.floor(damage * 0.5);
                        gameState.player.hp = currentHP - damage - extraDmg;
                        if (gameState.player.hp <= 0) gameState.player.hp = 0;
                        updateInventoryDisplay();
                        if (gameState.player.hp <= 0) {
                            showPopup('<strong>☢️ RADIATION DEATH</strong>', 'error', 'DEATH');
                            var origClose = closePopup;
                            closePopup = function() {
                                document.getElementById('popup-overlay').classList.remove('active');
                                closePopup = origClose;
                                defeat();
                            };
                        } else {
                            giveRadZoneLoot(lootQuality, damage + extraDmg);
                        }
                    }
                });
            }
        }
        
        function giveRadZoneLoot(quality, damageTaken) {
            var lootRewards = {
                common: { money: 3000, medkits: 1, materials: 3 },  // $30.00
                rare: { money: 6000, medkits: 2, materials: 5 },     // $60.00
                legendary: { money: 10000, medkits: 3, materials: 8 } // $100.00
            };
            var rewards = lootRewards[quality];
            
            showPopup(
                '<strong>☢️ ZONE CLEARED!</strong><br><br>' +
                (damageTaken > 0 ? 'Took ' + damageTaken + ' radiation damage.<br><br>' : '') +
                '<strong>' + quality.toUpperCase() + ' LOOT:</strong><br>' +
                '💵 ' + formatMoney(rewards.money) + '<br>' +
                '💉 ' + rewards.medkits + ' stimpak(s)<br>' +
                '📦 ' + rewards.materials + ' materials<br><br>' +
                'Calculate to collect!',
                'success',
                'LOOT FOUND'
            );
            
            var currentMoney = gameState.player.money;
            
            var origClose = closePopup;
            closePopup = function() {
                document.getElementById('popup-overlay').classList.remove('active');
                closePopup = origClose;
                
                requireCalculation({
                    title: '💰 RAD ZONE LOOT',
                    description: 'Cash found: ' + formatMoney(rewards.money) + '<br>Your cash: ' + formatMoney(currentMoney),
                    formula: formatMoney(currentMoney) + ' + ' + formatMoney(rewards.money),
                    answer: currentMoney + rewards.money,
                    isMoney: true,
                    xpReward: 15,
                    context: 'exploration',
                    onSuccess: function(newMoney) {
                        gameState.player.money = newMoney;
                        gameState.player.medkits += rewards.medkits;
                        addMaterial('Scrap Metal', Math.floor(rewards.materials / 2));
                        addMaterial('Chemicals', Math.ceil(rewards.materials / 2));
                        updateInventoryDisplay();
                        
                        awardXP(30, 'radiation zone');
                        processPendingCalcs(function() {
                            nextExplorationEvent();
                        });
                    },
                    onFailure: function() {
                        gameState.player.money += Math.floor(rewards.money / 2);
                        gameState.player.medkits += 1;
                        updateInventoryDisplay();
                        nextExplorationEvent();
                    }
                });
            };
        }
        
        function scavengeMaterials() {
            // Find random materials (crafting + building)
            var found = {
                metal: Math.floor(Math.random() * 4) + 1,
                chem: Math.floor(Math.random() * 3),
                elec: Math.floor(Math.random() * 2),
                cloth: Math.floor(Math.random() * 3) + 1,
                wood: Math.floor(Math.random() * 3) + 1,
                steel: Math.floor(Math.random() * 2)
            };

            addMaterial('Scrap Metal', found.metal);
            addMaterial('Chemicals', found.chem);
            addMaterial('Electronics', found.elec);
            addMaterial('Cloth', found.cloth);

            // Add building materials
            baseState.resources.wood += found.wood;
            baseState.resources.steel += found.steel;

            var foundText = '';
            if (found.metal > 0) foundText += 'Scrap Metal +' + found.metal + '<br>';
            if (found.chem > 0) foundText += 'Chemicals +' + found.chem + '<br>';
            if (found.elec > 0) foundText += 'Electronics +' + found.elec + '<br>';
            if (found.cloth > 0) foundText += 'Cloth +' + found.cloth + '<br>';
            if (found.wood > 0) foundText += '🪵 Wood +' + found.wood + '<br>';
            if (found.steel > 0) foundText += '🔩 Steel +' + found.steel + '<br>';

            showPopup(
                '<strong>🔍 SCAVENGED!</strong><br><br>' +
                foundText,
                'success',
                'MATERIALS FOUND'
            );

            updateInventoryDisplay();

            var originalClose = closePopup;
            closePopup = function() {
                document.getElementById('popup-overlay').classList.remove('active');
                closePopup = originalClose;
                nextExplorationEvent();
            };
        }
        
        function chooseExploration(action) {
            if (action === 'engage') {
                startCombat();
            } else if (action === 'sneak') {
                gameState.explorationAction = action;
                var problem = generateSneakProblem();
                gameState.currentProblem = { answer: problem.answer, action: action, xpReward: problem.xpReward };
                document.getElementById('exploration-choices').style.display = 'none';
                document.getElementById('exploration-math').style.display = 'block';
                document.getElementById('explore-problem').innerHTML = problem.question;
                document.getElementById('explore-answer').value = '';
                document.getElementById('explore-answer').focus();
            }
        }
        
        function generateSneakProblem() {
            var grade = getPlayerGradeLevel();
            var question, answer, xpReward;
            
            if (grade === 'K-1') {
                var stealth = Math.floor(Math.random() * 5) + 3;
                var noise = Math.floor(Math.random() * 3) + 1;
                answer = stealth - noise;
                question = '<strong>🤫 SNEAK CHECK</strong><br><br>';
                question += 'Your stealth skill: ' + stealth + '<br>';
                question += 'Noise you made: ' + noise + '<br><br>';
                question += '<strong>' + stealth + ' - ' + noise + ' = ?</strong>';
                xpReward = 8;
            } else if (grade === '2') {
                var base = 50;
                var bonus = Math.floor(Math.random() * 20) + 10;
                var penalty = Math.floor(Math.random() * 15) + 5;
                answer = base + bonus - penalty;
                question = '<strong>🤫 SNEAK CHECK</strong><br><br>';
                question += 'Base chance: ' + base + '%<br>';
                question += 'Shadow bonus: +' + bonus + '%<br>';
                question += 'Enemy alertness: -' + penalty + '%<br><br>';
                question += '<strong>' + base + ' + ' + bonus + ' - ' + penalty + ' = ?</strong>';
                xpReward = 12;
            } else if (grade === '3') {
                var enemies = Math.floor(Math.random() * 4) + 2;
                var detectChance = Math.floor(Math.random() * 10) + 5;
                answer = enemies * detectChance;
                question = '<strong>🤫 SNEAK CHECK</strong><br><br>';
                question += 'Number of enemies: ' + enemies + '<br>';
                question += 'Each has ' + detectChance + '% detection chance<br><br>';
                question += 'Total detection risk:<br><strong>' + enemies + ' × ' + detectChance + ' = ?</strong>';
                xpReward = 15;
            } else if (grade === '4') {
                var base = 60;
                var modifier = Math.floor(Math.random() * 5) + 2;
                var penalty = modifier * 5;
                answer = base - penalty;
                question = '<strong>🤫 SNEAK CHECK</strong><br><br>';
                question += 'Base success: ' + base + '%<br>';
                question += 'Difficulty multiplier: ' + modifier + ' × 5 = ' + penalty + '<br><br>';
                question += 'Final chance:<br><strong>' + base + ' - ' + penalty + ' = ?</strong>';
                xpReward = 20;
            } else if (grade === '5-6') {
                var base = 80;
                var reduction = 25;
                var amount = Math.floor(base * reduction / 100);
                answer = base - amount;
                question = '<strong>🤫 SNEAK CHECK</strong><br><br>';
                question += 'Base stealth: ' + base + '%<br>';
                question += 'Enemy perception reduces by ' + reduction + '%<br><br>';
                question += reduction + '% of ' + base + ' = ' + amount + '<br>';
                question += '<strong>' + base + ' - ' + amount + ' = ?</strong>';
                xpReward = 25;
            } else {
                var perception = Math.floor(Math.random() * 5) + 3;
                var stealth = Math.floor(Math.random() * 5) + 5;
                var distSquared = perception * perception + stealth * stealth;
                var distance = Math.sqrt(distSquared);
                answer = Math.round(distance * 10) / 10;
                question = '<strong>🤫 SNEAK CHECK</strong><br><br>';
                question += 'Detection vector calculation:<br>';
                question += '√(' + perception + '² + ' + stealth + '²) = √' + distSquared + '<br><br>';
                question += '<strong>= ? (round to 1 decimal)</strong>';
                xpReward = 30;
            }
            
            return { question: question, answer: answer, xpReward: xpReward };
        }
        
        function generateFleeProblem() {
            var grade = getPlayerGradeLevel();
            var question, answer, xpReward;
            
            if (grade === 'K-1') {
                var your = Math.floor(Math.random() * 5) + 5;
                var enemy = Math.floor(Math.random() * 3) + 2;
                answer = your - enemy;
                question = '<strong>🏃 ESCAPE CHECK</strong><br><br>';
                question += 'Your speed: ' + your + '<br>';
                question += 'Enemy speed: ' + enemy + '<br><br>';
                question += 'How much faster are you?<br><strong>' + your + ' - ' + enemy + ' = ?</strong>';
                xpReward = 8;
            } else if (grade === '2') {
                var yourSpeed = 8;
                var enemySpeed = 5;
                var time = Math.floor(Math.random() * 4) + 2;
                answer = (yourSpeed - enemySpeed) * time;
                question = '<strong>🏃 ESCAPE CHECK</strong><br><br>';
                question += 'You run at ' + yourSpeed + ' m/s<br>';
                question += 'Enemy runs at ' + enemySpeed + ' m/s<br>';
                question += 'Time: ' + time + ' seconds<br><br>';
                question += 'Gap = (' + yourSpeed + ' - ' + enemySpeed + ') × ' + time + '<br><strong>= ?</strong>';
                xpReward = 12;
            } else if (grade === '3') {
                var distance = Math.floor(Math.random() * 30) + 20;
                var speed = Math.floor(Math.random() * 5) + 5;
                answer = Math.floor(distance / speed);
                question = '<strong>🏃 ESCAPE CHECK</strong><br><br>';
                question += 'Distance to safety: ' + distance + ' meters<br>';
                question += 'Your speed: ' + speed + ' m/s<br><br>';
                question += 'Time needed:<br><strong>' + distance + ' ÷ ' + speed + ' = ?</strong>';
                xpReward = 15;
            } else if (grade === '4') {
                var yourDist = Math.floor(Math.random() * 20) + 15;
                var enemyDist = Math.floor(Math.random() * 10) + 8;
                answer = yourDist * enemyDist;
                question = '<strong>🏃 ESCAPE CHECK</strong><br><br>';
                question += 'You cover ' + yourDist + ' meters per burst<br>';
                question += 'You need ' + enemyDist + ' bursts to escape<br><br>';
                question += 'Total distance:<br><strong>' + yourDist + ' × ' + enemyDist + ' = ?</strong>';
                xpReward = 20;
            } else if (grade === '5-6') {
                var stamina = 100;
                var drain = 15;
                answer = Math.floor(stamina / drain);
                question = '<strong>🏃 ESCAPE CHECK</strong><br><br>';
                question += 'Stamina: ' + stamina + ' points<br>';
                question += 'Drain per second: ' + drain + ' points<br><br>';
                question += 'How many seconds can you run?<br><strong>' + stamina + ' ÷ ' + drain + ' = ?</strong>';
                xpReward = 25;
            } else {
                var yourSpeed = 8;
                var enemySpeed = 6;
                var time = 5;
                var yourDist = yourSpeed * time;
                var enemyDist = enemySpeed * time;
                answer = yourDist - enemyDist;
                question = '<strong>🏃 ESCAPE CHECK</strong><br><br>';
                question += 'Your speed: ' + yourSpeed + ' m/s | Enemy: ' + enemySpeed + ' m/s<br>';
                question += 'After ' + time + ' seconds:<br>';
                question += 'You: ' + yourSpeed + ' × ' + time + ' = ' + yourDist + 'm<br>';
                question += 'Enemy: ' + enemySpeed + ' × ' + time + ' = ' + enemyDist + 'm<br><br>';
                question += '<strong>Gap = ' + yourDist + ' - ' + enemyDist + ' = ?</strong>';
                xpReward = 30;
            }
            
            return { question: question, answer: answer, xpReward: xpReward };
        }
        
        function submitExplorationAnswer() {
            var userAnswer = parseFloat(document.getElementById('explore-answer').value);
            if (isNaN(userAnswer)) {
                showExplorationMessage('Enter a number', 'error');
                return;
            }
            
            var action = gameState.currentProblem.action;
            var correct = Math.abs(userAnswer - gameState.currentProblem.answer) < 0.1;
            
            recordMathResult(correct);
            
            document.getElementById('exploration-math').style.display = 'none';
            document.getElementById('exploration-choices').style.display = 'block';
            
            if (action === 'sneak') {
                if (correct) {
                    var xpText = awardXP(gameState.currentProblem.xpReward, 'sneak math');
                    var roll = Math.random() * 100;
                    if (roll < 55) {
                        // Check if we're at a location - if so, can still search but enemies remain
                        var atLocation = gameState.inLocation && currentLocation;
                        showPopup(
                            '<strong>🤫 SNEAKED PAST!</strong><br><br>' +
                            'You successfully avoided the enemy!' +
                            (atLocation ? '<br><span style="color: #ff0;">You can search quickly, but enemies are still here!</span>' : '') +
                            '<br><br>' + xpText,
                            'success',
                            'STEALTH SUCCESS'
                        );
                        var originalClose = closePopup;
                        closePopup = function() {
                            document.getElementById('popup-overlay').classList.remove('active');
                            closePopup = originalClose;
                            if (atLocation) {
                                // Allow quick search but don't mark as cleared
                                showLocationSearch();
                            } else {
                                nextExplorationEvent();
                            }
                        };
                    } else {
                        showExplorationMessage('Detected despite good math! Roll: ' + Math.floor(roll), 'error');
                        setTimeout(startCombat, 1500);
                    }
                } else {
                    showPopup(
                        '<strong>✗ MATH ERROR!</strong><br><br>' +
                        'Your answer: ' + userAnswer + '<br>' +
                        'Correct: ' + gameState.currentProblem.answer + '<br><br>' +
                        'The noise alerts the enemy!',
                        'error',
                        'DETECTED!'
                    );
                    var originalClose = closePopup;
                    closePopup = function() {
                        document.getElementById('popup-overlay').classList.remove('active');
                        closePopup = originalClose;
                        startCombat();
                    };
                }
            }
            
            updateXPDisplay();
        }
        
        function cancelExploration() {
            document.getElementById('exploration-math').style.display = 'none';
            document.getElementById('exploration-choices').style.display = 'block';
        }
        
        function showExplorationMessage(text, type) {
            var msg = document.createElement('div');
            msg.className = 'message ' + type;
            msg.textContent = text;
            document.getElementById('exploration-messages').appendChild(msg);
            setTimeout(function() {
                if (msg.parentNode) msg.parentNode.removeChild(msg);
            }, 2000);
        }
        
        // ============ COMBAT SYSTEM ============
        
        function startCombat() {
            var encounter = encounterTypes[Math.floor(Math.random() * encounterTypes.length)];

            // Get distance tier for difficulty scaling
            var tier = getDistanceTier();

            // Player starts on left side (1, 5) - middle left
            var playerX = 1;
            var playerY = 5;

            // Determine number of enemies (default 1)
            // Extra enemies start at Danger Zone (25km+), +1 per 25km
            var baseEnemyCount = encounter.enemyCount || 1;
            var distanceFromBase = travelState.distanceFromBase || 0;
            var extraEnemies = distanceFromBase >= 25 ? Math.floor(distanceFromBase / 25) : 0;
            extraEnemies = Math.min(extraEnemies, 4); // Cap at +4 extra enemies
            var enemyCount = baseEnemyCount + extraEnemies;
            var enemies = [];

            // Generate spawn positions for enemies on right side of grid
            // Spread them out vertically and slightly horizontally
            var spawnPositions = [];
            if (enemyCount === 1) {
                spawnPositions = [{x: 10, y: 4 + Math.floor(Math.random() * 2)}];
            } else {
                // Distribute enemies in a formation on the right side
                var verticalSpacing = Math.floor(8 / enemyCount);
                for (var i = 0; i < enemyCount; i++) {
                    var yPos = 1 + Math.floor(i * verticalSpacing) + Math.floor(Math.random() * 2);
                    yPos = Math.min(Math.max(yPos, 1), 8); // Keep within grid bounds
                    var xPos = 9 + Math.floor(Math.random() * 2); // x: 9 or 10

                    // Avoid duplicate positions
                    var positionTaken = spawnPositions.some(function(p) {
                        return p.x === xPos && p.y === yPos;
                    });
                    if (positionTaken) {
                        xPos = xPos === 9 ? 10 : 9;
                        if (spawnPositions.some(function(p) { return p.x === xPos && p.y === yPos; })) {
                            yPos = Math.min(yPos + 1, 8);
                        }
                    }
                    spawnPositions.push({x: xPos, y: yPos});
                }
            }

            // Create enemy objects with scaled HP based on distance tier
            var scaledHP = Math.floor(encounter.hp * tier.enemyMult);
            for (var j = 0; j < enemyCount; j++) {
                enemies.push({
                    id: j,
                    name: encounter.name + (enemyCount > 1 ? ' #' + (j + 1) : ''),
                    baseName: encounter.name,
                    hp: scaledHP,
                    maxHp: scaledHP,
                    x: spawnPositions[j].x,
                    y: spawnPositions[j].y,
                    type: encounter.type,
                    alive: true
                });
            }

            // Select battlefield (70% specific location, 30% encounter's own layout)
            var battlefieldData = selectBattlefield(encounter);
            var battlefield = battlefieldData.location;

            gameState.combat = {
                player: { x: playerX, y: playerY },
                enemies: enemies,
                targetedEnemy: 0, // Index of currently targeted enemy
                encounterName: encounter.name, // Original encounter name for display
                encounterData: encounter, // Full encounter data for skinning etc.
                isRare: encounter.rare || false,
                distanceTier: tier, // Store tier for loot calculation
                // Battlefield info
                battlefield: battlefield,
                // Legacy single enemy reference for backward compatibility
                enemy: enemies[0],
                cover: battlefieldData.cover,
                hazards: battlefieldData.hazards,
                traps: battlefieldData.traps,
                ap: 100,
                maxAp: 100,
                // Accuracy bonuses from tactical actions
                inCover: false,         // Player is mounted to cover (+15% accuracy)
                steadyAim: false,       // Player used breathing technique (+10% accuracy, next attack only)
                // XP tracker for consolidated end-of-combat calculation
                xpTracker: {
                    tactics: [],      // Movement, positioning (10 XP each)
                    combat: [],       // Attack math, damage calcs (15-20 XP each)
                    special: [],      // Hazards, traps, medkits (10-25 XP each)
                    defense: []       // Enemy damage calculations (10 XP each)
                }
            };

            gameState.mode = null;
            gameState.selectedCell = null;
            gameState.currentAction = null;
            gameState.currentProblem = null;

            // Hide save button during combat
            updateSaveButtonVisibility();

            // Build combat title with location info
            var combatTitle = '<strong>COMBAT:</strong> ' + encounter.description;
            if (enemies.length > 1) {
                combatTitle += ' (' + enemies.length + ' enemies)';
            }

            // Add battlefield location
            combatTitle += '<br><span style="color: #8af; font-size: 0.9em;">' +
                          battlefield.icon + ' ' + battlefield.name + '</span>';

            // Add difficulty tier indicator
            var extraInfo = '×' + tier.enemyMult.toFixed(1) + ' HP';
            if (extraEnemies > 0) {
                extraInfo += ', +' + extraEnemies + ' reinforcement' + (extraEnemies > 1 ? 's' : '');
            }
            combatTitle += '<br><span style="color: ' + tier.color + '; font-size: 0.85em;">' +
                          '⚔️ ' + tier.name + ' (' + extraInfo + ')</span>';

            document.getElementById('narrative-text').innerHTML = combatTitle;
            showScreen('combat-screen');
            renderGrid();
            updateCombatUI();
            updateEnvironmentActions();

            // Tutorial: first combat
            showTutorialTip('first_combat', 1500);
        }

        // Track XP earned during combat for consolidated calculation at victory
        function trackCombatXP(amount, reason, category) {
            if (!gameState.combat || !gameState.combat.xpTracker) return;
            
            var entry = { amount: amount, reason: reason };
            
            switch(category) {
                case 'tactics':
                    gameState.combat.xpTracker.tactics.push(entry);
                    break;
                case 'combat':
                    gameState.combat.xpTracker.combat.push(entry);
                    break;
                case 'special':
                    gameState.combat.xpTracker.special.push(entry);
                    break;
                case 'defense':
                    gameState.combat.xpTracker.defense.push(entry);
                    break;
                default:
                    gameState.combat.xpTracker.combat.push(entry);
            }
        }
        
        // Get consolidated XP summary for end of combat
        function getCombatXPSummary() {
            if (!gameState.combat || !gameState.combat.xpTracker) {
                return { total: 0, breakdown: [], formula: '0' };
            }
            
            var tracker = gameState.combat.xpTracker;
            var breakdown = [];
            var formulaParts = [];
            var total = 0;
            
            // Tactics XP (movement, positioning)
            if (tracker.tactics.length > 0) {
                var tacticsXP = tracker.tactics.reduce(function(sum, e) { return sum + e.amount; }, 0);
                var tacticsCount = tracker.tactics.length;
                var tacticsAvg = Math.round(tacticsXP / tacticsCount);
                breakdown.push({
                    category: '🚶 Tactics',
                    count: tacticsCount,
                    perItem: tacticsAvg,
                    subtotal: tacticsXP,
                    details: tracker.tactics.map(function(e) { return e.reason; }).join(', ')
                });
                formulaParts.push(tacticsCount + '×' + tacticsAvg);
                total += tacticsXP;
            }
            
            // Combat XP (attacks, damage)
            if (tracker.combat.length > 0) {
                var combatXP = tracker.combat.reduce(function(sum, e) { return sum + e.amount; }, 0);
                var combatCount = tracker.combat.length;
                var combatAvg = Math.round(combatXP / combatCount);
                breakdown.push({
                    category: '⚔️ Combat',
                    count: combatCount,
                    perItem: combatAvg,
                    subtotal: combatXP,
                    details: tracker.combat.map(function(e) { return e.reason; }).join(', ')
                });
                formulaParts.push(combatCount + '×' + combatAvg);
                total += combatXP;
            }
            
            // Special XP (hazards, traps, medkits)
            if (tracker.special.length > 0) {
                var specialXP = tracker.special.reduce(function(sum, e) { return sum + e.amount; }, 0);
                var specialCount = tracker.special.length;
                var specialAvg = Math.round(specialXP / specialCount);
                breakdown.push({
                    category: '💥 Special',
                    count: specialCount,
                    perItem: specialAvg,
                    subtotal: specialXP,
                    details: tracker.special.map(function(e) { return e.reason; }).join(', ')
                });
                formulaParts.push(specialCount + '×' + specialAvg);
                total += specialXP;
            }
            
            // Defense XP (surviving enemy attacks)
            if (tracker.defense.length > 0) {
                var defenseXP = tracker.defense.reduce(function(sum, e) { return sum + e.amount; }, 0);
                var defenseCount = tracker.defense.length;
                var defenseAvg = Math.round(defenseXP / defenseCount);
                breakdown.push({
                    category: '🛡️ Defense',
                    count: defenseCount,
                    perItem: defenseAvg,
                    subtotal: defenseXP,
                    details: tracker.defense.map(function(e) { return e.reason; }).join(', ')
                });
                formulaParts.push(defenseCount + '×' + defenseAvg);
                total += defenseXP;
            }
            
            // Victory bonus is always 50
            var victoryBonus = 50;
            breakdown.push({
                category: '🏆 Victory',
                count: 1,
                perItem: victoryBonus,
                subtotal: victoryBonus,
                details: 'Enemy defeated'
            });
            formulaParts.push(victoryBonus);
            total += victoryBonus;
            
            return {
                total: total,
                breakdown: breakdown,
                formula: formulaParts.join(' + ')
            };
        }
        
        function renderGrid() {
            var grid = document.getElementById('combat-grid');
            grid.innerHTML = '';

            for (var y = 0; y < GRID_HEIGHT; y++) {
                for (var x = 0; x < GRID_WIDTH; x++) {
                    var cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;

                    // Check what's in this cell
                    var isPlayer = gameState.combat.player.x === x && gameState.combat.player.y === y;

                    // Check if any alive enemy is at this position
                    var enemyAtCell = null;
                    var enemyIndex = -1;
                    for (var e = 0; e < gameState.combat.enemies.length; e++) {
                        var enemy = gameState.combat.enemies[e];
                        if (enemy.alive && enemy.x === x && enemy.y === y) {
                            enemyAtCell = enemy;
                            enemyIndex = e;
                            break;
                        }
                    }
                    var isEnemy = enemyAtCell !== null;
                    var isTargeted = isEnemy && enemyIndex === gameState.combat.targetedEnemy;

                    var cover = gameState.combat.cover.find(c => c.x === x && c.y === y);
                    var hazard = gameState.combat.hazards.find(h => h.x === x && h.y === y && !h.used);
                    var trap = gameState.combat.traps.find(t => t.x === x && t.y === y && !t.used);

                    if (isPlayer) {
                        cell.classList.add('player');
                        cell.innerHTML = '<span class="cell-content">☺</span>';
                    } else if (isEnemy) {
                        cell.classList.add('enemy');
                        if (isTargeted) {
                            cell.classList.add('enemy-targeted');
                        }
                        // Show enemy number if multiple enemies
                        var enemyLabel = gameState.combat.enemies.length > 1
                            ? '<span class="enemy-number">' + (enemyIndex + 1) + '</span>'
                            : '';
                        cell.innerHTML = '<span class="cell-content">☠</span>' + enemyLabel;
                        cell.dataset.enemyIndex = enemyIndex;
                    } else if (cover) {
                        cell.classList.add('cover-' + cover.type);
                    } else if (hazard) {
                        cell.classList.add('hazard');
                    } else if (trap) {
                        cell.classList.add('trap');
                    }

                    // Show path highlighting if in move mode
                    if (gameState.mode === 'move' && !isPlayer && !isEnemy) {
                        // Check if this cell is in the current path
                        var inPath = pathState.currentPath.findIndex(function(p) {
                            return p.x === x && p.y === y;
                        });

                        if (inPath !== -1) {
                            // Show as part of the path
                            if (inPath === pathState.currentPath.length - 1) {
                                cell.classList.add('path-end');
                            } else {
                                cell.classList.add('path');
                            }
                        } else if (!cover || cover.type !== 'wall') {
                            // Show as reachable (within AP range via pathfinding)
                            var difficulty = getMovementDifficulty();
                            var testPath = findPath(gameState.combat.player.x, gameState.combat.player.y, x, y, difficulty);
                            if (testPath) {
                                var pathCost = calculatePathCost(testPath, difficulty);
                                var apCost = pathDistanceToAP(pathCost);
                                if (apCost <= gameState.combat.ap) {
                                    cell.classList.add('move-range');
                                }
                            }
                        }
                    }

                    // Show attack range if in attack mode
                    if (gameState.mode === 'attack' && isEnemy) {
                        cell.classList.add('attack-range');
                    }

                    // Add coordinate label
                    cell.innerHTML += '<span class="cell-coord">' + x + ',' + y + '</span>';

                    cell.addEventListener('click', function() {
                        handleCellClick(parseInt(this.dataset.x), parseInt(this.dataset.y));
                    });

                    grid.appendChild(cell);
                }
            }

            // Add LOS overlay
            renderLineOfSight();
        }
        
        function renderLineOfSight() {
            // Remove existing LOS elements
            var existingLos = document.querySelector('.los-overlay');
            if (existingLos) existingLos.remove();
            var existingIndicator = document.querySelector('.los-indicator');
            if (existingIndicator) existingIndicator.remove();

            var grid = document.getElementById('combat-grid');
            var gridRect = grid.getBoundingClientRect();
            var cellSize = gridRect.width / GRID_WIDTH;

            // Create SVG overlay for LOS line
            var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.classList.add('los-overlay');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.style.position = 'absolute';
            svg.style.top = '0';
            svg.style.left = '0';

            var px = gameState.combat.player.x;
            var py = gameState.combat.player.y;

            // Get the targeted enemy (or first alive enemy)
            var targetedEnemy = getTargetedEnemy();
            if (!targetedEnemy) {
                grid.style.position = 'relative';
                grid.appendChild(svg);
                return;
            }

            var ex = targetedEnemy.x;
            var ey = targetedEnemy.y;

            // Calculate LOS to targeted enemy
            var losResult = calculateLineOfSight(px, py, ex, ey);

            // Draw line from player to targeted enemy
            var line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            var startX = (px + 0.5) * (100 / GRID_WIDTH);
            var startY = (py + 0.5) * (100 / GRID_HEIGHT);
            var endX = (ex + 0.5) * (100 / GRID_WIDTH);
            var endY = (ey + 0.5) * (100 / GRID_HEIGHT);

            line.setAttribute('x1', startX + '%');
            line.setAttribute('y1', startY + '%');
            line.setAttribute('x2', endX + '%');
            line.setAttribute('y2', endY + '%');
            line.classList.add('los-line');
            line.classList.add(losResult.status);

            svg.appendChild(line);

            // Draw faded lines to other alive enemies
            for (var i = 0; i < gameState.combat.enemies.length; i++) {
                var enemy = gameState.combat.enemies[i];
                if (enemy.alive && i !== gameState.combat.targetedEnemy) {
                    var otherLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    var otherEndX = (enemy.x + 0.5) * (100 / GRID_WIDTH);
                    var otherEndY = (enemy.y + 0.5) * (100 / GRID_HEIGHT);
                    otherLine.setAttribute('x1', startX + '%');
                    otherLine.setAttribute('y1', startY + '%');
                    otherLine.setAttribute('x2', otherEndX + '%');
                    otherLine.setAttribute('y2', otherEndY + '%');
                    otherLine.classList.add('los-line-secondary');
                    svg.appendChild(otherLine);
                }
            }

            grid.style.position = 'relative';
            grid.appendChild(svg);

            // Add LOS indicator showing target info
            var indicator = document.createElement('div');
            indicator.classList.add('los-indicator');
            indicator.classList.add(losResult.status);

            var targetLabel = gameState.combat.enemies.length > 1
                ? ' → ' + targetedEnemy.name
                : '';

            if (losResult.status === 'clear') {
                indicator.innerHTML = '✓ CLEAR SHOT' + targetLabel;
            } else if (losResult.status === 'partial') {
                indicator.innerHTML = '◐ PARTIAL (-' + losResult.penalty + '% acc)' + targetLabel;
            } else {
                indicator.innerHTML = '✗ BLOCKED' + targetLabel;
            }

            indicator.style.top = '5px';
            indicator.style.left = '50%';
            indicator.style.transform = 'translateX(-50%)';
            grid.appendChild(indicator);

            // Store LOS result for combat calculations
            gameState.combat.currentLOS = losResult;
        }

        // Helper to get the currently targeted enemy
        function getTargetedEnemy() {
            if (!gameState.combat || !gameState.combat.enemies) return null;

            // First try to get the targeted enemy
            var targeted = gameState.combat.enemies[gameState.combat.targetedEnemy];
            if (targeted && targeted.alive) return targeted;

            // If targeted enemy is dead, find first alive enemy
            for (var i = 0; i < gameState.combat.enemies.length; i++) {
                if (gameState.combat.enemies[i].alive) {
                    gameState.combat.targetedEnemy = i;
                    return gameState.combat.enemies[i];
                }
            }
            return null;
        }

        // Cycle through enemies (for targeting)
        function cycleTarget(direction) {
            if (!gameState.combat || gameState.combat.enemies.length <= 1) return;

            var aliveEnemies = [];
            for (var i = 0; i < gameState.combat.enemies.length; i++) {
                if (gameState.combat.enemies[i].alive) {
                    aliveEnemies.push(i);
                }
            }

            if (aliveEnemies.length <= 1) return;

            var currentIdx = aliveEnemies.indexOf(gameState.combat.targetedEnemy);
            var newIdx;
            if (direction > 0) {
                newIdx = (currentIdx + 1) % aliveEnemies.length;
            } else {
                newIdx = (currentIdx - 1 + aliveEnemies.length) % aliveEnemies.length;
            }

            gameState.combat.targetedEnemy = aliveEnemies[newIdx];
            // Update legacy reference
            gameState.combat.enemy = gameState.combat.enemies[gameState.combat.targetedEnemy];
            renderGrid();
            updateCombatUI();
        }

        // Select a specific enemy as target (from UI click)
        function selectTarget(enemyIndex) {
            if (!gameState.combat || enemyIndex < 0 || enemyIndex >= gameState.combat.enemies.length) return;

            var enemy = gameState.combat.enemies[enemyIndex];
            if (!enemy.alive) return; // Can't target dead enemies

            gameState.combat.targetedEnemy = enemyIndex;
            // Update legacy reference
            gameState.combat.enemy = enemy;
            renderGrid();
            updateCombatUI();
        }

        // Handle enemy defeat - marks dead, auto-targets next, checks victory
        function handleEnemyDefeat(defeatedEnemy) {
            // Mark this enemy as dead
            defeatedEnemy.hp = 0;
            defeatedEnemy.alive = false;

            // Check if all enemies are defeated
            var aliveEnemies = gameState.combat.enemies.filter(function(e) { return e.alive; });

            if (aliveEnemies.length === 0) {
                // All enemies defeated - victory!
                updateCombatUI();
                renderGrid();
                setTimeout(combatVictory, 1000);
                return true; // Victory
            } else {
                // More enemies remain - auto-target next alive enemy
                for (var i = 0; i < gameState.combat.enemies.length; i++) {
                    if (gameState.combat.enemies[i].alive) {
                        gameState.combat.targetedEnemy = i;
                        gameState.combat.enemy = gameState.combat.enemies[i];
                        break;
                    }
                }

                var remainingCount = aliveEnemies.length;
                var defeatedName = defeatedEnemy.name;
                showCombatMessage(
                    '<strong>💀 ' + defeatedName + ' DEFEATED!</strong><br><br>' +
                    remainingCount + ' enem' + (remainingCount === 1 ? 'y' : 'ies') + ' remaining!',
                    'success'
                );
                updateCombatUI();
                renderGrid();
                return false; // Combat continues
            }
        }

        // Check if enemy should be defeated (helper for damage checks)
        function checkEnemyDefeated(enemy, newHP) {
            if (newHP <= 0) {
                return handleEnemyDefeat(enemy);
            }
            return false;
        }
        
        function calculateLineOfSight(x1, y1, x2, y2) {
            // Bresenham's line algorithm to find cells between player and enemy
            var cellsInPath = [];
            
            var dx = Math.abs(x2 - x1);
            var dy = Math.abs(y2 - y1);
            var sx = x1 < x2 ? 1 : -1;
            var sy = y1 < y2 ? 1 : -1;
            var err = dx - dy;
            
            var x = x1;
            var y = y1;
            
            while (true) {
                // Don't include start or end points
                if ((x !== x1 || y !== y1) && (x !== x2 || y !== y2)) {
                    cellsInPath.push({x: x, y: y});
                }
                
                if (x === x2 && y === y2) break;
                
                var e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y += sy;
                }
            }
            
            // Check what's in the path
            var blocked = false;
            var partialCover = 0;
            
            for (var i = 0; i < cellsInPath.length; i++) {
                var cell = cellsInPath[i];
                var cover = gameState.combat.cover.find(c => c.x === cell.x && c.y === cell.y);
                
                if (cover) {
                    if (cover.type === 'wall') {
                        blocked = true;
                        break;
                    } else if (cover.type === 'medium') {
                        partialCover += 30;
                    } else if (cover.type === 'small') {
                        partialCover += 15;
                    }
                }
            }
            
            if (blocked) {
                return { status: 'blocked', penalty: 100, canShoot: false };
            } else if (partialCover > 0) {
                return { status: 'partial', penalty: Math.min(partialCover, 50), canShoot: true };
            } else {
                return { status: 'clear', penalty: 0, canShoot: true };
            }
        }
        
        function calculateDistance(x1, y1, x2, y2) {
            var dx = x2 - x1;
            var dy = y2 - y1;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        // Get current active weapon data
        function getActiveWeapon() {
            var slot = gameState.player.activeSlot;
            var weaponName = slot === 1 ? gameState.player.weapons.slot1 : gameState.player.weapons.slot2;
            return { name: weaponName, ...WEAPONS[weaponName] };
        }
        
        // Get weapon from specific slot
        function getWeaponInSlot(slot) {
            var weaponName = slot === 1 ? gameState.player.weapons.slot1 : gameState.player.weapons.slot2;
            if (!weaponName) return null;
            return { name: weaponName, ...WEAPONS[weaponName] };
        }
        
        // Switch active weapon
        function switchWeapon(slot) {
            if (gameState.player.activeSlot === slot) return;
            
            var weapon = getWeaponInSlot(slot);
            if (!weapon) return;
            
            gameState.player.activeSlot = slot;
            updateCombatUI();
            renderGrid();
            
            showPopup(
                '<strong>Switched to ' + weapon.name + '</strong><br><br>' +
                'Type: ' + weapon.type.toUpperCase() + '<br>' +
                'Damage: ' + weapon.damage + '<br>' +
                'Accuracy: ' + weapon.accuracy + '%<br>' +
                'AP Cost: ' + weapon.apCost + '<br>' +
                'Optimal Range: ' + weapon.optimalRange + ' squares (' + (weapon.optimalRange * SQUARE_FEET) + ' ft)<br>' +
                'Max Range: ' + weapon.maxRange + ' squares (' + (weapon.maxRange * SQUARE_FEET) + ' ft)',
                'info',
                'WEAPON SWITCHED'
            );
        }
        
        // Calculate range penalty/bonus for a weapon at given distance
        function calculateRangeModifier(weapon, distance) {
            if (weapon.type === 'melee') {
                // Melee weapons ONLY work when adjacent (distance <= 1.5 for diagonal)
                if (distance > 1.5) {
                    return { canHit: false, modifier: -100, reason: 'Must be adjacent for melee! (≤1.5 squares)' };
                }
                // Melee is very accurate when adjacent
                return { canHit: true, modifier: 10, reason: 'Adjacent - melee range' };
            } else {
                // Ranged weapons
                if (distance < weapon.minRange) {
                    // Too close - big penalty (enemy is on top of you)
                    var penalty = Math.floor((weapon.minRange - distance) * 25);
                    return { canHit: true, modifier: -penalty, reason: 'Too close! (-' + penalty + '%)' };
                } else if (distance <= weapon.optimalRange) {
                    // In optimal range - bonus
                    var bonus = 10;
                    return { canHit: true, modifier: bonus, reason: 'Optimal range (+' + bonus + '%)' };
                } else if (distance <= weapon.maxRange) {
                    // Beyond optimal but within max - increasing penalty
                    var penalty = Math.floor((distance - weapon.optimalRange) * 5);
                    return { canHit: true, modifier: -penalty, reason: 'Long range (-' + penalty + '%)' };
                } else {
                    // Beyond max range - severe penalty
                    var penalty = Math.floor((distance - weapon.maxRange) * 15) + 30;
                    return { canHit: true, modifier: -penalty, reason: 'Extreme range! (-' + penalty + '%)' };
                }
            }
        }
        
        function handleCellClick(x, y) {
            // Check if any alive enemy is at this position
            var enemyAtCell = null;
            var enemyIndex = -1;
            for (var i = 0; i < gameState.combat.enemies.length; i++) {
                var enemy = gameState.combat.enemies[i];
                if (enemy.alive && enemy.x === x && enemy.y === y) {
                    enemyAtCell = enemy;
                    enemyIndex = i;
                    break;
                }
            }
            var isEnemy = enemyAtCell !== null;

            if (gameState.mode === 'move') {
                // Only handle in auto-path mode; draw mode uses drag events
                if (pathState.mode !== 'auto') return;

                // Check if valid move target
                var cover = gameState.combat.cover.find(c => c.x === x && c.y === y);
                var isWall = cover && cover.type === 'wall';
                var isPlayer = gameState.combat.player.x === x && gameState.combat.player.y === y;

                if (isPlayer) {
                    showCombatMessage('You are already there!', 'info');
                } else if (isWall) {
                    showCombatMessage('Cannot move through walls!', 'error');
                } else if (isEnemy) {
                    showCombatMessage('Cannot move to enemy position!', 'error');
                } else {
                    initiateMove(x, y);
                }
            } else if (gameState.mode === 'attack') {
                if (isEnemy) {
                    // Target this enemy and attack
                    selectTarget(enemyIndex);
                    initiateAttack();
                }
            } else if (isEnemy) {
                // Not in any mode - clicking enemy just selects them as target
                selectTarget(enemyIndex);
            }
        }
        
        function enterMoveMode() {
            gameState.mode = 'move';
            pathState.currentPath = [];
            pathState.isDrawing = false;

            var difficulty = getMovementDifficulty();
            var directionInfo = difficulty === 'simple' ? '(↑↓←→ only)' : '(8 directions)';
            var costInfo = difficulty === 'hard' ? 'Euclidean distance × 5 AP' : '5 AP per square';

            document.getElementById('mode-indicator').style.display = 'block';
            document.getElementById('mode-indicator').className = 'mode-indicator';
            document.getElementById('mode-indicator').innerHTML =
                '🚶 MOVE MODE ' + directionInfo + '<br>' +
                '<div class="path-mode-toggle">' +
                    '<button id="auto-path-btn" class="' + (pathState.mode === 'auto' ? 'active' : '') + '" onclick="setPathMode(\'auto\')">🎯 Auto-Path</button>' +
                    '<button id="draw-path-btn" class="' + (pathState.mode === 'draw' ? 'active' : '') + '" onclick="setPathMode(\'draw\')">✏️ Draw Path</button>' +
                '</div>' +
                '<span style="font-size: 0.85em;">' + costInfo + '</span><br>' +
                '<button class="btn small" onclick="exitMode()">Cancel</button>' +
                (pathState.currentPath.length > 0 ? ' <button class="btn small" onclick="confirmPath()">Confirm Path</button>' : '');

            document.getElementById('grid-mode-text').textContent = pathState.mode === 'auto' ? '(Click destination)' : '(Drag to draw path)';
            renderGrid();
            setupPathDrawingEvents();
        }

        function setPathMode(mode) {
            pathState.mode = mode;
            pathState.currentPath = [];
            enterMoveMode(); // Refresh the UI
        }

        function setupPathDrawingEvents() {
            var grid = document.getElementById('combat-grid');

            // Remove old listeners by cloning
            var newGrid = grid.cloneNode(true);
            grid.parentNode.replaceChild(newGrid, grid);
            grid = newGrid;

            // Re-add click handlers to cells
            var cells = grid.querySelectorAll('.grid-cell');
            cells.forEach(function(cell) {
                var x = parseInt(cell.dataset.x);
                var y = parseInt(cell.dataset.y);

                cell.addEventListener('click', function(e) {
                    if (pathState.mode === 'auto') {
                        handleCellClick(x, y);
                    }
                });

                // Mouse events for draw mode
                cell.addEventListener('mousedown', function(e) {
                    if (pathState.mode === 'draw' && gameState.mode === 'move') {
                        e.preventDefault();
                        startPathDrawing(x, y);
                    }
                });

                cell.addEventListener('mouseenter', function(e) {
                    if (pathState.isDrawing && pathState.mode === 'draw') {
                        continuePathDrawing(x, y);
                    }
                });

                // Touch events for draw mode
                cell.addEventListener('touchstart', function(e) {
                    if (pathState.mode === 'draw' && gameState.mode === 'move') {
                        e.preventDefault();
                        startPathDrawing(x, y);
                    }
                }, { passive: false });
            });

            // Global mouse/touch up to end drawing
            document.addEventListener('mouseup', endPathDrawing);
            document.addEventListener('touchend', endPathDrawing);

            // Touch move handler on grid for continuous drawing
            grid.addEventListener('touchmove', function(e) {
                if (pathState.isDrawing && pathState.mode === 'draw') {
                    e.preventDefault();
                    var touch = e.touches[0];
                    var element = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (element && element.classList.contains('grid-cell')) {
                        var x = parseInt(element.dataset.x);
                        var y = parseInt(element.dataset.y);
                        continuePathDrawing(x, y);
                    }
                }
            }, { passive: false });
        }

        function startPathDrawing(x, y) {
            var px = gameState.combat.player.x;
            var py = gameState.combat.player.y;

            // Must start from an adjacent cell to player
            var difficulty = getMovementDifficulty();
            var offsets = getNeighborOffsets(difficulty);
            var isAdjacent = offsets.some(function(o) {
                return px + o.dx === x && py + o.dy === y;
            });

            if (!isAdjacent) {
                showCombatMessage('Start drawing from a cell next to you!', 'error');
                return;
            }

            if (!isCellWalkable(x, y)) {
                showCombatMessage('Cannot walk there!', 'error');
                return;
            }

            pathState.isDrawing = true;
            pathState.currentPath = [{ x: x, y: y }];
            renderGrid();
            updatePathCostDisplay();
        }

        function continuePathDrawing(x, y) {
            if (!pathState.isDrawing || pathState.currentPath.length === 0) return;

            // Check if this cell is already in path (backtracking)
            var existingIndex = pathState.currentPath.findIndex(function(p) {
                return p.x === x && p.y === y;
            });

            if (existingIndex !== -1) {
                // Backtrack: remove everything after this point
                pathState.currentPath = pathState.currentPath.slice(0, existingIndex + 1);
                renderGrid();
                updatePathCostDisplay();
                return;
            }

            // Check if adjacent to last cell in path
            var last = pathState.currentPath[pathState.currentPath.length - 1];
            var difficulty = getMovementDifficulty();
            var offsets = getNeighborOffsets(difficulty);
            var isAdjacent = offsets.some(function(o) {
                return last.x + o.dx === x && last.y + o.dy === y;
            });

            if (!isAdjacent) return; // Skip non-adjacent cells
            if (!isCellWalkable(x, y)) return; // Skip walls

            // Check AP cost doesn't exceed available
            var testPath = pathState.currentPath.concat([{ x: x, y: y }]);
            var pathCost = calculatePathCost(testPath, difficulty);
            var apCost = pathDistanceToAP(pathCost);

            if (apCost > gameState.combat.ap) {
                // Show error but don't add
                return;
            }

            pathState.currentPath.push({ x: x, y: y });
            renderGrid();
            updatePathCostDisplay();
        }

        function endPathDrawing() {
            if (pathState.isDrawing) {
                pathState.isDrawing = false;
                if (pathState.currentPath.length > 0) {
                    // Update mode indicator to show confirm button
                    enterMoveMode();
                }
            }
        }

        function updatePathCostDisplay() {
            if (pathState.currentPath.length === 0) return;

            var difficulty = getMovementDifficulty();
            var pathCost = calculatePathCost(pathState.currentPath, difficulty);
            var apCost = pathDistanceToAP(pathCost);

            document.getElementById('grid-mode-text').textContent =
                'Path: ' + pathState.currentPath.length + ' cells | Distance: ' + pathCost + ' | AP: ' + apCost;
        }

        function confirmPath() {
            if (pathState.currentPath.length === 0) {
                showCombatMessage('No path selected!', 'error');
                return;
            }

            var difficulty = getMovementDifficulty();
            var validation = validateDrawnPath(pathState.currentPath, difficulty);

            if (!validation.valid) {
                showCombatMessage('Invalid path: ' + validation.reason, 'error');
                return;
            }

            // Get final destination and AP cost
            var dest = pathState.currentPath[pathState.currentPath.length - 1];
            var pathCost = calculatePathCost(pathState.currentPath, difficulty);
            var apCost = pathDistanceToAP(pathCost);

            if (apCost > gameState.combat.ap) {
                showCombatMessage('Not enough AP!<br>Required: ' + apCost + ' AP<br>Available: ' + gameState.combat.ap + ' AP', 'error');
                return;
            }

            // Store the path for execution
            gameState.pendingMove = {
                path: pathState.currentPath.slice(),
                x: dest.x,
                y: dest.y,
                apCost: apCost,
                pathDistance: pathCost
            };

            // Show math problem based on difficulty
            initiatePathMove(pathState.currentPath, difficulty);
        }

        function enterAttackMode() {
            gameState.mode = 'attack';
            document.getElementById('mode-indicator').style.display = 'block';
            document.getElementById('mode-indicator').className = 'mode-indicator attack-mode';
            document.getElementById('mode-indicator').innerHTML = '🎯 ATTACK MODE - Click enemy to attack<br><button class="btn small" onclick="exitMode()">Cancel</button>';
            document.getElementById('grid-mode-text').textContent = '(Click enemy to attack)';
            renderGrid();
        }
        
        function exitMode() {
            gameState.mode = null;
            pathState.currentPath = [];
            pathState.isDrawing = false;
            document.getElementById('mode-indicator').style.display = 'none';
            document.getElementById('grid-mode-text').textContent = '(Select action below)';
            renderGrid();
        }
        
        function initiateMove(targetX, targetY) {
            // Auto-path mode: use A* to find path
            var px = gameState.combat.player.x;
            var py = gameState.combat.player.y;
            var difficulty = getMovementDifficulty();

            // Find path using A*
            var path = findPath(px, py, targetX, targetY, difficulty);

            if (!path) {
                showCombatMessage('No valid path to that location!', 'error');
                return;
            }

            if (path.length === 0) {
                showCombatMessage('You are already there!', 'info');
                return;
            }

            // Calculate path cost with exhaustion multiplier
            var pathCost = calculatePathCost(path, difficulty);
            var baseApCost = pathDistanceToAP(pathCost);
            var apMultiplier = getVitalsAPMultiplier();
            var apCost = Math.ceil(baseApCost * apMultiplier);

            if (apCost > gameState.combat.ap) {
                var msg = 'Not enough AP!<br><br>Required: ' + apCost + ' AP<br>Available: ' + gameState.combat.ap + ' AP';
                if (apMultiplier > 1) {
                    msg += '<br><br><span style="color:#ff0;">⚠️ Exhaustion increases AP costs by ' + Math.round((apMultiplier - 1) * 100) + '%</span>';
                }
                showCombatMessage(msg, 'error');
                return;
            }

            // Store the path and show it
            pathState.currentPath = path;
            renderGrid();

            // Store for execution
            gameState.pendingMove = {
                path: path.slice(),
                x: targetX,
                y: targetY,
                apCost: apCost,
                pathDistance: pathCost
            };

            // Show math problem based on difficulty
            initiatePathMove(path, difficulty);
        }

        function initiatePathMove(path, difficulty) {
            var px = gameState.combat.player.x;
            var py = gameState.combat.player.y;
            var dest = path[path.length - 1];
            var pathCost = calculatePathCost(path, difficulty);
            var baseApCost = pathDistanceToAP(pathCost);
            var apMultiplier = getVitalsAPMultiplier();
            var apCost = Math.ceil(baseApCost * apMultiplier);

            gameState.currentAction = 'move';

            var problem = '<strong>🚶 MOVEMENT</strong><br>';
            if (apMultiplier > 1) {
                problem += '<span class="ap-cost-tag">Cost: 5 AP per square</span> <span style="color:#ff0;">(+' + Math.round((apMultiplier - 1) * 100) + '% exhaustion)</span><br><br>';
            } else {
                problem += '<span class="ap-cost-tag">Cost: 5 AP per square</span><br><br>';
            }
            problem += 'Path from (' + px + ', ' + py + ') to (' + dest.x + ', ' + dest.y + ')<br>';
            problem += 'Path length: ' + path.length + ' cells<br><br>';

            if (difficulty === 'hard') {
                // Hard mode: show segment-by-segment euclidean calculation
                problem += '<strong>Calculate each segment (round to 0.1):</strong><br>';
                var prevX = px, prevY = py;
                var segments = [];
                for (var i = 0; i < path.length; i++) {
                    var dx = Math.abs(path[i].x - prevX);
                    var dy = Math.abs(path[i].y - prevY);
                    var segDist = Math.round(Math.sqrt(dx * dx + dy * dy) * 10) / 10;
                    segments.push(segDist);
                    if (i < 5) { // Show first 5 segments
                        problem += '(' + prevX + ',' + prevY + ')→(' + path[i].x + ',' + path[i].y + '): √(' + dx + '² + ' + dy + '²) = ' + segDist + '<br>';
                    }
                    prevX = path[i].x;
                    prevY = path[i].y;
                }
                if (path.length > 5) {
                    problem += '... +' + (path.length - 5) + ' more segments<br>';
                }
                problem += '<br><strong>Total distance: ' + segments.join(' + ') + ' = ?</strong><br>';
                if (apMultiplier > 1) {
                    problem += '<span style="font-size:0.85em; color: #888;">AP Cost: ⌈distance × 5⌉ × ' + apMultiplier.toFixed(2) + ' (exhaustion)</span>';
                } else {
                    problem += '<span style="font-size:0.85em; color: #888;">AP Cost: ⌈distance × 5⌉</span>';
                }

                gameState.currentProblem = {
                    answer: pathCost,
                    action: 'move',
                    apCost: apCost
                };
            } else if (difficulty === 'medium') {
                // Medium mode: count squares (diagonals count as 1)
                problem += 'Each step (including diagonal) = 1 square<br><br>';
                problem += '<strong>Total squares moved: ?</strong><br>';
                if (apMultiplier > 1) {
                    problem += '<span style="font-size:0.85em; color: #888;">AP Cost: (' + path.length + ' × 5) × ' + apMultiplier.toFixed(2) + ' = ' + apCost + ' AP</span>';
                } else {
                    problem += '<span style="font-size:0.85em; color: #888;">AP Cost: ' + path.length + ' × 5 = ' + apCost + ' AP</span>';
                }

                gameState.currentProblem = {
                    answer: path.length,
                    action: 'move',
                    apCost: apCost
                };
            } else {
                // Simple mode: count squares (cardinal only)
                problem += 'Each step = 1 square<br><br>';
                problem += '<strong>Total squares moved: ?</strong><br>';
                if (apMultiplier > 1) {
                    problem += '<span style="font-size:0.85em; color: #888;">AP Cost: (' + path.length + ' × 5) × ' + apMultiplier.toFixed(2) + ' = ' + apCost + ' AP</span>';
                } else {
                    problem += '<span style="font-size:0.85em; color: #888;">AP Cost: ' + path.length + ' × 5 = ' + apCost + ' AP</span>';
                }

                gameState.currentProblem = {
                    answer: path.length,
                    action: 'move',
                    apCost: apCost
                };
            }

            showCombatMathPhase(problem);
        }

        // Execute movement along a path, checking for traps at each step
        function executePathMovement(path, startAP, endAP, wasMiscalculation, extraAPCost) {
            var stepIndex = 0;
            var trapsTriggered = [];
            var totalTrapDamage = 0;
            var startHP = gameState.player.hp;

            // Clear pending move and path state
            gameState.pendingMove = null;
            pathState.currentPath = [];

            // Moving breaks cover position
            if (gameState.combat.inCover) {
                gameState.combat.inCover = false;
                gameState.combat.coverBonus = 0;
                updateTacticalButtons();
            }

            function moveNextStep() {
                if (stepIndex >= path.length) {
                    // Movement complete - show summary
                    finishMovement();
                    return;
                }

                var step = path[stepIndex];
                gameState.combat.player.x = step.x;
                gameState.combat.player.y = step.y;

                // Check for trap at this step
                var trap = gameState.combat.traps.find(function(t) {
                    return t.x === step.x && t.y === step.y && !t.used;
                });

                if (trap) {
                    trap.used = true;
                    trapsTriggered.push(trap);
                    totalTrapDamage += trap.damage;
                    gameState.player.hp -= trap.damage;

                    // Update display
                    updateCombatUI();
                    updateInventoryDisplay();
                    renderGrid();

                    if (gameState.player.hp <= 0) {
                        gameState.player.hp = 0;
                        // Death by trap - show message then defeat
                        var msg = '<strong>⚙ TRAP TRIGGERED!</strong><br><br>';
                        msg += 'Stepped on ' + trap.name + ' at (' + step.x + ', ' + step.y + ')!<br>';
                        msg += 'Damage: ' + trap.damage + '<br>';
                        msg += 'HP: ' + startHP + ' → 0';
                        showPopup(msg, 'error', 'DEATH');
                        var origClose = closePopup;
                        closePopup = function() {
                            document.getElementById('popup-overlay').classList.remove('active');
                            closePopup = origClose;
                            defeat();
                        };
                        return;
                    }
                }

                // Small delay between steps for visual effect
                stepIndex++;
                if (stepIndex < path.length) {
                    renderGrid();
                    setTimeout(moveNextStep, 100);
                } else {
                    moveNextStep();
                }
            }

            function finishMovement() {
                var dest = path[path.length - 1];
                updateCombatUI();
                updateInventoryDisplay();
                renderGrid();

                var msg = '';
                if (wasMiscalculation) {
                    msg += '<strong>⚠️ MISCALCULATION!</strong><br>';
                    msg += 'Wasted ' + extraAPCost + ' extra AP stumbling!<br><br>';
                }

                msg += 'Moved to (' + dest.x + ', ' + dest.y + ')<br>';
                msg += 'Path: ' + path.length + ' steps<br>';
                msg += 'AP: ' + startAP + ' → ' + endAP;

                if (trapsTriggered.length > 0) {
                    msg += '<br><br><strong style="color: #f44;">TRAPS TRIGGERED:</strong><br>';
                    trapsTriggered.forEach(function(trap) {
                        msg += '⚙ ' + trap.name + ' (-' + trap.damage + ' HP)<br>';
                    });
                    msg += 'Total damage: ' + totalTrapDamage + '<br>';
                    msg += 'HP: ' + startHP + ' → ' + gameState.player.hp;
                }

                showCombatMessage(msg, trapsTriggered.length > 0 || wasMiscalculation ? 'error' : 'info');
                returnToCombatChoices();
            }

            // Start walking the path
            moveNextStep();
        }

        function initiateAttack() {
            var px = gameState.combat.player.x;
            var py = gameState.combat.player.y;
            var ex = gameState.combat.enemy.x;
            var ey = gameState.combat.enemy.y;
            
            // Get active weapon
            var weapon = getActiveWeapon();
            
            // Check ammo for ranged weapons
            if (weapon.ammoType) {
                var currentAmmo = gameState.player.ammo[weapon.ammoType] || 0;
                if (currentAmmo < weapon.ammoPerShot) {
                    var ammoName = AMMO_TYPES[weapon.ammoType] ? AMMO_TYPES[weapon.ammoType].name : weapon.ammoType;
                    showCombatMessage('<strong>Out of Ammo!</strong><br><br>' + 
                        weapon.name + ' requires ' + weapon.ammoPerShot + ' ' + ammoName + '.<br>' +
                        'Current: ' + currentAmmo + '<br><br>' +
                        'Switch to a melee weapon or find more ammo!', 'error');
                    return;
                }
            }
            
            // Check line of sight (only for ranged)
            var los = gameState.combat.currentLOS;
            if (weapon.type === 'ranged' && !los.canShoot) {
                showCombatMessage('<strong>Cannot Attack!</strong><br><br>Line of sight is blocked by a wall.<br><br>Move to a different position or switch to melee.', 'error');
                return;
            }
            
            var dx = ex - px;
            var dy = ey - py;
            var distSquares = Math.sqrt(dx * dx + dy * dy);
            var roundedDist = Math.round(distSquares * 10) / 10;
            var distFeet = roundedDist * SQUARE_FEET;
            
            // Check range
            var rangeResult = calculateRangeModifier(weapon, roundedDist);
            
            if (!rangeResult.canHit) {
                showCombatMessage('<strong>Out of Range!</strong><br><br>' + weapon.name + ' cannot hit at ' + roundedDist + ' squares.<br><br>' + rangeResult.reason + '<br><br>Move closer or switch weapons!', 'error');
                return;
            }
            
            // Apply vitals AP cost multiplier (exhaustion increases costs)
            var apMultiplier = getVitalsAPMultiplier();
            var baseApCost = weapon.apCost;
            var apCost = Math.ceil(baseApCost * apMultiplier);

            if (apCost > gameState.combat.ap) {
                var msg = 'Not enough AP!<br><br>Required: ' + apCost + ' AP<br>Available: ' + gameState.combat.ap + ' AP';
                if (apMultiplier > 1) {
                    msg += '<br><br><span style="color:#ff0;">⚠️ Exhaustion increases AP costs by ' + Math.round((apMultiplier - 1) * 100) + '%</span>';
                }
                showCombatMessage(msg, 'error');
                return;
            }

            gameState.currentAction = 'attack';
            gameState.combat.ap -= apCost;

            // Calculate accuracy: weapon base + range modifier - cover penalty - vitals penalty - durability penalty + tactical bonuses + base bonus
            var baseAcc = weapon.accuracy;
            var rangeModifier = rangeResult.modifier;
            var coverPenalty = weapon.type === 'ranged' ? los.penalty : 0;
            var vitalsPenalty = getVitalsAccuracyPenalty();
            var durabilityAccPenalty = getDurabilityAccuracyPenalty();

            // Get tactical bonuses (cover mount + steady aim)
            var coverBonus = gameState.combat.inCover ? (gameState.combat.coverBonus || 15) : 0;
            var steadyBonus = gameState.combat.steadyAim ? (gameState.combat.steadyBonus || 10) : 0;

            // Get armory bonus from base
            var armoryBonus = baseState.totalBenefits.accuracyBonus || 0;

            var finalAcc = baseAcc + rangeModifier - coverPenalty - vitalsPenalty - durabilityAccPenalty + coverBonus + steadyBonus + armoryBonus;
            if (finalAcc < 5) finalAcc = 5;
            if (finalAcc > 95) finalAcc = 95;

            var problem = '<strong>🎯 ATTACK with ' + weapon.name + '</strong><br>';

            // Show AP cost with exhaustion calculation if applicable
            if (apMultiplier > 1) {
                problem += '<span class="ap-cost-tag">AP: ' + baseApCost + ' × ' + apMultiplier.toFixed(2) + ' = ' + apCost + '</span> <span style="color:#ff0;">(exhaustion)</span> (Remaining: ' + gameState.combat.ap + ')<br>';
            } else {
                problem += '<span class="ap-cost-tag">Cost: ' + apCost + ' AP</span> (Remaining: ' + gameState.combat.ap + ')<br>';
            }
            
            // Show ammo info for ranged weapons
            if (weapon.ammoType) {
                var currentAmmo = gameState.player.ammo[weapon.ammoType] || 0;
                problem += '<span style="color: #ff0;">Ammo: ' + currentAmmo + ' ' + weapon.ammoType + ' (uses ' + weapon.ammoPerShot + ')</span><br>';
            }
            problem += '<br>';
            
            problem += 'Weapon Type: ' + weapon.type.toUpperCase() + '<br>';
            problem += 'Optimal Range: ' + weapon.optimalRange + ' sq | Max: ' + weapon.maxRange + ' sq<br>';
            problem += 'Target Distance: ' + roundedDist + ' squares (' + distFeet + ' ft)<br><br>';
            
            if (weapon.type === 'ranged') {
                problem += 'Line of Sight: <span style="color:' + (los.status === 'clear' ? '#0f0' : '#ff0') + ';">' + los.status.toUpperCase() + '</span><br><br>';
            }
            
            problem += '<strong>Hit Chance Calculation:</strong><br>';
            problem += 'Weapon accuracy: ' + baseAcc + '%<br>';
            
            if (rangeModifier >= 0) {
                problem += 'Range bonus: +' + rangeModifier + '% (' + rangeResult.reason + ')<br>';
            } else {
                problem += 'Range penalty: ' + rangeModifier + '% (' + rangeResult.reason + ')<br>';
            }
            
            if (coverPenalty > 0) {
                problem += 'Cover penalty: -' + coverPenalty + '%<br>';
            }

            // Show vitals penalties
            if (vitalsPenalty > 0) {
                var vitalsReasons = [];
                var v = gameState.player.vitals;
                if (v.hunger < 50) vitalsReasons.push('hungry');
                if (v.warmth < 45 || v.warmth > 70) vitalsReasons.push(v.warmth < 45 ? 'cold' : 'hot');
                problem += '<span style="color:#ff0;">Condition penalty: -' + vitalsPenalty + '% (' + vitalsReasons.join(', ') + ')</span><br>';
            }

            // Show durability penalty
            if (durabilityAccPenalty > 0) {
                var durability = getActiveWeaponDurability();
                problem += '<span style="color:#f80;">Weapon wear: -' + durabilityAccPenalty + '% (' + durability + '% condition)</span><br>';
            }

            // Show tactical bonuses
            if (coverBonus > 0) {
                problem += '<span style="color:#0f0;">Cover bonus: +' + coverBonus + '% (mounted)</span><br>';
            }
            if (steadyBonus > 0) {
                problem += '<span style="color:#0f0;">Steady aim bonus: +' + steadyBonus + '% (breathing)</span><br>';
            }
            if (armoryBonus > 0) {
                problem += '<span style="color:#0f0;">Armory bonus: +' + armoryBonus + '% (base)</span><br>';
            }

            var calcString = baseAcc + (rangeModifier >= 0 ? ' + ' + rangeModifier : ' - ' + Math.abs(rangeModifier));
            if (coverPenalty > 0) {
                calcString += ' - ' + coverPenalty;
            }
            if (vitalsPenalty > 0) {
                calcString += ' - ' + vitalsPenalty;
            }
            if (durabilityAccPenalty > 0) {
                calcString += ' - ' + durabilityAccPenalty;
            }
            if (coverBonus > 0) {
                calcString += ' + ' + coverBonus;
            }
            if (steadyBonus > 0) {
                calcString += ' + ' + steadyBonus;
            }
            if (armoryBonus > 0) {
                calcString += ' + ' + armoryBonus;
            }
            problem += '<br><strong>' + calcString + ' = ?</strong>';
            
            gameState.currentProblem = {
                answer: finalAcc,
                action: 'attack',
                distance: roundedDist,
                weapon: weapon
            };

            showCombatMathPhase(problem);
            updateCombatUI();
        }

        function useMedKit() {
            if (gameState.player.medkits <= 0) {
                showCombatMessage('No medkits remaining!', 'error');
                return;
            }

            var apMultiplier = getVitalsAPMultiplier();
            var baseApCost = 30;
            var apCost = Math.ceil(baseApCost * apMultiplier);

            if (gameState.combat.ap < apCost) {
                var msg = 'Not enough AP!<br><br>Required: ' + apCost + ' AP<br>Available: ' + gameState.combat.ap + ' AP';
                if (apMultiplier > 1) {
                    msg += '<br><br><span style="color:#ff0;">⚠️ Exhaustion increases AP costs by ' + Math.round((apMultiplier - 1) * 100) + '%</span>';
                }
                showCombatMessage(msg, 'error');
                return;
            }

            gameState.currentAction = 'stimpak';
            gameState.combat.ap -= apCost;

            // Base heal 40%, plus medical bay bonus
            var baseHealPercent = 0.4;
            var medbayBonus = baseState.totalBenefits.healingBonus || 0;
            var totalHealPercent = baseHealPercent + (medbayBonus / 100);
            var healAmount = Math.floor(gameState.player.maxHp * totalHealPercent);

            var problem = '<strong>💉 MED KIT</strong><br>';
            if (apMultiplier > 1) {
                problem += '<span class="ap-cost-tag">AP: ' + baseApCost + ' × ' + apMultiplier.toFixed(2) + ' = ' + apCost + '</span> <span style="color:#ff0;">(exhaustion)</span> (Remaining: ' + gameState.combat.ap + ')<br><br>';
            } else {
                problem += '<span class="ap-cost-tag">Cost: ' + apCost + ' AP</span> (Remaining: ' + gameState.combat.ap + ')<br><br>';
            }
            problem += 'Med Kits available: ' + gameState.player.medkits + '<br>';
            problem += 'Current HP: ' + gameState.player.hp + '/' + gameState.player.maxHp + '<br><br>';
            problem += '<strong>Calculate healing amount:</strong><br>';
            if (medbayBonus > 0) {
                problem += 'Base heal: 40%<br>';
                problem += '<span style="color:#0f0;">Medical bay bonus: +' + medbayBonus + '%</span><br>';
                problem += 'Total: ' + Math.round(totalHealPercent * 100) + '% of ' + gameState.player.maxHp + ' = ?<br><br>';
                problem += '<span style="font-size:0.85em; color: #888;">Formula: ' + gameState.player.maxHp + ' × ' + totalHealPercent.toFixed(2) + ' = ?</span>';
            } else {
                problem += '40% of ' + gameState.player.maxHp + ' = ?<br><br>';
                problem += '<span style="font-size:0.85em; color: #888;">Formula: ' + gameState.player.maxHp + ' × 0.4 = ?</span>';
            }
            
            gameState.currentProblem = {
                answer: healAmount,
                action: 'stimpak'
            };

            showCombatMathPhase(problem);
            updateCombatUI();
        }

        function attemptFlee() {
            var apMultiplier = getVitalsAPMultiplier();
            var baseApCost = 50;
            var apCost = Math.ceil(baseApCost * apMultiplier);

            if (gameState.combat.ap < apCost) {
                var msg = 'Not enough AP!<br><br>Required: ' + apCost + ' AP<br>Available: ' + gameState.combat.ap + ' AP';
                if (apMultiplier > 1) {
                    msg += '<br><br><span style="color:#ff0;">⚠️ Exhaustion increases AP costs by ' + Math.round((apMultiplier - 1) * 100) + '%</span>';
                }
                showCombatMessage(msg, 'error');
                return;
            }

            gameState.currentAction = 'flee';
            gameState.combat.ap -= apCost;

            var problem = generateFleeProblem();

            var problemText = '<strong>🏃 FLEE ATTEMPT</strong><br>';
            if (apMultiplier > 1) {
                problemText += '<span class="ap-cost-tag">AP: ' + baseApCost + ' × ' + apMultiplier.toFixed(2) + ' = ' + apCost + '</span> <span style="color:#ff0;">(exhaustion)</span> (Remaining: ' + gameState.combat.ap + ')<br><br>';
            } else {
                problemText += '<span class="ap-cost-tag">Cost: ' + apCost + ' AP</span> (Remaining: ' + gameState.combat.ap + ')<br><br>';
            }
            problemText += problem.question;
            
            gameState.currentProblem = {
                answer: problem.answer,
                action: 'flee',
                xpReward: problem.xpReward
            };

            showCombatMathPhase(problemText);
            updateCombatUI();
        }

        function triggerHazard(index) {
            var hazard = gameState.combat.hazards[index];
            if (!hazard || hazard.used) return;

            var apMultiplier = getVitalsAPMultiplier();
            var baseApCost = 15;
            var apCost = Math.ceil(baseApCost * apMultiplier);

            if (gameState.combat.ap < apCost) {
                var msg = 'Not enough AP! Need ' + apCost + ' AP to trigger explosive.';
                if (apMultiplier > 1) {
                    msg += '<br><br><span style="color:#ff0;">⚠️ Exhaustion increases AP costs by ' + Math.round((apMultiplier - 1) * 100) + '%</span>';
                }
                showCombatMessage(msg, 'error');
                return;
            }

            gameState.currentAction = 'hazard';
            gameState.currentHazardIndex = index;
            gameState.combat.ap -= apCost;
            
            var hx = hazard.x;
            var hy = hazard.y;
            var ex = gameState.combat.enemy.x;
            var ey = gameState.combat.enemy.y;
            
            var dx = ex - hx;
            var dy = ey - hy;
            var distToEnemy = Math.sqrt(dx * dx + dy * dy);
            var roundedDist = Math.round(distToEnemy * 10) / 10;
            
            var problem = '<strong>💥 EXPLOSIVE: ' + hazard.name + '</strong><br><br>';
            problem += 'Calculate if enemy is in blast radius:<br><br>';
            problem += 'Explosive at (' + hx + ', ' + hy + ')<br>';
            problem += 'Enemy at (' + ex + ', ' + ey + ')<br><br>';
            problem += 'Distance = √[(' + ex + '-' + hx + ')² + (' + ey + '-' + hy + ')²]<br>';
            problem += 'Distance = √[' + (dx*dx) + ' + ' + (dy*dy) + '] = √' + (dx*dx + dy*dy) + ' = ' + roundedDist + 'm<br><br>';
            problem += 'Blast radius: ' + hazard.radius + 'm<br>';
            problem += '<strong>Is ' + roundedDist + 'm ≤ ' + hazard.radius + 'm?</strong><br>(Enter 1 for YES, 0 for NO)';
            
            var inRange = roundedDist <= hazard.radius ? 1 : 0;
            
            gameState.currentProblem = {
                answer: inRange,
                action: 'hazard',
                hazardIndex: index,
                inRange: inRange,
                damage: hazard.damage,
                hazardName: hazard.name
            };

            showCombatMathPhase(problem);
            updateCombatUI();
        }

        function triggerTrap(index) {
            var trap = gameState.combat.traps[index];
            if (!trap || trap.used) return;

            var apMultiplier = getVitalsAPMultiplier();
            var baseApCost = 15;
            var apCost = Math.ceil(baseApCost * apMultiplier);

            if (gameState.combat.ap < apCost) {
                var msg = 'Not enough AP! Need ' + apCost + ' AP to trigger trap.';
                if (apMultiplier > 1) {
                    msg += '<br><br><span style="color:#ff0;">⚠️ Exhaustion increases AP costs by ' + Math.round((apMultiplier - 1) * 100) + '%</span>';
                }
                showCombatMessage(msg, 'error');
                return;
            }

            // Check if enemy is on the trap
            var ex = gameState.combat.enemy.x;
            var ey = gameState.combat.enemy.y;

            if (trap.x !== ex || trap.y !== ey) {
                showCombatMessage('Enemy is not on the trap!<br><br>Enemy position: (' + ex + ', ' + ey + ')<br>Trap position: (' + trap.x + ', ' + trap.y + ')<br><br>Lure the enemy onto the trap first!', 'error');
                return;
            }

            gameState.currentAction = 'trap';
            gameState.currentTrapIndex = index;
            gameState.combat.ap -= apCost;
            
            var problem = '<strong>⚙ TRAP: ' + trap.name + '</strong><br><br>';
            problem += 'Enemy is standing on the trap!<br><br>';
            problem += 'Enemy position: (' + ex + ', ' + ey + ')<br>';
            problem += 'Trap position: (' + trap.x + ', ' + trap.y + ')<br><br>';
            problem += 'Trap damage: ' + trap.damage + '<br><br>';
            problem += '<strong>Confirm trap activation:</strong><br>What is the trap damage? Enter: ' + trap.damage;
            
            gameState.currentProblem = {
                answer: trap.damage,
                action: 'trap',
                trapIndex: index,
                damage: trap.damage,
                trapName: trap.name
            };

            showCombatMathPhase(problem);
            updateCombatUI();
        }

        // ============ TACTICAL ACTIONS: COVER & STEADY AIM ============

        // Check if player is adjacent to cover
        function getAdjacentCover() {
            if (!gameState.combat) return null;
            var px = gameState.combat.player.x;
            var py = gameState.combat.player.y;

            // Check all 8 directions for cover
            var directions = [
                {dx: -1, dy: 0}, {dx: 1, dy: 0}, {dx: 0, dy: -1}, {dx: 0, dy: 1},
                {dx: -1, dy: -1}, {dx: 1, dy: -1}, {dx: -1, dy: 1}, {dx: 1, dy: 1}
            ];

            for (var i = 0; i < directions.length; i++) {
                var checkX = px + directions[i].dx;
                var checkY = py + directions[i].dy;
                var cover = gameState.combat.cover.find(function(c) {
                    return c.x === checkX && c.y === checkY && (c.type === 'small' || c.type === 'medium');
                });
                if (cover) return cover;
            }
            return null;
        }

        // Take Cover action - mount to adjacent cover for accuracy bonus
        function takeCover() {
            if (gameState.combat.inCover) {
                showCombatMessage('<strong>Already in Cover!</strong><br><br>You are already mounted to cover.<br>Move to a new position to reset.', 'info');
                return;
            }

            var adjacentCover = getAdjacentCover();
            if (!adjacentCover) {
                showCombatMessage('<strong>No Cover Available!</strong><br><br>You must be adjacent to cover (░ or ▒) to take cover.<br><br>Move next to cover first!', 'error');
                return;
            }

            var apMultiplier = getVitalsAPMultiplier();
            var baseApCost = 15;
            var apCost = Math.ceil(baseApCost * apMultiplier);

            if (gameState.combat.ap < apCost) {
                var msg = 'Not enough AP!<br><br>Required: ' + apCost + ' AP<br>Available: ' + gameState.combat.ap + ' AP';
                if (apMultiplier > 1) {
                    msg += '<br><br><span style="color:#ff0;">⚠️ Exhaustion increases AP costs by ' + Math.round((apMultiplier - 1) * 100) + '%</span>';
                }
                showCombatMessage(msg, 'error');
                return;
            }

            gameState.currentAction = 'takeCover';

            // Determine cover bonus based on type
            var coverBonus = adjacentCover.type === 'medium' ? 20 : 15;

            // Get current weapon accuracy for the calculation
            var activeSlot = gameState.player.activeSlot || 1;
            var weaponName = gameState.player.weapons['slot' + activeSlot];
            var weapon = WEAPONS[weaponName] || WEAPONS['Glock 17'];
            var baseAccuracy = weapon.accuracy;

            var problem = '<strong>🛡️ TAKE COVER</strong><br>';
            if (apMultiplier > 1) {
                problem += '<span class="ap-cost-tag">AP: ' + baseApCost + ' × ' + apMultiplier.toFixed(2) + ' = ' + apCost + '</span> <span style="color:#ff0;">(exhaustion)</span><br><br>';
            } else {
                problem += '<span class="ap-cost-tag">Cost: ' + apCost + ' AP</span><br><br>';
            }
            problem += 'You brace against the ' + adjacentCover.type + ' cover.<br><br>';
            problem += '<strong>Cover Accuracy Bonus:</strong><br>';
            problem += adjacentCover.type.charAt(0).toUpperCase() + adjacentCover.type.slice(1) + ' cover grants +' + coverBonus + '% accuracy.<br><br>';
            problem += '<strong>Calculate your new accuracy:</strong><br>';
            problem += 'Base accuracy: ' + baseAccuracy + '%<br>';
            problem += 'Cover bonus: +' + coverBonus + '%<br><br>';
            problem += '<strong>' + baseAccuracy + ' + ' + coverBonus + ' = ?</strong>';

            gameState.currentProblem = {
                answer: baseAccuracy + coverBonus,
                action: 'takeCover',
                apCost: apCost,
                coverBonus: coverBonus,
                coverType: adjacentCover.type
            };

            showCombatMathPhase(problem);
            updateCombatUI();
        }

        // Steady Aim action - breathing technique for accuracy bonus on next attack
        function steadyAim() {
            if (gameState.combat.steadyAim) {
                showCombatMessage('<strong>Already Focused!</strong><br><br>You are already in a steady aim stance.<br>Use your attack to benefit from the bonus!', 'info');
                return;
            }

            var apMultiplier = getVitalsAPMultiplier();
            var baseApCost = 20;
            var apCost = Math.ceil(baseApCost * apMultiplier);

            if (gameState.combat.ap < apCost) {
                var msg = 'Not enough AP!<br><br>Required: ' + apCost + ' AP<br>Available: ' + gameState.combat.ap + ' AP';
                if (apMultiplier > 1) {
                    msg += '<br><br><span style="color:#ff0;">⚠️ Exhaustion increases AP costs by ' + Math.round((apMultiplier - 1) * 100) + '%</span>';
                }
                showCombatMessage(msg, 'error');
                return;
            }

            gameState.currentAction = 'steadyAim';

            // Calculate breathing rhythm problem
            var breathsIn = Math.floor(Math.random() * 3) + 3;  // 3-5 breaths
            var breathsOut = breathsIn;  // Same number out
            var holdTime = Math.floor(Math.random() * 3) + 2;   // 2-4 seconds hold
            var totalCycleTime = breathsIn + holdTime + breathsOut;
            var steadyBonus = 10;

            var problem = '<strong>🎯 STEADY AIM - Breathing Technique</strong><br>';
            if (apMultiplier > 1) {
                problem += '<span class="ap-cost-tag">AP: ' + baseApCost + ' × ' + apMultiplier.toFixed(2) + ' = ' + apCost + '</span> <span style="color:#ff0;">(exhaustion)</span><br><br>';
            } else {
                problem += '<span class="ap-cost-tag">Cost: ' + apCost + ' AP</span><br><br>';
            }
            problem += 'You control your breathing to steady your aim...<br><br>';
            problem += '<strong>Breathing Pattern:</strong><br>';
            problem += '• Inhale: ' + breathsIn + ' seconds<br>';
            problem += '• Hold: ' + holdTime + ' seconds<br>';
            problem += '• Exhale: ' + breathsOut + ' seconds<br><br>';
            problem += '<strong>Calculate total breathing cycle time:</strong><br>';
            problem += breathsIn + ' + ' + holdTime + ' + ' + breathsOut + ' = ?<br><br>';
            problem += '<span style="color: #0f0;">Success grants +' + steadyBonus + '% accuracy on your next attack!</span>';

            gameState.currentProblem = {
                answer: totalCycleTime,
                action: 'steadyAim',
                apCost: apCost,
                steadyBonus: steadyBonus
            };

            showCombatMathPhase(problem);
            updateCombatUI();
        }

        // Update cover and steady aim button states
        function updateTacticalButtons() {
            var coverBtn = document.getElementById('cover-btn');
            var steadyBtn = document.getElementById('steady-btn');
            var coverStatus = document.getElementById('cover-status');
            var steadyStatus = document.getElementById('steady-status');

            if (!gameState.combat) return;

            // Update cover button
            if (gameState.combat.inCover) {
                coverBtn.style.background = '#0a4';
                coverStatus.textContent = '✓ IN COVER';
                coverStatus.style.color = '#0f0';
            } else {
                var adjacentCover = getAdjacentCover();
                if (adjacentCover) {
                    coverBtn.style.background = '#456';
                    var bonus = adjacentCover.type === 'medium' ? 20 : 15;
                    coverStatus.textContent = '+' + bonus + '% accuracy';
                    coverStatus.style.color = '#fff';
                } else {
                    coverBtn.style.background = '#333';
                    coverStatus.textContent = 'No cover nearby';
                    coverStatus.style.color = '#888';
                }
            }

            // Update steady aim button
            if (gameState.combat.steadyAim) {
                steadyBtn.style.background = '#a40';
                steadyStatus.textContent = '✓ FOCUSED';
                steadyStatus.style.color = '#ff0';
            } else {
                steadyBtn.style.background = '#654';
                steadyStatus.textContent = '+10% next attack';
                steadyStatus.style.color = '#fff';
            }
        }

        function submitAnswer() {
            var userAnswer = parseFloat(document.getElementById('answer-input').value);
            if (isNaN(userAnswer)) {
                showCombatMessage('Please enter a number!', 'error');
                return;
            }
            
            var correct = Math.abs(userAnswer - gameState.currentProblem.answer) < 0.1;
            var action = gameState.currentProblem.action;
            
            recordMathResult(correct);
            
            if (correct) {
                // Track XP for end-of-combat consolidation instead of awarding immediately
                // (except for flee, which awards XP directly since player leaves combat)
                var xpReward = 15; // Base XP for combat math
                var category = 'combat';
                var reason = 'Math';
                
                if (action === 'move') {
                    xpReward = 15;
                    category = 'tactics';
                    reason = 'Move calc';
                } else if (action === 'attack') {
                    xpReward = 20;
                    category = 'combat';
                    reason = 'Attack';
                } else if (action === 'hazard') {
                    xpReward = 25;
                    category = 'special';
                    reason = 'Explosive';
                } else if (action === 'trap') {
                    xpReward = 25;
                    category = 'special';
                    reason = 'Trap';
                } else if (action === 'stimpak') {
                    xpReward = 15;
                    category = 'special';
                    reason = 'Med Kit';
                } else if (action === 'flee') {
                    // Flee doesn't track combat XP - it awards directly in executeCombatAction
                    xpReward = 0;
                } else if (action === 'takeCover') {
                    xpReward = 15;
                    category = 'tactics';
                    reason = 'Take Cover';
                } else if (action === 'steadyAim') {
                    xpReward = 15;
                    category = 'tactics';
                    reason = 'Steady Aim';
                }

                if (xpReward > 0) {
                    trackCombatXP(xpReward, reason, category);
                }
                executeCombatAction(action);
            } else {
                var content = '<strong>Incorrect Answer!</strong><br><br>';
                content += 'Your answer: ' + userAnswer + '<br>';
                content += 'Correct answer: ' + gameState.currentProblem.answer + '<br><br>';
                if (action === 'flee') {
                    content += 'Escape failed! The enemy blocks your path.';
                } else {
                    content += 'Action failed! AP spent is lost.';
                }
                showPopup(content, 'error', 'WRONG!');
                
                var originalClose = closePopup;
                closePopup = function() {
                    document.getElementById('popup-overlay').classList.remove('active');
                    closePopup = originalClose;
                    returnToCombatChoices();
                };
            }
            
            updateXPDisplay();
        }
        
        function executeCombatAction(action) {
            // First, clean up the initial math UI before doing anything else
            document.getElementById('math-phase').style.display = 'none';
            document.getElementById('choice-phase').style.display = 'block';
            document.getElementById('mode-indicator').style.display = 'none';
            
            if (action === 'move') {
                var move = gameState.pendingMove;
                var currentAP = gameState.combat.ap;
                var apCost = move.apCost;
                var path = move.path || [{ x: move.x, y: move.y }];
                var apMultiplier = getVitalsAPMultiplier();

                // Build description showing exhaustion if applicable
                var desc = 'Calculate remaining AP after move:';
                if (apMultiplier > 1) {
                    var baseAP = Math.round(apCost / apMultiplier);
                    desc = 'Base cost: ' + baseAP + ' AP × ' + apMultiplier.toFixed(2) + ' (exhaustion) = ' + apCost + ' AP<br><br>Calculate remaining AP:';
                }

                requireCalculation({
                    title: '🚶 MOVEMENT AP',
                    description: desc,
                    formula: currentAP + ' - ' + apCost,
                    answer: currentAP - apCost,
                    xpReward: 0,
                    context: 'combat',
                    onSuccess: function(newAP) {
                        trackCombatXP(10, 'AP calc', 'tactics');
                        gameState.combat.ap = newAP;
                        executePathMovement(path, currentAP, newAP, false);
                    },
                    onFailure: function() {
                        // Miscalculation penalty: extra AP lost, but still move
                        var extraAPCost = Math.ceil(apCost * 0.5);
                        var totalCost = apCost + extraAPCost;
                        var newAP = currentAP - totalCost;
                        if (newAP < 0) newAP = 0;
                        gameState.combat.ap = newAP;
                        executePathMovement(path, currentAP, newAP, true, extraAPCost);
                    }
                });
            } else if (action === 'attack') {
                var hitChance = gameState.currentProblem.answer;
                var weapon = gameState.currentProblem.weapon;

                // Consume steady aim bonus after attack (one-time use)
                if (gameState.combat.steadyAim) {
                    gameState.combat.steadyAim = false;
                    gameState.combat.steadyBonus = 0;
                    updateTacticalButtons();
                }

                // Store attack data for after ammo calculation
                var attackData = {
                    hitChance: hitChance,
                    weapon: weapon,
                    roll: Math.random() * 100,
                    rollDisplay: 0
                };
                attackData.rollDisplay = Math.floor(attackData.roll);
                
                // Function to process the attack after ammo calculation
                function processAttackResult() {
                    // Degrade weapon durability (2-4 points per attack)
                    var durabilityLoss = 2 + Math.floor(Math.random() * 3);
                    degradeWeaponDurability(durabilityLoss);

                    var roll = attackData.roll;
                    var rollDisplay = attackData.rollDisplay;

                    if (roll < attackData.hitChance) {
                        // HIT! Check for critical hit (advanced math levels only)
                        // Apply durability damage penalty
                        var durabilityPenalty = getDurabilityDamagePenalty();
                        var baseDmg = Math.max(1, Math.floor(weapon.damage * (100 - durabilityPenalty) / 100));
                        var isCritical = false;
                        var critChance = 15; // Base 15% crit chance
                        var critRoll = Math.random() * 100;
                        var critMultiplier = 2;
                        
                        // For middle/high school, add crit probability calculation
                        var playerGrade = getPlayerGradeLevel();
                        if (playerGrade === '7-8' || playerGrade === '9-12') {
                            isCritical = critRoll < critChance;
                            
                            if (isCritical) {
                                // Critical hit! Require probability or damage multiplier calculation
                                var dmg = baseDmg * critMultiplier;
                                var enemyHP = gameState.combat.enemy.hp;
                                
                                showPopup(
                                    '<strong>💥 CRITICAL HIT!</strong><br><br>' +
                                    'Roll: ' + rollDisplay + ' vs ' + attackData.hitChance + '%<br>' +
                                    'Crit Roll: ' + Math.floor(critRoll) + ' vs ' + critChance + '%<br><br>' +
                                    '<span style="color: #ff0;">Critical multiplier: ' + critMultiplier + 'x!</span>',
                                    'success',
                                    'CRITICAL!'
                                );
                                
                                var origClose = closePopup;
                                closePopup = function() {
                                    document.getElementById('popup-overlay').classList.remove('active');
                                    closePopup = origClose;
                                    
                                    if (playerGrade === '9-12') {
                                        // High school: calculate compound probability first
                                        var hitProb = attackData.hitChance / 100;
                                        var critProb = critChance / 100;
                                        var compoundProb = Math.round(hitProb * critProb * 100);
                                        
                                        requireCalculation({
                                            title: '🎲 COMPOUND PROBABILITY',
                                            description: 'What was the probability of this critical hit?<br><br>Hit chance: ' + attackData.hitChance + '% = ' + hitProb + '<br>Crit chance: ' + critChance + '% = ' + critProb + '<br><br>P(hit AND crit) = P(hit) × P(crit)',
                                            formula: hitProb + ' × ' + critProb + ' = ? (as %)',
                                            answer: compoundProb,
                                            xpReward: 0,
                                            context: 'combat',
                                            onSuccess: function() {
                                                trackCombatXP(25, 'Probability', 'combat');
                                                processCriticalDamage(baseDmg, critMultiplier, enemyHP, weapon);
                                            },
                                            onFailure: function() {
                                                processCriticalDamage(baseDmg, critMultiplier, enemyHP, weapon);
                                            }
                                        });
                                    } else {
                                        // Middle school: just calculate crit damage
                                        processCriticalDamage(baseDmg, critMultiplier, enemyHP, weapon);
                                    }
                                };
                                return;
                            }
                        }
                        
                        // Normal hit damage calculation
                        var dmg = baseDmg;
                        var enemyHP = gameState.combat.enemy.hp;
                        
                        var hitMsg = '<strong>🎯 HIT!</strong><br><br>' +
                            'Roll: ' + rollDisplay + ' vs ' + attackData.hitChance + '% needed<br>';
                        if (weapon.ammoType) {
                            hitMsg += '<span style="color: #ff0;">Ammo remaining: ' + gameState.player.ammo[weapon.ammoType] + ' ' + weapon.ammoType + '</span><br>';
                        }
                        hitMsg += '<br>Now calculate the damage...';
                        
                        showPopup(hitMsg, 'success', 'ATTACK HIT');
                        
                        var origClose = closePopup;
                        closePopup = function() {
                            document.getElementById('popup-overlay').classList.remove('active');
                            closePopup = origClose;
                            
                            requireCalculation({
                                title: '⚔️ DAMAGE CALCULATION',
                                description: weapon.name + ' deals ' + dmg + ' damage!<br>Enemy HP: ' + enemyHP,
                                formula: enemyHP + ' - ' + dmg,
                                answer: enemyHP - dmg,
                                xpReward: 0,
                                context: 'combat',
                                onSuccess: function(newHP) {
                                    trackCombatXP(15, 'Damage', 'combat');
                                    var targetEnemy = gameState.combat.enemy;
                                    targetEnemy.hp = newHP;
                                    showCombatMessage('<strong>💥 ' + dmg + ' DAMAGE!</strong><br><br>Enemy HP: ' + enemyHP + ' → ' + Math.max(0, newHP), 'success');
                                    updateCombatUI();
                                    updateInventoryDisplay();
                                    renderGrid();
                                    if (newHP <= 0) {
                                        if (!handleEnemyDefeat(targetEnemy)) {
                                            returnToCombatChoices();
                                        }
                                    } else {
                                        returnToCombatChoices();
                                    }
                                },
                                onFailure: function() {
                                    var reducedDmg = Math.floor(dmg / 2);
                                    var newHP = enemyHP - reducedDmg;
                                    var targetEnemy = gameState.combat.enemy;
                                    targetEnemy.hp = newHP;
                                    showCombatMessage('<strong>⚠️ GLANCING BLOW!</strong><br><br>Miscalculation reduced damage by 50%<br>Damage: ' + reducedDmg + ' (instead of ' + dmg + ')<br>Enemy HP: ' + enemyHP + ' → ' + Math.max(0, newHP), 'info');
                                    updateCombatUI();
                                    updateInventoryDisplay();
                                    renderGrid();
                                    if (newHP <= 0) {
                                        if (!handleEnemyDefeat(targetEnemy)) {
                                            returnToCombatChoices();
                                        }
                                    } else {
                                        returnToCombatChoices();
                                    }
                                }
                            });
                        };
                    } else {
                        // MISS
                        var missMsg = '<strong>💨 MISS!</strong><br><br>Roll: ' + rollDisplay + ' vs ' + attackData.hitChance + '% needed';
                        if (weapon.ammoType) {
                            missMsg += '<br><span style="color: #f44;">Ammo wasted! Remaining: ' + gameState.player.ammo[weapon.ammoType] + ' ' + weapon.ammoType + '</span>';
                        }
                        showCombatMessage(missMsg, 'error');
                        updateInventoryDisplay();
                        returnToCombatChoices();
                    }
                }
                
                // Helper function for critical damage calculation
                function processCriticalDamage(baseDmg, multiplier, enemyHP, weapon) {
                    requireCalculation({
                        title: '💥 CRITICAL DAMAGE',
                        description: 'Critical hit! Damage is multiplied!<br><br>Base damage: ' + baseDmg + '<br>Multiplier: ' + multiplier + 'x',
                        formula: baseDmg + ' × ' + multiplier,
                        answer: baseDmg * multiplier,
                        xpReward: 0,
                        context: 'combat',
                        onSuccess: function(critDmg) {
                            trackCombatXP(20, 'Crit dmg', 'combat');
                            // Now subtract from enemy HP
                            requireCalculation({
                                title: '⚔️ APPLY CRITICAL',
                                description: 'Critical damage: ' + critDmg + '<br>Enemy HP: ' + enemyHP,
                                formula: enemyHP + ' - ' + critDmg,
                                answer: enemyHP - critDmg,
                                xpReward: 0,
                                context: 'combat',
                                onSuccess: function(newHP) {
                                    trackCombatXP(15, 'Damage', 'combat');
                                    var targetEnemy = gameState.combat.enemy;
                                    targetEnemy.hp = newHP;
                                    showCombatMessage('<strong>💥💥 CRITICAL! ' + critDmg + ' DAMAGE!</strong><br><br>Enemy HP: ' + enemyHP + ' → ' + Math.max(0, newHP), 'success');
                                    updateCombatUI();
                                    updateInventoryDisplay();
                                    renderGrid();
                                    if (newHP <= 0) {
                                        if (!handleEnemyDefeat(targetEnemy)) {
                                            returnToCombatChoices();
                                        }
                                    } else {
                                        returnToCombatChoices();
                                    }
                                },
                                onFailure: function() {
                                    var reducedDmg = Math.floor(critDmg / 2);
                                    var newHP = enemyHP - reducedDmg;
                                    var targetEnemy = gameState.combat.enemy;
                                    targetEnemy.hp = newHP;
                                    showCombatMessage('<strong>⚠️ FUMBLED CRIT!</strong><br>Damage: ' + reducedDmg + '<br>Enemy HP: ' + enemyHP + ' → ' + Math.max(0, newHP), 'info');
                                    updateCombatUI();
                                    updateInventoryDisplay();
                                    renderGrid();
                                    if (newHP <= 0) {
                                        if (!handleEnemyDefeat(targetEnemy)) {
                                            returnToCombatChoices();
                                        }
                                    } else {
                                        returnToCombatChoices();
                                    }
                                }
                            });
                        },
                        onFailure: function() {
                            // Failed crit calculation - just do normal damage
                            var newHP = enemyHP - baseDmg;
                            var targetEnemy = gameState.combat.enemy;
                            targetEnemy.hp = newHP;
                            showCombatMessage('<strong>⚠️ FUMBLED CRIT!</strong><br>Only dealt base damage: ' + baseDmg, 'info');
                            updateCombatUI();
                            updateInventoryDisplay();
                            renderGrid();
                            if (newHP <= 0) {
                                if (!handleEnemyDefeat(targetEnemy)) {
                                    returnToCombatChoices();
                                }
                            } else {
                                returnToCombatChoices();
                            }
                        }
                    });
                }
                
                // If weapon uses ammo, require ammo calculation first
                if (weapon.ammoType && weapon.ammoPerShot > 0) {
                    var currentAmmo = gameState.player.ammo[weapon.ammoType];
                    var ammoUsed = weapon.ammoPerShot;
                    var newAmmo = currentAmmo - ammoUsed;
                    var ammoTypeName = AMMO_TYPES[weapon.ammoType] ? AMMO_TYPES[weapon.ammoType].name : weapon.ammoType;
                    
                    requireCalculation({
                        title: '🔫 AMMO CALCULATION',
                        description: 'Firing ' + weapon.name + '!<br>Current ' + ammoTypeName + ': ' + currentAmmo + '<br>Rounds fired: ' + ammoUsed,
                        formula: currentAmmo + ' - ' + ammoUsed,
                        answer: newAmmo,
                        xpReward: 0,
                        context: 'combat',
                        onSuccess: function(remainingAmmo) {
                            trackCombatXP(10, 'Ammo calc', 'combat');
                            gameState.player.ammo[weapon.ammoType] = remainingAmmo;
                            processAttackResult();
                        },
                        onFailure: function() {
                            // Fumbled ammo - lose extra round but attack continues
                            var extraLoss = weapon.ammoPerShot;
                            var fumbledAmmo = Math.max(0, newAmmo - extraLoss);
                            gameState.player.ammo[weapon.ammoType] = fumbledAmmo;
                            showCombatMessage('<strong>⚠️ FUMBLED AMMO!</strong><br><br>Miscounted and dropped extra rounds!<br>Lost ' + (ammoUsed + extraLoss) + ' ' + ammoTypeName + ' instead of ' + ammoUsed + '<br><br>Remaining: ' + fumbledAmmo, 'error');
                            updateInventoryDisplay();
                            // Attack still proceeds
                            processAttackResult();
                        }
                    });
                } else {
                    // Melee weapon - no ammo needed, proceed directly
                    processAttackResult();
                }
            } else if (action === 'stimpak') {
                var heal = gameState.currentProblem.answer;
                var oldHp = gameState.player.hp;
                var maxHp = gameState.player.maxHp;
                var newHp = Math.min(oldHp + heal, maxHp);
                
                // Require the HP addition calculation
                requireCalculation({
                    title: '💉 HEALING',
                    description: 'Current HP: ' + oldHp + '<br>Healing: +' + heal + '<br>Max HP: ' + maxHp,
                    formula: oldHp + ' + ' + heal + (oldHp + heal > maxHp ? ' (capped at ' + maxHp + ')' : ''),
                    answer: newHp,
                    xpReward: 0, // XP tracked separately for consolidated calculation
                    context: 'combat',
                    onSuccess: function(result) {
                        trackCombatXP(10, 'Heal calc', 'special');
                        gameState.player.hp = result;
                        gameState.player.medkits--;
                        showCombatMessage('<strong>💉 HEALED!</strong><br><br>HP: ' + oldHp + ' → ' + result + '/' + maxHp + '<br>Med Kits: ' + gameState.player.medkits, 'success');
                        updateCombatUI();
                        returnToCombatChoices();
                    },
                    onFailure: function() {
                        // Partial injection - heal half
                        var reducedHeal = Math.floor(heal / 2);
                        var partialHp = Math.min(oldHp + reducedHeal, maxHp);
                        gameState.player.hp = partialHp;
                        gameState.player.medkits--;
                        showCombatMessage('<strong>💉 PARTIAL HEAL!</strong><br><br>Fumbled injection - only 50% effective<br>HP: ' + oldHp + ' → ' + partialHp + '/' + maxHp + '<br>Med Kits: ' + gameState.player.medkits, 'info');
                        updateCombatUI();
                        returnToCombatChoices();
                    }
                });
            } else if (action === 'hazard') {
                var prob = gameState.currentProblem;
                gameState.combat.hazards[prob.hazardIndex].used = true;
                
                if (prob.inRange === 1) {
                    var targetEnemy = gameState.combat.enemy;
                    var enemyHP = targetEnemy.hp;
                    var dmg = prob.damage;

                    requireCalculation({
                        title: '💥 EXPLOSION DAMAGE',
                        description: prob.hazardName + ' explodes!<br>Damage: ' + dmg + '<br>Enemy HP: ' + enemyHP,
                        formula: enemyHP + ' - ' + dmg,
                        answer: enemyHP - dmg,
                        xpReward: 0, // XP tracked separately for consolidated calculation
                        context: 'combat',
                        onSuccess: function(newHP) {
                            trackCombatXP(20, 'Explosion', 'special');
                            targetEnemy.hp = newHP;
                            showCombatMessage('<strong>💥 BOOM!</strong><br>' + dmg + ' damage!<br>Enemy HP: ' + Math.max(0, newHP), 'success');
                            updateCombatUI();
                            renderGrid();
                            if (newHP <= 0) {
                                if (!handleEnemyDefeat(targetEnemy)) {
                                    returnToCombatChoices();
                                }
                            } else {
                                returnToCombatChoices();
                            }
                        },
                        onFailure: function() {
                            // Partial explosion - deal half damage
                            var reducedDmg = Math.floor(dmg / 2);
                            var newHP = enemyHP - reducedDmg;
                            targetEnemy.hp = newHP;
                            showCombatMessage('<strong>💥 PARTIAL EXPLOSION!</strong><br>Miscalculation reduced effect by 50%<br>Damage: ' + reducedDmg + '<br>Enemy HP: ' + Math.max(0, newHP), 'info');
                            updateCombatUI();
                            renderGrid();
                            if (newHP <= 0) {
                                if (!handleEnemyDefeat(targetEnemy)) {
                                    returnToCombatChoices();
                                }
                            } else {
                                returnToCombatChoices();
                            }
                        }
                    });
                } else {
                    showCombatMessage('<strong>💥 EXPLOSION!</strong><br>Enemy was out of range!', 'error');
                    returnToCombatChoices();
                }
            } else if (action === 'trap') {
                var prob = gameState.currentProblem;
                gameState.combat.traps[prob.trapIndex].used = true;
                var targetEnemy = gameState.combat.enemy;
                var enemyHP = targetEnemy.hp;
                var dmg = prob.damage;

                requireCalculation({
                    title: '⚙ TRAP DAMAGE',
                    description: prob.trapName + ' triggers!<br>Damage: ' + dmg + '<br>Enemy HP: ' + enemyHP,
                    formula: enemyHP + ' - ' + dmg,
                    answer: enemyHP - dmg,
                    xpReward: 0, // XP tracked separately for consolidated calculation
                    context: 'combat',
                    onSuccess: function(newHP) {
                        trackCombatXP(20, 'Trap dmg', 'special');
                        targetEnemy.hp = newHP;
                        showCombatMessage('<strong>⚙ TRAP!</strong><br>' + dmg + ' damage!<br>Enemy HP: ' + Math.max(0, newHP), 'success');
                        updateCombatUI();
                        renderGrid();
                        if (newHP <= 0) {
                            if (!handleEnemyDefeat(targetEnemy)) {
                                returnToCombatChoices();
                            }
                        } else {
                            returnToCombatChoices();
                        }
                    },
                    onFailure: function() {
                        // Partial trigger - deal half damage
                        var reducedDmg = Math.floor(dmg / 2);
                        var newHP = enemyHP - reducedDmg;
                        targetEnemy.hp = newHP;
                        showCombatMessage('<strong>⚙ PARTIAL TRIGGER!</strong><br>Miscalculation reduced effect by 50%<br>Damage: ' + reducedDmg + '<br>Enemy HP: ' + Math.max(0, newHP), 'info');
                        updateCombatUI();
                        renderGrid();
                        if (newHP <= 0) {
                            if (!handleEnemyDefeat(targetEnemy)) {
                                returnToCombatChoices();
                            }
                        } else {
                            returnToCombatChoices();
                        }
                    }
                });
            } else if (action === 'flee') {
                // Flee attempt - successful math means escape
                var xpText = awardXP(gameState.currentProblem.xpReward, 'flee math');

                showPopup(
                    '<strong>🏃 ESCAPED!</strong><br><br>' +
                    'You successfully fled from combat!<br><br>' +
                    xpText,
                    'success',
                    'ESCAPE SUCCESS'
                );

                var origClose = closePopup;
                closePopup = function() {
                    document.getElementById('popup-overlay').classList.remove('active');
                    closePopup = origClose;
                    processPendingCalcs(function() {
                        showScreen('exploration-screen');
                        updateInventoryDisplay();
                        updateXPDisplay();
                        nextExplorationEvent();
                    });
                };
            } else if (action === 'takeCover') {
                // Take Cover - grant accuracy bonus
                var prob = gameState.currentProblem;
                gameState.combat.ap -= prob.apCost;
                gameState.combat.inCover = true;
                gameState.combat.coverBonus = prob.coverBonus;

                showCombatMessage(
                    '<strong>🛡️ IN COVER!</strong><br><br>' +
                    'You brace against the ' + prob.coverType + ' cover.<br><br>' +
                    '<span style="color: #0f0;">+' + prob.coverBonus + '% accuracy bonus active!</span><br><br>' +
                    '<span style="font-size: 0.85em; color: #888;">Bonus remains until you move.</span>',
                    'success'
                );
                updateCombatUI();
                updateTacticalButtons();
                returnToCombatChoices();
            } else if (action === 'steadyAim') {
                // Steady Aim - grant accuracy bonus for next attack
                var prob = gameState.currentProblem;
                gameState.combat.ap -= prob.apCost;
                gameState.combat.steadyAim = true;
                gameState.combat.steadyBonus = prob.steadyBonus;

                showCombatMessage(
                    '<strong>🎯 STEADY AIM!</strong><br><br>' +
                    'You control your breathing and focus...<br><br>' +
                    '<span style="color: #ff0;">+' + prob.steadyBonus + '% accuracy on your next attack!</span><br><br>' +
                    '<span style="font-size: 0.85em; color: #888;">Bonus consumed after your next attack.</span>',
                    'success'
                );
                updateCombatUI();
                updateTacticalButtons();
                returnToCombatChoices();
            }
        }
        
        function cancelAction() {
            // Refund AP based on action
            if (gameState.currentAction === 'attack' && gameState.currentProblem && gameState.currentProblem.weapon) {
                gameState.combat.ap += gameState.currentProblem.weapon.apCost;
            } else if (gameState.currentAction === 'takeCover' || gameState.currentAction === 'steadyAim') {
                // Tactical actions haven't deducted AP yet (done on success), so no refund needed
            } else {
                var refunds = { stimpak: 30, hazard: 15, trap: 15, flee: 50 };
                if (refunds[gameState.currentAction]) {
                    gameState.combat.ap += refunds[gameState.currentAction];
                }
            }
            returnToCombatChoices();
        }
        
        function returnToCombatChoices() {
            gameState.mode = null;
            gameState.currentAction = null;
            gameState.currentProblem = null;
            document.getElementById('math-phase').style.display = 'none';
            document.getElementById('mode-indicator').style.display = 'none';
            document.getElementById('choice-phase').style.display = 'block';
            document.getElementById('grid-mode-text').textContent = '(Select action below)';
            updateCombatUI();
            updateEnvironmentActions();
            renderGrid();
        }
        
        function updateCombatUI() {
            // Player stats
            document.getElementById('player-hp').textContent = gameState.player.hp;
            document.getElementById('player-max-hp').textContent = gameState.player.maxHp;
            document.getElementById('player-ap').textContent = gameState.combat.ap;
            document.getElementById('player-max-ap').textContent = gameState.combat.maxAp;
            document.getElementById('player-x').textContent = gameState.combat.player.x;
            document.getElementById('player-y').textContent = gameState.combat.player.y;
            
            var hpPercent = (gameState.player.hp / gameState.player.maxHp) * 100;
            var apPercent = (gameState.combat.ap / gameState.combat.maxAp) * 100;
            document.getElementById('player-hp-bar').style.width = hpPercent + '%';
            document.getElementById('player-hp-bar').textContent = gameState.player.hp;
            document.getElementById('player-ap-bar').style.width = apPercent + '%';
            document.getElementById('player-ap-bar').textContent = gameState.combat.ap;
            
            // Distance calculation
            var dist = calculateDistance(
                gameState.combat.player.x, gameState.combat.player.y,
                gameState.combat.enemy.x, gameState.combat.enemy.y
            );
            var roundedDist = Math.round(dist * 10) / 10;
            
            // Weapon slots
            var weapon1 = getWeaponInSlot(1);
            var weapon2 = getWeaponInSlot(2);
            var activeWeapon = getActiveWeapon();
            
            // Update weapon slot 1
            if (weapon1) {
                document.getElementById('weapon1-name').textContent = weapon1.name;
                // Show ammo in stats line
                var stats1 = 'Dmg: ' + weapon1.damage + ' | Acc: ' + weapon1.accuracy + '%';
                if (weapon1.ammoType) {
                    var ammo1 = gameState.player.ammo[weapon1.ammoType] || 0;
                    stats1 += ' | Ammo: ' + ammo1;
                }
                document.getElementById('weapon1-stats').textContent = stats1;
                
                var range1Text = weapon1.type === 'melee' ? 
                    'Melee (≤' + weapon1.maxRange + ' sq)' : 
                    'Range: ' + weapon1.minRange + '-' + weapon1.maxRange + ' sq';
                if (weapon1.ammoType && (gameState.player.ammo[weapon1.ammoType] || 0) < weapon1.ammoPerShot) {
                    range1Text = '⚠ NO AMMO!';
                }
                document.getElementById('weapon1-range').textContent = range1Text;
                
                var range1 = calculateRangeModifier(weapon1, roundedDist);
                var slot1El = document.getElementById('weapon-slot-1');
                slot1El.classList.toggle('active', gameState.player.activeSlot === 1);
                
                // Check both range and ammo for highlighting
                var hasAmmo1 = !weapon1.ammoType || (gameState.player.ammo[weapon1.ammoType] || 0) >= weapon1.ammoPerShot;
                slot1El.classList.toggle('in-range', range1.canHit && range1.modifier >= 0 && hasAmmo1);
                slot1El.classList.toggle('out-of-range', !range1.canHit || range1.modifier < -20 || !hasAmmo1);
            }
            
            // Update weapon slot 2
            if (weapon2) {
                document.getElementById('weapon2-name').textContent = weapon2.name;
                // Show ammo in stats line
                var stats2 = 'Dmg: ' + weapon2.damage + ' | Acc: ' + weapon2.accuracy + '%';
                if (weapon2.ammoType) {
                    var ammo2 = gameState.player.ammo[weapon2.ammoType] || 0;
                    stats2 += ' | Ammo: ' + ammo2;
                }
                document.getElementById('weapon2-stats').textContent = stats2;
                
                var range2Text = weapon2.type === 'melee' ? 
                    'Melee (≤' + weapon2.maxRange + ' sq)' : 
                    'Range: ' + weapon2.minRange + '-' + weapon2.maxRange + ' sq';
                if (weapon2.ammoType && (gameState.player.ammo[weapon2.ammoType] || 0) < weapon2.ammoPerShot) {
                    range2Text = '⚠ NO AMMO!';
                }
                document.getElementById('weapon2-range').textContent = range2Text;
                
                var range2 = calculateRangeModifier(weapon2, roundedDist);
                var slot2El = document.getElementById('weapon-slot-2');
                slot2El.classList.toggle('active', gameState.player.activeSlot === 2);
                
                // Check both range and ammo for highlighting
                var hasAmmo2 = !weapon2.ammoType || (gameState.player.ammo[weapon2.ammoType] || 0) >= weapon2.ammoPerShot;
                slot2El.classList.toggle('in-range', range2.canHit && range2.modifier >= 0 && hasAmmo2);
                slot2El.classList.toggle('out-of-range', !range2.canHit || range2.modifier < -20 || !hasAmmo2);
            }
            
            // Enemy list and stats
            var aliveEnemies = gameState.combat.enemies.filter(function(e) { return e.alive; });
            var aliveCount = aliveEnemies.length;
            var totalEnemies = gameState.combat.enemies.length;

            // Update enemy count display
            document.getElementById('enemies-alive-count').textContent =
                totalEnemies > 1 ? '(' + aliveCount + '/' + totalEnemies + ')' : '';

            // Show/hide target controls based on alive enemy count
            var targetControls = document.getElementById('target-controls');
            targetControls.style.display = aliveCount > 1 ? 'block' : 'none';

            // Populate enemy list (compact view for multiple enemies)
            var enemyListContainer = document.getElementById('enemy-list-container');
            if (totalEnemies > 1) {
                var listHtml = '';
                for (var ei = 0; ei < gameState.combat.enemies.length; ei++) {
                    var enemy = gameState.combat.enemies[ei];
                    var isTargeted = ei === gameState.combat.targetedEnemy;
                    var hpPct = Math.max(0, enemy.hp) / enemy.maxHp * 100;
                    var statusClass = !enemy.alive ? 'enemy-dead' : (isTargeted ? 'enemy-targeted-item' : '');
                    var statusIcon = !enemy.alive ? '💀' : (isTargeted ? '🎯' : '');

                    listHtml += '<div class="enemy-list-item ' + statusClass + '" onclick="selectTarget(' + ei + ')" style="' +
                        'cursor: pointer; padding: 3px 5px; margin: 2px 0; border: 1px solid ' +
                        (isTargeted ? '#ff0' : '#444') + '; border-radius: 3px; font-size: 0.85em;' +
                        (enemy.alive ? '' : 'opacity: 0.5; text-decoration: line-through;') + '">' +
                        '<span>' + statusIcon + ' #' + (ei + 1) + ' ' + enemy.baseName + '</span>' +
                        '<span style="float: right;">' + Math.max(0, enemy.hp) + '/' + enemy.maxHp + '</span>' +
                        '</div>';
                }
                enemyListContainer.innerHTML = listHtml;
                enemyListContainer.style.display = 'block';
            } else {
                enemyListContainer.style.display = 'none';
            }

            // Get targeted enemy (uses getTargetedEnemy helper)
            var targetedEnemy = getTargetedEnemy();
            if (targetedEnemy) {
                // Update legacy reference
                gameState.combat.enemy = targetedEnemy;

                document.getElementById('enemy-name').textContent = targetedEnemy.name.toUpperCase();
                document.getElementById('enemy-hp').textContent = Math.max(0, targetedEnemy.hp);
                document.getElementById('enemy-max-hp').textContent = targetedEnemy.maxHp;
                document.getElementById('enemy-x').textContent = targetedEnemy.x;
                document.getElementById('enemy-y').textContent = targetedEnemy.y;
                document.getElementById('enemy-type').textContent = targetedEnemy.type === 'melee' ? 'Melee (rushes you)' : 'Ranged';

                var enemyHpPercent = (Math.max(0, targetedEnemy.hp) / targetedEnemy.maxHp) * 100;
                document.getElementById('enemy-hp-bar').style.width = enemyHpPercent + '%';
                document.getElementById('enemy-hp-bar').textContent = Math.max(0, targetedEnemy.hp);
            }
            
            // Distance display
            document.getElementById('current-distance').textContent = roundedDist;
            document.getElementById('current-feet').textContent = Math.round(roundedDist * SQUARE_FEET);
            
            // LOS status in side panel
            if (gameState.combat.currentLOS) {
                var los = gameState.combat.currentLOS;
                var losText = document.getElementById('los-text');
                if (los.status === 'clear') {
                    losText.innerHTML = '<span style="color: #0f0;">✓ Clear</span>';
                } else if (los.status === 'partial') {
                    losText.innerHTML = '<span style="color: #ff0;">◐ Partial (-' + los.penalty + '%)</span>';
                } else {
                    losText.innerHTML = '<span style="color: #f44;">✗ Blocked</span>';
                }
            }
            
            // Range status for active weapon
            var activeRange = calculateRangeModifier(activeWeapon, roundedDist);
            var rangeText = document.getElementById('range-text');
            if (!activeRange.canHit) {
                rangeText.innerHTML = '<span style="color: #f44;">' + activeRange.reason + '</span>';
            } else if (activeRange.modifier >= 0) {
                rangeText.innerHTML = '<span style="color: #0f0;">' + activeRange.reason + '</span>';
            } else {
                rangeText.innerHTML = '<span style="color: #ff0;">' + activeRange.reason + '</span>';
            }
            
            // Med Kit button
            document.getElementById('stimpak-btn').disabled = gameState.player.medkits <= 0 || gameState.combat.ap < 30;

            // Flee button
            document.getElementById('flee-btn').disabled = gameState.combat.ap < 50;

            // Update attack button with current weapon info
            updateAttackButton();

            // Update tactical action buttons (cover & steady aim)
            updateTacticalButtons();
        }
        
        function updateAttackButton() {
            var weapon = getActiveWeapon();
            document.getElementById('attack-ap-cost').textContent = weapon.apCost + ' AP';
            document.getElementById('attack-weapon-info').textContent = weapon.name + ' (' + weapon.type + ')';
            
            // Disable if not enough AP
            document.getElementById('attack-btn').disabled = gameState.combat.ap < weapon.apCost;
        }
        
        function updateEnvironmentActions() {
            var html = '';
            var activeHazards = gameState.combat.hazards.filter(h => !h.used);
            var activeTraps = gameState.combat.traps.filter(t => !t.used);
            
            if (activeHazards.length > 0 || activeTraps.length > 0) {
                html += '<div style="margin-top: 10px; padding: 10px; background: rgba(255,165,0,0.1); border: 1px solid #ffa500; border-radius: 5px;">';
                
                // Explosives section
                if (activeHazards.length > 0) {
                    html += '<strong style="color: #ffa500;">💥 EXPLOSIVES:</strong><br>';
                    gameState.combat.hazards.forEach(function(h, i) {
                        if (!h.used) {
                            html += '<button class="btn environment" onclick="triggerHazard(' + i + ')">';
                            html += '💥 ' + h.name + ' at (' + h.x + ',' + h.y + ') <span class="ap-cost-tag">15 AP</span><br>';
                            html += '<span style="font-size:0.8em">Damage: ' + h.damage + ' | Blast Radius: ' + h.radius + 'm</span></button>';
                        }
                    });
                }
                
                // Traps section
                if (activeTraps.length > 0) {
                    html += '<strong style="color: #a855f7;">⚙ TRAPS</strong> <span style="font-size:0.8em; color: #aaa;">(Enemy must be on trap)</span><br>';
                    gameState.combat.traps.forEach(function(t, i) {
                        if (!t.used) {
                            html += '<button class="btn" style="background: #a855f7; color: #fff;" onclick="triggerTrap(' + i + ')">';
                            html += '⚙ ' + t.name + ' at (' + t.x + ',' + t.y + ') <span class="ap-cost-tag">15 AP</span><br>';
                            html += '<span style="font-size:0.8em">Damage: ' + t.damage + ' | Must lure enemy to trap!</span></button>';
                        }
                    });
                }
                
                html += '</div>';
            }
            
            document.getElementById('env-actions').innerHTML = html;
        }
        
        function endTurn() {
            exitMode();
            enemyTurn();
        }
        
        function enemyTurn() {
            // Get all alive enemies
            var aliveEnemies = gameState.combat.enemies.filter(function(e) { return e.alive; });

            if (aliveEnemies.length === 0) return;

            // Process each enemy's turn sequentially
            var currentEnemyIndex = 0;

            function processNextEnemy() {
                if (currentEnemyIndex >= aliveEnemies.length) {
                    // All enemies have acted, reset AP and return to player turn
                    gameState.combat.ap = gameState.combat.maxAp;
                    updateCombatUI();
                    renderGrid();
                    return;
                }

                var enemy = aliveEnemies[currentEnemyIndex];
                currentEnemyIndex++;

                processSingleEnemyTurn(enemy, function() {
                    // Check if player died
                    if (gameState.player.hp <= 0) return;
                    // Small delay between enemy turns for readability
                    setTimeout(processNextEnemy, 300);
                });
            }

            processNextEnemy();
        }

        // Process a single enemy's turn with callback when done
        function processSingleEnemyTurn(enemy, onComplete) {
            var player = gameState.combat.player;
            
            // Enemy AI: melee enemies move toward player, ranged try to keep distance
            var dx = player.x - enemy.x;
            var dy = player.y - enemy.y;
            var dist = Math.sqrt(dx * dx + dy * dy);
            
            var moveLog = '';
            var oldX = enemy.x;
            var oldY = enemy.y;
            
            // Melee range is 1 square (adjacent, including diagonal = ~1.4 squares)
            var meleeRange = 1.5;
            
            if (enemy.type === 'melee' && dist > meleeRange) {
                // Melee enemies move up to 6 squares per turn (half the battlefield)
                // They always try to get as close as possible to the player
                var maxMoveSquares = 6;
                var bestX = enemy.x;
                var bestY = enemy.y;
                var bestDist = dist;

                // Try to move step by step toward the player, up to maxMoveSquares
                var testX = enemy.x;
                var testY = enemy.y;

                for (var step = 0; step < maxMoveSquares; step++) {
                    var stepDx = player.x - testX;
                    var stepDy = player.y - testY;

                    // Determine next step direction (prioritize the larger distance)
                    var nextX = testX;
                    var nextY = testY;

                    if (Math.abs(stepDx) >= Math.abs(stepDy)) {
                        nextX = testX + (stepDx > 0 ? 1 : (stepDx < 0 ? -1 : 0));
                    } else {
                        nextY = testY + (stepDy > 0 ? 1 : (stepDy < 0 ? -1 : 0));
                    }

                    // Check bounds
                    nextX = Math.max(0, Math.min(GRID_WIDTH - 1, nextX));
                    nextY = Math.max(0, Math.min(GRID_HEIGHT - 1, nextY));

                    // Check for walls
                    var coverAtNext = gameState.combat.cover.find(c => c.x === nextX && c.y === nextY);
                    var blockedByWall = coverAtNext && coverAtNext.type === 'wall';

                    // Check if another enemy is blocking
                    var blockedByEnemy = gameState.combat.enemies.some(function(e) {
                        return e !== enemy && e.alive && e.x === nextX && e.y === nextY;
                    });

                    // Check if player is there (can't walk through player)
                    var blockedByPlayer = nextX === player.x && nextY === player.y;

                    // If blocked, stop moving
                    if (blockedByWall || blockedByEnemy || blockedByPlayer) {
                        break;
                    }

                    // Valid move - update test position
                    testX = nextX;
                    testY = nextY;

                    // Check if this is closer to player
                    var newDist = Math.sqrt((player.x - testX) * (player.x - testX) + (player.y - testY) * (player.y - testY));
                    if (newDist < bestDist) {
                        bestX = testX;
                        bestY = testY;
                        bestDist = newDist;
                    }

                    // If in melee range, stop
                    if (newDist <= meleeRange) {
                        break;
                    }
                }

                // Apply the best position found
                if (bestX !== enemy.x || bestY !== enemy.y) {
                    enemy.x = bestX;
                    enemy.y = bestY;
                    var moveDistSquares = Math.sqrt((bestX - oldX) * (bestX - oldX) + (bestY - oldY) * (bestY - oldY));
                    var moveDistFeet = Math.round(moveDistSquares * SQUARE_FEET);
                    moveLog = 'Charged ' + moveDistFeet + ' ft: (' + oldX + ',' + oldY + ') → (' + bestX + ',' + bestY + ')';
                }
            }
            
            // Recalculate distance and LOS after move
            dx = player.x - enemy.x;
            dy = player.y - enemy.y;
            dist = Math.sqrt(dx * dx + dy * dy);
            var roundedDist = Math.round(dist * 10) / 10;
            var distFeet = roundedDist * SQUARE_FEET;

            // Check enemy's line of sight to player
            var enemyLOS = calculateLineOfSight(enemy.x, enemy.y, player.x, player.y);

            // Determine attack type based on range
            var isMeleeAttack = enemy.type === 'melee' && dist <= meleeRange;

            // Melee enemies can ONLY attack if in melee range
            if (enemy.type === 'melee' && dist > meleeRange) {
                // Melee enemy is out of range - can't attack, just end turn
                updateCombatUI();
                renderGrid();

                showPopup(
                    '<strong>' + enemy.name.toUpperCase() + '\'s TURN</strong><br><br>' +
                    (moveLog ? '🚶 ' + moveLog + '<br><br>' : '') +
                    '<span style="color: #ff0;">⚔️ Too far to attack! (Distance: ' + distFeet + ' ft)</span>',
                    'info',
                    'OUT OF RANGE'
                );
                var origCloseOutOfRange = closePopup;
                closePopup = function() {
                    document.getElementById('popup-overlay').classList.remove('active');
                    closePopup = origCloseOutOfRange;
                    onComplete();
                };
                return;
            }

            // Enemy attack
            var baseHit = isMeleeAttack ? 70 : 50;
            var distPenalty = isMeleeAttack ? 0 : Math.floor(dist * 2);
            var coverPenalty = isMeleeAttack ? 0 : enemyLOS.penalty;
            var hitChance = baseHit - distPenalty - coverPenalty;
            if (hitChance < 10) hitChance = 10;

            var roll = Math.random() * 100;
            var rollDisplay = Math.floor(roll);

            updateCombatUI();
            renderGrid();

            if (!enemyLOS.canShoot && !isMeleeAttack) {
                // Blocked by wall
                showPopup(
                    '<strong>' + enemy.name.toUpperCase() + '\'s TURN</strong><br><br>' +
                    (moveLog ? '🚶 ' + moveLog + '<br><br>' : '') +
                    '<span style="color: #0f0;">✓ Shot blocked by wall!</span>',
                    'info',
                    'ENEMY BLOCKED'
                );
                var origCloseBlocked = closePopup;
                closePopup = function() {
                    document.getElementById('popup-overlay').classList.remove('active');
                    closePopup = origCloseBlocked;
                    onComplete();
                };
            } else if (roll < hitChance) {
                // HIT - require player to calculate damage to their HP
                var baseDmg = Math.floor(Math.random() * 10) + (isMeleeAttack ? 20 : 15);
                var playerCover = gameState.combat.cover.find(c => c.x === player.x && c.y === player.y);
                var dmgReduction = 0;
                if (playerCover && !isMeleeAttack) {
                    if (playerCover.type === 'small') dmgReduction = 15;
                    else if (playerCover.type === 'medium') dmgReduction = 30;
                }
                var finalDmg = Math.floor(baseDmg * (100 - dmgReduction) / 100);
                var currentHP = gameState.player.hp;
                
                var attackType = isMeleeAttack ? '🗡️ MELEE HIT!' : '⚔️ RANGED HIT!';
                
                // If player has cover, require them to calculate the damage reduction first
                if (dmgReduction > 0) {
                    showPopup(
                        '<strong>' + enemy.name.toUpperCase() + '\'s TURN</strong><br><br>' +
                        (moveLog ? '🚶 ' + moveLog + '<br><br>' : '') +
                        '<span style="color: #f44;">' + attackType + '</span><br>' +
                        'Roll: ' + rollDisplay + ' vs ' + hitChance + '%<br><br>' +
                        '<span style="color: #ff0;">You have cover! (' + dmgReduction + '% reduction)</span><br>' +
                        'Base damage: ' + baseDmg + '<br><br>' +
                        'Calculate the reduced damage...',
                        'error',
                        'ENEMY HIT!'
                    );
                    
                    var origClose = closePopup;
                    closePopup = function() {
                        document.getElementById('popup-overlay').classList.remove('active');
                        closePopup = origClose;
                        
                        // First calculate cover reduction
                        requireCalculation({
                            title: '🛡️ COVER REDUCTION',
                            description: 'Your cover blocks ' + dmgReduction + '% of damage!<br><br>Base damage: ' + baseDmg + '<br>Reduction: ' + dmgReduction + '%<br><br>Calculate damage after reduction:<br>' + baseDmg + ' × ' + (100 - dmgReduction) + ' ÷ 100',
                            formula: baseDmg + ' × ' + (100 - dmgReduction) / 100 + ' (or ' + baseDmg + ' × 0.' + (100 - dmgReduction) + ')',
                            answer: finalDmg,
                            xpReward: 0,
                            context: 'combat',
                            onSuccess: function(reducedDmg) {
                                trackCombatXP(15, 'Cover calc', 'defense');
                                // Now calculate HP reduction
                                requireCalculation({
                                    title: '💔 DAMAGE TAKEN',
                                    description: 'Cover reduced damage to ' + reducedDmg + '!<br>Your HP: ' + currentHP,
                                    formula: currentHP + ' - ' + reducedDmg,
                                    answer: currentHP - reducedDmg,
                                    xpReward: 0,
                                    context: 'combat',
                                    onSuccess: function(newHP) {
                                        trackCombatXP(10, 'Survived hit', 'defense');
                                        gameState.player.hp = newHP;
                                        updateCombatUI();
                                        updateInventoryDisplay();
                                        
                                        if (newHP <= 0) {
                                            gameState.player.hp = 0;
                                            defeat();
                                        } else {
                                            showPopup(
                                                'Cover absorbed ' + (baseDmg - reducedDmg) + ' damage!<br>HP: ' + currentHP + ' → ' + newHP,
                                                'info',
                                                'DAMAGE APPLIED'
                                            );
                                            var ocDmg1 = closePopup;
                                            closePopup = function() {
                                                document.getElementById('popup-overlay').classList.remove('active');
                                                closePopup = ocDmg1;
                                                onComplete();
                                            };
                                        }
                                    },
                                    onFailure: function() {
                                        var extraDmg = Math.floor(reducedDmg * 0.5);
                                        gameState.player.hp = currentHP - reducedDmg - extraDmg;
                                        updateCombatUI();
                                        updateInventoryDisplay();
                                        showPopup('<strong>Miscalculated!</strong><br>Took ' + extraDmg + ' extra damage!<br>HP: ' + currentHP + ' → ' + gameState.player.hp, 'error', 'CRITICAL');
                                        if (gameState.player.hp <= 0) {
                                            gameState.player.hp = 0;
                                            var oc = closePopup;
                                            closePopup = function() {
                                                document.getElementById('popup-overlay').classList.remove('active');
                                                closePopup = oc;
                                                defeat();
                                            };
                                        } else {
                                            var ocCrit1 = closePopup;
                                            closePopup = function() {
                                                document.getElementById('popup-overlay').classList.remove('active');
                                                closePopup = ocCrit1;
                                                onComplete();
                                            };
                                        }
                                    }
                                });
                            },
                            onFailure: function() {
                                // Failed cover calc - take full damage!
                                showCombatMessage('<strong>Cover fumble!</strong> Didn\'t use cover properly - taking full damage!', 'error');
                                requireCalculation({
                                    title: '💔 FULL DAMAGE',
                                    description: 'You fumbled your cover! Taking full damage.<br>Your HP: ' + currentHP + '<br>Full damage: ' + baseDmg,
                                    formula: currentHP + ' - ' + baseDmg,
                                    answer: currentHP - baseDmg,
                                    xpReward: 0,
                                    context: 'combat',
                                    onSuccess: function(newHP) {
                                        gameState.player.hp = newHP;
                                        updateCombatUI();
                                        updateInventoryDisplay();
                                        if (newHP <= 0) {
                                            gameState.player.hp = 0;
                                            defeat();
                                        } else {
                                            showPopup('HP: ' + currentHP + ' → ' + newHP, 'info', 'DAMAGE APPLIED');
                                            var ocDmg2 = closePopup;
                                            closePopup = function() {
                                                document.getElementById('popup-overlay').classList.remove('active');
                                                closePopup = ocDmg2;
                                                onComplete();
                                            };
                                        }
                                    },
                                    onFailure: function() {
                                        var extraDmg = Math.floor(baseDmg * 0.5);
                                        gameState.player.hp = currentHP - baseDmg - extraDmg;
                                        updateCombatUI();
                                        updateInventoryDisplay();
                                        if (gameState.player.hp <= 0) {
                                            gameState.player.hp = 0;
                                            defeat();
                                        } else {
                                            onComplete();
                                        }
                                    }
                                });
                            }
                        });
                    };
                } else {
                    // No cover - original flow
                    showPopup(
                        '<strong>' + enemy.name.toUpperCase() + '\'s TURN</strong><br><br>' +
                        (moveLog ? '🚶 ' + moveLog + '<br><br>' : '') +
                        '<span style="color: #f44;">' + attackType + '</span><br>' +
                        'Roll: ' + rollDisplay + ' vs ' + hitChance + '%<br>' +
                        '<br><strong>Incoming damage: ' + finalDmg + '</strong><br><br>' +
                        'You must calculate your new HP...',
                        'error',
                        'ENEMY HIT!'
                    );
                    
                    var origClose = closePopup;
                    closePopup = function() {
                        document.getElementById('popup-overlay').classList.remove('active');
                        closePopup = origClose;
                        
                        requireCalculation({
                            title: '💔 DAMAGE TAKEN',
                            description: 'The enemy hit you!<br>Your HP: ' + currentHP + '<br>Damage: ' + finalDmg,
                            formula: currentHP + ' - ' + finalDmg,
                            answer: currentHP - finalDmg,
                            xpReward: 0,
                            context: 'combat',
                            onSuccess: function(newHP) {
                                trackCombatXP(10, 'Survived hit', 'defense');
                                gameState.player.hp = newHP;
                                updateCombatUI();
                                updateInventoryDisplay();

                                if (newHP <= 0) {
                                    gameState.player.hp = 0;
                                    defeat();
                                } else {
                                    showPopup(
                                        'HP: ' + currentHP + ' → ' + newHP,
                                        'info',
                                        'DAMAGE APPLIED'
                                    );
                                    var ocDmg3 = closePopup;
                                    closePopup = function() {
                                        document.getElementById('popup-overlay').classList.remove('active');
                                        closePopup = ocDmg3;
                                        onComplete();
                                    };
                                }
                            },
                            onFailure: function() {
                                var extraDmg = Math.floor(finalDmg * 0.5);
                                gameState.player.hp = currentHP - finalDmg - extraDmg;
                                updateCombatUI();
                                updateInventoryDisplay();

                                showPopup(
                                    '<strong>Miscalculated!</strong><br><br>' +
                                    'Panic caused extra damage: +' + extraDmg + '<br>' +
                                    'HP: ' + currentHP + ' → ' + gameState.player.hp,
                                    'error',
                                    'CRITICAL HIT'
                                );

                                var origClose2 = closePopup;
                                closePopup = function() {
                                    document.getElementById('popup-overlay').classList.remove('active');
                                    closePopup = origClose2;
                                    if (gameState.player.hp <= 0) {
                                        gameState.player.hp = 0;
                                        defeat();
                                    } else {
                                        onComplete();
                                    }
                                };
                            }
                        });
                    };
                }
            } else {
                // MISS
                showPopup(
                    '<strong>' + enemy.name.toUpperCase() + '\'s TURN</strong><br><br>' +
                    (moveLog ? '🚶 ' + moveLog + '<br><br>' : '') +
                    '<span style="color: #0f0;">✗ Missed!</span><br>' +
                    'Roll: ' + rollDisplay + ' vs ' + hitChance + '%',
                    'info',
                    'ENEMY MISSED'
                );
                var origCloseMiss = closePopup;
                closePopup = function() {
                    document.getElementById('popup-overlay').classList.remove('active');
                    closePopup = origCloseMiss;
                    onComplete();
                };
            }
        }
        
        function combatVictory() {
            gameState.encountersWon++;

            // Get combat data before clearing (for loot calculation)
            var tier = gameState.combat.distanceTier || getDistanceTier();
            var enemies = gameState.combat.enemies || [];
            var enemyCount = enemies.length;
            var battlefield = gameState.combat.battlefield || {};
            var encounterData = gameState.combat.encounterData || {};

            // Clear combat state so saving works
            gameState.combat = null;
            updateSaveButtonVisibility();

            // Check if we're at a location - if so, go to search phase after victory
            if (gameState.inLocation && currentLocation) {
                currentLocation.enemiesCleared = true;

                // Show brief victory message, then go to search phase
                showPopup(
                    '<strong>🏆 AREA CLEARED!</strong><br><br>' +
                    '<span style="color: ' + tier.color + ';">(' + tier.name + ')</span><br><br>' +
                    enemyCount + ' enem' + (enemyCount === 1 ? 'y' : 'ies') + ' defeated!<br>' +
                    'The area is now safe to search.',
                    'success',
                    'VICTORY!'
                );

                var origClose = closePopup;
                closePopup = function() {
                    document.getElementById('popup-overlay').classList.remove('active');
                    closePopup = origClose;
                    showScreen('exploration-screen');
                    updateInventoryDisplay();
                    updateXPDisplay();
                    autoSave();
                    showLocationSearch();
                };
                return;
            }

            // Not at a location - give direct loot (legacy behavior for random encounters)
            // Generate loot scaled by tier AND number of enemies
            var enemyMultiplier = 1 + (enemyCount - 1) * 0.5; // 1 enemy = 1x, 2 = 1.5x, 3 = 2x, etc.

            // Base money per enemy
            var baseMoneyPerEnemy = Math.floor(1500 * tier.lootMult);
            var bonusMoneyPerEnemy = Math.floor(Math.random() * 2000 * tier.lootMult);
            var baseMoney = Math.floor(baseMoneyPerEnemy * enemyCount);
            var bonusMoney = Math.floor(bonusMoneyPerEnemy * enemyCount);
            var totalMoney = baseMoney + bonusMoney;

            var lootItems = [];
            var pendingLoot = [];

            // Loot tables by tier
            var possibleLoot;
            if (tier.tier <= 2) {
                possibleLoot = ['Med Kit', 'Water Bottle', '9mm Rounds (24)', 'Duct Tape', 'Old Cash', 'Canned Beans', 'Canned Meat', 'Trail Mix', 'Beef Jerky', 'Raw Meat'];
            } else if (tier.tier === 3) {
                possibleLoot = ['Med Kit', 'Med Kit', 'Sports Drink', 'MRE', '.308 Rounds (10)', '5.56mm Rounds (30)', 'Camping Set', 'Leather Vest', 'Coffee', 'Circuitry'];
            } else if (tier.tier === 4) {
                possibleLoot = ['Med Kit', 'Med Kit', 'Sleeping Bag', 'Portable Stove', 'Metal Plate', '5.56mm Rounds (30)', '12 Gauge Shells (12)', 'Sensor Module', 'Gold Watch', 'Tactical Vest'];
            } else {
                possibleLoot = ['Med Kit', 'Med Kit', 'Tactical Vest', 'Water Purifier', '.308 Rounds (10)', '5.56mm Rounds (30)', '12 Gauge Shells (12)', 'Gold Watch', 'Silver Locket', 'Sensor Module'];
            }

            // Each enemy has a chance to drop loot
            var lootChance = 0.5 + (tier.tier - 1) * 0.1;
            for (var e = 0; e < enemyCount; e++) {
                if (Math.random() < lootChance) {
                    var lootItem = possibleLoot[Math.floor(Math.random() * possibleLoot.length)];
                    pendingLoot.push(lootItem);
                }
            }

            // Environment-based bonus loot from battlefield
            var envLoot = [];
            if (battlefield.name) {
                // Different environments provide different bonus materials
                if (battlefield.name.includes('Warehouse') || battlefield.name.includes('Factory') || battlefield.name.includes('Workshop')) {
                    envLoot.push({ type: 'material', name: 'Scrap Metal', amount: Math.floor(Math.random() * 3) + 2 });
                    envLoot.push({ type: 'material', name: 'Electronics', amount: Math.floor(Math.random() * 2) + 1 });
                }
                if (battlefield.name.includes('Hospital') || battlefield.name.includes('Clinic') || battlefield.name.includes('Pharmacy')) {
                    envLoot.push({ type: 'item', name: 'Med Kit' });
                    envLoot.push({ type: 'material', name: 'Chemicals', amount: Math.floor(Math.random() * 3) + 1 });
                }
                if (battlefield.name.includes('Office') || battlefield.name.includes('Bank') || battlefield.name.includes('Store')) {
                    envLoot.push({ type: 'money', amount: Math.floor(Math.random() * 2000) + 1000 });
                }
                if (battlefield.name.includes('Gas Station') || battlefield.name.includes('Garage')) {
                    envLoot.push({ type: 'material', name: 'Chemicals', amount: Math.floor(Math.random() * 2) + 1 });
                    envLoot.push({ type: 'material', name: 'Scrap Metal', amount: Math.floor(Math.random() * 2) + 1 });
                }
                if (battlefield.name.includes('Camp') || battlefield.name.includes('Forest') || battlefield.name.includes('Woods')) {
                    envLoot.push({ type: 'material', name: 'Cloth', amount: Math.floor(Math.random() * 3) + 1 });
                    envLoot.push({ type: 'resource', name: 'wood', amount: Math.floor(Math.random() * 5) + 3 });
                }
                if (battlefield.name.includes('Military') || battlefield.name.includes('Bunker') || battlefield.name.includes('Armory')) {
                    // Chance for ammo
                    var ammoTypes = ['9mm Rounds (24)', '5.56mm Rounds (30)', '.308 Rounds (10)', '12 Gauge Shells (12)'];
                    envLoot.push({ type: 'item', name: ammoTypes[Math.floor(Math.random() * ammoTypes.length)] });
                }
                if (battlefield.name.includes('Ruins') || battlefield.name.includes('Junkyard')) {
                    envLoot.push({ type: 'material', name: 'Scrap Metal', amount: Math.floor(Math.random() * 4) + 2 });
                    envLoot.push({ type: 'resource', name: 'steel', amount: Math.floor(Math.random() * 3) + 1 });
                }
            }

            // Process environment loot
            var envMoneyBonus = 0;
            var envMaterials = {};
            var envResources = { wood: 0, steel: 0 };
            for (var i = 0; i < envLoot.length; i++) {
                var loot = envLoot[i];
                if (loot.type === 'money') {
                    envMoneyBonus += loot.amount;
                } else if (loot.type === 'item') {
                    pendingLoot.push(loot.name);
                } else if (loot.type === 'material') {
                    envMaterials[loot.name] = (envMaterials[loot.name] || 0) + loot.amount;
                } else if (loot.type === 'resource') {
                    envResources[loot.name] = (envResources[loot.name] || 0) + loot.amount;
                }
            }

            // Add environment money to total
            totalMoney += envMoneyBonus;
            bonusMoney += envMoneyBonus;

            // Base materials (scaled by enemy count)
            var metalFound = 0;
            var materialChance = 0.4 + (tier.tier - 1) * 0.1;
            if (Math.random() < materialChance) {
                metalFound = Math.floor((Math.random() * 2 + 1) * tier.lootMult * enemyMultiplier);
            }
            metalFound += (envMaterials['Scrap Metal'] || 0);

            // Building materials (scaled by enemy count)
            var woodFound = tier.tier >= 2 ? Math.floor(Math.random() * tier.tier * 2 * enemyMultiplier) : 0;
            var steelFound = tier.tier >= 3 ? Math.floor(Math.random() * tier.tier * enemyMultiplier) : 0;
            woodFound += envResources.wood;
            steelFound += envResources.steel;

            // Show victory screen with detailed breakdown
            var content = '<strong>🏆 VICTORY!</strong><br>';
            content += '<span style="color: ' + tier.color + ';">(' + tier.name + ')</span><br><br>';
            content += '<strong>ENEMIES DEFEATED:</strong> ' + enemyCount + '<br>';
            if (battlefield.name) {
                content += '<strong>LOCATION:</strong> ' + battlefield.icon + ' ' + battlefield.name + '<br>';
            }
            content += '<br><strong>LOOT FOUND:</strong><br>';
            content += '💵 Cash: ' + formatMoney(baseMoney) + ' + ' + formatMoney(bonusMoney) + '<br>';
            if (pendingLoot.length > 0) content += '📦 Items: ' + pendingLoot.join(', ') + '<br>';
            if (metalFound > 0) content += '🔧 Scrap Metal: +' + metalFound + '<br>';
            if (envMaterials['Chemicals']) content += '🧪 Chemicals: +' + envMaterials['Chemicals'] + '<br>';
            if (envMaterials['Electronics']) content += '⚡ Electronics: +' + envMaterials['Electronics'] + '<br>';
            if (envMaterials['Cloth']) content += '🧵 Cloth: +' + envMaterials['Cloth'] + '<br>';
            if (woodFound > 0) content += '🪵 Wood: +' + woodFound + '<br>';
            if (steelFound > 0) content += '🔩 Steel: +' + steelFound + '<br>';
            content += '<br>Calculate your rewards!';

            showPopup(content, 'success', 'VICTORY!');

            var currentMoney = gameState.player.money;

            var origClose = closePopup;
            closePopup = function() {
                document.getElementById('popup-overlay').classList.remove('active');
                closePopup = origClose;

                // Loot money calculation
                requireCalculation({
                    title: '💵 LOOT: CASH',
                    description: 'Base loot: ' + formatMoney(baseMoney) + '<br>Bonus: ' + formatMoney(bonusMoney) + '<br>Your cash: ' + formatMoney(currentMoney),
                    formula: formatMoney(currentMoney) + ' + ' + formatMoney(baseMoney) + ' + ' + formatMoney(bonusMoney),
                    answer: currentMoney + totalMoney,
                    isMoney: true,
                    xpReward: 0,
                    context: 'exploration',
                    onSuccess: function(newMoney) {
                        gameState.player.money = newMoney;

                        // Apply other loot
                        pendingLoot.forEach(function(item) {
                            if (item === 'Med Kit') {
                                gameState.player.medkits++;
                            } else if (canCarryItem(item)) {
                                addToInventory(item);
                            }
                        });

                        // Apply materials from enemies
                        if (metalFound > 0) {
                            addMaterial('Scrap Metal', metalFound);
                        }

                        // Apply environment materials
                        if (envMaterials['Chemicals']) {
                            addMaterial('Chemicals', envMaterials['Chemicals']);
                        }
                        if (envMaterials['Electronics']) {
                            addMaterial('Electronics', envMaterials['Electronics']);
                        }
                        if (envMaterials['Cloth']) {
                            addMaterial('Cloth', envMaterials['Cloth']);
                        }

                        // Building materials
                        if (woodFound > 0) baseState.resources.wood += woodFound;
                        if (steelFound > 0) baseState.resources.steel += steelFound;

                        // Check if we can skin the animal
                        if (canSkinEncounter()) {
                            offerSkinning();
                        } else {
                            // Continue to exploration
                            showScreen('exploration-screen');
                            updateInventoryDisplay();
                            updateXPDisplay();
                            autoSave();
                            nextExplorationEvent();
                        }
                    },
                    onFailure: function() {
                        // Only get half money on wrong calc
                        gameState.player.money += Math.floor(totalMoney / 2);

                        // Still get building materials (can't lose those)
                        if (woodFound > 0) baseState.resources.wood += woodFound;
                        if (steelFound > 0) baseState.resources.steel += steelFound;

                        // Check if we can skin the animal (even on failed loot calc)
                        if (canSkinEncounter()) {
                            offerSkinning();
                        } else {
                            showScreen('exploration-screen');
                            updateInventoryDisplay();
                            autoSave();
                            nextExplorationEvent();
                        }
                    }
                });
            };
        }

        // ========== ANIMAL SKINNING SYSTEM ==========

        function hasSkinnableWeapon() {
            // Check if player has any weapon with canSkin: true equipped
            var weapon1 = gameState.player.weapons.slot1;
            var weapon2 = gameState.player.weapons.slot2;

            if (weapon1 && WEAPONS[weapon1] && WEAPONS[weapon1].canSkin) return true;
            if (weapon2 && WEAPONS[weapon2] && WEAPONS[weapon2].canSkin) return true;

            return false;
        }

        function canSkinEncounter() {
            // Check if the encounter has fur AND player has skinning weapon
            var encounterData = gameState.combat && gameState.combat.encounterData;
            if (!encounterData) return false;
            if (!encounterData.hasFur) return false;
            if (!hasSkinnableWeapon()) return false;
            return true;
        }

        function offerSkinning() {
            var encounterData = gameState.combat.encounterData;
            var hideYield = encounterData.hideYield || 1;
            var animalName = encounterData.name || 'Animal';

            var content = '<strong>🔪 SKINNING OPPORTUNITY</strong><br><br>';
            content += 'The ' + animalName + ' has valuable fur!<br><br>';
            content += 'You can harvest <span style="color: #ff0;">×' + hideYield + ' Animal Hide</span> from this creature.<br><br>';
            content += '<em>Requires: Hunting Knife equipped</em>';

            showPopup(content, 'info', 'SKIN ANIMAL?');

            // Replace popup buttons with custom skinning options
            var popupEl = document.getElementById('popup-overlay');
            var existingBtn = popupEl.querySelector('.popup-close-btn');
            if (existingBtn) existingBtn.remove();

            var buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = 'margin-top: 20px; display: flex; gap: 10px; justify-content: center;';

            var skinBtn = document.createElement('button');
            skinBtn.className = 'btn';
            skinBtn.textContent = '🔪 Skin Animal';
            skinBtn.style.cssText = 'background: linear-gradient(180deg, #8B4513 0%, #654321 100%);';
            skinBtn.onclick = function() {
                popupEl.classList.remove('active');
                skinAnimal(encounterData);
            };

            var skipBtn = document.createElement('button');
            skipBtn.className = 'btn';
            skipBtn.textContent = 'Leave It';
            skipBtn.style.cssText = 'background: linear-gradient(180deg, #555 0%, #333 100%);';
            skipBtn.onclick = function() {
                popupEl.classList.remove('active');
                showScreen('exploration-screen');
                updateInventoryDisplay();
                updateXPDisplay();
                autoSave();
                nextExplorationEvent();
            };

            buttonContainer.appendChild(skinBtn);
            buttonContainer.appendChild(skipBtn);

            popupEl.querySelector('.popup-content').appendChild(buttonContainer);
        }

        function skinAnimal(encounterData) {
            var hideYield = encounterData.hideYield || 1;
            var animalName = encounterData.name || 'Animal';

            // Math challenge for skinning
            var currentHide = 0;
            for (var i = 0; i < gameState.player.inventory.length; i++) {
                if (gameState.player.inventory[i] === 'Animal Hide') currentHide++;
            }

            requireCalculation({
                title: '🔪 SKINNING: ' + animalName.toUpperCase(),
                description: 'You carefully skin the ' + animalName + '.<br>Hides harvested: ' + hideYield + '<br>Current hides: ' + currentHide,
                formula: currentHide + ' + ' + hideYield,
                answer: currentHide + hideYield,
                xpReward: 5,
                context: 'exploration',
                onSuccess: function(result) {
                    // Add hides to inventory
                    for (var h = 0; h < hideYield; h++) {
                        addToInventory('Animal Hide');
                    }

                    showPopup(
                        '<strong>🔪 SKINNING COMPLETE!</strong><br><br>' +
                        'You harvested <span style="color: #ff0;">×' + hideYield + ' Animal Hide</span> from the ' + animalName + '.<br><br>' +
                        '<em>Tip: Tan hides at a workbench to make leather for crafting!</em>',
                        'success',
                        'HIDE OBTAINED'
                    );

                    var origClose = closePopup;
                    closePopup = function() {
                        document.getElementById('popup-overlay').classList.remove('active');
                        closePopup = origClose;
                        showScreen('exploration-screen');
                        updateInventoryDisplay();
                        updateXPDisplay();
                        autoSave();
                        nextExplorationEvent();
                    };
                },
                onFailure: function() {
                    // Failed skinning - only get half (rounded down)
                    var partialYield = Math.floor(hideYield / 2);

                    if (partialYield > 0) {
                        for (var h = 0; h < partialYield; h++) {
                            addToInventory('Animal Hide');
                        }
                        showPopup(
                            '<strong>🔪 SLOPPY WORK</strong><br><br>' +
                            'Your knife slipped! You only salvaged <span style="color: #ff0;">×' + partialYield + ' Animal Hide</span>.',
                            'warning',
                            'PARTIAL SUCCESS'
                        );
                    } else {
                        showPopup(
                            '<strong>🔪 RUINED!</strong><br><br>' +
                            'You damaged the hide beyond use. Nothing salvaged.',
                            'error',
                            'SKINNING FAILED'
                        );
                    }

                    var origClose = closePopup;
                    closePopup = function() {
                        document.getElementById('popup-overlay').classList.remove('active');
                        closePopup = origClose;
                        showScreen('exploration-screen');
                        updateInventoryDisplay();
                        autoSave();
                        nextExplorationEvent();
                    };
                }
            });
        }

        function defeat() {
            // Clear combat state
            gameState.combat = null;
            updateSaveButtonVisibility();

            document.getElementById('final-distance').textContent = gameState.distance;
            document.getElementById('final-encounters').textContent = gameState.encountersWon;
            document.getElementById('final-money').textContent = formatMoney(gameState.player.money);
            document.getElementById('final-correct').textContent = gameState.player.totalCorrect;
            document.getElementById('final-attempted').textContent = gameState.player.totalAttempted;

            var accuracy = gameState.player.totalAttempted > 0 ?
                Math.round((gameState.player.totalCorrect / gameState.player.totalAttempted) * 100) : 0;
            document.getElementById('final-accuracy').textContent = accuracy;
            document.getElementById('final-streak').textContent = gameState.player.bestStreak;

            document.getElementById('gameover-title').textContent = 'YOU DIED';
            document.getElementById('gameover-text').textContent = 'The wasteland claimed another victim...';
            showScreen('gameover-screen');
        }
        
        function restartGame() {
            startAdventure();
        }
        
        function showCombatMessage(text, type) {
            // Use popup for important messages
            showPopup(text, type);
        }
        
        function showPopup(content, type, title) {
            var overlay = document.getElementById('popup-overlay');
            var box = document.getElementById('popup-box');
            var titleEl = document.getElementById('popup-title');
            var contentEl = document.getElementById('popup-content');
            
            // Set type class
            box.className = 'popup-box ' + type;
            
            // Set title based on type
            if (title) {
                titleEl.textContent = title;
            } else if (type === 'success') {
                titleEl.textContent = '✓ SUCCESS';
            } else if (type === 'error') {
                titleEl.textContent = '✗ FAILED';
            } else {
                titleEl.textContent = 'ℹ INFO';
            }
            
            contentEl.innerHTML = content;
            overlay.classList.add('active');
        }
        
        function closePopup() {
            document.getElementById('popup-overlay').classList.remove('active');
        }
        
        var pendingPopupCallback = null;
        
        function showPopupWithCallback(content, type, title, callback) {
            showPopup(content, type, title);
            pendingPopupCallback = callback;
        }
        
        function closePopupWithCallback() {
            document.getElementById('popup-overlay').classList.remove('active');
            if (pendingPopupCallback) {
                var cb = pendingPopupCallback;
                pendingPopupCallback = null;
                cb();
            }
        }
        
        // Keyboard support
        document.getElementById('answer-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' || e.keyCode === 13) submitAnswer();
        });
        
        document.getElementById('explore-answer').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' || e.keyCode === 13) submitExplorationAnswer();
        });
        
        document.getElementById('shop-answer').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' || e.keyCode === 13) submitShopAnswer();
        });
        
        document.getElementById('craft-answer').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' || e.keyCode === 13) submitCraftAnswer();
        });
        
        document.getElementById('hack-answer').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' || e.keyCode === 13) submitHackAnswer();
        });
        
        document.getElementById('lock-answer').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' || e.keyCode === 13) submitLockAnswer();
        });

        // Handle fullscreen messages from parent
        window.addEventListener('message', (event) => {
            if (event.data.type === 'FULLSCREEN_ENTER') {
                document.body.classList.add('fullscreen-mode');
            } else if (event.data.type === 'FULLSCREEN_EXIT') {
                document.body.classList.remove('fullscreen-mode');
            }
        });
    </script>
</body>
</html>
